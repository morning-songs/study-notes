# 组件

​		`React` 的组件分为类组件和函数组件。自从函数组件出来之后，新项目便纷纷都使用函数组件了，而类组件只能存在一些老的项目之中。顾名思义，函数组件就是使用函数定义的组件，类组件就是使用类定义的组件。实际上，函数组件可以很轻松地转换为类组件。



### 类组件

​		类组件，虽然不久之后将被函数组件完全替代，但一些老项目过去是使用类组件来完成的。因此，仍有学习的必要，直至禁用它。	

​		如前所述，类组件是使用 `ES6` 的 `class` 定义的组件。所以，需要掌握 `class` 的相关用法以及其中的 `this` 指向。



#### 组件基础

##### 创建组件

​		创建类组件，是通过继承 `React.Component` 来实现的。类名就是该组件的名称，将类名使用一对尖括号包裹后，它就会变成组件。

​		在类组件中，必须定义一个 `render()` 方法，用于存放该组件的虚拟 `DOM`。也就是说，类组件的虚拟 `DOM` 要写在其 `render()` 方法中，并且必须使用 `return` 将它们返回，否则页面上不会渲染。

```jsx
class MyDiv extends React.Component {
    render() {
        // 在此定义并返回这个类组件的虚拟DOM
        return (
        	<div>
            	<p>类组件中的段落元素</p>
            </div>
        );
    }
}

// React.Component本身是一个函数，而继承自它的类也呈现出函数的形式（但它是一个类）。
console.log(MyDiv);
/*
ƒ MyDiv() {
	_classCallCheck(this, MyDiv);
	return _possibleConstructorReturn(this, (MyDiv.__proto__ || Object.getPrototypeOf(MyDiv)).apply(this, arguments));
}
*/

// 将类名使用<>包裹，它就会变成类组件。
console.log(<MyDiv />);
/*
{
    $$typeof: Symbol(react.element)
	key: null
	props: {}
	ref: null
	type: ƒ MyDiv()
	_owner: null
	_store: {validated: false}
	_self: null
	_source: null
	[[Prototype]]: Object
}
*/
```

​		类组件，可以被应用于其他虚拟 `DOM` 的定义中作为子组件使用，或者传递给 `render()` 方法进行渲染。

```jsx
// 将类组件作为子组件使用
let vnode = (
	<div>
    	<h1>嵌入类组件</h1>
        <MyDiv />
    </div>
);

// 将该类组件渲染到页面上
app.render(<MyDiv />);
```

##### 临时容器

​		在 `Vue` 中，可以将 `<template>` 元素作为临时容器来使用。它只会存在于编辑器中，不会被渲染到页面上。相应的，`React` 提供了一个 `<React.Fragment>` 组件来作为临时容器，它也可以作为虚拟 `DOM` 的根元素使用。

```jsx
let vnode = (
	<React.Fragment>
    	<h1>非根元素</h1>
        <p>这个也不是根元素</p>
    </React.Fragment>
);
```

​		如果 `<React.Fragment>` 组件上不需要任何属性的话，则可以直接简写为 `<>`。这个最新的简写语法，只在脚手架中得到了支持。

```jsx
let vnode = (
    // 只是这个临时容器上，不可以定义任何属性。
	<>
    	<h1>非根元素</h1>
        <p>这个也不是根元素</p>
    </>
);
```

##### `this` 指向

​		在类组件中，`this` 的指向与 `ES6 class` 中的 `this` 指向是一样的。正常情况下的 `this` 指向：

- 公共实例方法：`this` 指向类实例，如：`constructor()` 等类原型上的公开方法。
- 公共静态方法：`this` 指向类自身，如：`static change()` 等类身上的公开方法。
- 私有实例方法：`this` 指向类实例，如：`#setClassName()` 等类原型上的私有方法。
- 私有静态方法：`this` 指向类自身，如：`static #setId()` 等类身上的私有方法。

​		但要注意，在内联 `Babel` 脚本（`JSX` 环境）中，不期望出现 `#` 字符。意味着不可以使用 `#` 在类组件中定义私有方法。

​		另外，在类中属性和方法的归属并不总是相同：公共实例方法存在于类原型上，私有实例方法和实例属性都存在于类实例上，公共实例 `getter` 的返回值既存在类原型上又存在类实例上；静态字段都存在类自身上，但私有静态字段必须存在于封闭的类身上。



#### 状态管理

##### 定义数据

​		每个组件都有自己独立的状态（即：数据的状态）。一个类的数据，通常定义在 `constructor()` 中，以供每个类实例使用。

```jsx
class T extends React.Component {
    constructor() {
        super();
        this.text = "类组件的数据";
    }
}
```

​		为了便于统一管理组件数据，`React` 建议将类组件的响应式数据集中存放到类实例的 `state` 属性中。

```jsx
class T extends React.Component {
    constructor() {
        super();
        this.state = {
            text: "类组件的数据"
        };
    }
}
```

​		既然 `state` 是类实例上的属性。所以为了便于使用，则可以将其从 `constructor` 中提取出来，直接定义为类的公共实例属性。

```jsx
class T extends React.Component {
    state = {
        text: "请尝试修改这段文本"
    }
}
```

##### 注册事件

​		然而，要更新类组件的数据，首先要注册相关的事件。为了解决 `JS` 事件的兼容性问题，`React` 对它们进行了跨浏览器封装，形成了自定义的合成事件。为了应用合成事件，又对虚拟 `DOM` 元素的原生事件属性进行了重新定义，形成了 `React` 独有的合成事件属性。这些合成事件属性采用小驼峰命名，但只能在虚拟 `DOM` 元素中使用。也就是说，`React` 事件只能被用在虚拟 `DOM` 的合成事件属性上。

```jsx
function clickFn() {
    console.log('触发点击事件');
}

let vnode = (<button onClick={clickFn}>点击</button>);
```

​		必须注意的是，`ES6` 的类 **默认开启了严格模式（实际上，整个 `React` 都开启了严格模式）**。这意味着，如果只是传递类中某个方法的引用（如：将 `this.changeText` 注册给事件），那么其中的 `this` 将默认是 `undefined`。因此，在 `render` 中给虚拟 `DOM` 注册事件时，需要为事件处理程序绑定 `this`。而为了不立即执行事件回调，通常使用 `bind` 方法来进行绑定。

```jsx
class T extends React.Component {
    constructor() {
        super();
        this.state = {
            text: "请尝试修改这段文本"
        };
    }
    changeText() {
        this.state.text = "该段落的新内容";
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>{this.state.text}</p>
                <button onClick={this.changeText.bind(this)}>点击修改</button>
            </div>
        );
    }
}
```

​		另外一种解决方法是使用箭头函数来作为事件处理程序。这是因为箭头函数的 `this` 是在声明时自动绑定的，而且是不可更改的。当然，也可以像 `onClick={() => {}}` 这样直接提供箭头函数，但不推荐这么做。因为组件每次渲染时，都会创建这个箭头函数，造成不必要的性能浪费。更多参考：[事件处理](https://zh-hans.reactjs.org/docs/handling-events.html)、[`React` 事件处理](https://www.runoob.com/react/react-event-handle.html) 

```jsx
class T extends React.Component {
    constructor() {
        super();
        this.state = {
            text: "请尝试修改这段文本"
        };
    }
    changeText = () => {
        this.state.text = "该段落的新内容";
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>{this.state.text}</p>
                <button onClick={this.changeText}>点击修改</button>
            </div>
        );
    }
}
```

​		不过，通过原生 `JS` 修改类组件的数据不会得到任何视图上的响应。点击按钮，虽然触发了数据的更新，但并不会使视图更新。

##### 更新数据

​		因此，`React` 封装了一个 `setState()` 方法，同样用于修改 `state` 中的数据，但它在更新完数据后会立即触发视图的响应更新。实际上，每次调用它修改数据之后，它都会调用组件的 `render()` 方法来重新渲染该组件。

​		注释：`setState()` 存在于类原型的 `__proto__` 属性上（如：`T.prototype.__proto__.setState`），也就是说，它是被定义在 `React.Component.prototype` 上的方法。下面是它的源码：

```jsx
Component.prototype.setState = function (partialState, callback) {
	if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
		throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
	}

    // 调用组件的render方法，更新它的虚拟DOM
    this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```

​		由于该方法存在于类实例的原型链中，因此可以被类实例直接调用。`setState()` 可以在类的任何原型方法中被访问，但它坚决不能在 `render()` 中被调用。因为 `setState()` 本身就会触发 `render()`，如此调用就会造成**死循环**。如果要在 `render()` 中修改，则可使用原生的修改方式，如：`this.state.text = '';`。

```jsx
class T extends React.Component {
    state = {
		text: "请尝试修改这段文本"
	}
    changeText = () => {
        this.setState({text: "该段落的新内容"}); // 只修改text属性的值，而不是覆盖整个state。
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>{this.state.text}</p>
                <button onClick={this.changeText}>点击修改</button>
            </div>
        );
    }
}
```

​		虽然传给 `setState()` 的是一个对象，但它不会覆盖源 `state` 对象，而是与之合并进而更新源 `state`。

​		另外，有意思的一点是，由于调用 `this.setState()` 会执行类组件的 `render()` 来更新视图。因此，在组件内其他地方定义的组件数据，通过原生 `JS` 修改后也会被更新到视图上。这是因为触发组件的 `render()` 使该组件被重新渲染，并不是因为它们本身具有响应式的特点，只是因为沾了 `this.setState()` 的光。

```jsx
class T extends React.Component {
    state = {
		text: "请尝试修改这段文本"
	}
    otherDatas = {
        name: 'non-responsive'
    }
    changeText = () => {
        this.otherDatas.name = '非响应式数据';
        this.setState({text: "该段落的新内容"}); // 触发整个组件的视图更新
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>{this.state.text}</p>
                <p>{this.otherDatas.name}</p>
                <button onClick={this.changeText}>点击修改</button>
            </div>
        );
    }
}
```

​		另一个值得一提的是，在同一个事件处理程序中多次调用 `this.setState()`，不会多次触发 `render()`，只触发一次视图的更新。也就是说，在同一次事件处理中修改数据，只会触发一次 `render()`。

```jsx
class T extends React.Component {
    state = {
		name: 'xx',
        age: 20
	}
    changeState = () => {
        this.setState({name: "许昕"});
        this.setState({age: 21});
        this.setState({sex: '女'});
        // 无论调用多少次setState，都只会在最后触发一次render。
    }
    render() {
        console.log('rendered');
        return (
        	<div>
                <h1>组件状态</h1>
                <p>{this.state.name}</p>
                <p>{this.state.age}</p>
                <button onClick={this.changeState}>点击修改</button>
            </div>
        );
    }
}
```

​		`this.setState()` 也可以接收一个回调函数，它必须 `return` 一个值，通常是一个对象，该对象会与源 `state` 对象进行合并。当然，更应该关注的是，这个传递的回调函数会依次接收到两个参数：`state` 和 `props`。其中，`state` 就是源 `state` 对象，其中包含组件最新的数据；而 `props` 是组件上传递下来的数据（实质上，只是组件上的一些属性而已）。

```jsx
class T extends React.Component {
    state = {
        name: 'xx',
		age: 20
	}
    changeAge = () => {        
        // 传入一个函数
        this.setState(function (state, props) {
            return {age: ++state.age}; // 注意：这里应先自增再赋值，否则赋的值没有改变。
        });
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>姓名：{this.state.name}</p>
                <p>年龄：{this.state.age}</p>
                <button onClick={this.changeAge}>点击修改</button>
            </div>
        );
    }
}
```

##### 更新数组

​		前面提到过，`setState()` 可以接收一个回调函数，但它必须返回一个值（除了 `undefined` 和 `null`，因为它们会阻止 `setState` 调用组件的 `render` 方法）。返回任何其他值在多数情况下都没有什么问题，但通常建议返回一个更新相关数据的对象（如上所示）。

```jsx
class T extends React.Component {
    state = {
        name: 'xx',
		age: 20
	}
    changeAge = () => {
        this.setState((state, props) => {
            state.age++;
            return true; // 注意：这里返回任何值（除un和nu外）都可以触发数据和视图的更新。
        });
    }
    render() {
        return (
        	<div>
                <h1>组件状态</h1>
                <p>姓名：{this.state.name}</p>
                <p>年龄：{this.state.age}</p>
                <button onClick={this.changeAge}>点击修改</button>
            </div>
        );
    }
}
```

​		默认情况下，`React` 能够自动展开数组。但是当在 `setState` 中使用不替换数组引用的 `API` 更新数组时仍旧返回其他不相关的值，虽然能触发数据和视图的更新，`React` 却不会再自动展开该数组（此时，当在虚拟 `DOM` 中手动展开数组）。

```jsx
class T extends React.Component {
    state = {
        num: 20,
        arr: []
    }
    changeAge = () => {
        this.setState((state, props) => {
            state.num++;
            state.arr.push(1); // 使用数组API修改数组，但是这个API不会替换数组的引用。
            return false; // 返回不相关的值，将导致React不会在虚拟DOM中自动展开该数组。
        });
    }
    render() {
        return (
            <div>
                <h1>组件状态</h1>
                {/* 数字的更新没有受影响，但没有自动展开该数组，只能手动展开它 */}
                <p>数字更新：{this.state.num}</p>
                <p>不再展开：{this.state.arr}</p>
                <p>手动展开：{[...this.state.arr]}</p>
                <button onClick={this.changeAge}>点击修改</button>
            </div>
        );
    }
}
```

​		当然，如果在 `setState` 中直接赋值或使用 `API` 替换数组的引用，则仍可以返回其他不相关的值（该数组会被自动展开）。

```jsx
class T extends React.Component {
    state = {
        num: 20,
        arr: []
    }
    changeAge = () => {
        this.setState((state, props) => {
            state.num++;
            state.arr = [...state.arr, 1]; // 替换数组的引用
            return false; // 允许除了un和nu外的任何值，甚至可以直接：return state.arr = [...state.arr, 1];
        });
    }
    render() {
        return (
            <div>
                <h1>组件状态</h1>
                <p>数字更新：{this.state.num}</p>
                <p>自动展开：{this.state.arr}</p>
                <button onClick={this.changeAge}>点击修改</button>
            </div>
        );
    }
}
```

​		通常，我们都会在定义虚拟 `DOM` 时手动展开数组。因此，我们一般都可以在 `setState` 中返回任何其他值，且程序运行一切如常。

​		这一点在更新数组时，非常重要。这意味着，我们可以在 `setState` 中自由地使用数组的任何 `API` 来更新数组，无需替换它。

```jsx
class T extends React.Component {
    state = {
        arr: ['金泰妍', '林允儿', '李知恩']
    }
    changeAge = () => {
        this.setState(function (state, props) {
            state.arr.push('朴孝敏'); // 这里就可以任意使用数组的API。
            return ''; // 可以返回任何不相关的值，除了un和nu之外。
        });
    }
    render() {
        console.log('rendered');
        
        let { arr } = this.state;
        
        return (
            <div>
                <h1>组件状态</h1>
                {
                    arr.map((item, index) => {
                    	return <p key={index}>{item}</p>
                	})
                }
                <button onClick={this.changeAge}>点击修改</button>
            </div>
        );
    }
}
```

​		当然，使用扩展运算符会使更新数组更加简洁和直观：

```jsx
class T extends React.Component {
    state = {
        arr: ['金泰妍', '林允儿', '李知恩']
    }
    changeAge = () => {
        this.setState(function (state, props) {
            return {
                arr: [...state.arr, '朴孝敏'] // 该数组会被自动展开
            };
        });
    }
}
```

​		但既然只要求返回一个非 `undefined` 和非 `null` 的值，那么理所当然地也可以直接返回更新后的数组。

```jsx
class T extends React.Component {
    state = {
        arr: ['金泰妍', '林允儿', '李知恩']
    }
    changeAge = () => {
        this.setState(function (state, props) {
            return state.arr.push('朴孝敏'); // 该数组不会自动展开，必须手动展开它。
        });
    }
}
```



#### 获取组件

​		`React` 中有三种方法可以获得一个 `DOM` 节点或组件的引用。但由于前两种都有些许问题，解决起来也比较复杂，所以推荐直接使用最简单且最完美的第三种方式。

##### 绑定获取

​		通过 `React.createRef()` 可以创建一个 `ref` 容器对象，这个对象用于获取绑定了特定 `ref` 属性值的 `DOM` 节点或组件的引用。

​		绑定和获取的基本步骤如下：在类组件中任意一个虚拟 `DOM` 上添加 `ref` 属性，并将其属性值设为 `React.createRef()` 创建的特殊对象。然后，这个特殊对象就会自动获取到被它绑定的虚拟 `DOM` 的引用，并将其存入容器对象的 `current` 属性中。

```jsx
class Child extends React.Component {
    render() {
        return (<h1>子组件</h1>);
    }
}

class Father extends React.Component {
    // 创建ref容器以获取子虚拟DOM的引用
    myRefs = {
        h1Ref: React.createRef(),
        ChildRef: React.createRef()
    }

    render() {
        console.log(this.myRefs);
        return (
            <div>
                {/* 将创建的ref对象绑定给虚拟DOM的ref属性 */}
                <h1 ref={this.myRefs.h1Ref}>父组件</h1> {/* 此时，h1Ref便会获取到该元素的引用 */}
                <Child ref={this.myRefs.ChildRef} />   {/* 此时，ChildRef便会获取到该组件的引用 */}
            </div>
        );
    }
}
```

##### 元素数据

​		在 `DOM` 上使用 `ref` 属性，可以轻松获得该 `DOM` 的引用。获得 `DOM` 引用，主要为了获取其中的数据，尤其是表单字段和子组件。

```jsx
class T extends React.Component {
    myRefs = {
        iptRef: React.createRef()
    }
	getInputValue = () => {
		console.log(this.myRefs.iptRef.current.value);
    }
    render() {
        let { iptRef } = this.myRefs;
        return (
            <div>
                <h1>类组件</h1> 
                <p>输入框：<input ref = {iptRef} /></p>
                <button onClick={this.getInputValue}>获取输入数据</button>
            </div>
        );
    }
}
```



#### 组件通信

​		组件之间的通信，可以分为上级和下级之间以及同级之间的相互通信。常见于：父子组件通信、兄弟组件通信和跨组件通信。当然，组件之间的从属关系取决于 `DOM` 结构，而非其他。

##### 父子通信

​		给 `this.setState()` 传入一个函数时，该函数的第二个参数用于接收从父组件传递过来的数据，如前所述。因此，父组件向子组件传递数据也是所有组件通信中最为简单的。

- 父组件：直接在子组件的虚拟 `DOM` 上，通过设置标签属性向子组件传递数据即可。
- 子组件：每个组件上都有一个 `props` 实例属性，它会自动接收组件上传递的数据。这个 `props` 属性也会实时传给 `setState()`。

```jsx
class S extends React.Component {
    state = {
        firstName: 'Zi',
        lastName: ''
    }
    getProps = () => {
        this.setState((state, props) => {
            console.log(this.props === props); // true
            return props; // 若返回对象，则它将与state合并
        });
    }
    render() {
        let { firstName, lastName } = this.state;
        return (
            <div>
                <h1>子组件</h1>
                <p>姓：{lastName}</p>
                <p>名：{firstName}</p>
                <button onClick={this.getProps}>获取传递数据</button>
            </div>
        );
    }
}

class F extends React.Component {
    state = {
        firstName: 'Lao',
        lastName: 'Wang'
    }
    render() {
        let { lastName } = this.state;

        return (
            <div>
                <h1>父组件</h1>
                <S lastName={lastName} /> {/* 必须补全，否则会默认传递布尔值true */}
            </div>
        );
    }
}
```

​		但要注意的是，`this.props` 接收到的所有数据都会被转为只读。尝试直接修改 `this.props` 中的传递数据会导致报错。有人说这是因为 `React` 只实现了单向响应的数据流。实际上，任何框架都不会允许子组件直接修改父组件传递的数据。

​		如果子组件确实要修改父组件传递的数据，那么子组件只能将数据传递给父组件，然后由父组件根据接收到的数据完成修改。

- 父组件：在传递数据时，同时传递一个可以修改这些数据的方法。
- 子组件：接收到数据后，通过父组件提供的修改方法来修改它们。

​		使用柯里化箭头函数实现：

```jsx
class Child extends React.Component {
    render() {
        let [info, setInfo] = this.props.info;
        return (
        	<div>
            	<h1>子组件</h1>
                <div>{info}</div>
                <button onClick={setInfo("子组件修改了父组件传递的数据")}>点击修改</button>
            </div>
        );
    }
}

class Father extends React.Component {
    state = {
        info: "父组件传递给子组件的数据"
    }
    setInfo = (info) => {
        return () => {
            this.setState({ info });
        }
    }
	render() {
        return (
        	<div>
            	<h1>父组件</h1>
                {this.state.info}
                <Child info={[this.state.info, this.setInfo]} />
            </div>
        );
    }
}
```

​		使用 `Function.prototype.bind` 实现：

```jsx
class Child extends React.Component {
    render() {
        let [info, setInfo] = this.props.info;
        return (
        	<div>
            	<h1>子组件</h1>
                <div>{info}</div>
                {/* 
                	由于React开启了严格模式，因此bind会将this严格绑定为指定的值。
                	也就是说，如果绑定this为null或undefined，则this将绑成它们。
                	如果不想被bind修改this指向，那么被绑函数应该被声明为箭头函数。
                */}
                <button onClick={setInfo.bind(null, "子组件修改了父组件传递的数据")}>点击修改</button>
            </div>
        );
    }
}

class Father extends React.Component {
    state = {
        info: "父组件传递给子组件的数据"
    }
    setInfo = (info) => {
        this.setState({ info });
    }
	render() {
        return (
        	<div>
            	<h1>父组件</h1>
                {this.state.info}
                <Child info={[this.state.info, this.setInfo]} />
            </div>
        );
    }
}
```

​		从子组件调用父组件提供的方法修改父组件的传递数据这个示例中，不难看出：子组件要发送数据给父组件，只需要调用父组件提供的方法即可（将数据以参数的形式传给父组件）。

```jsx
class Child extends React.Component {
    state = {
        sentData: '子组件发送给父组件的数据'
    }
    render() {
        let {sentData} = this.state;
        let setData = this.props.setData;
        return (
        	<div>
            	<h1>子组件</h1>
                <button onClick={setData(sentData)}>给父组件传递数据</button>
            </div>
        );
    }
}

class Father extends React.Component {
    state = {
        receivedData: ""
    }
    setData = (receivedData) => {
        return () => {
            this.setState({ receivedData });
        }
    }
	render() {
        let {receivedData} = this.state;
        return (
        	<div>
            	<h1>父组件</h1>
                {receivedData}
                <Child setData={this.setData} />
            </div>
        );
    }
}
```

##### 兄弟通信

​		兄弟组件之间不可以直接进行通信。因此，需要以父组件为中转站。其基本原理如下：

- 父组件：定义初始数据，并提供一个修改该数据的方法。
- 子组件：
  - 发送者：调用父组件传递的修改数据的方法，向父组件传递数据。
  - 接收者：发送者传递数据给父组件后，父组件转发数据给接收者。

```jsx
class Sender extends React.Component {
    state = {data: '发送数据'}
    sent = () => {
        this.props.transfer(this.state.data);
    }
    render() {
        return (
        	<div>
            	<h1>发送者</h1>
                <button onClick={this.sent}>发送</button>
            </div>
        );
    }
}

class Receiver extends React.Component {
    state = {data: ''}
    render() {
        let {data} = this.props;
        this.state.data = data; // 在render中不可调用setState，只能通过原生方式修改。
        return (
        	<div>
            	<h1>接收者</h1>
                {this.state.data}
            </div>
        );
    }
}

class Agent extends React.Component {
    state = {data: ''}
    transfer = (data) => {
        this.setState({data});
    }
    render() {
        let {data} = this.state;
        return (
        	<div>
            	<h1>父组件</h1>
                <Sender transfer={this.transfer} />
                <Receiver data={data} />
            </div>
        );
    }
}
```

##### 深层通信

​		深层通信指的是，跨组件通信。有时，一个组件可能需要直接将数据传递给后代组件，而不是只能传给子组件。

​		在 `React` 中，跨组件通信通过 `React.createContext()` 创建的一个上下文对象来实现。基本步骤如下：

- 创建上下文：先在全局通过调用 `React.createContext()` 创建一个 `context` 上下文对象。
- 包裹子组件：然后在发送者组件中，使用内置的类组件 `<context.Provider>` 包裹其子组件。
- 设置传递值：在这个内置类组件上有一个必填的 `value` 属性，它用于存放要发送的数据。
- 绑定上下文：接收者组件通过将 `contextType` 静态属性绑定为该上下文对象来接收数据。

​		首先在全局创建一个上下文对象，然后，获取该上下文对象上的 `<Provider>` 内置类组件。在发送者组件中使用这个内置类组件包裹其子组件，这个子组件必须是接收者组件的直系祖先。接着，使用接收者组件所对应的类的 `contextType` 静态属性来绑定发送者组件所使用的上下文对象。这样一来，二者之间便建立起了跨越中间组件的直接通信渠道。此时，发送者组件就可以在内置类组件上通过必填的 `value` 属性传递数据了，然后接收者组件的 `context` 实例属性会自动接收这些数据。

```jsx
// 创建上下文
const {createContext} = React,
      MyContext = createContext();

class ThirdGeneration extends React.Component {
    // 绑定上下文
    static contextType = MyContext
    render() {
        return (
        	<div>
            	<h1>第三代组件</h1>
                <div>{this.context}</div> {/* 获取传递数据 */}
            </div>
        );
    }
}

class SecondGeneration extends React.Component {
    render() {
        return (
        	<div>
            	<h1>第二代组件</h1>
                <ThirdGeneration />
            </div>
        );
    }
}

class FirstGeneration extends React.Component {
    render() {
        return (
        	<div>
            	<h1>第一代组件</h1>
                {/* 使用上下文上的Provider组件包裹子组件，并通过value属性设置传值 */}
                <MyContext.Provider value={'第一代组件发送的数据'}>
                	<SecondGeneration  />
                </MyContext.Provider>
            </div>
        );
    }
}
```

​		注意：给 `value` 设置的数据不可以是普通对象、函数和内置的 `<Provider>` 类组件，可以是原始值、数组以及任何可渲染的元素。如果要传递普通对象，则可以使用 `JSON` 格式。

```jsx
class FirstGeneration extends React.Component {
    render() {
        return (
        	<div>
            	<h1>第一代组件</h1>
                <MyContext.Provider value={JSON.stringify({a: 1})}> {/* 在接收者组件中再使用parse转即可 */}
                	<SecondGeneration  />
                </MyContext.Provider>
            </div>
        );
    }
}
```

​		当然，`<Provider>` 类组件也是可以互相包裹的，以向后代组件传递更多的数据（或者给不同的后代组件提供不同的数据）。

```jsx
const {createContext} = React,
      MyContext1 = createContext(),
	  MyContext2 = createContext();

class ThirdGeneration extends React.Component {
    // 绑定上下文1
    static contextType = MyContext1
    render() {
        return (
        	<div>
            	<h1>第三代组件</h1>
                <div>{this.context}</div> {/* 获取传递数据 */}
            </div>
        );
    }
}

class SecondGeneration extends React.Component {
	// 绑定上下文2
    static contextType = MyContext2
    render() {
        return (
        	<div>
            	<h1>第二代组件</h1>
                <div>{this.context}</div> {/* 获取传递数据 */}
                <ThirdGeneration />
            </div>
        );
    }
}

class FirstGeneration extends React.Component {
    render() {
        return (
        	<div>
            	<h1>第一代组件</h1>
                <MyContext1.Provider value={'第一代组件发送的数据1'}>
                    <MyContext2.Provider value={'第一代组件发送的数据2'}>
                		<SecondGeneration  />
                    </MyContext2.Provider>
                </MyContext1.Provider>
            </div>
        );
    }
}
```

​		更多参考：[`Context`](https://zh-hans.reactjs.org/docs/context.html) 

##### 类型检查

​		在组件之间互相通信时，有时可能需要检查其他组件（不信任的组件）传递过来的数据是否是自身需要的数据类型。限制数据类型，当然可以使用 `TypeScript` 的语法。不过，也可以通过引入第三方的类型校验库来进行检测。

​		在 `React 15.5` 之前，可以直接使用 `React.PropTypes` 属性来进行类型检测。但自 `React 15.5` 起，`React.PropTypes` 已移入另一个包中。请使用 [`prop-types` 库](https://www.npmjs.com/package/prop-types) 代替。

```react
<script src="https://unpkg.com/prop-types@15.6/prop-types.js"></script>
```

​		很明显，`PropTypes` 库用于检测接收者组件的 `props` 属性中数据的类型。因此，要检测哪个组件接收到的数据的类型，就在这个组件的类上设置 `propTypes` 属性。它是一个配置对象，在这个对象中配置每个 `prop` 数据的类型。可检测的类型大致有：

- 数字：`PropTypes.number` —— 传递的数据必须是数字型
- 字符串：`PropTypes.string` ——  传递的数据必须是字符串型
- 布尔值：`PropTypes.bool` ——  传递的数据必须是布尔型
- 符号型：`PropTypes.symbol` ——  传递的数据必须是符号型
- 函数：`PropTypes.func` ——  传递的数据必须是函数型
- 数组：`PropTypes.array` ——  传递的数据必须是数组型
- 对象：`PropTypes.object` ——  传递的数据必须是对象型
- 节点：`PropTypes.node` ——  传递的数据可以是任何可被渲染的节点（包括数字、字符串、元素、数组或 `Fragment`）
- 元素：`PropTypes.element` ——  传递的数据必须是 `React` 元素
- 元素类型：`PropTypes.elementType` ——  传递的数据必须是 `React` 元素的类型（如：`"Child"`，**只用在脚手架中**）。
- 实例类型：`PropTypes.instanceOf()` ——  传递的数据必须是指定构造函数或类的实例（使用 `instanceof` 来判断）。
- 枚举类型：`PropTypes.oneOf([])` ——  传递的数据必须是指定数组中的一项。
- 类型枚举：`PropTypes.oneOfType([])` —— 传递的数据的类型必须是指定数组中的一项。
- 数组元素：`PropTypes.arrayOf()` —— 传递的数据必须是指定类型的数组（即：由某一类型的元素组成）。
- 对象属性：`PropTypes.objectOf()` —— 传递的数据必须是指定属性值类型的对象（即：由某一类型的值组成）。
- 形态类型：`PropTypes.shape({})` —— 传递的数据应该是包含指定属性以及对应值类型的对象（即：可由特定的类型值组成）。
- 确切类型：`PropTypes.exact({})` —— 传递的数据只能是包含指定属性以及对应值类型的对象（即：只由特定的类型值组成）。
- 任意类型：`PropTypes.any` —— 传递的数据可以是任意类型。
- 必传数据：你可以在任何 `PropTypes` 类型后面加上 `.isRequired` ，确保这个数据没有被提供时，会发出警告信息。
- 自定义验证器：你可以使用函数指定一个自定义验证器。它在验证失败时应返回一个 `Error` 对象，而不是抛出异常。

```jsx
class Child extends React.Component {
    render() {
        let {name, age, isMale, person, strOrNum} = this.props;
        return (
        	<div>
            	<h1>子组件</h1>
                <p>姓名：{name}</p>
                <p>年龄：{age}</p>
                <p>性别：{isMale ? '男' : '女'}</p>
            </div>
        );
    }
}

function Person() {}

class Father extends React.Component {
    render() {
        return (
        	<div>
            	<Child 	name = "王子" 
                    	age = {17} 
                    	isMale = {true} 
                    	person = {new Person()} 
                    	strOrNum = {'str'}
                    	numArr = {[0, 1, 2]}
                    	strObj = {{a: 'so'}}
                    	shape = {{name: 'shape', id: 0}}
                    	exact = {{age: 21}}
                    	customProp = {'matchme'}
				/>
            </div>
        );
    }
}

// 限制<Child />组件接收到的数据的类型
Child.propTypes = {
    name: PropTypes.string, 					 // 只能传递字符串
    age: PropTypes.number, 						 // 只能传递数字
    isMale: PropTypes.bool, 					 // 只能传递布尔值
    person: PropTypes.instanceOf(Person), 		 // 只能传递Person的实例
    strOrNum: PropTypes.oneOfType([ 			 // 只能传递字符串或数字
        PropTypes.string, 
        PropTypes.number
    ]),
    numArr: PropTypes.arrayOf(PropTypes.number),  // 只能传递数字型数组（元素必须都是数字型）
    strObj: PropTypes.objectOf(PropTypes.string), // 只能传递字符串型对象（属性值必须都是字符串型）
    shape: PropTypes.shape({ 					  // 只能传递一个对象，如果包含指定属性则必须符合其值类型。
        // 在这里指定的属性都是可选的数据，可以不传，也可以传其他属性。
        // 但如果传递的对象包含这里的属性，则必须符合此处的值类型要求。
        name: PropTypes.string,
        age: PropTypes.number
    }),
    exact: PropTypes.exact({ 					  // 只能传递一个对象，只能包含指定的属性且必须符合其值类型。
        // 在这里指定的属性仍是可选的数据，可以不传，但不能传其他属性。
        // 但如果传递的对象包含这里的属性，则必须符合此处的值类型要求。
        // 与shape的唯一区别：exact不可以传额外的属性，而shape可以。
        name: PropTypes.string,
        age: PropTypes.number
    }),
    customProp: function(props, propName, componentName) {
        // 自定义校验器会依次接收三个参数：组件实例的props属性，接收到的传递数据的名称，作为接收者的当前组件的名称。
    	if (!/matchme/.test(props[propName])) {
      		return new Error(`非法的传递数据'${propName}'被传递给'${componentName}'，导致校验失败。`);
    	}
  	}
}
```

​		元素类型：`PropTypes.elementType`，只能在脚手架中使用。

```jsx
import './App.css';
import PropTypes from "prop-types"

function Foo({Bar}) {
	return (<div>{Bar()}</div>);
}

Foo.propTypes = {
  	Bar: PropTypes.elementType
};

function Bar() {
  	return (<div>Bar组件</div>);
}

function App() {
  	return (
    	<div className="App">
      		<Foo Bar={Bar} />
    	</div>
  	);
}

export default App;
```

​		如果接收到的数据类型与在 `propTypes` 中规定的数据类型不匹配，浏览器就会发出警告，但它并不会阻止数据被接受和渲染。

```jsx
class Father extends React.Component {
    render() {
        return (
        	<div>
            	<Child name="王子" age="17" isMale="true" />
            </div>
        );
    }
}
```

​		比如上面这个修改，浏览器虽然会发出警告，但实际上数据还是会被组件接收，并且也被渲染到了页面上。

​		既然 `propTypes` 是在组件的类上使用的属性，那么当然可以将其直接作为类的静态属性，这是毋庸置疑的。

```jsx
class Child extends React.Component {
    // 限制该类组件接收到的数据的类型
    static propTypes = {
        name: PropTypes.string,
        age: PropTypes.number,
        isMale: PropTypes.bool
    }
    render() {
        let {name, age, isMale} = this.props;
        return (
        	<div>
            	<h1>子组件</h1>
                <p>姓名：{name}</p>
                <p>年龄：{age}</p>
                <p>性别：{isMale ? '男' : '女'}</p>
            </div>
        );
    }
}
```

​		更多参考：[使用 `PropTypes` 进行类型检查](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html) 

##### 默认传值

​		你可以在组件对应的类上，通过配置特定的 `defaultProps` 属性来定义 `props` 的默认值。只有当组件没有接收到这些数据时，才会使用它们的默认值。

```jsx
class Greeting extends React.Component {
  	static defaultProps = {
    	name: 'stranger' // 如果没有接收到name数据，则使用这个默认值。
  	}
  	render() {
    	return (
      		<div>Hello, {this.props.name}</div>
    	)
  	}
}
```

​		`defaultProps` 用于确保当父组件没有传递某些数据时，它们能够有一个默认值。`propTypes` 类型检查发生在 `defaultProps` 赋值之后，所以类型检查也适用于 `defaultProps`。



#### 生命周期

​		`React` 类组件的生命周期，分为三大阶段：挂载、更新和卸载。其中，卸载阶段只有一个 `componentWillUnmount` 钩子函数。

​		每个组件都包含 “生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。**你可以使用此[生命周期图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)作为速查表**。在下述列表中，常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。

##### 周期图谱

​		常用的生命周期函数，如下图：

​		<img src="images/%E7%AC%AC%E4%BA%8C%E8%8A%82/image-20230221145701214.png" alt="image-20230221145701214" style="zoom: 67%;" />

​		所有的生命周期函数，如下图：

​       <img src="images/%E7%AC%AC%E4%BA%8C%E8%8A%82/image-20230221075256173.png" alt="image-20230221075256173" style="zoom: 67%;" /> 

- 组件初始化：初始化组件的数据和方法（相当于在初始化时更新一次 `state`）。
- 状态更新前：每次 `state` 更新之前触发，并设置返回值决定如何更新 `state`。
- 虚拟更新前：在 `state` 更新之后触发，并根据返回值决定是否调用 `render` 重新组织组件的 `DOM` 内容。
- 虚拟更新时：在 `render` 中定义组件的初始虚拟 `DOM`，或在后续更新组件的虚拟 `DOM`（如果允许的话）。
- 虚拟插入前：在将 `render` 更新的虚拟 `DOM` 插入到页面中之前执行。
- 更新渲染中：`React` 将根据插入的虚拟 `DOM` 内容，重新渲染该组件。
- 完成挂载后：在组件被挂载到页面中之后执行，只在初始挂载时执行。
- 重新渲染后：在将 `render` 更新的虚拟 `DOM` 插入到页面中之后执行。
- 组件卸载前：在组件触发卸载操作，即将被卸载之前执行。

​		更多参考：[`React.Component`](https://zh-hans.reactjs.org/docs/react-component.html)、[生命周期图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) 

##### 挂载阶段

​		当组件实例被创建并插入 `DOM` 中时，其生命周期调用顺序如下：

- [**`constructor()`**](https://zh-hans.reactjs.org/docs/react-component.html#constructor)：在组件初始化时调用，以初始化组件的数据或方法（每个组件只调用一次）。
- [`static getDerivedStateFromProps()`](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)：会在调用 `render` 方法之前调用，并且在初始挂载及后续更新时都会被调用。
- [**`render()`**](https://zh-hans.reactjs.org/docs/react-component.html#render)：定义组件的所有虚拟 `DOM` 内容，在每次 `state` 或 `props` 更新后都应被调用，以返回新的虚拟 `DOM` 内容。
- [**`componentDidMount()`**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount)：组件被挂载到 `DOM` 树中后立即调用，即：组件被挂载到页面上之后（每个组件只调用一次）。

###### `constructor`

​		`constructor(props, context)` 具有两个参数：`props` —— `this.props`，`context` —— `this.context`。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super();
        console.log('来自父组件的数据：', props);
        console.log('来自跨组件的数据：', context);
    }
}
```

​		由于 `constructor` 会在类初始化的最后阶段执行，这意味着 `constructor` 能访问类的所有初始化数据和方法。因此，**如果不初始化 `state` 或不进行方法绑定，则不需要为 `React` 组件实现构造函数。**在 `React` 组件挂载之前，会调用它的构造函数。

​		在为 `React.Component` 子类实现构造函数时，应在其他语句之前调用 `super(props)`。否则，`this.props` 在构造函数中可能会出现未定义的 `bug`。

​		通常，在 `React` 中，构造函数仅用于以下两种情况：

- 通过给 `this.state` 赋值对象来初始化 [内部 `state`](https://zh-hans.reactjs.org/docs/state-and-lifecycle.html)。
- 为 [事件处理函数](https://zh-hans.reactjs.org/docs/handling-events.html) 绑定实例。

```jsx
class T extends React.Component {
    constructor(props) {
        super(props);
        // 初始化state
        this.state = {
            arr: ['金泰妍', '林允儿', '李知恩']
        }
        // 为事件处理程序绑定this
        this.change = this.change.bind(this);
    }

    change() {
        this.setState((state, props) => {
            return {
                arr: [...state.arr, '朴孝敏']
            };
        });
    }
    
	render() {
        return (
            <div>
                <h1>测试</h1>
                <button onClick={this.change}>点击</button>
                {
                    this.state.arr
                } 
            </div>
        );
    }
}
```

​		提前绑定 `this`，避免在使用时绑定，从而更方便事件传参。

```jsx
class T extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            arr: ['金泰妍', '林允儿', '李知恩']
        }
        // 提前绑定this
        this.change = this.change.bind(this);
    }

    change(val) {
        return () => {
            this.setState((state, props) => {
                return {
                    arr: [...state.arr, val]
                };
            });
        }
    }

    render() {
        return (
            <div>
                <h1>测试</h1>
                <button onClick={this.change('朴孝敏')}>点击</button>
                {
                    this.state.arr
                } 
            </div>
        );
    }
}
```

​		在 `constructor()` 函数中**不要调用 `setState()` 方法**。如果你的组件需要使用内部 `state`，请直接在构造函数中为 **`this.state` 赋值初始 `state`**。

​		要避免在构造函数中引入任何副作用或订阅。如遇到此场景，请将对应的操作放置在 `componentDidMount` 中。

​		注意：**避免将 `props` 的值复制给 `state`！这是一个常见的错误：**

```jsx
constructor(props) {
 	super(props);
 	// 不要这样做
 	this.state = { color: props.color };
}
```

​		如此做毫无必要（你可以直接其他方法中使用 `this.props.color`），同时还产生了 `bug`（更新 `props` 中的 `color` 时，并不会更新此 `state`） 。**只有在你刻意忽略 `prop` 更新的情况下可这样使用。**此时，应将 `color` 重命名为 `initialColor` 或 `defaultColor`。必要时，你可以[修改它的 `key`](https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key)，以强制 “重置” 其内部 `state`。

###### `static getDerivedStateFromProps`

​		`static getDerivedStateFromProps(props, state)` 接收两个参数：

- `props` —— 最新的 `props`，常与 `shouldComponentUpdate` 中的 `nextProps` 相同。
- `state` —— 最新的 `state`，常与 `shouldComponentUpdate` 中的 `nextState` 相同。即：`setState` 参数与 `state` 合并后的。

​		`props` 和 `state` 中的任何一个更新时，都视为组件的一次更新，当然也会触发 `static getDerivedStateFromProps()` 方法。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super(props);
        console.log('来自父组件的数据：', props);
        console.log('来自跨组件的数据：', context);
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('来自父组件的数据', props); // 最新的props
        console.log('组件自身的数据', state); 	 // 最新的state，融合了setState传参与原state之后的新state。
        return null; // 表示此时不需要再更新state，相当于返回了一个：{...state}。
    }
}
```

​		`getDerivedStateFromProps` 会在调用 `render` 方法之前调用，并且在初始挂载及后续更新时都会被调用。它必须返回一个对象或 `null`，可以返回一个有用的对象来更新 `state`，如果返回 `null` 则不再向 `state` 提供任何更新内容（并不是阻止更新 `state`）。简单来说，就是在更新 `state` 前调用，可根据新的 `props` 数据或 `setState` 的传参设计返回值去更新 `state`，返回值将与 `state` 合并。

​		然后，新的 `props` 和 `state` 将依次作为下一钩子 `shouldComponentUpdate` 的 `nextProps` 和 `nextState` 这两个参数。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super(props);
        console.log('来自父组件的数据：', props);
        console.log('来自跨组件的数据：', context);
        this.state = {
            n: 0
        };
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
		// 在return之前对state的修改，都会映射到state中。
        state.n = 1; 	// 更新state
        // return表示最后一次向state提交可更新的数据内容。
        return null; // 在上述更新操作发生之后无需再更新。
    }
	render() {
        console.log(this.state);
        return (
            <div>
                <h1>组件</h1>
                {this.state.n}
            </div>
        );
    }
}
```

​		值得注意的是，`static getDerivedStateFromProps()` 是类上的静态方法。其中的 `this` 为 `undefined`。定义了该生命周期方法之前，必须初始化 `state`，否则会报错。

###### `render`

​		`render()` 不接收任何参数。它是 `class` 组件中唯一必须实现的方法。

​		它是一个纯函数，这意味着在不修改组件 `state` 的情况下，每次调用都会返回相同的结果（即：相同的虚拟 `DOM` 内容），并且它不会直接与浏览器交互。如需与浏览器进行交互，请在 `componentDidMount()` 或其他生命周期方法中执行你的操作。保持 `render()` 为纯函数，可以使组件更容易思考。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super(props);
        console.log('来自父组件的数据：', props);
        console.log('来自跨组件的数据：', context);
        this.state = {
            name: 'T'
        };
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('来自父组件的数据', props);
        console.log('组件自身的数据', state);
        return null; // 不更新state。
    }
    // 返回（最新的）虚拟DOM
    render() {
        return (
        	<div>
            	{this.state.name}
            </div>
        );
    }
}
```

​		当 `render` 被调用时，它会检查 `this.props` 和 `this.state` 的变化并返回以下类型之一：

- **`React` 元素**：通常通过 `JSX` 创建。例如，`<div />` 会被 `React` 渲染为 `DOM` 节点，`<MyComponent />` 会被 `React` 渲染为自定义组件，无论是 `<div />` 还是 `<MyComponent />` 均为 `React` 元素。
- **数组或 `fragments`**：使得 `render` 方法可以返回多个元素。欲了解更多详细信息，请参阅 [`fragments`](https://zh-hans.reactjs.org/docs/fragments.html) 文档。
- **`Portals`**：可以渲染子节点到不同的 `DOM` 子树中。欲了解更多详细信息，请参阅有关 [`portals`](https://zh-hans.reactjs.org/docs/portals.html) 的文档。
- **字符串或数值类型**：它们在 `DOM` 中会被渲染为文本节点。
- **布尔类型或 `null`**：什么都不渲染（主要用于支持返回 `test && <Child />` 的模式，其中 `test` 为布尔类型）。

​		注意：如果 `shouldComponentUpdate()` 返回 `false`，则不会调用 `render()`。

###### `componentDidMount`

​		`componentDidMount()` 不接收任何参数，它会在组件挂载（插入 `DOM` 树中）后立即调用。依赖于 `DOM` 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super(props);
        this.state = {
            name: 'T'
        };
        console.log('定义初始state');
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('更新state');
        return null; // 不更新state。
    }
    // 返回（最新的）虚拟DOM
    render() {
        console.log('state已变动，返回新的虚拟DOM');
        return (
        	<div>
                <h1 className='h1'>类组件生命周期</h1>
            	{this.state.name}
            </div>
        );
    }
    // 挂载完成后
    componentDidMount() {
        console.log('组件已挂载到页面中');
        let h1 = document.getElementsByClassName('h1')[0]; // 此时，才能够获取到刚插入的组件DOM内容。
    }
}
```

​		这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 `componentWillUnmount()` 里取消订阅。

​		你可以在 `componentDidMount()` 里 **直接调用 `setState()`**。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 `render()` 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 `constructor()` 中初始化 `state`。如果你的渲染依赖于 `DOM` 节点的大小或位置，比如实现 `modals` 和 `tooltips` 等情况下，你可以使用此方式处理。

##### 更新阶段

​		当组件的 `props` 或 `state` 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

- [`static getDerivedStateFromProps()`](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)：与挂载阶段的相同，在每次 `state` 更新之前调用，并决定如何更新 `state`。
- [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)：是否应该更新组件的虚拟 `DOM` 内容，即：是否调用 `render` 重新组织 `DOM`。【实例数据部分更新】
- [**`render()`**](https://zh-hans.reactjs.org/docs/react-component.html#render)：与挂载阶段的相同，用于根据最新的 `state` 或 `props` 更新（或定义）组件的虚拟 `DOM` 内容。【实例数据全部更新】
- [`getSnapshotBeforeUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate)：将虚拟 `DOM` 内容提交到 `DOM` 树之前调用，即：在提交虚拟 `DOM` 至页面重新渲染之前。
- [**`componentDidUpdate()`**](https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate)：在组件被重新渲染完成后立即调用。首次渲染时不会执行此方法，而是进行组件的挂载。

###### `shouldComponentUpdate`

​		`shouldComponentUpdate(nextProps, nextState)` 接收两个参数：

- `nextProps` —— 下一版 `this.props`，与 `getSnapshotBeforeUpdate` 中的 `this.props` 相同。
- `nextState` —— 下一版 `this.state`，与 `getSnapshotBeforeUpdate` 中的 `this.state` 相同。上一钩子更新后的 `state`。

​		由于组件更新时并不会更新其实例，因此在实例数据未更新前它们都将保持原状。而在 `shouldComponentUpdate` 触发时，组件实例上的数据未完全更新，因此其中的 `this.props` 和 `this.state` 都是旧值。注意：在经过 `static getDerivedStateFromProps()` 处理之前的 `props` 和 `state` 都是旧值，处理之后的才是新值（即：此处的 `nextProps` 和 `nextState`）。

```jsx
class T extends React.Component {
    // 定义初始state
    constructor(props, context) {
        super(props);
        console.log('来自父组件的数据：', props);
        console.log('来自跨组件的数据：', context);
        this.state = {
            n: 0,
            b: 'b'
        }
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('getDerivedStateFromProps', props, state);
        state.n = 1; 	// 更新state
        return null; 	// 在上述更新操作发生之后无需再更新。
    }
    // 是否允许render更新
    shouldComponentUpdate(nextProps, nextState) {
        // 组件实例（this）上的props和state未完全更新
        console.log('shouldComponentUpdate', nextProps, this.props, nextState, this.state);
        return true; // 允许执行组件的render来更新虚拟DOM
    }
    render() {
        // 组件实例（this）上的props和state已全部更新
        console.log('render', this.props, this.state);
        return (
            <div>
                <h1>类组件生命周期</h1>
                {this.state.n}
                <button onClick={() => this.setState({n: ++this.state.n, a: 1})}>点击</button>
            </div>
        );
    }
}
```

​		点击后，执行结果如下：

```js
'来自父组件的数据：' {}
'来自跨组件的数据：' {}
'getDerivedStateFromProps' {} {n: 0, b: 'b'}
'render' {} {n: 1, b: 'b'}
'getDerivedStateFromProps' {} {n: 2, b: 'b', a: 1}
'shouldComponentUpdate' {} {} {n: 1, b: 'b', a: 1} {n: 2, b: 'b'}
'render' {} {n: 1, b: 'b', a: 1}
```

​		`shouldComponentUpdate` 钩子函数必须设置返回值，它是一个布尔值。根据返回值，决定 `React` 组件的输出（即：`render` 的输出）是否要受当前 `state` 或 `props` 更改的影响，即：**是否执行 `render()`**。默认行为是 `state` 每次发生变化后组件都会 `render()`。大部分情况下，你应该遵循此默认行为。

​		继 `props` 或 `state` 更新之后，`shouldComponentUpdate()` 会在组件 `render()` 之前被调用。返回值默认为 `true`。首次渲染或使用 `forceUpdate()` 时不会都调用该方法。

​		此方法仅作为 **[性能优化的方式](https://zh-hans.reactjs.org/docs/optimizing-performance.html)** 而存在。不要企图依靠此方法来 “阻止” 渲染，因为这可能会产生 `bug`。如果要这样，你应该 **考虑使用内置的 [`PureComponent`](https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent) 组件**，而不是手动编写 `shouldComponentUpdate()`。`PureComponent` 会对 `props` 和 `state` 进行浅层比较，并减少了跳过必要更新的可能性。

​		如果你一定要手动编写此函数，可以将 `this.props` 与 `nextProps` 以及 `this.state` 与`nextState` 进行比较，并返回 `false` 以告知 `React` 可以跳过更新。请注意，返回 `false` 并不会阻止子组件在 `state` 更改时重新渲染。

​		我们不建议在 `shouldComponentUpdate()` 中进行深层比较或使用 `JSON.stringify()`。这样非常影响效率，且会损害性能。

​		目前，如果 `shouldComponentUpdate()` 返回 `false`，则不会调用 [`UNSAFE_componentWillUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillupdate)，[`render()`](https://zh-hans.reactjs.org/docs/react-component.html#render) 和 [`componentDidUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate)。后续版本，`React` 可能会将 `shouldComponentUpdate` 视为提示而不是严格的指令，并且，当返回 `false` 时，仍可能导致组件重新渲染。

###### `getSnapshotBeforeUpdate`

​		`getSnapshotBeforeUpdate(prevProps, prevState)` 接收两个参数：

- `prevProps` —— 上一版 `props`，与 `shouldComponentUpdate` 中的 `this.props` 相同。
- `prevState` —— 上一版 `state`，与 `shouldComponentUpdate` 中的 `this.state` 相同。

​		此时，组件实例数据已完全更新。其返回值将被作为 `componentDidUpdate` 钩子函数的第三个参数。

​		`getSnapshotBeforeUpdate()` 在最近一次渲染输出（提交到 `DOM` 节点）之前调用，即：在将虚拟 `DOM` 提交给 `React` 进行渲染之前。它使得组件能在其视图发生更改之前从 `DOM` 中捕获一些信息（例如，滚动位置）。

​		此用法并不常见，但它可能出现在 `UI` 处理中，如需要以特殊方式处理滚动位置的聊天线程等。

​		应返回 `snapshot` 的值（或 `null`）。

```jsx
class T extends React.Component {
    // 定义初始state
    state = {
        name: 'T'
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('更新state');
        return null; // 不更新state。
    }
    // 是否允许render更新
    shouldComponentUpdate(nextProps, nextState) {
        console.log(nextProps, nextState); // 获取最新的props和state。
        console.log('在render()之前执行');
        return true; // 允许执行组件的render来更新虚拟DOM
    }
    // 返回（最新的）虚拟DOM
    render() {
        console.log('state已变动，返回新的虚拟DOM');
        return (
        	<div>
                <h1 className='h1'>类组件生命周期</h1>
            	{this.state.name}
                <button onClick={() => this.setState({name: 't'})}>点击修改</button>
            </div>
        );
    }
    // 在虚拟DOM被插入到页面之前执行
    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('在提交虚拟DOM到页面之前执行');
        console.log(prevProps, prevState); // 获取之前的props和state。
        return 'getSnapshotBeforeUpdate的返回值';
    }
}
```

​		注意，在设置了 `getSnapshotBeforeUpdate` 之后，必须设置 `componentDidUpdate`，否则会报错。

###### `componentDidUpdate`

​		`componentDidUpdate(prevProps, prevState, snapshot)` 接收三个参数：`prevProps` —— 上一版 `props`，`prevState` —— 上一版 `state`，`snapshot` —— `getSnapshotBeforeUpdate` 的返回值。

​		`componentDidUpdate()` 会在组件被重新渲染完成后立即调用。首次渲染不会执行此方法。

​		当组件更新后，可以在此处对 `DOM` 进行操作。如果你对更新前后的 `props` 进行了比较，也可以选择在此处进行网络请求。例如，当 `props` 未发生变化时，则不会执行网络请求。

```jsx
class T extends React.Component {
    // 定义初始state
    state = {
        name: 'T'
    }
    // 根据props更新state
    static getDerivedStateFromProps(props, state) {
        console.log('更新state');
        return null; // 不更新state。
    }
    // 是否允许render更新
    shouldComponentUpdate(nextProps, nextState) {
        console.log('在render()之前执行');
        return true; // 允许执行组件的render来更新虚拟DOM
    }
    // 返回（最新的）虚拟DOM
    render() {
        console.log('state已变动，返回新的虚拟DOM');
        return (
        	<div>
                <h1 className='h1'>类组件生命周期</h1>
            	{this.state.name}
                <button onClick={() => this.setState({name: 't'})}>点击修改</button>
            </div>
        );
    }
    // 在虚拟DOM被插入到页面之前执行
    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('在提交虚拟DOM到页面之前执行');
        return 'getSnapshotBeforeUpdate的返回值';
    }
    // 在组件被重新渲染后执行
    componentDidUpdate(prevProps, prevState, snapshot) {
        // 获取上一次的props和state，以及getSnapshotBeforeUpdate的返回值。
        console.log(prevProps, prevState, snapshot); 
        console.log('组件重新渲染完成'); // 此时，才可以获取到最新的DOM内容。
    }
}
```

​		你也可以在 `componentDidUpdate()` 中 **直接调用 `setState()`**，但请注意 **它必须被包裹在一个条件语句里**，正如下面的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 `props` “镜像” 给 `state`，请考虑直接使用 `props`。 欲了解更多有关内容，请参阅 [为什么 `props` 复制给 `state` 会产生 `bug`](https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)。

```jsx
componentDidUpdate(prevProps) {
  	// 典型用法（不要忘记比较 props）：
  	if (this.props.userID !== prevProps.userID) {
    	this.setState(this.props.userID);
  	}
}
```

​		如果组件实现了 `getSnapshotBeforeUpdate()` 生命周期（不常用），则它的返回值将作为 `componentDidUpdate()` 的第三个参数 `"snapshot"` 参数传递。否则此参数将为 `undefined`。

​		注意：如果 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate) 返回值为 `false`，则不会调用 `componentDidUpdate()`。

##### 卸载阶段

​		类组件的卸载阶段只有一个 `componentWillUnmount()` 钩子函数，它不接收任何参数。

​		`componentWillUnmount()` 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 `timer`，取消网络请求或清除在 `componentDidMount()` 中创建的订阅等。

```jsx
class T extends React.Component {
    // 定义初始state
    state = {
        name: 'T'
    }
    // 更新state之前
    static getDerivedStateFromProps(props, state) {
        console.log('更新state');
        return null; // 不更新state。
    }
    // 是否允许render更新
    shouldComponentUpdate(nextProps, nextState) {
        console.log('在render()之前执行');
        return true; // 允许执行组件的render来更新虚拟DOM
    }
    // 返回最新的虚拟DOM
    render() {
        console.log('state已变动，返回新的虚拟DOM');
        return (
        	<div>
                <h1 className='h1'>类组件生命周期</h1>
            	{this.state.name}
                <button onClick={() => this.setState({name: 't'})}>点击修改</button>
            </div>
        );
    }
    // 组件被重新渲染之前
    getSnapshotBeforeUpdate(prevProps, prevState) {
        console.log('在提交虚拟DOM到页面之前执行');
        return 'getSnapshotBeforeUpdate的返回值';
    }
    // 组件被重新渲染之后
    componentDidUpdate(prevProps, prevState, snapshot) {
        console.log('组件重新渲染完成'); // 此时，才可以获取到最新的DOM内容。
    }
    // 组件即将卸载前执行
    componentWillUnmount() {
        console.log('组件即将卸载');
    }
}
```

​		`componentWillUnmount()` 中 **不应调用 `setState()`**，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。

##### 错误处理

​		当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

- [`static getDerivedStateFromError()`](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror)：在后代组件抛出错误后被调用。
- [`componentDidCatch()`](https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch)：在后代组件抛出错误后被调用。

###### `static getDerivedStateFromError`

​		`static getDerivedStateFromError(error)` 接收一个参数：`error` —— 错误的信息。

​		此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 `state`。

```jsx
class ErrorBoundary extends React.Component {
  	constructor(props) {
    	super(props);
    	this.state = { hasError: false };
  	}

  	static getDerivedStateFromError(error) {
    	// 更新 state 使下一次渲染可以显降级 UI
    	return { hasError: true };
  	}

  	render() {
    	if (this.state.hasError) {
      		// 你可以渲染任何自定义的降级 UI
      		return <h1>Something went wrong.</h1>;
    	}
		// 如果没有错误，则渲染原 UI
    	return this.props.children;
  	}
}
```

​		`getDerivedStateFromError()` 会在 “渲染” 阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 `componentDidCatch()`。

###### `componentDidCatch`

​		此生命周期在后代组件抛出错误后被调用。 它接收两个参数：

1. `error` —— 抛出的错误。
2. `info` —— 带有 `componentStack` `key` 的对象，其中包含 [有关组件引发错误的栈信息](https://zh-hans.reactjs.org/docs/error-boundaries.html#component-stack-traces)。

​		`componentDidCatch()` 会在 “提交” 阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：

```jsx
class ErrorBoundary extends React.Component {
  	state = { hasError: false }

 	static getDerivedStateFromError(error) {
    	// 更新 state 使下一次渲染可以显示降级 UI
    	return { hasError: true };
  	}

  	componentDidCatch(error, info) {
    	// "组件堆栈" 例子:
    	//   in ComponentThatThrows (created by App)
    	//   in ErrorBoundary (created by App)
    	//   in div (created by App)
    	//   in App
    	logComponentStackToMyService(info.componentStack);
  	}

  	render() {
    	if (this.state.hasError) {
      		// 你可以渲染任何自定义的降级 UI
      		return <h1>Something went wrong.</h1>;
    	}

    	return this.props.children;
  	}
}
```

​		`React` 的开发和生产构建版本在 `componentDidCatch()` 的方式上有轻微差别。

​		在开发模式下，错误会冒泡至 `window`，这意味着任何 `window.onerror` 或 `window.addEventListener('error', callback)` 会中断这些已经被 `componentDidCatch()` 捕获的错误。

​		相反，在生产模式下错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 `componentDidCatch()` 捕获的错误。

​		注意：如果发生错误，你可以通过调用 `setState` 使用 `componentDidCatch()` 渲染降级 `UI`，但在未来的版本中将不推荐这样做。 可以使用静态 `getDerivedStateFromError()` 来处理降级渲染。



### 函数组件

​		函数组件与类组件有着诸多相似之处。直观来看，相当于将类组件中的数据和方法都集中地放到了一个函数里面。



#### 组件基础

##### 创建组件

​		使用 `function` 声明一个构造函数（函数名大驼峰式），函数名为组件名。使用时以一对尖括号包裹，即可将其转换为组件。

```jsx
// 声明函数组件
function Demo() {}

// 渲染函数组件
app.render(<Demo />);
```

##### 定义 `DOM`

​		函数组件将 `return` 值作为自身的虚拟 `DOM` 内容，相当于类组件中 `render` 的 `return` 所扮演的角色。

```jsx
// 声明函数组件
function Demo() {
    // 通过return来返回虚拟 DOM
    return (
        <div>
            <h1>函数组件</h1>
        </div>
    );
}
```

##### 组件数据

​		在函数组件中，使用原生 `JS` 定义的数据都是组件的非响应式数据。

```jsx
// 声明函数组件
function Demo() {
    // 定义非响应式数据
	let NonResponsiveData = '非响应式的数据';

    return (
        <div>
            <h1>函数组件</h1>
        </div>
    );
}
```

##### 组件方法

​		在函数组件中，定义的任何函数（`function` 或箭头函数）都可直接作为组件的方法来使用。

```jsx
// 声明函数组件
function Demo() {
    // 定义组件方法
	function add() {}
    let delete = () => {};

    return (
        <div>
            <h1>函数组件</h1>
        </div>
    );
}
```

##### `this` 指向

​		由于 `React` 默认开启了严格模式，所以在任何作用域中声明的函数（除对象中的方法外），其 `this` 都将默认是 `undefined`。

```jsx
// 声明函数组件
function Demo() {
    console.log(this, '组件内部'); // undefined
    
    // 定义组件方法
	(function() {
        console.log(this, '普通函数'); // undefined
    }());
    
    (() => {
        console.log(this, '箭头函数'); // undefined
    })();

    return (
        <div>
            <h1>函数组件</h1>
        </div>
    );
}
```

​		当然，每个方法在调用时都可以修改其 `this` 指向。但由于默认指向 `undefined`，所以在函数组件中，通常会避免使用 `this`。所有与 `this` 相关的组件方法都会直接使用函数参数或全局方法的形式来提供。



#### 状态管理

​		前面提到过，可以直接在函数组件中通过原生 `JS` 定义组件数据，只不过它们不是响应式的。

##### 定义状态

​		要定义响应式的函数组件数据，则应使用 `React.useState()` 方法。调用时可以传入初始数据，不传则默认为 `undefined`。该方法返回一个 `[state, setState]` 数组。其中，`state` 是该数据的最新状态，`setState` 则是重写此数据的方法（与类组件的相似）。

```jsx
const { useState } = React;

function T() {
    // 定义一条数据，并获取它的最新状态以及修改方法。
    let [arr, setArr] = useState([1, 2, 3]);
    
    // 查看数据的最新状态
    console.log(arr); // [1, 2, 3]
}
```

##### 重写状态

​		使用 `React.useState()` 方法定义一条数据时，其返回值提供了修改该数据的方法。但要注意以下两点：

- 修改数据是重写式的覆盖原数据。修改数据的方法是异步执行的。
- 禁止直接在函数组件中修改数据。应该通过异步方式的修改数据，如：点击事件等。

```jsx
function T() {
    // 定义一条数据，并获取它的最新状态以及修改方法。
    let [arr, setArr] = useState([1, 2, 3]);
    
	let change = () => {
		// 重写数据（覆盖原数据）
        setArr([0, 0, 0]); 	// 异步执行数据重写
        console.log(arr); 	// 无法获得最新状态
    }
    
    return (
    	<div>
        	<h1>状态管理</h1>
            <ul>
            	{
                    arr.map((item, index) => {
                        return (<li key={index}>{item}</li>);
                    })
                }
            </ul>
            <button onClick={change}>点击</button>
        </div>
    );
}
```

​		值得注意的是，`setArr` 本身是 **异步重写** 数据的。因此，点击后并不能在事件处理程序中立即获得该数据的最新状态。

​		另外，`React` 要求**函数组件必须重写原数据**。原始值默认是替换，但**引用值必须替换原来的引用**，否则组件不会更新。

```jsx
function T() {
    // 定义一条数据，并获取它的最新状态以及修改方法。
    let [arr, setArr] = useState([1, 2, 3]);
    
	let change = () => {
        arr.pop(); // 只删除最后一项，但没有改变引用
        setArr([...arr]); // 重写数据（覆盖原引用）
    }
    
    return (
    	<div>
        	<h1>状态管理</h1>
            <ul>
            	{
                    arr.map((item, index) => {
                        return (<li key={index}>{item}</li>);
                    })
                }
            </ul>
            <button onClick={change}>点击</button>
        </div>
    );
}
```



#### 组件通信

​		函数组件的通信原理与类组件的相似，只是所使用的 `API` 或方法不同而已。

##### 父子通信

​		父子通信，基本使用步骤如下：

- 父传子：首先在组件标签上，使用属性设置传递值。然后组件所对应的函数会使用第一个参数来自动接收。
- 子传父：父组件定义并传递修改自身数据的方法，子组件调用父组件传递的修改方法，上传数据给父组件。

​		父传子示例：

```jsx
function T(props) {
    // 组件所对应的函数的首参会自动接收组件上传递下来的数据。
    console.log(props); // {age: 1}
}

// 将函数组件渲染到页面上
app.render(<T age={1} />); // 在组件标签上，通过属性设置传值。
```

​		子传父示例：

```jsx
const { useState } = React;

function Child(props) {
    let [data, setData] = props.data;
    
    return (
    	<div>
        	<h1>子组件</h1>
            {/* 绑定任何值，都不会改变其this的指向 */}
            <button onClick={setData.bind(null, '子组件发送的数据')}>发送</button>
        </div>
    );
}

function Father() {
    let [data, setData] = useState();
    
    return (
    	<div>
        	<h1>父组件</h1>
            <div>子组件传递的数据：{data}</div>
            <Child data={[data, setData]} /> {/* 建议将原数据也一并传递，方便接收者根据原数据重写它 */}
        </div>
    );
}
```

​		注意：`React.useState()` 返回的修改数据的方法，经过了 `React` 的处理，可直接使用 `bind` 向事件处理程序预传参数。

##### 类型检查

​		同样的，可以使用 `prop-types` 工具来对组件上传递的数据进行类型校验，也是作为组件的静态属性。

```jsx
// 只能定义在函数外部
T.propTypes = {
    age: PropTypes.number
}
```

##### 默认传值

​		直接在组件上使用 `defaultProps` 属性，即可定义组件的默认 `props` 传值。

```jsx
// 只能定义在函数外部
T.defaultProps = {
    age: 0
}
```

##### 兄弟通信

​		与类组件的兄弟通信原理类似，同级函数组件之间的通信也要经历如下步骤：

- 父组件：定义初始数据，并提供一个修改该数据的方法。【数据中转站】
- 子组件：
  - 发送者：调用父组件传递的修改数据的方法，向父组件传递数据。
  - 接收者：发送者传递数据给父组件后，父组件转发数据给接收者。

```jsx
const { useState } = React;

function Sender({sentData}) {
    let [data, setData] = sentData;
    
    let sent = () => {
        setData('兄弟组件发送的数据');
    }
    
    return (
        <div>
            <h1>发送者</h1>
            <button onClick={sent}>发送</button>
        </div>
    );
}

function Receiver({receivedData}) {
    let [data, setData] = receivedData;
    
    return (
        <div>
            <h1>接收者</h1>
            <div>兄弟组件的数据：{data}</div>
        </div>
    );
}

function Agent() {
    let [data, setData] = useState('中转站数据');

    return (
        <div>
            <h1>父组件</h1>
            <Sender sentData={[data, setData]} />
            <Receiver receivedData={[data, setData]} />
        </div>
    );
}
```

##### 深层通信

​		函数组件的深层通信，同样使用 `React.createContext()` 方法。基本步骤如下：

- 创建上下文：先在全局通过调用 `React.createContext()` 创建一个 `context` 上下文对象。
- 包裹子组件：然后在发送者组件中，使用内置的类组件 `<context.Provider>` 包裹其子组件。
- 设置传递值：在这个内置类组件上有一个必填的 `value` 属性，它用于存放要发送的数据。
- 绑定上下文：接收者组件调用 `React.useContext()` 绑定该上下文对象，数据在其返回值中。

```jsx
const { createContext, useContext } = React;

// 创建上下文
const MyContext = createContext();

function ThirdGeneration() {
    // 绑定上下文，获取数据
    let data = useContext(MyContext);
    
    return (
        <div>
            <h1>第三代组件</h1>
            <div>深层通信的数据：{data}</div>
        </div>
    );
}

function SecondGeneration() {
    return (
        <div>
            <h1>第二代组件</h1>
            <ThirdGeneration />
        </div>
    );
}

function FirstGeneration() {
    return (
        <div>
            <h1>第一代组件</h1>
            {/* 使用上下文上的Provider组件包裹子组件，并通过value属性设置传值 */}
            <MyContext.Provider value={'第一代组件发送的数据'}>
                <SecondGeneration  />
            </MyContext.Provider>
        </div>
    );
}
```

​		其他的用法和注意事项与类组件完全相同。



#### 获取元素

​		由于 `this` 默认指向，因此**在函数组件内部是无法获取组件实例的**。所以，函数组件的 `ref` 只能获取到元素节点或类组件的引用。

##### `useRef`

​		函数组件的 `ref` 采用 `hooks` 写法，通过 `React` 上的 `useRef` 方法获取，其原理和用法与类组件的 `createRef` 相似。

```jsx
// 获取 useRef 方法
const { useRef } = React;

// 定义类组件
class Child extends React.Component {
    render() {
        return (
            <div>
                <h1>子类组件</h1>
            </div>
        );
    }
}

function Father() {
    // 创建 Ref 容器以获取 DOM
    let ChildRef = useRef();
    
    // 定义组件方法
    let getRef = () => {
        console.log(ChildRef.current); // 打印获取到的DOM内容
    };
    
    return (
    	<div>
        	<h1>获取子类组件</h1>
            <Child ref={ChildRef} /> {/* 通过DOM上的ref属性绑定Ref容器，将该DOM的引用传递给它 */}
            <button onClick={getRef}>获取</button>
        </div>
    );
}
```

​		注释：`Ref` 容器是一次性的，它们只会绑定一个 `React` 元素。如果同时绑定元素和组件，则会选择绑定组件，而不是元素。

##### `Ref` 转发

​		虽然不可以直接获取到函数组件的实例，但可以通过 `React.forwardRef()` 方法定义函数组件，以此来转发该函数组件中某个子节点的引用。首先需要给 `React.forwardRef()` 传入一个渲染函数，它可接收 `props` 和 `ref` 这两个参数，分别表示父组件传递的数据和父组件创建的 `Ref` 容器。然后在这个渲染函数中定义该函数组件的所有内容，最终 `React.forwardRef()` 会返回一个函数组件节点。

​		获得 `forwardRef` 函数组件之后，就可以在父组件中直接嵌入它了。同样要将父组件创建的 `Ref` 容器绑定到它的 `ref` 属性上。但这个 `ref` 绑定并不是获取函数组件的实例，而是将 `Ref` 容器作为参数向下传递，并作为 `forwardRef` 渲染函数的第二参数被接收。

```jsx
const {useRef, forwardRef} = React;

const Child = forwardRef((props, iptRef) => {
    // 第二个参数，就是组件标签上传递的 Ref 容器。
    return (
    	<div>
        	<h1>子组件</h1>
            <input ref={iptRef} /> {/* 转发该input元素的引用 */}
        </div>
    );
});

function Father() {
    let iptRef = useRef();
    
    let getRef = () => {
        console.log(iptRef.current);
    };
    
    return (
    	<div>
        	<h1>父组件</h1>
            <Child ref={iptRef} /> {/* 向下传递 Ref 容器 */}
            <button onClick={getRef}>获取</button>
        </div>
    );
}
```

​		如果有多个节点要获取，则可给 `ref` 属性赋值一个包含多个 `Ref` 容器的对象。

```jsx
const Child = forwardRef((props, refs) => {
    // 第二个参数，就是组件标签上传递的 Ref 容器。
    return (
        <div>
            <h1>子组件</h1>
            <input ref={refs.ref1} /> {/* 转发该input元素的引用 */}
            <input ref={refs.ref2} /> {/* 转发该input元素的引用 */}
        </div>
    );
});

function Father() {
    let ref1 = useRef();
    let ref2 = useRef();

    let getRef = () => {
        console.log(ref1.current.value);
        console.log(ref2.current.value);
    };

    return (
        <div>
            <h1>父组件</h1>
            <Child ref={{ref1, ref2}} /> {/* 向下传递 Ref 容器 */}
            <button onClick={getRef}>获取</button>
        </div>
    );
}
```

​		但其实，根本不需要使用 `React.forwardRef()` 方法，直接使用 `props` 传递 `Ref` 容器也能获取子级函数组件中的子节点引用。

```jsx
const { useRef } = React;

function Child(props) {
    return (
        <div>
            <h1>子组件</h1>
            <input ref={props.iptRef} /> {/* 获取该input元素的引用 */}
        </div>
    );
};

function Father() {
    let iptRef = useRef();

    let getRef = () => {
        console.log(iptRef.current);
    };

    return (
        <div>
            <h1>父组件</h1>
            <Child iptRef={iptRef} /> {/* 向下传递 Ref 容器 */}
            <button onClick={getRef}>获取</button>
        </div>
    );
}
```

