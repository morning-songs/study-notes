# `TypeScript`

### 基础

目的：限制变量的类型。

分类：类型系统根据类型检查的机制，可分为动态类型和静态类型。

- 动态类型：在运行阶段进行类型检查，如 `JS` 解释型语言，没有编译阶段。
- 静态类型：在编译阶段进行类型检查，如 `TS` 在运行之前需要先编译为 `JS`。

注意：所有合法的 `JS` 代码，都是 `TS` 代码，意味着合法的 `JS` 代码都可以直接搬到 `TS` 中使用，因为 `TS` 是 `JS` 的扩展和延伸。

扩展：

​		`TypeScript` 和 `VSCode` 都是由微软开发的，并且 `VSCode` 内部是使用 `TS` 语言来开发的。所以，`VSCode` 对 `TS` 的支持非常好，也因此 `VSCode` 对书写的 `TS` 代码拥有很强大的语法检查能力，以及语法提示和语法矫正功能。例如：在使用 `VSCode` 书写 `TS` 代码的过程中，`VSCode` 就能够实时地提示出语法错误（将鼠标悬停到提示错误的代码上时，还会显示详细的错误信息）。

编译：在 `node` 中可使用 `tsc` 指令将指定的 `ts` 文件编译为 `js` 文件，如：`tsc index.ts`。如果 `ts` 文件中有语法错误，则会在控制台打印错误信息。默认情况下，即使在编译过程中报出了错误，最终仍然会在同级目录下转换出一个同名的 `js` 文件，如：`index.js`。

语言类型：根据是否允许变量自动发生类型转换，可以将语言分为强类型语言和弱类型语言。

- 弱类型：变量可以根据环境变化自动进行转换，即：允许隐式类型转换，如：`JS`，`TS`，`PHP` 等。
- 强类型：不会隐式转换类型，除非强制类型转换，否则永远保持该类型，如：`Java`，`C++` 等。

注释：`TS` 是完全兼容 `JS` 的，因为 `TS` 的核心理念就是在完全保留 `JS` 运行行为的基础上，去引入静态类型系统，来提高代码的可维护性以及减少 `bug`。因此，`TS` 也是一门弱类型语言，即：`TS` 允许隐式类型转换。



### 使用

##### 安装

在 `NPM` 官网，找到 `TypeScript` 的工具包，当前安装为 4.9.4 版本，建议全局安装。

```shell
npm install -g typescript@4.9.4
```

检查版本号：安装好之后，通过 `tsc -v` 指令检查安装的版本号。【`tsc`：是由 `TS` 工具包提供的指令】

##### 编译

新建 `ts` 文件，在命令行窗口中通过 `tsc` 指令将指定的 `ts` 文件编译成 `js` 文件。

```shell
tsc index.ts
```

如果被编译的 `ts` 文件中有语法错误，则会在控制台中打印错误信息。默认情况下，无论是否在编译过程中报出了错误，最终都会在同级目录下转换并生成一个同名的 `js` 文件，如：`index.js`。

##### 执行

要查看 `ts` 执行的结果，可以通过执行编译生成的 `js` 文件，将其引入 `html` 文件中或者直接在命令行工具中通过 `node` 指令执行它。

```shell
node index.js
```

`VSCode` 终端运行：按 `F5` 可选择在何处运行当前文件，可选择将 `ts` 文件在 `Node.js` 环境下运行。快捷键：`ctrl + ~`（反引号键）



### 语法

##### 限定变量类型

在声明变量时，可以在变量名后紧跟一个 `:` 以及一个数据类型，以此来实现对变量类型的提前限定。

```tsx
let age:number = 14; // 官方称其为：类型注解
```

冒号前后可以有空格，也可以都省略。但更应值得注意的是，严格模式下，如果变量声明时未初始化，那么使用它之前必须为其赋值。

```tsx
// 默认在严格模式下
// 未初始化变量
let num: number; // 在JS中默认将其赋值为：undefined

// 任何一个变量在使用前，必须先为其赋值，否则会报错。
console.log(num); // Variable 'num' is used before being assigned.

num = 10;

console.log(num); // 10
------------------------------------------------------------------------------------------------------------

// 在非严格模式下：允许在为赋值之前使用未初始化的变量
let str: string;

console.log(str); // undefined
```

误区：

- `TS` 的类型系统限制的是变量的类型，而不是值的类型。通过限制变量类型来限制值。
- 限制变量的类型，是为了在赋值时，保证赋给该变量的值应该符合此变量的类型要求。
- 所以，值的类型通常都一定符合变量的类型要求。但也有变量误存其他类型值的情况。

```tsx
let num: number = 0;
let an: any = 'any';

num = an;

console.log(typeof num, num); // 'string' 'any'
```

##### 语法判断干扰

当在 `VSCode` 中，同时打开 `ts` 文件及其编译后的 `js` 文件时，由于两个文件中的变量都相同，所以，`VSCode` 会误认为开发者在 `ts` 文件中声明了两个同名变量，因此会出现语法报错的提示。此时，只需要关闭其编译的 `js` 文件即可。

##### 简化运行步骤

每次写完 `ts` 代码，运行它都需要经过如下两步：先通过 `tsc` 指令编译指定的 `ts` 文件，然后通过 `node` 指令执行其编译的 `js` 文件。

为了简化这两个步骤，可以在 `npm` 中下载 `ts-node` 工具包，建议全局安装。

```shell
npm install -g ts-node
```

当安装好之后，该包会提供一个 `ts-node` 的命令。使用该指令就可以直接运行 `ts` 文件了。

```shell
ts-node index.ts
```

`ts-node` 工具会先将 `ts` 文件进行编译，然后运行其编译后的 `js` 文件。相当于是对原先两个步骤的封装，但它并不会生成 `js` 文件。

##### `ts` 配置文件

通过 `tsc --init` 可以得到 `ts` 初始化的默认配置文件。在项目根目录下会生成该 `tsconfig.json` 配置文件。

##### 指定目标版本

在 `tsconfig.json` 配置文件中，可以通过 `target` 根节点将 `ts` 文件编译成指定版本的 `js` 文件。默认为 `es3`，即：`ES3` 语法。

```json
"target": "es2020", // 编译成es2020版本的js文件，以支持使用es2020语法书写的代码。
```

注释：所有高于 `target` 的语法都会被降级为 `target` 的语法，但这不包括 `API`（它需要填充 `polyfill` 以及设置 `lib` 编译选项）。`lib` 选项用于指定要包含在编译过程中的 `JavaScript` 标准库。默认情况下，`TypeScript` 编译器将根据目标 `JavaScript` 版本自动选择相应的标准库。

更多参考：[`tsconfig#target`](https://www.typescriptlang.org/tsconfig#target) 

##### `ts` 数据类型

`ts` 的数据类型：

- `JS` 原有类型：
  - 原始类型：`nunber`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`。
  - 对象类型：`object`（对象、数组、函数、集合……）
- `TS` 新增类型：联合类型、接口、元组、枚举、`any`、`void` ……

注释：由于 `ts` 相关的文件已经使用了一些变量名，因此要避免使用这些变量，以防止变量冲突。例如：在 `lib.dom.d.ts` 文件中已经声明过了 `name` 变量，因此，不能在 `ts` 文件中再使用该变量，可使用 `myName` 等变量代替。

```tsx
// 在lib.dom.d.ts文件中，有如下声明：
declare const name: void;
```

另外，虽然 `bigint` 类型和 `number` 类型都是数字类型，但是在 `ts` 中两者的变量不能互换值。它们本身就是两种原始的数据类型。

```tsx
let myAge:number = 14;

myAge = 1000n; // 提示报错：不能将类型“bigint”分配给类型“number”。
```

##### `void` 类型

`ts` 新增的数据类型 `void` 类型，表示空值类型，其变量除了可以被赋值为 `void` 类型外，还可以被手动赋值为 `undefined` 或 `null`。

```tsx
let v1:void = undefined,
    v2:void = null; // 仅限非严格模式下
```

不过，在严格模式下，将 `void` 类型的变量赋值为 `null` 会发生语法错误。此时，可以在 `ts` 的默认配置文件中，将 `strict` 根节点的值改为 `false`，表示关闭严格模式。

`undefined` 类型和 `null` 类型：这两种类型在 `ts` 中，一般用处不大，因为它们只能被赋值为 `undefined` 或 `null` 值。但是，在 `ts` 的非严格模式下，这两种类型可以被看作是所有类型的子类型，这意味着它们可以作为任何类型的初始值。但是 `void` 类型不可以。

```tsx
// 仅限非严格模式下
let num:number = undefined,
    str:string = null;
```

##### 数组类型

在 `ts` 中，限制数组类型其实是在限制（最里层）数组中元素的类型。主要有两种限制方法。

```tsx
// 一维数组
// 1、类型[]的常用表示法
let arr1:number[] = [1, 2, 3];
let arr2:string[] = ['1', '2', '3'];

// 2、泛型表示法
let arr3:Array<string> = ['1', '2', '3'];

// 多维数组：在类型后的中括号数量，就是该数组的维度。
// 1、常用表示法
// 二维数组
let arr4: number[][] = [[1], [2], [3]];
// 三维数组
let arr5: number[][][] = [[[1]], [[2]], [[3]]];

// 2、泛型表示法
// 二维数组
let arr6: Array<Array<number>> = [[1], [2], [3]];
// 三维数组
let arr7: Array<Array<Array<number>>> = [[[1]], [[2]], [[3]]];
```

从泛型表示法中，可以直观地看出：限制数组类型，就是在限制最里层的数组元素的类型。并且支持更复杂的类型约束。

第一种在表示一维数组时比较直观且方便好用，因此是常用的限制一维数组元素类型的方法。但是，这样只能在数组中填充单一的数据类型，如果要填充多种类型，可以使用 `ts` 新增的联合数据类型。

##### 联合类型

由多种数据类型组成的数据类型，值可以是指定的数据类型中的任意一种。使用一个竖线 `|` 来连接多种数据类型，表示一种并集。

```tsx
let a: number | string = '1'; 	// 可以理解为：a变量能够存储number值和/或string值。
let b: number | string = 2; 	// 可以理解为：b变量能够存储number值和/或string值。

// 在数组中的使用
let arr1: number[] | string[] = [1, 2, 3]; // 元素要么都是number，要么都是string，元素类型单一。
let arr2: number[] | string[] = ['1', '2', '3'];
// 上面这种方式，可将数组元素限制为number或者string类型的值，但应用这样限制的数组只接受单一类型的元素，它是一种单类型数组。
// 如果要在数组中允许多种类型的元素，可以使用如下的语法。
let arr3: (number | string)[] = [1, '2', 3]; // 元素既可以是number，也可以是string，元素类型多样。
```

另外，当定义多维数组的类型时，使用泛型表示法会更加方便和直观。

```tsx
// 二维数组
let arr: Array<Array<number | string> | boolean> = [[1], [2], true];
```

##### 类型别名

类型别名：使用 `type` 关键字给某个类型自定义一个别名，主要用在复杂的数据类型中，如：联合类型。

```tsx
// 当联合类型过长，或者需要多次使用时，可以给这种类型起一个别名。
let arr1: number[] | string[] | boolean[] = [1, 2, 3];
let arr2: (number | string | boolean)[] = [1, '2', 3];

// 定义类型别名
type SingleArray_nsb = number[] | string[] | boolean[];
type Array_nsb = (number | string | boolean)[];
// 使用类型别名
let arr3: SingleArray_nsb = [1, 2, 3];
let arr4: Array_nsb = [1, '2', false];
```

关于类型别名的规范：建议将首字母大写，且在末尾体现数据类型，尽量做到见名知意，如 `CustomArray`。

注意：类型别名看起来像是创建了一种新的数据类型，但它并不没有创建新的数据类型，只是给某种类型起了一个方便的别名而已。

##### 类型推论

在 `TS` 中，当没有明确指定某个变量的类型时，`TS` 会根据变量的值推断出该变量的类型，并将其隐式限定为该类型。

```tsx
let a = 'wanzi';

a = 14; // 语法错误：不能将类型“number”分配给类型“string”。
```

由于类型推论机制的存在，就可以像 `js` 一样直接给变量初始化一个值，而省略类型注解了，因为变量会被自动限制为其初始值的类型。

```tsx
let num = 10; // 将num变量自动限制为number类型。
```

如果只声明了变量而未将其初始化，那么该变量将被推断为 `any` 类型，即：任意类型的值都可以赋给它。

```tsx
let a; // 变量a为any类型，可以存储任意类型的值

a = 1;
a = '0';
```

在 `ts` 中，通常不建议将变量指定为 `any` 类型，因为这样就与 `js` 无异了。而类型注解的意义就在于：给暂时不初始化的变量手动指定一个类型，避免类型推论机制将其推断为 `any` 类型。

```tsx
let a:number; // 注解该变量的数据类型

a = 1;
```

##### `any` 类型

`any` 类型表示任意类型。一旦定义为了 `any` 类型，那么它就失去了 `TS` 的类型检查（或保护）机制，它就与使用 `js` 没有区别了。因此，通常情况下，当提示某个值 “隐式具有 `any` 类型” 时，就可能会在编译时报错。

没有 `any` 类型的字面量，所以也就没有 `any` 类型的值。`TS` 只有 `any` 类型的变量，这种变量表示可以在任何时候存储任意类型的值。与 `JS` 的变量极其相似，在运算过程中也会首先确定值的类型，但变量始终为 `any` 型。

有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any`类型来标记这些变量。在对现有代码进行改写的时候，`any`类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。



### 小结

特性：类型系统（避免不必要的语法错误，提高开发效率），适用于任何规模的项目（尤其是中大型项目）。

与标准同步发展：

​		从 `2015` 年开始，`ECMA` 组织在每年的 6 月份左右都会发布一个最新版本的 `ES` 语法，每一版中都会带来一些新的语法。任何人都可以向标准委员会（又称 `TC39` 委员会）提案，要求修改语言标准。

​		一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 `TC39` 委员会批准。

1. `Stage 0`：`Strawman`（提议阶段）
2. `Stage 1`：`Proposal`（提案阶段）
3. `Stage 2`：`Draft`（草案阶段）
4. `Stage 3`：`Candidate`（候选阶段）
5. `Stage 4`：`Finished`（定案阶段）

​		一个提案只要能够进入 `Stage 2`，就差不多会包括在以后的正式标准里面。`ECMAScript` 当前的所有草案，可以在 `TC39` 的官方网站 https://tc39.es/ecma262 中查看。而当进入 `Stage 3` 时，其语法就可能已经得到部分浏览器的支持了，并成为实验性语法。

​		一个新的 `ES` 语法只要到了候选阶段，`TS` 就可以支持该语法了，不需要等到正式发布。几乎与标准同步发展，不用担心兼容性。

优势：`TS` 相对于 `JS` 的优势

- 能够更早地发现代码的错误，提高开发效率。
- 大多数的 `IDE` 编辑器都已经对 `TS` 有了很好的支持，代码提示更全，开发体验更好。
- 类型系统提高代码的可维护性。
- 支持最新的 `ES` 语法。
- 类型推论机制，降低了成本（包括学习和开发）。

误区：`TS` 虽然很好用，但如果项目不需要类型验证，甚至使用 `TS` 反而会降低项目运行效率的话，就不必使用 `TS`。应该在需要它的时候，合理地运用它，而不是在任何时候都滥用它。

