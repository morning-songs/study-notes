# 继承

​                                 <img src="第九节.assets/image-20220323094705279.png" alt="image-20220323094705279" style="zoom:80%;" /> 

- 原型链继承，将所有东西都继承过来，没有选择。
- 借用方式，每一次call / apply 都要多执行一遍借用的函数，浪费效率。
- 共享原型，将一个原型对象绑定到多个构造函数上，使它们的实例共享一个原型。
  - 核心：<img src="第九节.assets/image-20220323100444069.png" alt="image-20220323100444069" style="zoom: 50%;" /> 
  - 封装：<img src="第九节.assets/image-20220323100611701.png" alt="image-20220323100611701" style="zoom:50%;" /> 
  - 缺点：共享原型，一改全改。
- 圣杯模式：断开直接联系，找一个中间层传递【共享原型的升级版】
  - 核心： <img src="第九节.assets/image-20220323102028947.png" alt="image-20220323102028947" style="zoom:50%;" />
  - 核心封装：<img src="第九节.assets/image-20220323104607208.png" alt="image-20220323104607208" style="zoom:67%;" />  
  - 最终封装版：constructor 和 超类 问题
    - constructor是构造函数prototype上的内置属性，实例对象上没有这个属性。
      - <img src="第九节.assets/image-20220323111121237.png" alt="image-20220323111121237" style="zoom:50%;" /> 
    - 超类：超级父级，方便实例对象可以找到自己究竟（实际）继承自哪个原型。
    - <img src="第九节.assets/image-20220323112440540.png" alt="image-20220323112440540" style="zoom:67%;" /> 

深度学习：通过大量的数据对比，总结出规律，在应用规律解决问题中，验证并拓展规律。

### 命名空间

管理变量，防止污染全局，适用于模块化开发。【避免命名冲突】

解决：

- 第一种：在对象上命名，由对象提供接口
  - 将一系列命名定义到各自对象里，总和到一个对象中，通过该对象提供唯一的编程接口。
  - <img src="第九节.assets/image-20220323192635627.png" alt="image-20220323192635627" style="zoom:50%;" /> 
  - <img src="第九节.assets/image-20220323192842548.png" alt="image-20220323192842548" style="zoom:67%;" /> 
- 第二种：在立即执行函数中命名，return留出接口。
  - 在一个立即执行函数中，进行命名执行，最后返回核心逻辑。【init：入口，初始化】
  - 将核心逻辑放到一个函数中被返回，当启用init时，会执行这些核心代码。
  - <img src="第九节.assets/image-20220323193916131.png" alt="image-20220323193916131" style="zoom:50%;" /> 

### 模拟JQuery链式调用

链式调用如下：

<img src="第九节.assets/image-20220324140604406.png" alt="image-20220324140604406" style="zoom: 50%;" /> 

模拟代码如下：【同一对象上方法的连续调用】

<img src="第九节.assets/image-20220324144904605.png" alt="image-20220324144904605" style="zoom:50%;" /> 

### 深入对象

##### 对象的键值对

对象上的键实质上是字符串类型的变量。

定义对象属性的两种方式：

- 常用形式：字符串变量 --- { name ：“ 丸子 ” }
- 底层逻辑：字符串键 --- { “ name ” ：“ 丸子 ” }【类似 JSON 格式】
  - <img src="第九节.assets/image-20220325110038617.png" alt="image-20220325110038617"  /> 

##### 对象的属性访问

访问对象属性的常用方法是通过对象点属性的方式，而底层实现是通过对象["属性"]的方式来完成的。

<img src="第九节.assets/image-20220324145549611.png" alt="image-20220324145549611" style="zoom:67%;" /> 常用方法是通过隐式调用底层方法来实现的。

案例：底层方法的便捷之处

<img src="第九节.assets/image-20220324145851964.png" alt="image-20220324145851964" style="zoom:67%;" /> 

##### 对象的枚举 / 遍历

1. for in【枚举】
   - <img src="第九节.assets/image-20220324164153474.png" alt="image-20220324164153474" style="zoom:50%;" /> 
   - 该循环将 obj 中的键一个一个地存放到 prop 中。
   - 注意：区分 obj.prop 与 obj[prop] 的不同
     - 错误：<img src="第九节.assets/image-20220324165610546.png" alt="image-20220324165610546" style="zoom:50%;" /> 
     - 正确：在枚举时，只能通过obj[prop]访问。【在枚举时：obj.prop 相当于 obj["prop"]】
   - 案例：让对象中每一个属性的值加 1 
     - 错误：<img src="第九节.assets/image-20220324164650413.png" alt="image-20220324164650413" style="zoom:50%;" />  返回3个NaN，key 被当作 obj1 的一个属性来访问，结果undefined。
     - 正确：obj[key] ++；
   - for in 会将对象上所有的属性都遍历出来，包括继承自原型的属性。
     - <img src="第九节.assets/image-20220324170837200.png" alt="image-20220324170837200" style="zoom:67%;" /> ![image-20220324170916974](第九节.assets/image-20220324170916974.png) 
2. hasOwnProperty【自有属性】
   - 判断该属性是不是对象自身有的，而不是继承来的，返回一个布尔值。【不是继承的true，是继承的false】
     - true的情况：直接定义在对象上的属性和方法【非继承的】
     - false的情况：通过继承得来的属性和方法【继承的】
   - 作用：过滤掉继承来的属性，只要自身有的。
   - <img src="第九节.assets/image-20220324171806874.png" alt="image-20220324171806874" style="zoom:67%;" /> 
3. in操作符【存在属性】
   - 判断该对象上有没有该属性（能不能访问到），包括继承来的，返回一个布尔值。【存在true，不存在false】
   - 使用：‘属性名’ in 对象；【属性名必须是字符串形式，否则报错‘not defined’】
   - <img src="第九节.assets/image-20220324172515849.png" alt="image-20220324172515849" style="zoom:80%;" /> 
4. instanceof操作符【属于实例】
   - 判断 左边 是不是 右边构造出来的一个实例。【instance：实例】
   - 作用：用来区分数据是什么类型
     - <img src="第九节.assets/image-20220324173559637.png" alt="image-20220324173559637" style="zoom:50%;" /> 

##### 区分数组和对象的三种常用方法

- 通过构造器constructor判断
- 通过instanceof判断
- 通过toString判断
  - 系统内置的构造函数都重写了toString方法，可以借此区分类型
  - <img src="第九节.assets/image-20220324174901593.png" alt="image-20220324174901593" style="zoom:67%;" /> 
  - 使用call改变this指向：
    - ![image-20220324175236440](第九节.assets/image-20220324175236440.png) 





