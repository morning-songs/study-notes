# 函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。



### 描述



#### `Function`

​		用于创建新的 `Function` 对象。直接调用构造函数可以动态地创建函数，但会产生与 `eval()` 类似的安全性和性能问题（但远没有那么严重）。然而，与 `eval()` 不同的是，`Function` 构造函数只创建在全局作用域中执行的函数（这种创建函数的方式已被废弃）。

​		`Function` 实例内部具有两个槽位：`[[Call]]`（具有它就可以被小括号调用）和 `[[Construct]]`（具有它就可以被 `new` 调用）。

​		一个函数要想成为能够被 `new` 调用的构造函数，除了必须具备如上的两个内置槽位，还必须要拥有一个内置的 `prototype` 属性。

​		由函数表达式和函数声明定义的函数只会被解析一次，而由 `Function` 构造函数定义的函数则不是。也就是说，每次它被调用时，传递给 `Function` 构造函数的函数体字符串都要被解析一次。虽然函数表达式每次都创建一个闭包（这里指当前作用域），但它的函数体不会被重解析，因此函数表达式仍然比 `new Function()` 快。因此，通常应该尽可能避免使用 `Function` 构造函数。

​		然而，应该注意的是，在由 `Function` 构造函数的字符串生成的函数内嵌套的函数表达式和函数声明不会重复解析。例如：

```js
// 在Function的字符串函数主体中，嵌套的函数不会被重复解析。
new Function("const bar = 'Foo'; return function() {console.log(bar);};");
```

​		函数声明很容易（通常是无意地）变成函数表达式。函数声明在遇到以下情况之一时就不再为函数声明了：

- 成为表达式的一部分
- 不再是函数或脚本本身的 “源元素”。“源元素” 是一个脚本或函数体中的非嵌套语句。

```js
let x = 0;               		// source element

if (x === 0) {           		// source element
  	x = 10;                		// not a source element
  	function boo() {}      		// not a source element
}

function foo() {         		// source element
  	let y = 2;             		// source element
  	function bar() {}      		// source element
  	while (y < 10) {       		// source element
    	function blah() {}   	// not a source element
    	y++;                 	// not a source element
  	}
}
```

```js
// function declaration
function foo() {}

// function expression
(function bar() {})

// function expression
x = function hello() {}

if (x) {
  	// function expression
  	function world() {}
}

// function declaration
function a() {
  	// function declaration
  	function b() {}
  	if (0) {
    	// function expression
    	function c() {}
  	}
}
```

​		块级函数：在严格模式下，从 `ES6` 开始，块内的函数现在被限定在该块内。在 `ES6` 之前，块级函数在严格模式下是被禁止的。

```js
'use strict';

{
    function fn() {
        return 1;
    }
}

fn(); // ReferenceError: fn is not defined
```

```js
// 在非严格模式下，函数声明不受块限制。
{
    function fn() {
        return 2;
    }
}

fn(); // 2
```

​		尤其是在一些流程控制语句中，可能会引发兼容性的问题。

​		在 `ES6` 中，如果 `shouldDefineZero` 为 `false`，那么就不应该定义 `zero`，因为块永远不执行。然而，这是标准的一个新部分。从历史上看，这是未指定的，并且一些浏览器会定义 `zero`，不管块是否执行。

```js
if (shouldDefineZero) {
  	function zero() {     // DANGER: compatibility risk
    	console.log("This is zero.");
  	}
}

// shouldDefineZero：false
zero; // undefined【zero变量还是因为函数声明被提升了，只不过没有被赋予函数的引用】

// shouldDefineZero：true
zero(); // "This is zero."
```

​		在严格模式下，所有支持 `ES6` 的浏览器都以相同的方式处理这个问题：只有当 `shouldDefineZero` 为 `true` 时才定义 `zero`，并且只存在于 `if-block` 的作用域内。

​		一种更安全的方法是将函数表达式有条件地赋值给一个变量：

```js
// 更接近顶层函数声明的行为：使用var定义使其成为可用的全局变量。
var zero;
if (shouldDefineZero) {
    zero = function () {
        console.log('This is zero.');
    };
}
```

​		示例：返回一个字符串，其中包含用前导零填充的数字格式化表示形式。

```js
// 返回一个以前导零填充的字符串
function padZeros(num, totalLen) {
    let numStr = num.toString();
    const numZeros = totalLen - numStr.length;
    for (let i = 0; i < numZeros; i++) {
        numStr = `0${numStr}`;
    }
    return numStr;
}

let result;
result = padZeros(42, 4); // "0042"
result = padZeros(42, 2); // "42"
result = padZeros(05, 4); // "0005"
reslut = padZeros(50, 1); // "50"
```

​		确定函数是否存在：可以使用 `typeof` 操作符确定函数是否存在。在下面的示例中，将执行一个测试，以确定 `window` 对象是否具有一个名为 `noFunc` 的函数属性。如果是，就使用；否则，将执行其他操作。

```js
if (typeof window.noFunc === 'function') {
    // use noFunc()
} else {
    // do something else
}
```



#### 原型

​		由于历史原因，`Function.prototype` 被设定为一个函数，可以通过 `getOwnPropertyDescriptors` 查看其（静态）属性和方法。

```js
typeof Function.prototype; // 'function'

// 静态（即：自有）属性和方法
Object.getOwnPropertyDescriptors(Function.prototype);
/*
{
	apply: {writable: true, enumerable: false, configurable: true, value: ƒ},
	arguments: {enumerable: false, configurable: true, get: ƒ, set: ƒ},
	bind: {writable: true, enumerable: false, configurable: true, value: ƒ},
	call: {writable: true, enumerable: false, configurable: true, value: ƒ},
	caller: {enumerable: false, configurable: true, get: ƒ, set: ƒ},
	constructor: {writable: true, enumerable: false, configurable: true, value: ƒ},
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: '', writable: false, enumerable: false, configurable: true},
	toString: {writable: true, enumerable: false, configurable: true, value: ƒ},
	Symbol(Symbol.hasInstance): {writable: false, enumerable: false, configurable: false, value: ƒ}
}
*/
```

​		`Function.prototype` 上的一些属性已经废用，如：`arguments`、`caller`、`displayName`。其中，`arguments` 属性被函数内部的`arguments` 变量取代；`caller` 指向正在调用当前的函数的函数。此属性已弃用，仅用于某些非严格函数；`dispalyName` 是函数的显示名称，已废弃。



#### 静态属性

每个函数都具有如下的静态属性：【由于 `Function.prototype` 也是函数，它也具有部分如下属性。但这并不意味着它们是原型属性】

- `arguments`：函数的实参列表（类数组）
- `caller`：执行该函数的函数（如果该函数在另一个函数中执行，则 `caller` 指向那个函数）
- `length`：函数的形参个数（不包括剩余形参，只包括第一个有初始值的形参之前的形参）
- `name`：函数的名称
- `prototype`：函数的原型空间。当函数被 `new` 操作符当作构造函数使用时，它将成为其实例对象的 `[[Prototype]]` 指针。

```js
function fn() {}

Object.getOwnPropertyDescriptors(fn);
/*
{
    arguments: {value: null, writable: false, enumerable: false, configurable: false},
    caller: {value: null, writable: false, enumerable: false, configurable: false},
    length: {value: 0, writable: false, enumerable: false, configurable: true},
    name: {value: 'fn', writable: false, enumerable: false, configurable: true},
    prototype: {value: {…}, writable: true, enumerable: false, configurable: false}
}
*/
```

需要注意的是，箭头函数并没有这么多的静态属性，它默认只有 `length` 和 `name` 这两个静态属性。

```js
let fn = () => {};

Object.getOwnPropertyDescriptors(fn);
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'fn', writable: false, enumerable: false, configurable: true}
}
*/
```



##### `arguments` 属性

​		`arguments` 属性是函数的实参列表，它是一个典型的类数组对象，依次收录执行时传入的每一个实参。

```js
function fn() {
    console.log(fn.arguments === arguments); // 虽然它们初始时一模一样，但它们是两个独立的对象。
    console.log(arguments);
}

// arguments对象只有在函数执行时，才会被赋值，否则保持默认值null。
fn(1, 2, 3);
/*
> false
> Arguments(3) [1, 2, 3]
*/

fn.arguments; // null
```

​		`fn.arguments` 对象不能修改自己的元素，但 `arguments` 对象可以。通过形参对实参的修改会同时反映到这两个对象中。但只要出现了 `arguments` 对象，`fn.arguments` 就会立即恢复原样。

```js
function fn(a, b, c) {
    a = 0;
    fn.arguments[1] = 1;
    console.log(fn.arguments);
}

fn(1, 2, 3); // Arguments(3) [0, 2, 3]

// 转递特性，恢复原样
function fn(a, b, c) {
    a = 0;
    console.log(fn.arguments);
    console.log(arguments);
}

fn(1, 2, 3);
/*
> Arguments(3) [1, 2, 3]
> Arguments(3) [0, 2, 3]
*/
```



##### `caller` 属性

​		`caller` 属性指向调用该函数的那个函数。

```js
function outer() {
    inner();
}

function inner() {
    console.log(inner.caller);
}

outer(); // f outer() {}
```



##### `length` 属性

​		`length` 属性，只计算第一个拥有默认值的形参之前的形参数量，且不计算剩余形参。

​		`Function` 构造函数本身就是一个 `Function` 对象，它的 `length` 属性值为 1，即：`Function.length === 1;`

​		由于历史原因，`Function.prototype` 本身就是一个可调用对象，其 `length` 值为 0。

```js
// length不包括剩余形参
function fn(a, b, ...args) {}
fn.length; // 2

// length只包括第一个被初始化的形参之前的形参
function fn(a = 0, b, c) {}
fn.length; // 0

function fn(a, b = 0, c) {}
fn.length; // 1

function fn(a, b, c) {}
fn.length; // 3
```



##### `name` 属性

​		`Function` 对象的只读属性 `name` 指示函数在创建时所指定的名称，对于匿名创建的函数，它可以是 `anonymous` 或空字符串。

​		函数的 `name` 属性可用于在调试工具或错误消息中标识函数（如果遇到错误，堆栈跟踪将包含函数的名称，从而更容易找到错误的根源），它对语言本身没有语义意义。

​		`name` 属性通常是从函数的定义方式中推断出来的。

（1）函数声明

`name` 属性返回函数声明的名称。

```js
// 具名函数
(function fn() {}).name; // 'fn'

// 匿名函数
(function() {}).name; // ''

// 箭头函数
(() => {}).name; // ''
```

（2）默认导出

默认导出的是函数声明而不是函数表达式。具名函数，`name` 为声明时的名称；匿名函数，`name` 为 `"default"` 或接收时的变量名。

```js
// 导出函数（在someModule.js中）
export default function() {};

// 导入函数（在main.js中）
import someModule from './someModule.js';
someModule.name; // 'default'
```

（3）构造函数

在过去，用 `Function()` 构造函数创建的函数名称为 `"anonymous"`。而现在，不能再使用构造函数创建的函数了。

（4）函数表达式

具名函数表达式，`name` 为声明时的名称。匿名函数表达式和箭头函数表达式，`name` 为接收它们的变量名。

```js
// 具名函数表达式
let fn = function f() {};
fn.name; // 'f'

// 匿名函数表达式
let fn = function() {};
fn.name; // 'fn'

// 箭头函数
let fn = () => {};
fn.name; // 'fn'

// 对象方法
let o = {
    fn() {}
};
o.fn.name; // 'fn'

// 解构方法
let [fn = () => {}] = [];
fn.name; // 'fn'

let {fn: f = () => {}} = {};
f.name; // 'f'

function fn(f = () => {}) {
    f.name; // 'f'
}

class Fn {
    static f = () => {};
}
Fn.f.name; // 'f'
```

（5）捆绑函数

`Function.prototype.bind()` 生成一个捆绑函数（`Bound function`），其 `name` 将以 `"bound"` 前缀。

```js
function fn() {}
fn.bind({}).name; // 'bound fn'
```

（6）读写函数

与 `Bound` 函数相同，当使用 `getter` 读取函数和 `setter` 写入函数时，`"get"` 或 `"set"` 将作为 `name` 的前缀。

```js
const o = {
    get fn() {},
    set fn(v) {}
};

const descriptor = Object.getOwnPropertyDescriptor(o, 'fn');
descriptor.get.name; // 'get fn'
descriptor.set.name; // 'set fn'
```

（7）类

类的名称遵循与函数声明和表达式相同的算法。

警告：由于这个内置的 `name` 属性是静态属性，因此只有在函数没有重写它时，`JavaScript` 才能应用这个内置的 `name` 属性。如果，在函数上重写了这个静态属性，那么 `name` 将会失去对函数的名称标识。

​		你可以使用 `obj.constructor.name` 来检查对象的“类”，或直接使用 `Class.name` 检查类名。

```js
class Foo {}

let obj = new Foo;
obj.constructor.name; // 'Foo'
```

​		然而，当重写了这个 `name` 静态属性后，我们便无法应用内置的 `name` 属性了，`name` 从此也就失去了对函数的标识作用。

```js
class Foo {
    static name() {}
}

const foo = new Foo;
foo.constructor.name; // f name() {}
```

​		因此，您可能不能依赖静态的 `name` 属性来始终保存类的名称。

（8）符号名称

如果函数名是一个符号，并且该符号具有描述，则方法名是以方括号包裹的符号描述。没有描述，则为空字符串。

```js
const sym1 = Symbol(),
      sym2 = Symbol('foo');

const o = {
    [sym1]() {},
    [sym2]() {}
};

o[sym1].name; // ''
o[sym2].name; // '[foo]'
```

（9）私有方法

私有字段和私有方法的名称会以哈希字符（`#`）为前缀。

```js
class Foo {
    #fn1 = () => {}
    #fn2() {}
    getNames() {
        console.log(this.#fn1.name);
        console.log(this.#fn2.name);
    }
}

new Foo().getNames();
/*
> '#fn1'
> '#fn2'
*/
```

（10）`JavaScript` 压缩器和精简器

警告：当在源代码转换中使用 `name` 属性时要小心，比如 `JavaScript` 压缩器（简化器）或模糊处理器执行的转换。这些工具通常会作为`JavaScript` 构建管道的一部分使用，以在将程序部署到生产环境之前减小其大小。而这样的转换通常会在构建时更改函数的名称。

```js
// 源代码
function Foo() {}
const foo = new Foo();

if (foo.constructor.name === 'Foo') {
    console.log("'foo' is an instance of 'Foo'");
} else {
    console.log('Oops!');
}

// 可能会被压缩为
function a() {}
const b = new a();

if (b.constructor.name === 'Foo') {
  	console.log("'foo' is an instance of 'Foo'");
} else {
  	console.log('Oops!');
}
```

​		在未压缩版本中，程序运行到 `true` 分支并打印 `"'foo' is an instance of 'Foo'"` ——然而，在压缩版本中，它的行为不同，运行到 `else` 分支。如果依赖于 `name` 属性，就像上面的例子一样，请确保构建管道不会更改函数名，或者不要假定函数有特定的名称。



##### `prototype` 属性

​		函数的 `prototype` 属性是在声明时就伴随产生的，它默认只有一个 `constructor` 属性，这个属性指回函数本身。

```js
function fn() {}

fn.prototype; // {constructor: f fn()}

fn.prototype.constructor === fn; // true
```

​		需要注意的是，`Function.prototype` 上并没有 `prototype` 属性，虽然它也是一个函数。另外类的 `prototype` 属性是不可写的。

```js
// Function.prototype没有prototype。
Function.prototype.prototype; // undefined

// 普通函数
function fn() {}
Object.getOwnPropertyDescriptor(fn, 'prototype');
/*
{
	configurable: false,
	enumerbale: false,
	writable: true,
	value: {constructor: f}
}
*/

// 类
class Foo {}
Object.getOwnPropertyDescriptor(Foo, 'prototype');
/*
{
	configurable: false,
	enumerbale: false,
	writable: false,
	value: {constructor: f}
}
*/
```

​		一个 `Function` 对象的 `prototype` 属性会在当该函数被 `new` 操作符当作构造函数执行时被使用。而它也将成为新对象的原型。

```js
// 函数的prototype属性，是一个原型空间
function Person() {}

let person = new Person(); // 使用Person.prototype属性创建实例。并将实例的[[Prototype]]指向它。

Object.getPrototypeOf(person) === Person.prototype; // true
```

注释：您可以阅读 [`Inheritance and the prototype chain`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#inheritance_with_the_prototype_chain) 以获得更多关于构造函数的原型属性和结果对象的原型之间交互的信息。

​		具有原型属性的函数并不足以使其具有作为构造函数的资格。如 `Generator` 函数有一个 `prototype` 属性，但不能被 `new` 调用：

```js
// 前面提到过，要想作为构造函数被new调用，其内部还应该具有一个[[Construct]]特性。
let asyncGeneratorFn = async function* asyncGeneratorFunction() {};
new asyncGeneratorFn; // TypeError: asyncGeneratorFn is not a constructor

let generatorFn = function* generatorFunction() {};
new generatorFn; // TypeError: generatorFn is not a constructor
```

​		相反，在不使用 `new` 调用生成器函数时，它们的 `prototype` 属性才会被使用，并且成为返回的 `Generator` 对象的原型。

```js
let asyncGeneratorFn = async function* asyncGeneratorFunction() {};

let agf = asyncGeneratorFn();

Object.getPrototypeOf(agf) === asyncGeneratorFn.prototype; // true
```

​		此外，还有些函数可能也有一个 `prototype`，但在用 `new` 调用时无条件抛出错误。例如，`Symbol()` 和 `BigInt()` 函数在用 `new` 调用时就会抛出错误，因为 `Symbol.prototype` 和 `BigInt.prototype` 本意仅用于为原始值提供方法，而不是直接构造包装类对象。

​		下面的这些函数没有内置的原型，因此不具备成为构造函数的资格，即使后来手动分配了原型属性：

```js
// 在对象中，采用ES6简写语法定义的函数，像箭头函数一样只有length和name两个自有属性。
const fn = {foo() {}}.foo;
Object.getOwnPropertyDescriptors(fn);
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'foo', writable: false, enumerable: false, configurable: true}
}
*/

// 箭头函数
const arrowFn = () => {};
Object.getOwnPropertyDescriptors(arrowFn);
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'arrowFn', writable: false, enumerable: false, configurable: true}
}
*/

// 异步函数
const aynycFn = async function asyncFunction() {};
Object.getOwnPropertyDescriptors(aynycFn);
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'asyncFunction', writable: false, enumerable: false, configurable: true}
}
*/
```

```js
const fn = {foo() {}}.foo;

fn.prototype = (function() {}).prototype;

new fn(); // TypeError: fn is not a constructor
```

​		绑定函数虽然没有原型属性，但它们也有可能是可构造的。当它们被构造时，实际调用的构造器是其目标函数（即：原函数）。如果目标函数是可构造的，那么它将返回一个相应的标准实例。

```js
// 目标函数可构造
const boundFunction = (function f() {}).bind(null);
new boundFunction(); // f {}【f的实例】

// 目标函数不可构造
const boundFunction = (() => {}).bind(null);
new boundFunction(); // TypeError: boundFunction is not a constructor
```

​		如果一个函数的原型被原始值重写，当用 `new` 调用该函数时，返回的对象的原型将是 `Object.prototype`（换句话说，`new` 会忽略非对象值的 `prototype` 属性，并构造一个普通对象）。

```js
function Ctor() {}

Ctor.prototype = 3;

Ctor.prototype; // 3

// 其实例的[[Prototype]]指针，直接指向了Object.prototype。
Object.getPrototypeOf(new Ctor()) === Object.prototype; // true
```

​		通过函数的原型属性，可以改变所有实例的共享数据。

```js
function Ctor() {}

const p1 = new Ctor();
const p2 = new Ctor();

Ctor.prototype.prop = 1;

console.log(p1.prop); // 1
console.log(p2.prop); // 1
```

​		在类的原型上添加公共数据：非静态的类字段在每个实例上添加属性，非静态的类方法在类原型上声明函数。然而，没有办法向类原型中添加非函数属性。如果您想在所有实例之间共享静态数据（例如，`Error.prototype.name` 在所有 `Error` 实例之间都是相同的），您可以在类的原型上手动分配它。

```js
class Dog {
    // 非静态的数据，会成为每个实例的自有属性。
    name = 'lucky';
    
    // 非静态的函数，会成为类原型中的静态方法。
    getName() {
        return this.name;
    }
}

// 没有可以直接添加原型数据的语法，但你可以在类prototype属性手动添加。
Dog.prototype.age = 4;

new Dog(); // Dog {name: 'lucky'}
/*
Dog {
	name: 'lucky',
	[[Prototype]]: Object {
		age: 4,
		constructor: class Dog,
		getName: f getName()
	}
}
*/
```

​		在类初始化时调用静态初始化块，可以使这更符合人体工程学。

```js
class Dog {
    static {
        this.prototype.age = 4;
    }
}

Object.getPrototypeOf(new Dog()); // {age: 4, constructor: class Dog}
```



#### 原型方法

原型上具有四个方法：

- `apply`：修改指定函数内部的 `this` 值，并以类数组的形式传递参数。
- `bind`：创建一个新函数，当调用该函数时，将其 `this` 设置为指定值。并且可以为新函数，预设一个参数序列（优先传入）。
- `call`：修改指定函数内部的 `this` 值，并将参数逐个传入。
- `toString`：返回表示函数源代码的字符串。



##### `apply`

`apply()` 方法使用给定的 `this` 值调用指定的函数，并以数组（或类数组对象）的形式提供参数。

参数：

- `thisArg`：如果函数没有处于严格模式，传入的 `null` 和 `undefined` 值将被替换为全局对象，原始值将被转换为对象。
- `argsArray`：类数组对象，指定被调函数的实参，如果不为函数提供实参，则默认传入 `null` 或 `undefined`。

返回值：使用指定的 `this` 值和实参调用函数的结果。

```js
// 非严格模式
// 替换值
function fn() {
    console.log(this);
}
fn(null); // window

// 包装类
function fn(a, b) {
    console.log(this);
    console.log(a, b);
}
fn.apply(1, null); // 传入null、undefined或[]的效果都是一样的。
/*
> Number {1}
> undefined undefined
*/

// 严格模式（this值就是传入的值，没有替换和转换）
// 无替换
function fn() {
    'use strict';
    console.log(this);
}
fn.apply(null); // null

// 无转换
function fn() {
    'use strict';
    console.log(this);
}
fn.apply(1); // 1
```

​		注意：这个函数与 `call()` 几乎相同，除了 `call()` 接受一个参数列表，而 `apply()` 接受一个参数数组之外（见下文）。

​		在调用一个现有的函数时，你可以为其分配一个不同的 `this` 对象。`this` 引用当前对象（正调用该函数的对象）。使用 `apply`，您可以只编写一次某个方法，然后在另一个对象中继承它，而不必为新对象重写方法。

​		您还可以使用任何类型的类数组对象作为第二个参数。在实践中，这意味着它需要具有一个 `length` 属性以及范围为 `[0, length)` 的整数（`"index"`）属性。例如，你可以使用一个 `NodeList`，或者一个像 `{'length': 2, '0': 'eat', '1': 'bananas'}` 这样的自定义对象。你也可以使用 `arguments`，例如：

```js
function wrapper() {
  	return anotherFn.apply(null, arguments);
}

// 使用剩下的参数和参数扩展语法，这可以重写为：
function wrapper(...args) {
  	return anotherFn(...args);
}
// 一般来说，fn.apply(null, args)相当于是fn(...args)的参数扩展语法。
```

​		使用 `apply` 方法，将一个数组追加到另一个数组：你可以使用 `Array.prototype.push()` 将一个元素追加到一个数组中。由于 `push()` 接受数量可变的参数，您也可以一次推送多个元素。但如果将一个数组传递给 `push()`，它实际上会将该数组作为单个元素添加，而不是逐个地添加其元素，最终成为一个数组中的一个数组。另一方面，在本例中，`Array.prototype.concat()` 确实具有期望的行为，但它不是追加到现有数组中，而是创建并返回一个新的数组。

```js
// 在本例中，可以使用apply隐式地将数组“展开”为一系列参数。
const array = ["a", "b"];
const elements = [0, 1, 2];

array.push.apply(array, elements); // 继续在push方法中袭用array作为this值，并将另一个数组以参数的形式传入。

console.info(array); // ["a", "b", 0, 1, 2]

// 同样的效果也可以通过扩展语法实现。
const array = ["a", "b"];
const elements = [0, 1, 2];

array.push(...elements); // 直接将数组元素扩展成一个个元素批量传入。

console.info(array); // ["a", "b", 0, 1, 2]
```

​		使用 `apply` 和内置函数：对于一些需要编写循环以遍历数组的任务，巧妙地运用 `apply` 可以让你调用一些更为方便的内置函数。

```js
// 例如，利用Math.max/Math.min，来找出数组中的最大值/最小值。
const numbers = [5, 6, 1, 3, 2];

let max = Math.max.apply(null, numbers); // 相当于调用了：Math.max(...numbers);

let min = Math.min.apply(null, numbers);

// vs. 基于简单循环的算法
max = -Infinity;
min = +Infinity;

for (let i = 0, len = numbers.length; i < len; i++) {
    let value = numbers[i];
    
    if (value > max) {
        max = value;
    }
    if (value < min) {
        min = value;
    }
}
```

​		但是要注意：通过这种方式使用 `apply`，可能会有超过 `JavaScript` 引擎参数长度限制的风险。使用大量参数 `apply` 一个函数的结果因引擎而异（`JavaScriptCore` 引擎的硬编码参数限制为 `65536`）。

​		这是因为这种限制（实际上，甚至是任何使用超大栈空间的行为的本质）是未详细说明的。一些引擎会抛出异常。更致命的是，其他引擎会任意限制实际传递给 `apply` 函数的参数数量，导致参数丢失。

​		如果你的参数数组可能增长到成千上万，推荐使用混合策略：将数组切块后一次性应用到目标方法。

```js
// 寻找数组中的最小值
function minOfArray(arr) {
  	let min = Infinity;
  	let QUANTUM = 32768; // 每个块的最大长度

  	for (let i = 0, len = arr.length; i < len; i += QUANTUM) {
        // 将数组切块，切块起点为i，每个块最大长度为QUANTUM，最小长度为len。
    	const submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));
    	min = Math.min(submin, min); // 依次比较每个块中的最小值，保留最小的值。
  	}

  	return min;
}

let min = minOfArray([5, 6, 2, 3, 7]);
min; // 2
```

​		使用 `apply` 模拟 `new` 执行构造器的行为，来使你能够在构造器中使用一个类数组对象而非参数列表。

```js
// 在Function的原型上重写constructor方法，以供给其实例。
Function.prototype.construct = function (aArgs) {
  	let oNew = Object.create(this.prototype); // 创建当前构造函数的空实例。
  	this.apply(oNew, aArgs); // 盗用当前构造函数，为刚创建的空实例添加属性。
    // 这两句通常可以简写为：let oNew = new this(...aArgs);
    
  	return oNew; // 返回实例。
};

// 自定义的构造函数
function MyConstructor() {
  	for (let nProp = 0; nProp < arguments.length; nProp++) {
    	this['property' + nProp] = arguments[nProp];
  	}
}

let myArray = [4, 'Hello world!', false];
let myInstance = MyConstructor.construct(myArray);

myInstance.property1;                // 'Hello world!'
myInstance instanceof MyConstructor; // true

myInstance; // MyConstructor {property0: 4, property1: 'Hello world!', property2: false}
```

**备注：** 这个非原生的 `Function.construct` 方法无法和一些原生构造器（例如 [`Date`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)）一起使用。在这种情况下你必须先使用 [`bind`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) 方法来捆绑 `Date`（因为实际被调用的构造器其实是原函数）。例如，假设有如下一个数组要用在 `Date` 构造器中：`[2012, 11, 4]`；这时你需要这样写：`new (Function.prototype.bind.apply(Date, [null].concat([2022, 10, 22])))()` ——无论如何这不是最好的实现方式并且也许不该用在任何生产环境中。

```js
new (Function.prototype.bind.apply(Date, [null].concat([2022, 10, 22])))();
// Tue Nov 22 2022 00:00:00 GMT+0800 (中国标准时间)

new (Function.prototype.bind.apply(Date))([2022, 11, 22]);
// Tue Nov 22 2022 00:00:00 GMT+0800 (中国标准时间)

// 实际上相当于：
let newDate = Date.bind(null);
new newDate([2022, 11, 22]);
```



##### `bind`

​		`bind()` 方法创建一个新函数（绑定函数），当调用该函数时，将其 `this` 关键字设置为所提供的值，在调用新函数时，在所提供的任何参数之前有一个给定的参数序列。

参数：【预绑定的 `this` 值和实参】

- `thisArg`：当调用绑定函数时，这个值被作为 `this` 参数传递给目标函数。如果函数没有处于严格模式，`null` 和 `undefined` 将被替换为全局对象，原始值将被转换为对象。如果绑定函数被 `new` 操作符构造，那么该参数将被忽略，而是调用目标函数来构造。
- 绑定函数的预定实参（它们会首先作为绑定函数的实参被传入，然后才是绑定函数自己的实参）。

返回值：一个具有指定 `this` 值和可选初始参数的给定函数的副本。

​		`bind()` 函数会创建一个新的绑定函数（`bound function`，`BF`）。绑定函数是一个 `exotic function object`（怪异函数对象），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。 绑定函数具有以下内部属性：

- `[[BoundTargetFunction]]`：包装的函数对象（即：原函数，也被称为 “目标函数”）。
- `[[BoundThis]]`：始终绑定的 `this` 值（无法被修改）。
- `[[BoundArguments]]`：预绑定的实参列表。
- `[[Call]]`：执行与此对象关联的代码。内部方法的参数是一个 `this` 值和一个调用时传递给绑定函数的实参列表。

```js
// 目标函数（原函数）
function targetFn() {
    console.log(this);
    console.log([...arguments]);
}

// 绑定函数（新函数）：执行时将绑定的this值与实参传入目标函数。
let boundFn1 = targetFn.bind({}), 		// 绑定时，无预定实参。
    boundFn2 = targetFn.bind({}, 1, 2); // 绑定时，有预定实参。【也被称为：偏函数】

// 在绑定时预定的实参，会首先占据绑定函数的实参列表。
boundFn1(3, 4);
/*
> {}
> [3, 4]
*/

boundFn2(3, 4);
/*
> {}
> [1, 2, 3, 4]
*/

// 当绑定函数被new执行时，会实际调用其目标函数，绑定的this值也将失效。
new boundFn1(1, 2);
/*
> targetFn {}
> [1, 2]
*/

new boundFn2();
/*
> targetFn {}
> [1, 2]
*/
```

​		`bind()` 函数创建一个新的绑定函数。调用绑定函数通常会导致执行它所包装的函数，该函数也称为目标函数。绑定函数将存储传递的参数——包括 `this` 的值和前几个实参——作为其内部状态。这些值是预先存储的，而不是在调用时传递的。通常可以看到当调用绑定函数（除了把它当作构造函数）时，`const boundFn = fn.bind(thisArg, arg1, arg2)` 等价于 `const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs)` 的作用。

```js
// 模拟bind方法：
// 1、创建新函数，2、绑定this，3、预定参数。
Function.prototype.Bind = function (thisArg, ...preArgs) {
    return (...args) => this.apply(thisArg, [...preArgs, ...args]);
}

function fn() {
    console.log(this);
    console.log(arguments);
}

const bind = fn.Bind({id: 0}, 1, 2);
bind(3, 4); // {id: 0}, [1, 2, 3, 4]

bind.call({id: 1}); // {id: 0}, [1, 2]
```

​		绑定函数可以通过调用 `boundFn.bind(thisArg, /* more args */)` 进一步绑定，创建另一个绑定函数 `boundFn2`。新绑定函数的`thisArg` 值会被忽略，因为 `boundFn2` 的目标函数，也就是 `boundFn`，已经有了一个绑定的 `this` 值。当调用 `boundFn2` 时，它将调用 `boundFn`，而 `boundFn` 又调用 `fn`。`fn` 最终接收到的参数依次为：`boundFn` 绑定的参数、`boundFn2` 绑定的参数和 `boundFn2` 接收的参数。

```js
// 在参数表不简单的函数中使用严格指令是非法的
function fn(...args) {
    'use strict';
    console.log(this, ...args);
}

const boundFn = fn.bind({id: 1}, 1, 2);
const boundFn2 = boundFn.bind({id: 2}, 3, 4);
boundFn2(5, 6); // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list

// 非严格模式
function fn(...args) {
    console.log(this, ...args);
}

const boundFn = fn.bind({id: 1}, 1, 2);
const boundFn2 = boundFn.bind({id: 2}, 3, 4);
boundFn2(5, 6); // {id: 1} 1 2 3 4 5 6
```

​		如果目标函数是可构造的，那么绑定函数也可以使用 `new` 运算符构造。实际上被调用去构造的是目标函数。预先设置的参数像往常一样提供给目标函数，而提供的 `this` 值将被忽略（因为构造准备了自己的 `this`，正如 `Reflect.construct` 的参数那样）。如果绑定函数是被直接构造的，`new.target` 将会变成目标函数（也就是说，绑定函数对 `new.target` 是透明的）。

```js
class Base {
  	constructor(...args) {
    	console.log(new.target === Base);
    	console.log(args);
  	}
}

const BoundBase = Base.bind(null, 1, 2);

new BoundBase(3, 4); // true, [1, 2, 3, 4], Base {}
```

​		但是，因为绑定函数没有 `prototype` 属性，所以它不能用作 `extends` 的基类。

```js
class Derived extends class {}.bind(null) {};
// TypeError: Class extends value does not have valid prototype property undefined

// 相当于：
class Base {}

const BoundBase = Base.bind(null);

class Derived extends BoundBase {}
```

​		当使用绑定函数作为 `instanceof` 的右侧时，`instanceof` 会到达目标函数（它被存储在绑定函数内部）并读取其原型。

```js
class Base {}

const BoundBase = Base.bind(null, 1, 2);

new Base() instanceof BoundBase; // true
```

​		绑定函数，具有如下两个自有属性：

- `length`：目标函数的 `length` 减去被绑定的参数个数（不包括 `thisArg` 参数），0 是最小值。
- `name`：目标函数的 `name` 加上一个 `"bound"` 前缀。

```js
function fn(...args) { // 目标函数length为：0
	console.log(args);
    console.log(`fn.length: ${fn.length}, boundFn.length: ${boundFn.length}`);
}

let boundFn = fn.bind(null, 1, 2); // 绑定的参数个数为：2

boundFn(3, 4);
/*
> [1, 2, 3, 4]
> 'fn.length: 0, boundFn.length: 0'
*/
------------------------------------------------------------------------------------------------------------

function fn(a, b, c) { // 目标函数length为：3
    console.log(`fn.length: ${fn.length}, boundFn.length: ${boundFn.length}`);
}

let boundFn = fn.bind(null, 1, 2); // 绑定的参数个数为：2

boundFn(3, 4); // 'fn.length: 3, boundFn.length: 1'
------------------------------------------------------------------------------------------------------------

function fn(a, b, c, d, e) { // 目标函数length为：5
    console.log(`fn.length: ${fn.length}, boundFn.length: ${boundFn.length}`);
}

let boundFn = fn.bind(null, 1, 2); // 绑定的参数个数为：2

boundFn(3, 4); // 'fn.length: 5, boundFn.length: 3'
```

​		绑定函数也继承了目标函数的原型链。但是，它没有目标函数的其他属性（例如静态属性，如果目标函数是一个类的话）。

​		`bind()` 最简单的用法是使一个函数无论如何调用，都用特定的 `this` 值调用（因为它已经被存于函数的内存中了）。

```js
function fn(...args) {
    console.log(this, args);
}

let boundFn = fn.bind({id: 1}, 0);

boundFn(1); // {id: 1} [0, 1]

boundFn.call({id: 2}, 2); // {id: 1} [0, 2]
```

​		新 `JavaScript` 程序员的一个常见错误是从对象中提取方法，然后稍后调用该函数，并期望它使用原先的对象作为它的 `this` （例如，通过在基于回调的代码中使用该方法）。

​		然而，如果不特别注意，原先的对象通常会丢失。使用原先的对象从函数中创建一个绑定函数，巧妙地解决了这个问题:

```js
this.x = 9; // this在非严格模式下，引用全局对象（例如：window）。

const module = {
  	x: 81,
  	getX() {
    	return this.x;
  	}
};

module.getX(); //  returns 81

const retrieveX = module.getX;
retrieveX(); //  returns 9; 这个未绑定this值（unbound this）的函数在全局作用域下被调用。

// 创建一个函数副本，将其this绑定到module对象。
const boundGetX = retrieveX.bind(module);
boundGetX(); //  returns 81
```

​		**如果你在 `Node CommonJS` 模块中这样运行，顶部作用域 `this` 将指向 `module.exports` 而不是 `globalThis`，无论是否在严格模式下**。然而，在函数中，未绑定的 `this` 的引用仍然遵循 “非严格中是 `globalThis`，严格中是 `undefined`” 的规则。因此，在非严格模式（默认）中，`retrieveX` 将返回 `undefined`，因为 `this.x = 9;` 写入的对象与 `getX` 读取的对象不同：写入 `module.exports`，但读取 `globalThis`。

​		事实上，一些内置 “方法” 其实也是返回绑定函数的 `getter`，一个著名的例子是 `Intl.NumberFormat.prototype.format()`，当访问它时，返回一个绑定函数，您可以直接将其作为回调传递。更多参考：[`Intl.NumberFormat.prototype.format()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/format) 

```js
const a = [123456.789, 987654.321, 456789.123];

const numberFormat = new Intl.NumberFormat('es-ES');

const formatted = a.map((n) => numberFormat.format(n));

console.log(formatted.join('; '));
// → "123.456,789; 987.654,321; 456.789,123"
```

​		偏函数：`bind()` 的下一个最简单的用法是使函数具有预先指定的初始参数。如上所示。

​		使用定时器：默认情况下，在 `setTimeout()` 中，`this` 关键字将被设置为 `globalThis`，它在浏览器中是 `window`。当使用需要 `this` 引用类实例的类方法时，您可以显式地将 `this` 绑定到回调函数，以便维持这个实例。

```js
class LateBloomer {
    constructor() {
        this.petalCount = Math.floor(Math.random() * 12) + 1;
    }
    bloom() {
        // 一秒之后，执行回调。
        setTimeout(this.declare.bind(this), 1000);
    }
    declare() {
        console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
    }
}

const flower = new LateBloomer();
flower.bloom(); // 'I am a beautiful flower with 3 petals!'
------------------------------------------------------------------------------------------------------------

// 您还可以使用箭头函数来实现此目的。
class LateBloomer {
  	bloom() {
        // 在原型方法中，this指向实例。
    	setTimeout(() => this.declare(), 1000);
  	}
}
```

​		如果你希望将绑定函数限制为只能通过 `new` 调用，或者只能通过不使用 `new` 调用，则目标函数必须执行该限制，例如：通过检查`new.target !== undefined` 或使用一个类来代替。

```js
function targetFn() {
    // 只有使用new调用时，new.target才不是undefined。
    if (new.target !== undefined) {
        // 只有通过new调用时，才执行的代码。
    } else {
        // 只有不通过new调用时，才执行的代码。
    }
}
```

​		绑定类：在类上使用 `bind()` 可以保留类的大部分语义，只是当前类的所有静态属性都会丢失。然而，由于保留了原型链，您仍然可以访问从父类继承而来的静态属性。

```js
class Base {
    static id = 'base';
}

class Derived extends Base {
    static id = 'derived';
}

Object.getOwnPropertyDescriptors(Derived);
/*
{
	id: {value: 'derived', writable: true, enumerable: true, configurable: true},
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'Derived', writable: false, enumerable: false, configurable: true},
	prototype: {value: Base, writable: false, enumerable: false, configurable: false}
}
*/

const BoundDerived = Derived.bind(null);

Object.getOwnPropertyDescriptors(BoundDerived);
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'bound Derived', writable: false, enumerable: false, configurable: true}
}
*/

BoundDerived.__proto__ === Base; // true

// 绑定类上没有目标类的静态属性（但它可以通过继承链访问父类的静态属性）
BoundDerived.id; 	// 'base'
Derived.id; 		// 'derived'
```

将方法转换为实用函数：

​		当你想要将一个需要特定 `this` 值的方法转换为一个接受先前的 `this` 参数作为普通参数的普通实用函数时，`bind()` 也很有用。

​		以 `Array.prototype.slice()` 为例，您希望使用它将类数组对象转换为真正的数组。你可以像这样创建一个快捷方式：

```js
const slice = Array.prototype.slice();

slice.call(arrayLike);
```

​		使用 `bind()` 可以简化这一点。在下面的代码中，`slice()` 是 `Function.prototype.call()` 的绑定函数，`this` 值被设置为`Array.prototype.slice()`。这意味着额外的 `call()` 调用可以被消除：

```js
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice); // 相当于：unboundSlice.call;

slice(arrayLike); // 相当于：unboundSlice.call(arrayLike);
```



##### `call`

​		`call()` 方法使用给定的 `this` 值和逐个提供的参数调用函数。

参数：

- `thisArg`：调用函数时被用作 `this` 的值。如果函数非严格执行，`null` 和 `undefined` 将被替换为全局对象，原始值将被包装类。
- 逐个传入的实参

返回值：使用指定的 `this` 值和实参调用函数的结果。

```js
function fn(a, b) {
    console.log(this);
    console.log(a, b);
}

fn.call({}, 1, 2);
/*
> {}
> 1 2
*/
```

​		`call()` 允许为一个对象方法并被另一个对象赋值和调用。能使用 `apply` 的地方，基本上都能使用 `call` 去替换。

```js
// 使用call执行匿名函数
const animals = [
  	{ species: 'Lion', name: 'King' },
  	{ species: 'Whale', name: 'Fail' }
];

function assignPrintMethod(i) {
  	this.print = function () {
    	console.log(`#${i} ${this.species}: ${this.name}`);
  	}
  	this.print();
}

for (let i = 0; i < animals.length; i++) {
  	assignPrintMethod.call(animals[i], i);
}
/*
> #0 Lion: King
> #1 Whale: Fail
*/
```

​		普通函数的执行，其实相当于调用 `call` 但不传递修改 `this` 的值。

```js
function fn(a, b) {
    console.log(this);
    console.log(a, b);
}

fn(1, 2);
/*
> window
> 1 2
*/

fn.call(null, 1, 2);
/*
> window
> 1 2
*/
```

​		严格模式下，`this` 值将是任何被传入的值。非严格模式下，非对象的 `this` 值会被转为对象，但 `null` 和 `undefined` 会被替换。

```js
// 非严格模式
function fn() {
    console.log(this);
}

fn.call(null); // window
fn.call('fo'); // String {'fo'}
fn.call(true); // Boolean {true}
fn.call(Symbol('foo')); // Symbol {Symbol(foo), description: 'foo'}

// 严格模式下
function fn() {
    'use strict';
    console.log(this);
}

fn.call(null); // null
fn.call('fo'); // 'fo'
fn.call(true); // true
fn.call(Symbol('foo')); // Symbol(foo)
```



##### `toString`

​		`toString()` 方法返回一个字符串，表示指定函数的源代码。

```js
// 自定义函数
function sum(a, b) {
    return a + b;
}

sum.toString(); // 'function sum(a, b) {\n    return a + b;\n}'

// 内置函数
Math.abs.toString(); // 'function abs() { [native code] }'
```

​		`Function` 对象重写了继承自 `Object` 的 `toString()` 静态方法；它继承的不是 `Object.prototype.toString` 原型方法。对于用户定义的 `Function` 对象，`toString` 方法返回一个字符串，其中包含用于定义函数的源文本片段。而 `Function` 还有一个同名的静态方法，它们两者是同一个方法，即：`Function.prototype.toString === Function.toString`。

```js
// Function.prototype的toString方法继承的是Object.toString，而不是Object.prototype.toString。
function fn() {}

Object.toString(fn); // 'function Object() { [native code] }'

Object.prototype.toString(fn); // '[object Object]'
```

​		当一个函数将被表示为文本值时，`JavaScript` 会自动调用 `toString` 方法，例如当一个函数与一个字符串连接时。

```js
function sum(a, b) {
    return a + b;
}

sum + ''; // 'function sum(a, b) {\n    return a + b;\n}'
```

​		`toString()` 方法将抛出一个 `TypeError` 异常，如果它的 `this` 值不是一个 `Function` 对象的话。

```js
Function.prototype.toString.call('foo'); 
// TypeError: Function.prototype.toString requires that 'this' be a Function
```

​		如果这个 `toString` 方法，在内置函数、由 `Function.prototype.bind()` 创建的函数或其他非 `javascript` 函数上调用，则`toString()` 返回一个**原生函数字符串**，类似于：`"function someName() { [native code] }"`。

​		对于内部对象方法和函数，`someName` 是函数的初始名称；否则它可能是由实现定义（`implementation-defined`）的，但始终以属性名称语法的形式呈现，如：`[1 + 1]`、`someName` 或 `1`。

​		注意：这意味着在原生函数字符串上使用 `eval()` 肯定会出现语法错误。

​		从 `ES2018` 开始，规范要求 `toString()` 返回与声明时完全相同的源代码，包括任何空格和注释——或者，如果主机由于某种原因没有可用的源代码，则需要返回一个原生函数字符串。在兼容性表中可以找到对这种修改后行为的支持。

```js
// 比较实际源代码和toString的结果
function test(fn) {
  	console.log(fn.toString());
}

function f() {}
class A {a() {}}
function* g() {}

test(f); // 'function f() {}'
test(A); // 'class A {a() {}}'
test(g); // 'function* g() {}'
test((new A).a); // 'a() {}'

test((a) => a); // '(a) => a'
test({*a() {}}.a); // "*a() {}"
test({[0](){}}[0]); // "[0]() {}"

test(Object.getOwnPropertyDescriptor({
  	get a() {},
}, "a").get); // "get a() {}"
test(Object.getOwnPropertyDescriptor({
  	set a(x) {},
}, "a").set); // "set a(x) {}"

test(Function.prototype.toString); // "function toString() { [native code] }"
test(function f() {}.bind(0)); // "function () { [native code] }"
```

​		注意，在 `Function.prototype.toString()` 修订之后，当调用 `toString()` 时，其实现永远不被允许合成不是原生函数字符串的函数源码（不允许对该方法的实现在其不是原生函数的字符串时合成函数的源码）。该方法总是返回用于创建函数的确切源代码——包括上面的 `getter` 和 `setter` 示例。`Function` 构造函数本身具有合成函数源代码的能力（即，一种隐式的 `eval()` 形式）。



#### 箭头函数

​		箭头函数表达式是传统函数表达式的一个紧凑替代方案，但有局限性，不能在所有情况下使用。

​		以下是箭头函数与传统函数的区别，以及一些局限性：

- 箭头函数没有自己的绑定 `this`，参数或 `super`，并且不应该用作方法。
- 箭头函数不能访问 `new.target` 关键字。
- 箭头函数不适合 `call`、`apply` 和 `bind` 方法，这些方法通常依赖于建立一个作用域。
- 箭头函数不能用作构造函数。
- 箭头函数不能在其主体内使用 `yield`。

​		让我们逐步将 “传统匿名函数” 分解为最简单的 “箭头函数”：

```js
// 传统的匿名函数
(function (a) {
    return a + 100;
});

// 箭头函数的分解
// 1、删除关键字"function"，并将箭头放在参数和开头的主体括号之间。
(a) => {
    return a + 100;
}

// 2、删除主体括号和关键字"return" - return是隐含的。
(a) => a + 100;

// 3、删除参数括号
a => a + 100;
```

​		对于命名函数，我们将箭头表达式视为变量：

```js
// Traditional Function
function bob(a) {
  	return a + 100;
}

// Arrow Function
const bob2 = (a) => a + 100;
```

​		要返回一个对象的字面量表达式，需要在对象字面量周围加圆括号：

```js
() => ({foo: "a"}); // 返回对象：{foo: 'a'}
```

​		如前所述，箭头函数表达式最适合于非方法函数。让我们看看当我们尝试使用它们作为方法时会发生什么：

```js
'use strict';

const obj = { // 并不新建一个作用域。
  	i: 10,
  	b: () => console.log(this.i, this),
  	c() {
    	console.log(this.i, this);
  	},
}

obj.b(); // undefined, Window (or the global object)
obj.c(); // 10, obj对象
```

​		因为类的主体有一个 `this` 上下文，所以箭头函数作为类的字段遮蔽类的 `this` 上下文，且箭头函数主体中的 `this` 将正确地指向实例（或类本身，对于静态字段）。但是，因为它是一个闭包，而不是函数本身的绑定，所以 `this` 值不会根据执行上下文而改变。

```js
// 使用箭头函数来定义方法：（箭头函数中的this是始终绑定的）
class C {
    static {
        console.log(this === C); // 定义时执行。
    }

    static sf = () => {
        console.log(this === C); // 箭头静态方法中的this自动绑定为类自身。
    }

    fn = function() {
        console.log(this === c); // 普通实例方法中的this初始绑定为类实例。
    }
    arrow = () => {
        console.log(this === c); // 箭头实例方法中的this自动绑定为类实例。
    }
    
    protoFn() {
        console.log(this === c); // 普通原型方法中的this初始绑定为类实例。
    }
}

// true

C.prototype.protoArrow = () => {
    console.log(this === c); // 箭头原型方法中的this自动绑定为window。
};

C.sf(); // true

let {sf} = C;

sf(); 	// true

let c = new C;
c;
/*
C {
	arrow: () => {...},
	fn: f (),
	[[Prototype]]: Object {
		protoArrow: () => {},
		constructor: class C,
		protoFn: f protoFn()
	}
}
*/

c.fn(); 	// true
c.arrow(); 	// true

c.protoFn(); 	// true
c.protoArrow(); // false

let {fn, arrow, protoFn, protoArrow} = c;

fn(); 		// false
arrow(); 	// true

protoFn(); 		// false
protoArrow(); 	// false
```

```js
class C {
    a = 1; // 实例属性
    autoBoundMethod = () => { // 实例方法【注意，这里是函数表达式而不是函数声明，因此它不是原型方法】
        console.log(this.a); // this自动绑定为实例。
    }
    
    // 使用箭头函数定义静态方法，其中的this将绑定为类自身。
    static staticAutoBoundFn = () => {
        return this; // this自动绑定为类自身。
    }
}

C.staticAutoBoundFn() === C; // true

const c = new C();
c; // C {a: 1, autoBoundMethod: f}

c.autoBoundMethod(); // 1

const {autoBoundMethod} = c;

autoBoundMethod(); // 1【普通函数将在此处返回：undefined】
```

​		箭头函数属性通常被称为 **“自动绑定方法”**，因为与其等价的普通方法是：

```js
class C {
    a = 1; // 实例属性
    constructor() {
        this.method = this.method.bind(this); // 实例方法（与autoBoundMethod等价的普通方法）
    }
    method() { // 原型方法
        console.log(this.a);
    }
}

// 其实并不完全等价，因为这样还会在原型上增加一个多余的同名方法。
new C; // {a: 1, method: f, [[Prototype]]: {constrouctor: f, method: f}}
```

​		注意：类字段（这里指实例方法）是在实例上定义的，而不是在原型上，因此每次创建实例都会创建一个新的函数引用并分配一个新的闭包，这可能导致比普通的未绑定方法占用更多的内存（通常建议将方法定义在原型上）。

`call`、`apply`、`bind`

​		`call`、`apply` 和 `bind` 方法不适合作为箭头函数——因为它们被设计成允许方法在不同的作用域内执行——而箭头函数是基于定义它们的作用域来建立 `this` 的。

​		例如，`call`、`apply` 和 `bind` 在传统函数中可以如期工作，因为我们为每个方法建立了作用域：

```js
// 一个带有this的简单对象。
const obj = {
    num: 100
};

// 一个操作this的简单函数。
const add = function () {
    return this;
}

// call
const resultCall = add.call(obj); // 基于obj建立作用域
resultCall === obj; // true

// apply
const resultApply = add.apply(obj); // 基于obj建立作用域
resultApply === obj; // true

// bind
const resultBind = add.bind(obj); // 基于obj建立作用域
resultBind() === obj; // true
```

​		对于箭头函数，由于 `add` 函数本质上是在 `window` （全局）作用域中创建的，因此它将假定 `this` 就是 `window`。

```js
// 一个带有this的简单对象。
const obj = {
    num: 100
};

// 在全局作用域下声明的箭头函数
const add = () => this;

// call
add.call(obj) === window; // true

// apply
add.apply(obj) === window; // true

// bind
add.bind(obj)() === window; // true
```

​		也许使用箭头函数的最大好处就是与 `setTimeout()` 和 `EventTarget.prototype.addEventListener()` 等方法一起使用，这些方法通常需要某种闭包、`call`、`apply` 或 `bind` 来确保函数在合适的作用域中执行。

```js
// 传统函数的例子
const obj = {
  	count: 10,
  	doSomethingLater() {
    	setTimeout(function () { // 这个函数在window作用域中执行
      		this.count++;
      		console.log(this.count);
    	}, 300);
  	},
};

obj.doSomethingLater(); // "NaN"，因为window作用域中没有count属性。

// 箭头函数的例子
const obj = {
  	count: 10,
  	doSomethingLater () {
    	// 传统函数将“this”绑定到“obj”上下文。
    	setTimeout(() => {
          	// 因为箭头函数没有自己的绑定，并且setTimeout也不会自己创建一个绑定，所以传统函数的obj上下文将在此被使用。
      		this.count++;
      		console.log(this.count);
    	}, 300);
  	},
};

obj.doSomethingLater(); // 11
```

​		箭头函数没有自己的 `arguments` 对象。因此，在本例中，`arguments` 是对其封闭作用域的 `arguments` 的引用（只是普通变量）：

```js
const arguments = [1, 2, 3];

const arr = () => arguments[0]; // arguments对于箭头函数来说只是一个外来的普通变量。

arr(); // 1

function fn(n) {
    const f = () => arguments[0]; // fn的隐式arguments绑定。arguments[0]是n
    return f();
}

fn(3); // 3
```

​		注意：您不能在严格模式下声明名为 `arguments` 的变量，因此上面的代码将是一个语法错误。这使得 `arguments` 的作用域影响更容易推理。在大多数情况下，使用剩余形参是比使用 `arguments` 对象更好的选择。

​		箭头函数不能作为构造函数使用，在与 `new` 一起使用时将抛出 `TypeError`。箭头函数也没有原型属性。`yield` 关键字不能在箭头函数体中使用（除非允许在进一步嵌套的函数中使用）。因此，箭头函数不能用作生成器。

```js
const arrow = *() => { // SyntaxError: Unexpected token '*'
	yield 1;
};

// 嵌套中可以使用。
const arrow = () => {
    return function* () {
        yield 1;
    }
}

arrow()(); // Generator {<suspended>}
```

​		换行符：箭头函数不能在参数和箭头之间包含换行符。然而，可以通过将换行符放在箭头后面或使用小括号、大括号（如下所示）进行修改，以确保代码保持漂亮和简洁，您还可以在参数之间添加换行符。

```js
// 禁止的写法：
const func = (a, b, c)
  	=> 1;

// 允许的写法：
const func = (a, b, c) =>
	1;

const func2 = (a, b, c) => (
  	1
);

const func3 = (a, b, c) => {
  	return 1;
};

const func4 = (
  	a,
  	b,
  	c
) => 1;
```

​		解析顺序：尽管箭头函数中的箭头不是操作符，但与常规函数相比，箭头函数具有特殊的解析规则，与操作符优先级的交互不同。

```js
let callback;

callback = callback || () => {}; // SyntaxError: Malformed arrow function parameter list
```

​		因为 `=>` 的优先级低于大多数操作符，所以必须使用小括号来避免 `callback||()` 被解析为箭头函数的参数列表。

```js
callback = callback || (() => {}); // 使用小括号封闭箭头函数。
```



#### 默认参数

​		如果没有传递值或传递 `undefined`，默认函数参数允许用默认值初始化命名参数（即：形参）。

​		在 `JavaScript` 中，函数参数默认为 `undefined`。但是，设置一个不同的默认值通常是很有用的。这正是默认参数提供的帮助。

```js
function multiply(a, b) {
    return a * b;
}

multiply(5, 2); // 10
multiply(5); 	// NaN
```

​		在过去，设置默认值的一般策略是测试函数体中的参数值，如果它们是 `undefined`，则为其赋值。在下面的例子中，如果只带一个参数调用 `multiply`, `b` 会被设为 1。

```js
function multiply(a, b) {
    b = typeof b !== 'undefined' ? b : 1;
    return a * b;
}

multiply(5, 2); // 10
multiply(5); 	// 5
```

​		使用默认参数，函数体中的检查就不再必要了。现在，你可以在函数头中指定 1 作为 `b` 的默认值:

```js
function multiply(a, b = 1) {
  	return a * b;
}

multiply(5, 2); 		// 10
multiply(5); 			// 5
multiply(5, undefined); // 5
```

​		参数依旧从左到右设置，第一个默认形参之后的形参不会影响函数的长度（`length` 不会计算它们的数量）。

​		默认参数初始化式存在于它们自己的作用域中，该作用域是为函数体创建的作用域的父作用域。

​		这意味着前面的参数可以在后面参数的初始化式中被引用。但是，在函数体中声明的函数和变量不能在默认值参数初始化式中被引用；尝试这样做会抛出一个运行时 `ReferenceError`。这也包括在函数体中使用 `var` 声明的变量。例如，以下函数在调用时将抛出`ReferenceError`，因为默认形参值不能访问函数体的子作用域：

```js
function f(a = go()) {
    function go() {
        return "P";
    }
}

f(); // ReferenceError: go is not defined
```

​		这个函数将打印参数 `a` 的值，因为变量 `var a` 只被提升到为函数体创建的（子）作用域的顶部，而不是为参数列表创建的父作用域的顶部，因此它的值对 `b` 是不可见的。

```js
function f(a, b = () => console.log(a)) {
  	var a = 1;
  	b();
}

f(); 	// undefined
f(5); 	// 5
```

​		传递 `undefined` 和其他假值：传递 `undefined` 表示继续使用默认值，传递其他非 `undefined` 值（包括假值）都会取代默认值。

```js
function test(num = 1) {
    console.log(num);
}

test(); // 1，【其实是传递了：undefined】

test(null); // null
```

​		调用时求值：默认实参在调用时求值。与 `Python` 不同的是，每次调用函数时都会创建一个新对象。

```js
function append(value, array = []) {
  	array.push(value);
  	return array;
}

// 每次调用都创建全新的参数和内部变量。
append(1); // [1]
append(2); // [2]
------------------------------------------------------------------------------------------------------------

// 这甚至适用于函数和变量：
function callSomething(thing = something()) {
  	return thing;
}

let numberOfTimesCalled = 0;
function something() {
  	numberOfTimesCalled += 1;
  	return numberOfTimesCalled;
}

callSomething(); // 1
callSomething(); // 2
```

​		前面定义的参数可用于后面的默认参数：

```js
function go() {
  	return "P";
}

// 各种边界情况：
function withDefaults(
  	a,
  	b = 5,
  	c = b,
  	d = go(),
  	e = this,
  	f = arguments,
  	g = this.value,
) {
  	return [a, b, c, d, e, f, g];
}

function withoutDefaults(a, b, c, d, e, f, g) {
  	switch (arguments.length + 1) {
    	case 1:
      		b = 5;
    	case 2:
      		c = b;
    	case 3:
      		d = go();
    	case 4:
      		e = this;
    	case 5:
      		f = arguments;
    	case 6:
      		g = this.value;
  	}
  	return [a, b, c, d, e, f, g];
}

withDefaults.call({ value: "=^_^=" });
// [undefined, 5, 5, "P", {value:"=^_^="}, arguments, "=^_^="]

withoutDefaults.call({ value: "=^_^=" });
// [undefined, 5, 5, "P", {value:"=^_^="}, arguments, "=^_^="]
```

​		在解构赋值语法中使用默认值赋值：一种常见的方法是将空对象、空数组设置为解构形参的默认值；例如：`[x = 1, y = 2] =[]`。这使得它可以不向函数传递任何东西，但仍然有预先填充的值：

```js
// 在解构赋值中设立默认值
function preFilledArray([x = 1, y = 2] = []) { // 第一实参必须为可迭代的数组或类数组。
  	return x + y;
}

preFilledArray(); // 3
preFilledArray([]); // 3
preFilledArray([2]); // 4
preFilledArray([2, 3]); // 5

// 同样适用于对象：
function preFilledObject({ z = 3 } = {}) { // 第一实参必须为对象。
  	return z;
}

preFilledObject(); 			// 3
preFilledObject({}); 		// 3
preFilledObject({ z: 2 }); 	// 2
```

另外，一旦设置了参数的默认值，参数就会进入到函数的 `Local` 作用域中，并且在 `Local` 作用域的基础上再创建一个块级的子作用域。该作用域用于收集函数内部声明的所有变量，函数结束前，这个作用域会消失。这种语法行为，在不设置参数默认值时，是不会出现的。



#### 剩余形参

​		剩余（`rest`）形参语法允许函数接受不定数量的实参作为数组，提供了一种在 `JavaScript` 中表示可变参数函数的方法。

​		函数定义的最后一个形参可以加上 `...`（三个 `U+002E FULL STOP` 字符）前缀，这将导致所有剩余的（用户提供的）参数被放置在一个标准 `JavaScript` 数组中。只有函数定义中的最后一个形参才可以成为剩余形参。

```js
function myFun(a, b, ...restArgs) {
    console.log(a, b, restArgs);
}

myFun('one', 'two', 'three', 'four', 'five', 'six', 'seven');
// one, two, ['three', 'four', 'five', 'six', 'seven']
```

注意事项：

- 函数定义只能有一个剩余形参。
- 剩余形参必须是函数定义中的最后一个形参。

剩余形参和 `arguments` 对象之间的三个重要区别：

- `arguments` 对象是一个伪数组，而剩余形参是 `Array` 实例。因此可以直接对其应用所有的数组方法，但对 `arguments` 则不行。
- `arguments` 对象具有特定于自身的附加功能（如 `callee` 属性），而剩余形参只是一个普通数组。
- 剩余形参将所有的剩余参数捆绑到一个数组中，因此它不包含在它之前定义的任何形参。而 `arguments` 对象包含所有的形参。

将 `arguments` 转为数组：

- 引入剩余形参是为了减少通常用于将 `arguments` 转换为数组的样板代码。
- 在剩余形参之前，需要先将 `arguments` 转换为普通数组，然后再在它们身上调用数组方法。
- 现在，你可以使用剩余参数轻松地访问一个普通的实参数组。

```js
// 旧语法：
function fn(a, b) {
  	const normalArray = Array.prototype.slice.call(arguments);
  	// — or —
  	const normalArray2 = [].slice.call(arguments);
  	// — or —
  	const normalArrayFrom = Array.from(arguments);

  	const first = normalArray.shift(); 	// OK, gives the first argument
  	const firstBad = arguments.shift(); // ERROR (arguments is not a normal array)
}

// 新语法：
function fn(...args) {
	const normalArray = args;
  	const first = normalArray.shift(); 	// OK, gives the first argument
}
```



#### 实参对象

​		`arguments` 是一个类数组对象，可在函数内部访问，其中包含传递给该函数的所有实参。

​		注意：在现代代码中，剩余参数应该是首选。

​		`arguments` 对象在所有非箭头函数中是一个可用的局部变量。你可以通过使用 `arguments` 对象在函数内部引用函数的实参。

​		`arguments` 对象对于变参函数（调用时接受比正式声明更多参数的函数）非常有用，例如 `Math.min()`。下面这个示例函数接受任意数量的字符串参数，并返回最长的一个。

```js
function longestString() {
  	let longest = '';
  	for (let i = 0; i < arguments.length; i++) {
    	if (arguments[i].length > longest.length) {
      		longest = arguments[i];
    	}
  	}
  	return longest;
}
```

​		你可以使用 `arguments.length` 来计算调用函数时使用了多少个实参。如果您希望计算函数声明接受多少个参数，应检查该函数的`length` 属性。

​		可以设置或重新分配每个参数索引，如：`arguments[1] = 'new value';`。只有简单形参的非严格函数（即：没有剩余形参、默认形参或解构形参）将与 `arguments` 对象同步形参的新值，反之亦然。

```js
// 如果函数开启了严格模式，或者拥有一个剩余形参、默认形参、解构形参都会导致下述关系破裂。
function func(a) {
  	arguments[0] = 99; 	// 更新arguments[0]时也会更新a。
  	console.log(a);
}
func(10); // 99

function func2(a) {
  	a = 99; 			// 更新a时也会更新arguments[0]。
  	console.log(arguments[0]);
}
func2(10); // 99
```

​		拥有剩余、默认或解构形参的非严格函数不会将在函数体中赋给形参的新值与 `arguments` 对象同步。相反，在具有复杂形参的非严格函数中，`arguments` 对象将总是反映调用函数时传递给函数的值。

```js
function funcWithDefault(a = 55) {
  	arguments[0] = 99; // updating arguments[0] does not also update a
  	console.log(a);
}
funcWithDefault(10); // 10

function funcWithDefault2(a = 55) {
  	a = 99; // updating a does not also update arguments[0]
  	console.log(arguments[0]);
}
funcWithDefault2(10); // 10

// An untracked default parameter
function funcWithDefault3(a = 55) {
  	console.log(arguments[0]); // 只反映实际传递的参数
  	console.log(arguments.length);
}
funcWithDefault3(); // undefined; 0
```

​		所有严格模式函数都表现出同样的行为，不管传递的参数类型是什么。也就是说，给函数体中的形参赋新值永远不会影响 `arguments` 对象，给实参索引赋新值也不会影响形参的值，即使函数只有简单形参。

注意：你不能在一个接受剩余、默认或解构形参的函数定义体中写 `"use strict";` 指令，这样做将抛出语法错误。

```js
function fn(a = 10) {
    "use strict"; // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
}
```

​		`arguments` 是一个类数组对象，这意味着 `arguments` 有一个 `length` 属性和从零开始的索引属性，但它没有 `Array` 的内置方法，如 `forEach()` 或 `map()`。但是，可以使用 `slice()`、`Array.from()` 或 `spread` 扩展语法中的一种将它转换为真正的数组。

```js
const args = Array.prototype.slice.call(arguments);
// or
const args = Array.from(arguments);
// or
const args = [...arguments];
```

​		对于常见的使用情况，将其用作类数组对象就足够了，因为它既可迭代，又具有 `length` 和数字索引。例如，`apply()` 接受类数组对象。

```js
function midpoint() {
  	return (Math.min.apply(null, arguments) + Math.max.apply(null, arguments)) / 2;
}

console.log(midpoint(3, 1, 4, 1, 5)); // 3
```

​		这个例子定义了一个连接多个字符串的函数。函数的唯一正式（形式）参数是一个字符串，它是一个将各项分隔连接的字符。

```js
// 指定一个分隔符（首参），以连接各项。
function myConcat(separator) {
  	const args = Array.prototype.slice.call(arguments, 1);
  	return args.join(separator);
}

// 以", "连接各项实参。
myConcat(', ', 'red', 'orange', 'blue'); // 'red, orange, blue'

// 以"; "连接各项实参。
myConcat('; ', 'elephant', 'giraffe', 'lion', 'cheetah'); // 'elephant; giraffe; lion; cheetah'

// 以". "连接各项实参。
myConcat('. ', 'sage', 'basil', 'oregano', 'pepper', 'parsley'); // 'sage. basil. oregano. pepper. parsley'
```

​		这个例子定义了一个函数，它为列表创建一个包含 `HTML` 的字符串。该函数的唯一正式参数是一个字符串，如果该列表是无序的（`bulleted`），则它为 `"u"` ；如果列表是有序的（`numbered`），则为 `"o"`。函数定义如下：

```js
function list(type) {
    let html = `<${type}l><li>`;
    const args = Array.prototype.slice.call(arguments, 1);
    html += args.join('</li><li>');
    html += `</li></${type}l>`;
    return html;
}

// 您可以向此函数传递任意数量的参数，它将每个参数作为列表项添加到指定类型的列表中。
list('u', 'One', 'Two', 'Three'); // '<ul><li>One</li><li>Two</li><li>Three</li></ul>'
```



##### 属性

`arguments` 对象上主要有三大属性：

- `callee`：对参数所属的当前正在执行函数的引用，即：执行状态下的函数本身。严格模式下禁止该属性。
- `length`：实际传递给函数的参数个数，即：实参数量。
- `[@@iterator]`：返回一个新的 `Array` 迭代器对象，该对象包含参数中每个索引的值。

```js
function fn() {
    console.log(Object.getOwnPropertyDescriptors(arguments));
}

fn();
/*
{
	callee: {writable: true, enumerable: false, configurable: true, value: ƒ},
	length: {value: 0, writable: true, enumerable: false, configurable: true},
	Symbol(Symbol.iterator): {writable: true, enumerable: false, configurable: true, value: ƒ}
}
*/
```



`callee`：更多参考：[`arguments.callee`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee) 

​		`arguments.callee` 属性包含当前正在执行的函数本身。

```js
function fn() {
    return arguments.callee;
}

fn() === fn; // true
```

警告：在严格模式下访问 `arguments.callee` 将抛出 `TypeError`。如果函数必须引用自身，则可以使用具名函数表达式或者函数声明。

​		`callee` 是 `arguments` 对象的一个属性。它可用于引用该函数的函数体中当前正在执行的函数。这在函数名未知的情况下非常有用，比如在没有名称的函数表达式中（也称为 “匿名函数”）。

​		早期版本的 `JavaScript` 不允许命名函数表达式，因此不能创建递归函数表达式。

```js
// 例如：这样的语法是有效的
function factorial(n) {
  	return n <= 1 ? 1 : factorial(n - 1) * n;
}

[1, 2, 3, 4, 5].map(factorial);

// 但是，对匿名函数来说做不到这样。
[1, 2, 3, 4, 5].map(function (n) {
  	return n <= 1 ? 1 : /* what goes here? */ (n - 1) * n;
});

// 为避开这一点，arguments.callee被新增来使你可以做到这一点。
[1, 2, 3, 4, 5].map(function (n) {
  	return n <= 1 ? 1 : arguments.callee(n - 1) * n;
});
```

​		然而，`arguments.callee` 的设计具有多重问题。第一个问题就是：递归调用将得到一个不同的 `this` 值。

```js
const global = this;

// 首次执行this指向window，但递归开始后指向arguments对象，因为：arguments.callee();
const sillyFunction = function (recursed) {
  	if (this !== global) {
    	console.log('This is: ', this);
  	} else {
    	console.log('This is the global');
  	}

  	if (!recursed) {
    	return arguments.callee(true);
  	}
}

sillyFunction();
// This is the global
// This is: Arguments {...}
```

​		此外，对 `arguments.callee` 的引用使得内联和尾部递归在一般情况下是不可能的（您可以通过追踪等方法在特定情况下实现这一点，但即使是最好的代码也会因为不必要的检查而处于次最优状态）。

​		`ECMAScript 3` 通过允许命名函数表达式解决了这些问题。

```js
[1, 2, 3, 4, 5].map(function factorial(n) {
  	return n <= 1 ? 1 : factorial(n - 1) * n;
});
```

这样有很多好处：

- 可以在代码内部像调用其他函数一样调用该函数。
- 它不会在外部作用域中创建变量（`IE8` 及以下版本除外）。
- 它比访问 `arguments` 对象具有更好的性能。

​		严格模式禁用了泄露堆栈信息的其他属性，比如函数的 `caller` 属性。这是因为查看调用堆栈有一个唯一的重要影响：它会使得大量的优化变得不可能，或者更加困难。例如，如果你不能保证函数 `f` 不会调用未知函数，则不可能内联 `f`。

```js
function f(a, b, c, d, e) {
  	return a ? b * c : d * e;
}
```

​		如果 `JavaScript` 解释器不能保证在调用时提供的所有参数都是数字，那么它需要在内联代码之前插入对所有参数的检查，否则就不能内联函数。这意味着，任何可能已经微不足道地内联的调用站点都会积累大量的守卫。现在，在这种特殊情况下，智能解释器应该能够重新安排检查，使其更优化，且不检查任何不需要的值。然而，在许多情况下，这是不可能的，因此不可能内联。

​		递归函数必须能够引用自己。通常，函数通过它的名称来引用它自己。然而，匿名函数（可以由函数表达式或 `Function` 构造函数创建）没有名称。因此，如果没有可访问的变量引用它，函数可以引用自己的唯一方法就是 `arguments.callee`。

​		下面的示例定义一个函数，该函数又定义并返回一个阶乘函数。这个示例不是很实际，而且几乎没有使用命名函数表达式无法实现相同结果的情况。

```js
function create() {
  	return function (n) {
    	if (n <= 1) {
      		return 1;
    	}
    	return n * arguments.callee(n - 1);
  	};
}

const result = create()(5); // 120

// 使用命名函数表达式改写：
function create() {
  	return function f(n) {
    	if (n <= 1) {
      		return 1;
    	}
    	return n * f(n - 1);
  	};
}
```

​		尽管函数表达式现在可以被命名了，但箭头函数始终停留于匿名，这意味着它们不能引用自己，除非先将其赋值给一个变量。幸运的是，在 `Lambda` 微积分中有一个非常好的解决方案，它允许函数既是匿名的又是自引用的。这种技术被称为 [`Y-combinator`](https://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator)（`Y` - 协调器或 `Y` - 组合子）。这里我们没有解释它是如何工作的，只有它的作品。【`Lambda`：兰姆达（`λ`），匿名函数】

```js
// The Y-combinator: a utility function!
const Y = (hof) => ((x) => x(x))((x) => hof((y) => x(x)(y)));

console.log(
  	[1, 2, 3, 4, 5].map(
        // 将高阶函数放入Y-combinator中，"factorial"不是函数名：它是作为参数被引入的。
    	Y((factorial) => (n) => (n <= 1 ? 1 : factorial(n - 1) * n))
  	)
);
// [ 1, 2, 6, 24, 120 ]
```

注意：该方法为每次迭代分配一个新的闭包，这可能会显著增加内存使用量。这里只是为了演示这种可能性，但在生产中应该避免使用。始终推荐使用临时变量或命名函数表达式来代替。



`length`：更多参考：[`arguments.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/length) 

​		`arguments.length` 属性包含传递给函数的参数个数。

​		该属性指示实际传递给函数的参数个数。它可以大于或小于已定义的形参的数量（参见 `Function.prototype.length`）。

```js
function fn(a, b, c = 0) {
    console.log(fn.length); // 简单形参的数量
    console.log(arguments.length); // 实参数量
}

fn(1); // 2, 1
```



`[@@iterator]`：更多参考：[`arguments[@@iterator]`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/@@iterator) 

​		`arguments` 对象的 `@@iterator` 方法实现了可迭代对象协议，并允许 `arguments` 被大多数期望可迭代对象的语法消耗，例如 `spread` 语法和 `for-of` 循环。它返回一个迭代器，生成 `arguments` 对象中每个索引的值。

​		该属性的初始值与 `Array.prototype.values` 属性的初始值是同一个函数对象（也与 `Array.prototype[@@iterator]` 相同）。

​		返回值与 `Array.prototype.values()` 的相同：一个新的可迭代迭代器对象，生成 `arguments` 对象中每个索引的值。

​		注意，您很少需要直接调用此方法。`@@iterator` 方法的存在使 `arguments` 可迭代，然后像 `for-of` 循环这样的迭代语法会自动调用此方法以获得要遍历的迭代器。

```js
function f() {
  	for (const letter of arguments) {
    	console.log(letter);
  	}
}

f("w", "y", "k", "o", "p"); // "w", "y", "k", "o", "p"
```



#### 存取函数

##### `getter`

​		`get` 语法将对象属性绑定到一个函数（此时必须指定函数名称），在查找该属性时将调用该函数。

​		有时可能会需要一个能够返回动态计算值的属性，或者希望在不需要显示地调用方法的情况下，也能反映其内部变量状态的属性。而这在 `JavaScript` 中，可以通过使用 `getter` 来完成。

​		虽然可以结合使用 `getter` 和 `setter` 创建出一种伪属性，但不可能同时将 `getter` 绑定一个到属性又让该属性实际保存一个值。

```js
// 后者覆盖前者
let obj = {
    a: 1,
	get a() {
        return 2;
    }
};

obj; // {a: 2, get a: f a()}

// 尽管拥有同名属性，但在getter中直接返回同名属性，会导致访问死循环。
let obj = {
	get a() {
        return this.a;
    }
};

obj; // {a: [Exception: RangeError: Maximum call stack size exceeded ...], get a: f a()}
```

​		对象会实际地创建一个同名属性，并使其始终同步相应 `getter` 的返回值；如果 `getter` 被定义在原型上，与其同步的同名属性还会被直接地创建在实例上，只不过这个属性是 “隐藏” 的，不会被 `Object.hasOwn` 等检查出来。

```js
// 对象会切实地创建一个同名属性，并始终同步对应getter的返回值。
let obj = {
    get a() {
        return 1;
    },
    set a(val) {
        console.log(val);
    }
}

obj; // {a: 1, get a: f a(), set a: f a(val)}

Object.hasOwn(obj, 'a'); // true

Object.getOwnPropertyDescriptor(obj, 'a');
// {enumerable: true, configurable: true, get: ƒ a(), set: ƒ a(val)}
```

```js
class Example {
    get a() {
        return 1;
    }
}

let exp = new Example;
exp;
/*
Example {
	a: 1,
	[[Prototype]]: Object {
		a: 1,
		constructor: class Example,
		get a: f a()
	}
}
*/

Object.hasOwn(exp, 'a'); // false

Object.hasOwn(Object.getPrototypeOf(exp), 'a'); // true
```

使用 `get` 语法时注意以下几点：

- 它可以具有一个标识符。标识符要么是一个数字（索引属性），要么是一个字符串（普通属性），也可以是动态的计算属性名。
- 它的参数必须为零（参见 [不兼容的 `ES5` 更改：字面 `getter` 和 `setter` 函数现在必须有确切的零或一个参数](https://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/) 以获得更多信息）。
- 在过去，在对象字面量中不能出现与 `getter` 同名的方法或属性；而现在，后者都会覆盖前者。
- 如果不设置对应的 `setter` 修改器，`getter` 的值无法被直接重写。
- 如果你想删除 `getter`，你可以直接通过 `delete` 操作符删除它。

```js
// 后者覆盖前者
let obj = {
    get x() {
        return 1;
    },
    get x() {
        return 2;
    }
};
obj.x; // 2

// x方法被重写
let obj = {
    x() {
        return 1;
    },
    get x() {
        return 2;
    }
};
obj.x; // 2

// x属性被重写
let obj = {
    x: 1,
    get x() {
        return 2;
    }
};
obj.x; // 2
```

```js
// 删除getter：与其同名的属性也会被删除。
let obj = {
    get a() {
        return 1;
    }
}

delete obj.a; // true
```

​		想要在以后的任何时候将 `getter` 附加到现有对象中，可以使用 `Object.defineProperty()`。

```js
const o = {a: 0};

// 为已有对象添加getter
Object.defineProperty(o, 'b', { get() { return this.a + 1; } });

console.log(o.b); // 1
```

​		`getter` 提供了一种定义对象属性的方法，但在这些属性被访问之前，它们都不会计算其值。`getter` 将计算值的成本推迟到需要该值时。如果你从来不需要它，你就永远不会付出成本。

​		另一种优化技术是智能（或记忆）`getters`，它可以怠惰地或推迟计算属性值，并将其缓存供以后访问。该值在第一次调用 `getter`时计算，然后缓存，以便后续访问缓存的值而不必重新计算它。这在以下情况下很有用：

- 如果属性值的计算开销很大（占用大量 `RAM` 或 `CPU` 时间，生成工作线程，检索远程文件，等等）。
- 如果现在不需要该值。它将在以后使用，或者在某些情况下根本不使用。
- 如果它被使用了，它将会被多次访问，并且不需要重新计算该值（因为该值永远不会被更改或不应该被重新计算）。

注意：这意味着您不应该为您希望更改其值的属性编写惰性 `getter`，因为如果 `getter` 是惰性的，那么它将不会重新计算该值。请注意，`getter` 并非天生 “懒惰” 或 “容易记忆” 的；如果您想要这种行为，则必须实现这种技术。

​		在下面的例子中，对象有一个 `getter` 作为其自有属性。在获取这个属性时，该属性将从对象中删除并重新添加，但这次隐式地作为数据属性添加。最后，返回其值。

```js
const obj = {
  	get a() {
    	delete this.a;
    	return this.a = 1;
  	},
}

obj; // {a: 1, get a: f a()}

// 在访问一次之后，getter将被去除，a将成为数据属性。
obj.a; // 1

obj; // {a: 1}
```

​		虽然使用 `get` 关键字和 `Object.defineProperty()` 有相似的结果，但当它们在类上使用时，两者之间有一些细微的差别。

​		当使用 `get` 时，该属性将定义在实例的原型上，而使用 `Object.defineProperty()` 时，该属性将定义在它所应用的实例上。

```js
class Example {
  	get hello() {
    	return 'world';
  	}
}

const obj = new Example();
obj; // {hello: 'world', [[Prototype]]: {constructor: class Example, hello: 'world', get hello: f hello()}}

Object.getOwnPropertyDescriptor(obj, 'hello'); // undefined

console.log(
  	Object.getOwnPropertyDescriptor(
    	Object.getPrototypeOf(obj), 'hello'
  	)
); // {set: undefined, enumerable: false, configurable: true, get: ƒ}
```



##### `setter`

​		`set` 语法将对象属性绑定到一个函数，当试图设置该属性时会调用它。它必须且只有一个参数，自动传递试图重写该属性的值。

```js
let obj = {
    // 必须设置val形参，否则会报语法错误。
    set a(val) {
        console.log("newValue:", val);
    }
};

obj; // {set a: f a(val)}

obj.a = 1; // "newValue: 1"
```

​		在 `JavaScript` 中，每当试图更改指定的属性时，可以使用 `setter` 来执行函数。`setter` 最常与 `getter` 一起使用，以创建一种伪属性。与 `getter` 一样，不可能同时在保存实际值的属性上设置 `setter`，后者会覆盖前者；在 `setter` 中重写同名属性也会死循环。

​		下面的示例定义了在 `language` 对象上定义了一个伪属性`current` 。当 `current` 被重新赋值时，它会用这个值更新 `log`：

```js
const language = {
    set current(name) {
        this.log.push(name);
    },
    log: []
};

language.current = "EN";
language.current = "CN";
language.current = "FA";

language.log; // ["EA", "CN", "FA"]

// 注意，current没有定义，任何访问它的尝试都将得到：undefined。
language.current; // undefined

// 如果你想删除这个setter，可以通过delete删除它。
delete language.current; // true
```



#### 闭包

​		闭包（`closure`）是绑定在一起（封闭）的函数及其周围状态（词汇环境）的引用的组合。换句话说，闭包允许您从内部函数访问外部函数的作用域。在 `JavaScript` 中，闭包是每次在函数创建时创建的。



##### 词法作用域

​		考虑下面的示例代码：

```js
function init() {
  	var name = 'Mozilla'; // name是由init创建的本地变量
  	function displayName() {
    	// displayName()是内部函数，一个闭包（函数）。
    	console.log(name); // 使用父函数中声明的变量
  	}
  	displayName();
}
init(); // "Mozilla"
```

​		`init()` 创建一个名为 `name` 的本地变量和一个名为 `displayName()` 的函数。`displayName()` 函数是在 `init()` 中定义的内部函数，只能在 `init()` 函数体中使用。注意，`displayName()` 函数本身没有本地变量。然而，由于内部函数可以访问外部函数中的变量，因此，`displayName()` 可以访问父函数 `init()` 中声明的变量 `name`。

​		使用这个 [`JSFiddle`](https://jsfiddle.net/3dxck52m/) 链接运行代码，注意 `displayName()` 函数中的 `console.log()` 语句成功地显示了 `name` 变量的值，该值是在它的父函数中声明的。这是词法作用域（`lexical scoping`）的一个示例，它描述了当函数被嵌套时语法解析器如何解析变量名。词法一词指的是：词法作用域使用变量在源代码中声明的位置来确定该变量在何处可用。嵌套函数可以访问在其外部作用域中声明的变量。

​		在这个特定的例子中，这个作用域被称为函数作用域，因为变量是可访问的，而且只能在声明它的函数体中访问。



##### 块级作用域

​		传统上（在 `ES6` 之前），`JavaScript` 只有两种作用域：函数作用域和全局作用域。用 `var` 声明的变量要么是函数作用域的，要么是全局作用域的，这取决于它们是在函数内部还是在函数外部声明的。这可能很棘手，因为带花括号的块不会创建作用域。

```js
if (Math.random() > 0.5) {
  	var x = 1;
} else {
  	var x = 2;
}

console.log(x); // 1 or 2
```

​		对于来自其他语言（例如 `C`、`Java`）的人来说，这些语言的块会创建作用域，上面的代码应该在 `console.log` 行上抛出一个错误，因为我们在任何块中都超出了 `x` 的作用域。然而，由于块不为 `var` 创建作用域，这里的 `var` 语句实际上创建了一个全局变量。

​		在 `ES6` 中，`JavaScript` 引入了 `let` 和 `const` 声明，它们允许您创建块作用域变量。

```js
if (Math.random() > 0.5) {
  	const x = 1;
} else {
  	const x = 2;
}
console.log(x); // ReferenceError: x is not defined
```

​		本质上，块最终在 `ES6` 中被视为作用域，但只有在使用 `let` 或 `const` 声明变量时才会这样做。此外，`ES6` 引入了模块，它引入了另一种作用域。闭包能够捕获所有这些作用域中的变量，我们将在后面介绍这些作用域。



##### 闭包作用域

​		考虑下面的代码示例：

```js
function makeFunc() {
  	const name = 'Mozilla';
  	function displayName() {
    	console.log(name);
  	}
  	return displayName;
}

const myFunc = makeFunc();
myFunc(); // "Mozilla"
```

​		运行这段代码的效果与上面 `init()` 函数示例完全相同。不同且有趣的是 `displayName()` 内部函数在执行之前从外部函数返回。

​		乍一看，这似乎不太直观，但这段代码仍然可以工作。在某些编程语言中，函数中的局部变量只会在函数的执行期间存在。一旦 `makeFunc()` 完成执行，您可能会认为 `name` 变量将不可访问。然而，在 `JavaScript` 中显然不是这样，因为这段代码仍然如期工作。

​		原因是这个函数在 `JavaScript` 中形成了闭包。闭包是函数和声明该函数的词法环境的组合。此环境包含在闭包创建时处于作用域内的任何本地变量。在本例中，`myFunc` 是对运行 `makeFunc` 时创建的 `displayName` 函数实例的引用。`displayName` 实例维护对其词法环境的引用，变量 `name` 存在于该环境中。因此，在调用 `myFunc` 时，变量 `name` 仍然可用，然后 `"Mozilla"` 被传递打印。

​		下面是一个稍微有趣一点的例子，一个 `makeAdder` 函数：

```js
function makeAdder(x) {
  	return function (y) {
    	return x + y;
  	};
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

add5(2); // 7
add10(2); // 12
```

​		在本例中，我们定义了一个函数 `makeAdder(x)` ，它接受一个参数 `x`，并返回一个新函数。它返回的函数接受一个参数 `y`，并返回 `x` 和 `y` 的和。

​		本质上，`makeAdder` 是一个函数工厂。它创建可以向参数添加特定值的函数。在上面的例子中，函数工厂创建了两个新函数，一个为参数加 5，另一个为参数加 10。

​		`add5` 和 `add10` 都是闭包。它们共享相同的函数体定义，但存储不同的词法环境。在 `add5` 的词法环境中，`x` 为5，而在 `add10` 的词法环境中，`x` 为 10。



##### 实用的闭包

​		闭包非常有用，因为它们允许将数据（词法环境）与操作该数据的函数关联起来。这与面向对象编程有明显的相似之处，在面向对象编程中，对象允许您将数据（对象的属性）与一个或多个方法相关联。

​		因此，通常在你使用只有一个方法的对象的地方，都可以使用闭包。

​		在 `Web` 中，你可能想要这样做的情况非常普遍。大部分用前端 `JavaScript` 编写的代码都是基于事件的。您定义了一些行为，然后将其附加到由用户触发的事件上（例如单击或按下键）。代码作为回调（响应事件而执行的单个函数）附加。

​		例如，假设我们想要向页面添加按钮以调整文本大小。一种方法是指定 `body` 元素的字体大小（以像素为单位），然后使用相对 `em`单位设置页面上其他元素（如 `header`）的大小:

```css
body {
  	font-family: Helvetica, Arial, sans-serif;
  	font-size: 12px;
}

h1 {
  	font-size: 1.5em;
}

h2 {
  	font-size: 1.2em;
}
```

​		这样的交互式文本大小按钮可以改变 `body` 元素的 `font-size` 属性，而页面上的其他元素会根据相关单元进行调整。这在 `JavaScript` 中，可以这样实现：

```js
// 动态生产可以修改正文字体大小的函数。
function makeSizer(size) {
  	return function () {
    	document.body.style.fontSize = `${size}px`;
  	};
}

const size12 = makeSizer(12);
const size14 = makeSizer(14);
const size16 = makeSizer(16);
```

​		`size12`、`size14` 和 `size16` 现在是分别将正文文本大小调整为 12、14 和 16 像素的函数。您可以将它们附加到按钮上（在本例中是超链接），如下面的代码示例所示。

```js
document.getElementById('size-12').onclick = size12; // 将正文字体大小调整为12px
document.getElementById('size-14').onclick = size14; // 将正文字体大小调整为14px
document.getElementById('size-16').onclick = size16; // 将正文字体大小调整为16px
```

```html
<a href="#" id="size-12">12</a>
<a href="#" id="size-14">14</a>
<a href="#" id="size-16">16</a>
```



##### 私有的方法

​		`Java` 等语言允许将方法声明为私有的，这意味着它们只能由同一类中的其他方法调用。

​		`JavaScript` 在类之前，没有声明私有方法的原生方式，但是可以使用闭包来模拟私有方法。私有方法不仅仅用于限制对代码的访问，它们还提供了管理全局命名空间的强大方法。

​		下面的代码演示了如何使用闭包来定义可以访问私有函数和变量的公共函数。注意，这些闭包遵循 [模块设计模式](https://www.google.com/search?q=javascript+module+pattern)：

```js
const counter = (function () {
  	let privateCounter = 0;
  	function changeBy(val) {
    	privateCounter += val;
  	}

  	return {
    	increment() {
      		changeBy(1);
    	},

    	decrement() {
      		changeBy(-1);
    	},

    	value() {
      		return privateCounter;
    	},
  	};
})();

counter.value(); // 0

counter.increment();
counter.increment();
counter.value(); // 2

counter.decrement();
counter.value(); // 1
```

​		在前面的例子中，每个闭包都有自己的词法环境。但是在这里，三个函数共享一个词法环境。

​		共享词法环境是在匿名函数体中创建的，这个匿名函数被定义后会立即执行（也称为 `IIFE`）。词法环境包含两个私有项：一个名为 `privateCounter` 的变量和一个名为 `changeBy` 的函数。您不能从该匿名函数外部访问这些私有成员。相反，您可以使用从匿名包装器返回的三个公共函数来访问它们。这三个公共函数是共享相同词法环境的闭包（函数）。多亏了 `JavaScript` 的词法作用域，使得它们每一个都可以访问 `privateCounter` 变量和 `changeBy` 函数。

```js
const makeCounter = function () {
  	let privateCounter = 0;
  	function changeBy(val) {
    	privateCounter += val;
  	}
  	return {
    	increment() {
      		changeBy(1);
    	},

    	decrement() {
      		changeBy(-1);
    	},

    	value() {
      		return privateCounter;
    	},
  	};
};

const counter1 = makeCounter();
const counter2 = makeCounter();

counter1.increment();
counter1.increment();

console.log(counter1.value()); // 2
console.log(counter2.value()); // 0

counter1.decrement();
console.log(counter1.value()); // 1
console.log(counter2.value()); // 0
```

​		多个 `counter` 保持彼此独立。每个闭包函数通过自己的闭包引用 `privateCounter` 变量的不同版本。每当其中一个 `counter` 被调用时，通过更改这个变量的值，它的词汇环境就会发生变化。更改一个闭包中的变量值不会影响另一个闭包中的相应值。

​		注意：以这种方式使用闭包，提供了许多与面向对象编程相关的好处。特别是数据隐藏和封装。



##### 闭包作用域链

每个闭包有三个作用域：

- `Local scope`：本地作用域（自己的作用域）
- `Enclosing scope`：闭包作用域（可以是块级作用域、函数作用或模块作用域）
- `Script scope`：脚本作用域（当前脚本元素的作用域）
- `Global scope`：全局作用域

​		一个常见的错误是没有意识到，在外部函数本身是一个嵌套函数的情况下，对外部函数作用域的访问包括了外部函数的闭包作用域——有效地创建了函数作用域链。为了进行演示，请考虑以下示例代码。

```js
// 全局作用域
const e = 10;

function sum(a) {
  	return function (b) {
    	return function (c) {
      		// 外部函数作用域
      		return function (d) {
        		// 本地作用域
        		return a + b + c + d + e;
      		};
    	};
  	};
}

sum(1)(2)(3)(4); // 20
```

​		在上面的例子中，有一系列嵌套的函数，它们都可以访问外部函数的作用域。在这种情况下，我们可以说闭包（函数）可以访问所有外部函数的作用域。

​		闭包也可以捕获块级作用域和模块作用域中的变量。例如，下面的语句在块级作用域变量 `y`上 创建一个闭包：

```js
function outer() {
  	const x = 5;
  	if (Math.random() > 0.5) {
    	const y = 6;
    	return () => console.log(x, y); // 闭包函数
  	}
}

let inner = outer(); 
inner(); // 5 6

// inner的作用域链：
Scope: {
    Local: {
        Return value: undefined,
        this: undefined
    },
    Block: {
        y: 6
    },
    Closure (outer): {
        x: 5
    },
    Global: Window
}
```

​		闭包在模块上可能更有趣。

```js
// myModule.js【这里可以将模块理解为一个自执行函数】
let x = 5;
let y = 0;

// 闭包函数持有整个父作用域
export const getX = () => x; 	// 闭包函数1
export const setX = (val) => { 	// 闭包函数2
  	x = val;
}
```

​		在这里，模块导出了一对 `getter-setter` 函数，它们在模块作用域上封装了变量 `x` 。使 `x` 不能从其他模块直接访问，只可以用提供的函数对其进行读写。

```js
import { getX, setX } from "./myModule.js";

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6
```

```js
// getX或setX的作用域链：
[[Scopes]]: Scopes[4] [
    0: Closure {x: 6, y: 0, getX: f, setX: f}, // 注意：这个闭包是整个模块的作用域！！！
    1: Closure ('./myModule.js') {__webpack_exports__: Module, ...},
    2: Closure {__webpack_modules__: {...}, ...},
    3: Global {window: Window, ...}
]
```

​		闭包还可以封装导入的值，这些值被视为动态绑定（`live bindings`），因为当原始值更改时，导入的值也会相应更改。

```js
// myModule.js
export let x = 1;
export const setX = (val) => {
  	x = val;
}
```

```js
// closureCreator.js
import { x } from "./myModule.js"; // x是从其他模块导入的，并不属于这个模块作用域。

export const getX = () => x; // 封装一个动态绑定的导入值（Close over an imported live binding）
```

```js
import { getX } from "./closureCreator.js";
import { setX } from "./myModule.js";

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
```

```js
// getX的作用域链：
[[Scopes]]: Scopes[4] [
    0: Closure {getX: f}, // 注意：由于x是导入值，因此它并不存在于这个闭包中！！！
    1: Closure ('./closureCreator.js') {__webpack_exports__: Module, ...},
    2: Closure {__webpack_modules__: {...}, ...},
    3: Global {window: Window, ...}
]

// setX的作用域链：
[[Scopes]]: Scopes[4] [
    0: Closure {x: 2, setX: f},
    1: Closure ('./myModule.js') {__webpack_exports__: Module, ...},
    2: Closure {__webpack_modules__: {...}, ...},
    3: Global {window: Window, ...}
]
```



##### 循环创建闭包

​		在引入 `let` 关键字之前，在循环中创建闭包时会出现一个常见问题。为了进行演示，请考虑以下示例代码。

```html
<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>
```

```js
function showHelp(help) {
  	document.getElementById('help').textContent = help;
}

function setupHelp() {
  	var helpText = [
    	{ id: 'email', help: 'Your e-mail address' },
    	{ id: 'name', help: 'Your full name' },
    	{ id: 'age', help: 'Your age (you must be over 16)' },
  	];

  	for (var i = 0; i < helpText.length; i++) {
    	// 问题的起因：Culprit is the use of `var` on this line
    	var item = helpText[i];
    	document.getElementById(item.id).onfocus = function () {
      		showHelp(item.help);
    	};
  	}
}

setupHelp();
```

​		`helpText` 数组定义了三个帮助性提示，每个提示都与文档中输入字段的 `ID` 相关联。循环通过遍历这些定义，将 `onfocus` 事件与每个显示相关提示信息的方法挂钩。

​		如果您尝试这段代码，您将看到它没有按照预期工作。无论你聚焦于哪个字段，你的年龄信息都会显示出来。

​		这是因为赋值给 `onfocus` 的函数是闭包，它们由函数定义和从 `setupHelp` 函数的作用域中捕获的环境组成。通过循环创建了三个闭包，但是每个闭包共享同一个词法环境，其中有一个值不断变化的变量（`item`）。这是因为 `item` 变量是用 `var` 声明的，由于提升而属于函数作用域。当执行 `onfocus` 的回调时，`item.help` 的值才能被确定。因为到那个时候循环已经完成了它的过程，`item` 变量对象（由所有三个闭包共享）已经指向 `helpText` 列表中的最后一个条目。

​		这种情况下的一个解决方案是，使用更多闭包：特别是使用前面所描述的函数工厂：

```js
function showHelp(help) {
  	document.getElementById('help').textContent = help;
}

// 设计一个回调构造工厂，其构造的每个回调函数拥有彼此独立的闭包作用域。
function makeHelpCallback(help) {
  	return function () {
    	showHelp(help);
  	};
}

function setupHelp() {
  	var helpText = [
    	{ id: 'email', help: 'Your e-mail address' },
    	{ id: 'name', help: 'Your full name' },
    	{ id: 'age', help: 'Your age (you must be over 16)' },
  	];

  	for (var i = 0; i < helpText.length; i++) {
    	var item = helpText[i];
    	document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  	}
}

setupHelp();
```

​		这次和预期的一样。`makeHelpCallback` 函数工厂为每个回调创建一个新的词法环境，其中 `help` 从 `helpText` 数组中引用相应的字符串，而不是所有回调都共享一个词法环境。

```js
// 当然，也可以使用匿名闭包编写上述代码
function showHelp(help) {
  	document.getElementById('help').textContent = help;
}

function setupHelp() {
  	var helpText = [
    	{ id: 'email', help: 'Your e-mail address' },
    	{ id: 'name', help: 'Your full name' },
    	{ id: 'age', help: 'Your age (you must be over 16)' },
  	];

  	for (var i = 0; i < helpText.length; i++) {
    	(function () {
      		var item = helpText[i];
      		document.getElementById(item.id).onfocus = function () {
        		showHelp(item.help);
      		};
    	})(); // 即时事件监听器附加item的当前值（在迭代之前保留）。
  	}
}

setupHelp();
```

​		如果不想使用更多闭包，可以使用 `let` 或 `const` 关键字：

```js
function showHelp(help) {
  	document.getElementById('help').textContent = help;
}

function setupHelp() {
  	const helpText = [
    	{ id: 'email', help: 'Your e-mail address' },
    	{ id: 'name', help: 'Your full name' },
    	{ id: 'age', help: 'Your age (you must be over 16)' },
  	];

  	for (let i = 0; i < helpText.length; i++) {
    	const item = helpText[i]; // 生成一个块级作用域，让这个作用域成为闭包环境。
    	document.getElementById(item.id).onfocus = () => {
      		showHelp(item.help);
    	};
  	}
}

setupHelp();
```

​		本例使用 `const` 而不是 `var`，因此每个闭包都绑定块级作用域变量，这意味着不需要额外的闭包。

​		另一种替代方法是使用 `forEach()` 遍历 `helpText` 数组，并在每个 `<input>` 上附加一个监听器，如下所示：

```js
function showHelp(help) {
  	document.getElementById('help').textContent = help;
}

function setupHelp() {
  	var helpText = [
    	{ id: 'email', help: 'Your e-mail address' },
    	{ id: 'name', help: 'Your full name' },
    	{ id: 'age', help: 'Your age (you must be over 16)' },
  	];

  	helpText.forEach(function (text) {
    	document.getElementById(text.id).onfocus = function () {
      		showHelp(text.help);
    	};
  	});
}

setupHelp();
```



##### 性能方面考虑

​		如前所述，每个函数实例管理自己的作用域和闭包。因此，如果某个特定任务不需要闭包，那么在其他函数中多余地创建闭包函数是不明智的，因为这将在处理速度和内存消耗方面对脚本的性能产生负面影响。

​		例如，当创建一个新的对象/类时，方法通常应该与对象的原型相关联，而不是定义到对象构造函数中。原因是每当构造函数被调用时，这些方法都将被重新分配（也就是说，会为每个对象都创建）。考虑以下情况：

```js
// 这些方法，将被创建在每一个对象实例上。
function MyObject(name, message) {
  	this.name = name.toString();
  	this.message = message.toString();
  	this.getName = function () {
    	return this.name;
  	};

  	this.getMessage = function () {
    	return this.message;
  	};
}
```

​		因为前面的代码没有利用在这个特定实例中使用闭包的好处，我们反而可以重写它去避免使用闭包，如下所示：

```js
function MyObject(name, message) {
  	this.name = name.toString();
  	this.message = message.toString();
}

MyObject.prototype = {
  	getName() {
    	return this.name;
  	},
  	getMessage() {
    	return this.message;
  	},
};
```

​		但是，**不建议重新定义原型**。下面的例子改为对现有原型的补充：

```js
function MyObject(name, message) {
  	this.name = name.toString();
  	this.message = message.toString();
}

MyObject.prototype.getName = function () {
  	return this.name;
};

MyObject.prototype.getMessage = function () {
  	return this.message;
};
```

在前面的两个例子中，继承的原型可以被所有对象共享，方法定义不需要在每个对象创建时都发生。参见 [继承和原型链](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) 了解更多信息。

<hr>



### 函数基础

​		函数是 `ECMAScript` 中最有意思的部分之一，因为函数实际上也是对象。每个函数都是 `Function` 类型的实例，而 `Function` 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，但不一定始终与函数本身紧密绑定。



##### 函数声明

函数通常以函数声明的方式定义，相当于声明了一个变量，而变量引用了一个匿名函数，此时这个变量名就是函数名。

函数声明：

- `ECMAScript` 中的普通函数使用 `function` 关键字声明【`function`：函数、功能】
- 声明箭头函数不需要任何关键字，也不需要函数名称。

```js
// 普通函数
function fn () {} 			// 普通声明（它会被被添加到window上）
let fn = function () {}; 	// 函数表达式（这种方式更形象地揭示了函数声明的本质性概念）
(function () {})(); 		// 自执行函数

// 箭头函数
let fn = () => {}; 			// 函数表达式
(() => {})(); 				// 自执行函数
```

​		最后一种定义函数的方式是使用 `Function` 构造函数。这个构造函数可以接收任意多个**字符串参数**，最后一个参数始终会被当成函数体，而之前的参数都是函数实例的参数。如：`let sum = new Function("num1", "num2", "return num1 + num2");`

​		不推荐使用这种语法来定义函数，因为这段代码实际上会被解释两次：第一次是将它当作常规 `ECMAScript` 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是一个很重要的理解。而上面这种语法很好地诠释了这种概念。实际上，因为 `eval` 语法的废弃，这个构造函数的语法也随着被废弃了，会被视为 “不安全的 `eval` 语法”。

```js
const multiply = new Function('x', 'y', 'return x * y');
// EvalError: Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive
```

​		要注意的是，函数声明会被提升，它发生在变量提升之后。而函数表达式不可以发生函数声明提升，这是他们之间的唯一区别。

```js
fn();	// 1
function fn() {return 1};
var fn = 0;
fn; 	// 0

// 实际上发生了如下过程
// 变量声明提升
var fn = undefined;

// 函数声明提升
fn = function () {return 1};

// 调用fn
fn(); // 1

// 重写fn
fn = 0;

------------------------------------------------------------------------------------------------------------

// 若是函数表达式，则不会发生函数提升，因为赋值总是发生在执行时。
fn(); // TypeError: fn is not a function
var fn = function () {return 1};

// 变量提升
var fn = undefined;

// 调用fn
fn(); // TypeError: fn is not a function

// 赋值fn
fn = function () {return 1};
```

​		**建议**：不要在 `if...else` 等流程控制语句中进行函数声明，因为它们可能会被提升，若是同名则还可能会发生覆盖。

```js
// 危险的写法
if (condition) {
    function fn() {
        console.log(1);
    }
} else {
    function fn() {
        console.log(2);
    }
}

// 虽然现代浏览器基本上已经解决了这个问题，但在老版本中可能仍然存在。若遇到，可使用函数表达式进行改写。
let fn;

if (condition) {
    fn = function () {
        console.log(1);
    };
} else {
    fn = function () {
        console.log(2);
    }
}
```

​		无论是变量声明提升还是函数声明提升，都不是我们能够人为控制的，因此，可能在意想不到的时候带来巨大的风险。建议尽可能多的使用函数表达式来规避不必要的风险。广义上，只要函数被当作值来使用，它都是一个函数表达式。



##### 箭头函数

​		`ECMAScript 6` 新增了使用胖箭头（`=>`）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数。

​		箭头函数简洁的语法非常适合嵌入函数的场景：

```js
let ints = [1, 2, 3];

// 旧写法
ints.map(function (i) {return i + 1;}); // [2, 3, 4]

// 简洁写法
ints.map((i) => {return i + 1;}); 		// [2, 3, 4]
```

如果只有一个参数，还可以省略小括号。只有在没有参数，或者有多个参数的情况下，小括号才是必须的：

```js
let fn = (x) => {return x * 2;};
// 等效写法：
let fn = x => {return x * 2;};

// 无参数
let getRandom = () => {return Math.random();};

// 多参数
let sum = (a, b) => {return a + b;};
```

​		箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句（只有在函数体中，才能定义多条语句），跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的结果值：

```js
let fn = (x) => {return x * 2;};
// 等效写法：
let fn = x => x * 2;

// 支持的迷惑性写法（一般建议在书写时，带上规范的括号）
let obj = {};
let setName = x => x.name = 'wz';
setName(obj);
obj.name; // 'wz'

// 无效的写法（去掉大括号语法后就不能再使用return关键字）
let fn = (a, b) => return a * b; // SyntaxError: Unexpected token 'return'
```

​		箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 `arguments`、`super` 和 `new.target`，不能被用作构造函数。此外，箭头函数没有 `prototype` 属性，也**没有自己的 `this` 对象（但它可以访问外部的 this 对象，只要存在于它的作用域链中）**。

- `arguments`：是 `function` 声明的函数中的一个局部变量，因此，箭头函数中没有。
- `super`：是派生构造函数中的关键字，箭头函数不能被当作构造函数。
- `new.target`：是记录 `new` 执行的构造函数，箭头函数无法被 `new` 执行。
- `prototype`：是 `function` 声明的函数上的一个自有属性，因此，箭头函数上没有。

```js
// 箭头函数默认只有两个属性
Object.getOwnPropertyDescriptors(() => {});
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: '', writable: false, enumerable: false, configurable: true}
}
*/

// 普通函数默认属性
Object.getOwnPropertyDescriptors(function () {});
/*
{
	arguments: {value: null, writable: false, enumerable: false, configurable: false},
	caller: {value: null, writable: false, enumerable: false, configurable: false},
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: '', writable: false, enumerable: false, configurable: true},
	prototype: {value: {…}, writable: true, enumerable: false, configurable: false}
}
*/
```



##### 对象方法

采用 `ES6` 函数简写语法，在对象中定义的方法（以下称为“简写方法”），基本上与标准函数无异，但仍然存在一些重要的差别。

- 标准方法具有基本的五大静态属性，而简写方法却像箭头函数一样仅仅只有 `length` 和 `name` 这两个基本属性。
- 标准方法可以作为构造函数被 `new` 执行，而简写方法不行（因为它没有内置的 `prototype` 属性）。
- 标准方法可以访问 `caller` 属性，但简写方法不行（因为它不具有）。
- 简写方法虽然不具有 `arguments` 属性，但它具有 `arguments` 对象。而且还具有自己的 `this` 对象。

```js
let obj = {
    a: function() {
        console.log(Object.getOwnPropertyDescriptors(this.a));
    },
    b() {
        console.log(Object.getOwnPropertyDescriptors(this.a));
    },
    c: () => {
        console.log(Object.getOwnPropertyDescriptors(obj.c));
    }
};

obj.a();
/*
{
	arguments: {value: Arguments(0), writable: false, enumerable: false, configurable: false},
	caller: {value: null, writable: false, enumerable: false, configurable: false},
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'a', writable: false, enumerable: false, configurable: true},
	prototype: {value: {…}, writable: true, enumerable: false, configurable: false}
}
*/

obj.b();
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'b', writable: false, enumerable: false, configurable: true}
}
*/

obj.c();
/*
{
	length: {value: 0, writable: false, enumerable: false, configurable: true},
	name: {value: 'c', writable: false, enumerable: false, configurable: true}
}
*/
```

关于对象方法中 `this` 指向的问题，请参考下文（函数高阶 - 函数内部 - `this`）。



##### 自执行函数

​		立即调用的匿名函数（自执行函数）又被称作立即调用的函数表达式（`IIFE`，`Immediately Invoked Function Expression`）。

函数自执行：

- 直接在普通具名函数后面通过 `()` 调用是无效的并且还会报错，但函数表达式可以。
- 可使用一元运算符【自增减不推荐】或小括号将函数转为表达式来实现自执行函数。

```js
// 普通具名函数
function fn () {}();            // 报错

// 函数表达式
let fn = function () {}(); 		// 立即执行

// 可使用的一元运算符：+, -, !, ~, ()
+function () {}(); 				// 立即执行
(function () {})(); 			// 推荐形式

// 自增减：不推荐，因为自执行完后会将变量自增减而引发错误。
++function () {}(); 			// 立即执行，但执行完后报错【因为函数名不能自增减】【现在已不支持】
```

块级作用域：

​		使用 `IIFE` 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。`ECMAScript 5` 尚未支持块级作用域，使用 `IIFE` 模拟块级作用域是相当普遍的。

​		在 `ECMAScript 5.1` 及以前，为了防止变量定义外泄，`IIFE` 是个非常有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。

​		在 `ECMAScript 6` 以后，`IIFE` 就没有那么必要了，因为块级作用域中的变量无须 `IIFE` 就可以实现同样的隔离。

计数器副本：

​		`IIFE` 另一个实用的用途就是，可以生成计数器副本（这个特点后来也被添加到块级作用域中了）。

```js
// var声明的变量既不受块级作用域的限制，也不会产生变量副本。
for (var i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 10, 10, 10, 10, 10, 10, 10, 10, 10, 10
    });
}

// 使用IIFE解决
for (var i = 0; i < 10; i++) {
    (function (i) {
        setTimeout(() => {
            console.log(i); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
        })
    })(i);
}

// 在ES6中，使用块级变量解决。
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    });
}
```



##### 函数调用

函数调用：【本质上是通过函数的引用来实现调用的】

- 普通具名函数通过函数名来实现调用【函数引用保存在函数名里，它实际上是一个会**被提升的 `let` 变量**】
- 函数表达式通过变量调用【函数引用保存在变量里，因此，函数表达式会自动忽略函数名】
- 箭头函数通过变量调用【函数引用保存在变量里，因此，箭头函数的函数名就是变量名】

```js
// 具名函数：通过函数名调用
function fn1 () {}; 	// fn1()

// 函数表达式
let fn1 = function test () {}; 	// fn1()
let fn2 = function () {}; 		// fn2()

// 箭头函数：通过变量名调用
let fn = () => {}; 		// fn()

// 本质：函数调用的本质是，调用函数在内存中的引用。
function fn () {}; 	// fn是一个被提升的let变量，保存着该函数的引用
let fn1 = function test () {}; 	// 引用保存在fn1变量中，test在以字符串的形式存于name中之后，被立即销毁了。
```



##### 函数名

​		函数名一般指 `function` 关键字后面的字符串，可通过 `name` 属性查看。而函数标识符是指保存函数引用的变量名，通常与函数名相同。函数名只有一个且只读，函数标识符可以有多个。标识符实际上可以理解为指针、引用，因为它用于建立名称与使用之间的关系。

函数名：【通过`name`属性查看，字符串形式】

- 具名函数：函数名为紧跟关键字身后的字符串。标识符通常与函数名相同，但在表达式中它是保存引用的变量名。
- 匿名函数和箭头函数：如果函数引用被变量保存了，那么函数名即为变量名（标识符），如果没有则为空串。
- `Function` 构造的实例：原为 `"anonymous"`，现已被废弃。

​		匿名函数（`anonymous funtion`），即：`function` 关键字后面没有名称（匿名函数有也时候也被称为兰姆达函数）。

​		**名称的意义**：创建具名函数的好处之一是，如果遇到错误，堆栈跟踪将包含函数的名称，从而更容易找到错误的根源。

```js
// 具名函数：关键字后的函数名称
function fn1 () {}; // 还会创建一个fn1变量。
fn1.name; 	// "fn1"

// 函数表达式：具名--关键字后的名称，匿名--变量名。但标识符都是变量名。
let fn1 = function test () {}; 	// test is not defined
fn1.name; 						// "test"，test会成为该函数的一个内部变量，仍然引用自身。
let fn2 = function () {}; 		
fn2.name; 						// "fn2"

// 箭头函数：变量名
let fn = () => {}; 		
fn.name; 						// "fn"

// 没被保存的匿名函数和箭头函数
(function () {}).name; 	// ''
(() => {}).name; 		// ''
```

​		如果函数是一个获取函数、设置函数，或者使用 `bind()` 实例化，那么函数名前面会加上一个前缀：

```js
// bind实例化
function foo() {}
foo.bind(null).name; // 'bound foo'

// getter和setter
let obj = {
    _foo: '',
    get foo() {
        return this._foo; 
    },
    set foo(value) {
        this._foo = value;
    }
};

let fooDescriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
fooDescriptor.get.name; // 'get foo'
fooDescriptor.set.name; // 'set foo'
```



##### 函数终止

函数终止：

- 使用 `return` 语句，立即停止执行并退出当前函数。因此，`return` 语句后面的代码不会被执行。
- `return` 语句不仅可以终止函数，还可以返回一个值作为执行后的结果。【默认值：`undefined`】

值得注意的是：

- 函数在执行完毕后，会立即销毁所有局部变量，而形成闭包可以打破这个硬操作。
- 通过 `return` 返回值与传递参数一样，实际上都只是在栈层面上简单的拷贝操作。

```js
// 退出当前函数
function fn () {
    (function () {
        return 1; // 仅退出当前函数
    })();
    console.log(222);    // 222
}
------------------------------------------------------------------------------------------------------------

// 只执行遇到的第一个return
function fn () {
    return 1;
    return 2; // 被忽略
}
fn(); // 1
------------------------------------------------------------------------------------------------------------

// 返回值：原始值
function fn() {
    let num = 0;
    return num; 	// 将num的值拷贝一份，作为返回的结果
    // 相当于：return 0;
}

// 返回值：引用值
function fn () {
    let obj = {};
    return obj;		// 将obj的引用拷贝一份，作为返回的结果
    // 相当于：return obj的引用;
}
```



##### 严格模式

严格模式：【违反以下规则，会报错】

- 函数不能以 `eval` 或 `arguments` 作为名称；

- 函数的参数和变量都不能叫 `eval` 或 `arguments`； 

- 两个命名参数不能拥有同一个名称。

```js
let a = 1, b = 2;

function fn(a, b) {
    "use strict"; // 必须作为可执行语句的第一句，否则无法开启。
    return a + b;
}
fn(a, b); // 3
```



##### 函数传参

​		`ECMAScript` 函数的参数跟大多数其他语言不同。`ECMAScript` 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。

​		之所以会这样，主要是因为 `ECMAScript` 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，没有问题；如果数组的元素超出了要求，也没问题。事实上，在使用 `function` 关键字定义（非箭头）函数时，可以在函数内部访问 `arguments` 对象，从中取得传进来的每个参数值。严格模式下，重写（覆盖） `arguments` 对象会导致语法错误。

​		`arguments` 对象是一个类数组对象（但不是 `Array` 的实例），它接收了调用时所有传入的参数，可以使用中括号语法访问其中的元素（第一个参数是 `arguments[0]`，第二个参数是 `arguments[1]`）。要确定传进来多少个参数，可以访问 `arguments.length` 属性。

```js
// 有了arguments对象之后，形参就不是必须的了。
function fn() {
    return arguments[0] + arguments[1];
}

fn(1, 2); // 3
```

​		**函数形参就是在函数首部使用 `let` 隐式声明的局部变量；函数传参就是给形参赋值的过程；函数实参则是实际赋给形参的值。关于函数形参，还有一点：使用 `let` 或 `cosnt` 声明形参会导致报错（因为变量已存在），但可以使用 `var` 声明形参。之所以说形参是隐式的 `let` 变量，是因为：1、形参存在暂时性死区，且不允许被 `let` 或 `const` 再次声明，但其值允许被更改，因此是 `let` 变量；2、形参允许被 `var` 再次声明，但正常情况下是不允许 `let` 变量被重复声明的，因此是隐式的。**

```js
// 声明形参时，可以选择性地进行初始化。这个初始值会被传入的非undefined实参覆盖。
function createPerson(name, age = 18, sex) {
    return {name, age, sex};
}

// 传入undefined，并不会修改形参的初始值。
createPerson('wz', undefined, '女'); // {name: 'wz', age: 18, sex: '女'}

createPerson('qz', 20, '男'); 		// {name: 'qz', age: 20, sex: '男'}

------------------------------------------------------------------------------------------------------------

// 实际上，在初始化某个形参时，还可以调用其前面的形参，因为形参是按顺序声明的。
function fn(x = 0, y = x) {
    console.log(x, y);
}

fn(); 		// 0 0
fn(1); 		// 1 1
fn(1, 2); 	// 1 2
```

​		`ECMAScript` 并没有提供规定形参类型的机制，也就没有验证实参的语法，因此可以随意传参。如果需要限制类型，可使用 `TS`。

```tsx
function fn_js(name) {
    console.log(name);
}

fn_js(1); // 1

function fn_ts(name: String) {
    console.log(name);
}

fn_ts(1); // 报错
```

```js
// 因此，默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值。
let romanNumbers = ['I', 'II', 'III', 'IV', 'V', 'VI'];
let ordinality = 0;

function getNumerals() {
    // 每次调用后递增。
    return romanNumbers[ordinality++];
}

function makeKing(name = 'Henry', numerals = getNumerals()) {
    return `King ${name} ${numerals}`;
}

makeKing(); 				// 'King Henry I'
makeKing('Louis', 'XVI'); 	// 'King Louis XVI'
makeKing(); 				// 'King Henry II'
makeKing(); 				// 'King Henry III'
------------------------------------------------------------------------------------------------------------

// 再看一个例子：有一个包含对象结构相同的数组，要根据对象某个属性对数组重新排序，可以像下面这样做。
// 使用sort排序，设计一个比较函数。由于比较的是指定属性的值，因此需要一个外部函数接收属性，然后在其内部返回sort所需的回调。
function compare(property) {
    return function (obj1, obj2) {
        let value1 = obj1[property],
            value2 = obj2[property];
        return value1 > value2 ? 1 : -1; // 必须给-1或1，否则无法正常排序。
    }
}

let data = [
    {name: 'ez', age: 17},
    {name: 'ow', age: 16},
    {name: 'oe', age: 20}
];

// 根据name属性排序
data.sort(compare('name')); // [{name: 'ez', age: 17}, {name: 'oe', age: 20}, {name: 'ow', age: 16}]

// 根据age属性排序
data.sort(compare('age')); // [{name: 'ow', age: 16}, {name: 'ez', age: 17}, {name: 'oe', age: 20}]
```

​		函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：

```js
let makeKing = (name = 'Henry') => `King ${name}`;

makeKing(); // 'King Henry'
```

通过传参方式激活的 `arguments` 槽位与形参，二者之间还会建立一种始终保持的一一映射的对应关系。

**注释**：如果对函数的任何一个形参进行了初始化，或者开启了严格模式，都会导致这种关系断裂。

```js
// 传参（同时激活了arguments槽位和形参，推荐方式）
function fn(a, b) { // 【不能进行形参初始化，否则这种关系会失效】
    // 单方面修改
    a = 1;
    arguments[1] = 2;
    
    // 无论任何时候，二者都是对应的。它们在内存中是分开的，只不过是保持同步而已。
    console.log(arguments[0] === a, arguments[0], a);
    console.log(arguments[1] === b, arguments[1], b);
}

fn(0, 0);
/*
> true 1 1
> true 2 2
*/
```

```js
// 当然，arguments槽位和形参也可以通过手动激活，但这种方式并不能建立上述的对应关系。
function fn(a, b) {
    // 手动激活槽位和形参
    arguments[0] = a = undefined;
    arguments[1] = b = undefined;
    
    a = 1;
    arguments[1] = 2;
    
    // 二者相互独立，互无关联。
    console.log(arguments[0] === a, arguments[0], a);
    console.log(arguments[1] === b, arguments[1], b);
}

fn();
/*
> false undefined 1
> false 2 undefined
*/
```

函数参数：

- 函数形参是使用 `let` 在函数首部隐式声明的局部变量【局部形参，默认值 `undefined`】

- 函数传参：按值传递，这意味着它实际上就是复制变量的过程：将实参直接拷贝给形参。

- 函数实参被存在内置形参 `arguments` 中【形参与实参未必数量相同】，它是一个类数组


根据函数传参的特性，可知：原始值被传入后便与外部无关，引用值被传入后仍旧映射到外部

```js
// 函数传参：按值传递。
function test (a, b, o) {
    // 当函数被执行时：自动执行以下两步
    // 1、首先在首部声明形参，值初始为undefined
    let a, b, o;
    // 2、实参形参相统一，将实参赋值给形参
    a = 1; b = 2; o = obj;
}
test(1, 2, obj);

// 未被接收的实参会被忽略，但会存在arguments中
+function (a, b) {
    console.log(arguments); // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}(1, 2, 3);
```

箭头函数中未定义 `arguments` 变量，因此只能使用形参接收实参，多余实参将被舍弃。但它可以访问外部函数的 `arguments` 变量。

```js
// 箭头函数中没有定义arguments变量。
let fn = () => {
    console.log(arguments);
}
fn(); // ReferenceError: arguments is not defined

// 如果外部函数具有arguments变量，则内部的箭头函数可以访问它。
function fn1() {
    let fn2 = () => {
        console.log(arguments); // 不是因为它具有了这个变量，只是因为这个变量存在于它的作用域链中。
    };
    fn2();
}
fn1(1, 2); // Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```



##### 参数收集

​		`ES6` 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。

```js
// 扩展参数（此时，仍可以定义形参来接收，但一一定义略显笨拙）
function sum(a, b, c) {
	console.log(arguments); // arguments并不关心参数是如何传进来的，它只是负责接收。
}

// 将数组中的元素，依次取出并传入函数，而不是传入整个数组。
sum(...[1, 2, 3]); // Arguments(3) [1, 2, 3]

// 等效于：
sum.apply(null, [1, 2, 3]);
```

```js
// 实际上，还可以在前面或后面继续传入其他参数。
function fn() {
    console.log(arguments);
}

fn(0, ...[1, 2, 3], 4, ...[5, 6]); // Arguments(7) [0, 1, 2, 3, 4, 5, 6]
```

​		在传递时可以通过扩展操作符一一传递实参，在接收时也可以通过剩余操作符将剩余未接收的实参一一收录到指定的数组中。

```js
// 注意：因为一个数组要收集多少参数是不可确定的，所以剩余运算符只能用于最后一个形参。
function fn(...arr) {
    console.log(arr);
}

fn(1, 2, 3); // [1, 2, 3]

// 如果将剩余运算符用于中间形参，将会抛出语法错误。
function fn(a, ...b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

fn(1, ...[2, 3], 4); // SyntaxError: Rest parameter must be last formal parameter

// 正确用法
function fn(a, b, ...c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

fn(1, ...[2, 3], 4);
/*
> 1
> 2
> [3, 4]
*/

// 当然，如果没有剩余的参数，则会得到一个空数组。
function fn(a, b, ...c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

fn(1, [2, 3]);
/*
> 1
> [2, 3]
> []
*/
```

​		这个语法对于箭头函数来说是一个福音，它虽然没有 `arguments` 变量，但可以通过剩余运算符模拟一个 `arguments` 变量。

```js
let fn = (...arr) => {
    console.log(arr);
}

fn(1, 2, 3); // [1, 2, 3]
```

​		注意：使用剩余运算符收集的数组，与 `arguments` 是毫无关联的。它只是一个普通数组，并没有 `arguments` 的特殊行为。



##### 函数重载

​		`ECMAScript` 函数不能像传统编程那样重载。在其他语言比如 `Java` 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，`ECMAScript` 函数没有签名，因为参数是由一个包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。

​		如果像传统编程一样在 `ECMAScript` 中定义了两个同名函数，则后定义的会覆盖先定义的。

```js
function addSomeNumber(num) { 
 	return num + 100; 
} 

function addSomeNumber(num) { 
 	return num + 200; 
} 

addSomeNumber(100); // 300
```

不过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。

```js
function add() {
    if (arguments.length === 1) {
        return arguments[0] + 10;
    } else if (arguments.length === 2) {
        return arguments[0] + arguments[1];
    }
}

add(10); 		// 20
add(10, 20); 	// 30
```

闭包，立即销毁，函数作用域

<hr>


### 函数高阶

#### 函数内部

​		在 `ECMAScript 5` 中，函数内部存在两个特殊的对象：`arguments` 和 `this`。`ECMAScript 6` 又新增了 `new.target` 伪属性。



##### `arguments`

​		`arguments` 对象只有以 `function` 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 `arguments` 对象其实还有一个 `callee` 属性，是一个指向 `arguments` 对象所在函数的指针。【`callee`：被召者，被调用函数】

```js
function fn() {
    console.log(arguments.callee === fn); // 这个属性在递归匿名函数，以及在解耦函数逻辑与函数名当中都非常有用。
}

fn(); // true
------------------------------------------------------------------------------------------------------------

// 匿名函数递归，不需要知道函数名和标识符。
function () {
    arguments.callee();
}

// 具名函数解耦，函数标识符有被修改的风险，但callee并不关心标识符，因此可以很好地将函数的逻辑与名称分开。
function fn() {
    arguments.callee();
}
```

```js
// 一个经典的例子就是负责阶乘计算的函数。
function fn1(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * fn1(num - 1); // n! = n x (n - 1)!，且 n > 1。
    }
}

fn1(5); // 120 = 5 x 4 x 3 x 2 x 1

// 更安全的递归是
function fn2(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}

// 来看下面这种情况。
let copyFn1 = fn1,
    copyFn2 = fn2;

fn1 = function () {return 0};
fn2 = function () {return 0};

copyFn1(5); // 0【耦合】
copyFn2(5); // 120【解耦】
fn1(5); 	// 0
fn2(5); 	// 0
```



##### `this`

​		另一个特殊的对象是 `this`，只有标准函数才拥有自己的 `this` 对象，箭头函数只是将它当作一个普通的外部变量。

​		另外，**现代函数中的 `this` 对象不能被重写**，这在过去的函数中是被允许的。

​		在标准函数中，`this` 引用的是把函数当成方法调用的上下文对象，当不指定调用者时，函数由 `windows` 来调用。`this` 到底引用哪个对象必须到函数被调用时才能确定，而不是在定义时确定的（无论它被定义在函数中、对象中、还是全局下，都无法确定 `this`）。

```js
window.color = 'red';

let o = {
    color: 'bule',
    sayColor() {
        console.log(this.color);
    }
};

let sayColor = o.sayColor;

// 指定调用者：this指向调用者
o.sayColor(); // 'blue'

// 不指定调用者：this指向window
sayColor(); // 'red'
// 因为它实际上会被window对象调用，相当于执行：window.sayColor(); 或 sayColor.call(window);【函数不会被添加到window上】

------------------------------------------------------------------------------------------------------------

// 每个标准函数都有自己的this、arguments、caller、new.target等，彼此独立。
function fn1() {
    console.log(this); // window
    function fn2() {
        console.log(this); // window
    }
    fn2();
}

fn1();
```

​		前面提到过，箭头函数中没有 `this` 对象。不过，这并不妨碍它访问外部的 `this` 对象，**`this` 对箭头函数来说只是一个普通变量**。

```js
(function () {
    (() => {console.log(this);})(); // window
})();

// 并不是它有this，而是全局下的this指向window。
(() => {console.log(this);})(); // window
console.log(this); 				// window
```

​		标准函数才有 `this` 对象，且 `this` 只有在调用时才能确定，而不是在定义时确定的。箭头函数没有 `this` 对象，它只能访问其外部的 `this` 对象，因此箭头函数中访问到的 `this` 对象，是在定义时就确定的，且一经定义就无法被更改。若以一言以简之，则：标准函数中 `this` **只能在执行时确定**，可以被**随意更改**；箭头函数中的 `this` **只能在定义时确定**，一经确定**无法更改**。

注解：假设箭头函数有 `this` 的话，那么其 `this` 一定是与外部 `this` 始终绑定的。它并不在意外部 `this` 是谁，但始终保持一致。

```js
// 对象中的this
let o = {
    // 这是标准函数的简写语法。
    a() {
        return this;
    },
    b: () => {return this;},
    c: {
        d() {
            return this;
        },
        e: () => {return this;}
    },
    f() {
        console.log(this.g());
        console.log((() => {return this;})());
    },
    g: () => {return this;}
};

o.a(); // 对象o
o.b(); // window【虽然它具有调用者，但它没有this，于是访问到了全局中的this】

o.c.d(); // 对象c
o.c.e(); // window【原理同上】

// 箭头函数的这种行为，不是call和apply能够修改的，因为它根本就没有this对象。
o.a.call({}); // {}【o.c.d同理】
o.b.call({}); // window【o.c.e同理】

o.f();
/*
> window
> 对象o
*/
```

​		正是因为箭头函数没有自己的 `this`，所以它能够访问外部的 `this` 对象，也因此，它在嵌套函数中具有更广泛的用途。而标准函数因为具有自己的 `this` 所以不能直接访问外部的 `this`，只能通过一个变量来转移引用。

```js
// 标准函数
function fn() {
    let that = this;
    (function () {
        console.log(that);
    })();
}
fn.call({id: 1}); // {id: 1}

// 箭头函数
function fn() {
    (() => {
        console.log(this);
    })();
}
fn.call({id: 2}); // {id: 2}
```

​		由于箭头函数本身简洁的语法以及没有 `this` 对象这个特点，箭头函数非常适合用来做回调函数。



##### `caller`

​		`ECMAScript 5` 也会给函数对象上添加一个属性：`caller`。虽然 `ECMAScript 3` 中并没有定义，但所有浏览器除了早期版本的 `Opera` 都支持这个属性。这个属性引用的是调用当前函数的函数，如果是在全局作用域中调用的则为 `null`。【`caller`：调用者】

```js
function fn1() {
    console.log(fn1.caller);
}

function fn2() {
    fn1(); // fn1在fn2中被调用，因此fn1.caller指向了fn2。
}

fn1(); // null
fn2(); // fn2
```

​		若要降低耦合度，则可以通过 `arguments.callee.caller` 来引用同样的值。但在严格模式下访问 `caller`、`callee` 都会报错。

```js
function fn() {
    'use strict';
    console.log(arguments.callee); // TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
    console.log(fn.caller); // 错误同上
}

fn();
```



##### `new.target`

​		`ECMAScript` 中的函数既可以作为构造函数实例化新对象，也可以作为普通函数被调用。`ECMAScript 6` 新增了检测函数是否使用 `new` 关键字调用的 `new.target` 属性。如果函数是作为普通函数调用的，则 `new.target` 的值是 `undefined`；如果是使用 `new` 关键字调用的，则 `new.target` 将引用函数自身。

```js
function fn() {
    return new.target;
}

// 普通调用
fn(); 		// undefined

// new调用
new fn() === fn; // true
```



#### 函数属性

​		每个函数都有两个属性：`length` 和 `prototype`。



##### `length`

`length` 属性指示函数中形参的个数，可通过 `arguments.length` 查看实参个数。

```js
function fn1() {}
function fn2(a) {}
function fn3(a, b) {}

fn1.length; // 0
fn2.length; // 1
fn3.length; // 2
```



##### `prototype`

​		`prototype` 属性只有标准函数才拥有，它是函数的原型空间。原型中的数据和方法由所有实例共享。它对于自定义类型非常重要。在 `ECMAScript5` 中，`prototype` 属性是不可枚举的，因此使用 `for-in` 循环不会返回这个属性。

```js
function fn() {}

// prototype属性中默认只有一个constructor方法。
fn.prototype; // {constructor: f fn()}
```

​		如果把构造函数比作生产汽车的工厂，那么 `prototype` 就是生产汽车的原型模具，它定义了汽车一些最基本的功能和参数。



#### 函数方法

​		`Function.prototype` 上具有三个方法，都用于修改函数的 `this` 对象，分别是：`call`、`apply`、`bind`。

​		注释：传入的 `this` 值可以是对象，也可以是 `null` 或 `undefined`。后者表示不修改 `this` 对象，继续使用默认值 `window`。而如果，传入的 `this` 值是一个原始值，那么它将被转为对象。



##### `call`

​		`call` 方法，可接收多个参数：新的 `this` 对象和一系列实参。即：`fn.call(thisArg, arg1, arg2, ...)`。

```js
// 修改this指向
function fn(a, b) {
    console.log(this);
}

// 这其实相当于：fn.call(null, 1, 2);
fn(1, 2); // window

fn.call({}, 1, 2); // {}
```

​		在严格模式下，调用函数时如果没有指定上下文对象，则 `this` 值不会指向 `window`。除非使用 `apply()` 或 `call()` 把函数指定给一个对象，否则 `this` 的值会变成 `undefined`。

```js
function fn() {
    'use strict';
    console.log(this);
}

fn(); // undefined

fn.call({}); // {}
```

​		不过 `call` 还具有召唤的意味：当函数没有调用者时，可用来为它指定调用者；当对象没有这个函数时，可以为它借来方法。

```js
let obj = {
    name: 'wz',
    sayName() {
        console.log(this.name);
    }
};

// 1、提供调用者
let sayName = obj.sayName;

obj.sayName(); // 'wz'

// 失去调用者，其this将指向默认的window。
sayName(); // ''

sayName.call(obj); // 'wz'，这其实相当于：obj.sayName();
------------------------------------------------------------
// 2、借用方法
// 标准形式：Function.prototype.apply.call(fn, thisArg, args);
let obj1 = Object.create(null, {
    name: {
        value: 'cy'
    }
});

// obj1借用obj对象的sayName方法。
Function.prototype.apply.call(obj.sayName, obj1); // 'cy'，这其实相当于：obj1调用了obj.sayName方法。
// 注解：apply为obj1提供了应用函数的功能，call则为obj1借来了其他对象的方法。

// 更简洁的语法：
Reflect.apply(obj.sayName, obj1, []); // 'cy'
```

```js
// 直接调用原型上的内置方法，其实会将首参作为其内部的this来使用。
Array.prototype.slice.call([1, 2], 1, 2); // 等价于：[1, 2].slice(1, 2);

Function.prototype.apply.call(fn, thisArg, [arg1, arg2]); 	// 等价于：fn.apply(thisArg, [arg1, arg2]);

Function.prototype.call.apply(fn, [thisArg, arg1, arg2]); 	// 等价于：fn.call(thisArg, arg1, arg2);

Function.prototype.call.bind(fn, thisArg, arg1)(arg2); 		// 等价于：fn.call(thisArg, arg1, arg2);

Function.prototype.apply.bind(fn, thisArg, [arg1, arg2])(); // 等价于：fn.apply(thisArg, [arg1, arg2]);

Function.prototype.bind.call(fn, thisArg, arg1)(arg2); 		// 等价于：fn.bind(thisArg, arg1)(arg2);

Function.prototype.bind.apply(fn, [thisArg, arg1])(arg2); 	// 等价于：fn.bind(thisArg, arg1)(arg2);
```

```js
function fn(...args) {
    console.log(this);
    console.log(args);
}

// call参数
Function.prototype.apply.call(fn, {id: 1}, [1, 2, 3, 4]); 	// 等价于：fn.apply({id: 1}, [1, 2, 3, 4]);

// apply参数
Function.prototype.call.apply(fn, [{id: 2}, 1, 2, 3, 4]); 	// 等价于：fn.call({id: 2}, 1, 2, 3, 4);

// bind参数
Function.prototype.call.bind(fn, {id: 3}, 1, 2)(3, 4); 		// 等价于：fn.call({id: 3}, 1, 2, 3, 4);

// call参数
Function.prototype.bind.call(fn, {id: 4}, 1, 2)(3, 4); 		// 等价于：fn.bind({id: 4}, 1, 2)(3, 4);

// apply参数
Function.prototype.bind.apply(fn, [{id: 5}, 1, 2])(3, 4); 	// 等价于：fn.bind({id: 5}, 1, 2)(3, 4);

// bind参数
Function.prototype.apply.bind(fn, {id: 6}, [1, 2, 3, 4])(); // 等价于：fn.apply({id: 6}, [1, 2, 3, 4]);
```



##### `apply`

​		`apply` 方法，只接收两个参数：新的 `this` 对象和一个实参列表。即：`fn.apply(thisArg, args)`。

```js
function fn(...args) {
    console.log(args);
}

fn.apply(null, [1, 2], [3, 4]); // [1, 2]
```

​		`apply` 具有应用的意味，它也可以像 `call` 那样，为一个方法指定调用者或为一个对象借来方法。

```js
let obj = {
    id: 1,
    logThis(...args) {
        console.log(this);
        console.log(args);
    }
};

// 1、提供调用者
let logThis = obj.logThis;

// 失去调用者，其this将指向默认的window。
logThis(1, 2);
/*
> window
> [1, 2]
*/

logThis.apply(obj, [1, 2]);
/*
> {id: 1, logThis: f}
> [1, 2] 
*/

// 2、借用方法
// 标准形式：Function.prototype.call.apply(fn, [thisArg, arg1, arg2, ...]);
let obj1 = Object.create(null, {
    id: {
        value: 2
    }
});

// obj1借用obj对象的logThis方法。
Function.prototype.call.apply(obj.logThis, [obj1, 1, 2]);
/*
> {id: 2}【注意：它没有logThis方法】
> [1, 2]
*/
```



##### `bind`

​		`bind` 方法，只接受一个参数。`bind` 意为绑定，它会创建一个新的函数，然后将这个新函数的 `this` 值绑定为传入的对象参数。

``` js
function fn() {
    console.log(this);
}

let o = {
    id: 1
};

// 创建一个新的fn函数，将其this指向对象o。
fn.bind(o); // f fn()

// 默认绑定fn的this值。
fn.bind()(); // window

fn.bind(o)(); // {id: 1}
```

​		实际上，`bind` 方法也可以接收额外的参数，这些参数会成为新函数的预传实参，即：位于新函数的实参之前。

```js
function fn(a, b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}

let newFn = fn.bind({}, 1, 2);

newFn(3); // 传入时，先传预设的实参，再传自身的实参。
/*
> 1
> 2
> 3
*/
```



#### 继承方法

​		对函数而言，继承的方法 `toLocaleString()` 和 `toString()` 始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法 `valueOf()` 返回函数本身。

```js
function fn(a, b) {
    // 求值a与b的和、差。
    let c = a + b,
        d = a - b;
    return a * b * c * d;
}

fn.toLocaleString();
// 'function fn(a, b) {\n // 求值a与b的和、差。\n let c = a + b,\n d = a - b;\n return a * b * c * d;\n}'

fn.toString();
// 'function fn(a, b) {\n // 求值a与b的和、差。\n let c = a + b,\n d = a - b;\n return a * b * c * d;\n}'

fn.valueOf(); // f fn(a, b)
```



#### 递归

递归：反复调用函数自身，一直递增或递减地执行下去，直至遇到一个值，然后开始一层一层地回归。触发回归的值被称为**“回归值”**。

百科：递归是一种直接或间接调用自身的编程技巧，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。



##### 设计递归

递归，就是在运行的过程中调用自己。构成递归需具备的条件：

- 子问题须与原问题做同样的事，且更为简单；
- 不能无限制地调用本身，须有个出口，化简为非递归状况处理。

基本思路：将原来复杂的问题，拆分为一个个简单的相似的子问题，这些简单的子问题必须要能还原原问题。还必须要设计一个出口，这个出口应是进行最后一次递归的回归条件。这意味着程序会从它开始一步一步地还原问题，因此它又是还原过程中最基本的条件。

**注释**：回归过程中，是从回归值开始，将该值一层一层地向上返回的，然后作为函数的执行结果，并不是直接将回归值返回给最顶层的。

```js
let arr = [];

function fn(num) {
    arr.push(num);
    if (num > 1) {
        // 递归条件
        return fn(num - 1); // 继续将回归值向上传递，直至最顶层。
    } else {
        // 回归条件
        return 1; // 回归值（如果被继续向上传递，则会被作为函数执行的结果；如果没有，则执行结果为undefined）
    }
}

fn(5); 	// 1【递归函数的执行结果：回归值或undefined】
arr; 	// [5, 4, 3, 2, 1]
```

```js
// 清除所有引用自身的属性
function clearCircularReferences(subject, _fn = keys => { keys[1][keys[0]] = null }, _refs = new WeakSet()){
	// 避免无限递归（当弱集中存在该引用值时退出，这意味着当遇到相等的引用值时，说明存在循环引用并需要及时解除）
	if (_refs.has(subject)) {
		return _fn(_fn.keyEntries); // 调用清除程序，逐层清除所有造成循环引用的属性。
   	}
	// 若参数为引用值，将其添加到弱集中。并且递归地遍历参数，判断其内部是否还具有引用值。
 	if (typeof subject === "object") {
       	_refs.add(subject);
        for (const key in subject) {
       		_fn.keyEntries = [key, subject]; // 将造成循环引用的属性及其父对象以条目形式存入清除程序的一个属性中。
            clearCircularReferences(subject[key], _fn, _refs); // 在递归中，继续使用fn和_refs。
        }
    }
}

const foo = {
    foo: "Foo",
    bar: {
        bar: "Bar",
        bas: {}
    },
};

// 自身属性引用自身
foo.bar.baz = foo;
foo.bar.bas.baf = foo;
foo.bar.bas.baa = foo.bar.baz;

// 检查指定对象是否存在循环引用，若存在则调用清除程序清除所有引用属性。
clearCircularReferences(foo);

foo; // {bar: {bar: 'Bar', bas: {baa: null, baf: null}, baz: null}, foo: 'Foo'}
```



##### 递归的问题

​		递归的问题在于，如何在函数内部始终准确地调用自身。因为函数引用暴露在外面，则可能被外界更改，从而引发错误。

```js
function fn(num) {
    if (num > 1) {
        return num * fn(num - 1);
    } else {
        return 1;
    }
}

let fn1 = fn;

// 如果fn在调用前被更改了，则在执行时会引发错误。
fn = null;
fn1(5); // TypeError: fn is not a function
------------------------------------------------------------------------------------------------------------
// 1、第一个解决的办法就是使用callee属性。
function fn(num) {
    if (num > 1) {
        return num * arguments.callee(num - 1);
    } else {
        return 1;
    }
}

// 不过，这个办法的问题在于不能在严格模式下使用。
// 因此，诞生了第二种方法：使用具名函数表达式（在函数名中提到过：在具名函数表达式中，函数名会成为内部变量）。
let fn = function f(num) {
    if (num > 1) {
        return num * f(num - 1);
    } else {
        return 1;
    }
};
```

使用具名函数表达式来定义递归函数，具有如下四个优势：

- 函数的逻辑不依赖于外部变量 `fn`，即使被转移给其他变量也可以正常运行。【函数解耦】
- `f` 会被作为该函数的内部变量，所以它在外部是未定义的。既不会干扰同名变量，也不会被重写。【私密变量】
- 它可以在严格模式下执行。【严格执行】
- 创建命名函数表达式，另外的好处是，如果遇到错误，堆栈跟踪将包含函数的名称，从而更容易找到错误的根源。【方便溯源】

不过递归，还存在尾调用优化的问题，具体优化参见下文。



#### 尾调用

​		`ECMAScript 6` 规范新增了一项内存管理优化机制，让 `JavaScript` 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：

```js
function outer() {
    return inner(); // 尾调用（一个函数执行结束，以执行完另一个函数为标志）
}
```



##### 优化

在 `ES6` 优化之前，执行这个例子会在内存中发生如下操作：

1. 执行到 `outerFunction` 函数体，第一个栈帧被推到栈上。
2. 执行 `outerFunction` 函数体，到 `return` 语句。计算返回值必须先计算 `innerFunction`。
3. 执行到 `innerFunction` 函数体，第二个栈帧被推到栈上。【**需要优化的关键**】
4. 执行 `innerFunction` 函数体，计算其返回值。
5. 将返回值传回 `outerFunction`，然后 `outerFunction` 再返回值。
6. 将栈帧弹出栈外。

在 `ES6` 优化之后，执行这个例子会在内存中发生如下操作：

(1) 执行到 `outerFunction` 函数体，第一个栈帧被推到栈上。

(2) 执行 `outerFunction` 函数体，到达 `return` 语句。为求值返回语句，必须先求值 `innerFunction`。

(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 `innerFunction` 的返回值也是 `outerFunction`的返回值。

(4) 弹出 `outerFunction` 的栈帧。【**实现优化的关键**】

(5) 执行到 `innerFunction` 函数体，栈帧被推到栈上。

(6) 执行 `innerFunction` 函数体，计算其返回值。

(7) 将 `innerFunction` 的栈帧弹出栈外。

​		很明显，第一种情况至少会同时存在两个栈帧（并且每多调用一次嵌套函数，就会多增加一个栈帧），而第二种情况只会同时存在一个栈帧（无论调用多少次嵌套函数，都只有一个栈帧）。这就是 `ES6` 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，那么引擎就会这样做。



##### 优化条件

尾调用优化的条件就是确定外部栈帧真的没有必要存在了，涉及的条件如下：

- 代码在严格模式下执行；
- 外部函数的返回值是对尾调用函数的调用；
- 尾调用函数返回后不需要执行额外的逻辑；
- 尾调用函数不是引用外部函数的闭包。

下面展示了几个违反上述条件的函数，因此都不符合尾调用优化的要求：

```js
// 该脚本开启严格模式
'use strict';

// 无优化：尾调用没有返回 
function outerFunction() { 
 	innerFunction(); 
} 

// 无优化：尾调用没有直接返回
function outerFunction() { 
 	let innerFunctionResult = innerFunction(); 
 	return innerFunctionResult; 
} 

// 无优化：尾调用返回后，增加了额外的逻辑（必须在尾调用函数执行结束之后，紧接着执行外部函数的return）
function outerFunction() { 
 	return innerFunction().toString(); 
} 

// 无优化：尾调用是一个闭包
function outerFunction() { 
 	let foo = 'bar'; 
 	function innerFunction() { return foo; } // 形成了闭包
 	return innerFunction(); 
}
```

下面是几个符合尾调用优化条件的例子：

```js
"use strict"; 

// 有优化：栈帧销毁前执行参数计算
function outerFunction(a, b) { 
 	return innerFunction(a + b); 
} 

// 有优化：初始返回值不涉及栈帧
function outerFunction(a, b) { 
 	if (a < b) { 
 		return a; // 不涉及栈帧
 	} 
 	return innerFunction(a + b); // 满足尾调用优化
} 

// 有优化：两个内部函数都在尾部
function outerFunction(condition) { 
 	return condition ? innerFunctionA() : innerFunctionB(); 
}
```

​		**差异化尾调用**和**递归尾调用**是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，**这个优化在递归场景下的效果是最明显的**，因为递归代码最容易在栈内存中迅速产生大量栈帧。

注意：之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 `f.arguments` 和 `f.caller`，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。



##### 递归优化

​		可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数：

```js
function fib(n) { 
 	if (n < 2) { 
 		return n; 
 	} 
 	return fib(n - 1) + fib(n - 2); // fin(n) = fib(n - 1) + fib(n - 2);【当前项 = 前两项之和】
} 

console.log(fib(0)); // 0 
console.log(fib(1)); // 1 
console.log(fib(2)); // 1 
console.log(fib(3)); // 2 
console.log(fib(4)); // 3 
console.log(fib(5)); // 5 
console.log(fib(6)); // 8
```

​		显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，`fib(n)` 的栈帧数的内存复杂度是 *O*(2<sup>n</sup> )。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：`fib(1000);` 

​		当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：

```js
"use strict"; 

// 基础框架 
function fib(n) { 
 	return fibImpl(0, 1, n); // 满足尾调用优化
} 

// 执行递归（从第一、二项开始，执行n+1次相邻数累加，获取第n+1个数）
function fibImpl(a, b, n) { 
 	if (n === 0) { // 包含0，执行n + 1次
 		return a; // 0, 1, 1, 2, 3, 5, 8, ...（回归值：第n + 1个数）
 	} 
 	return fibImpl(b, a + b, n - 1); // 满足尾调用优化
}
```

这样重构之后，就可以满足尾调用优化的所有条件，再调用 `fib(1000)` 就不会对浏览器造成威胁了。



#### 闭包

​		闭包，是指：在其作用域链上存在其他函数作用域的函数，就像在一个对象的原型链中包含另一个对象那样。它通常被实现为嵌套函数，因为函数嵌套为形成闭包提供了天然的环境。

不同的定义：

- 百科：闭包就是能够读取其他函数内部变量的函数。例如在 `javascript` 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
- `MDN`：闭包是一个函数以及与其绑定的周边环境状态的引用的组合（即：闭包函数 + 闭包对象）。



##### 闭包的产生

问题：

- 内部函数一定要引用外部函数的变量，才能形成闭包麽？【是的】
- 非嵌套结构的函数引用另一函数的变量，会形成闭包麽？【不会】
- 内部函数一定要被返回出去使用，不能在内部被执行麽？【不是】

注释：

- 闭包，在定义时就可以确定它能否产生（是否具备形成条件），但要到引用它时才会真正形成（不引用就不会产生）。
- 这是 `JS` 引擎针对闭包做出的优化：**只有在引用闭包函数时，才会产生闭包**；不引用闭包函数，则不会产生。

```js
// 能够形成闭包的环境
function outer(prop) {
    function inner() {
        console.log(prop); // 一定要直接使用外部函数中的变量，才能形成闭包。
    }
}

// 不能形成闭包的环境
function outer(prop) {
    function inner(prop) {
        console.log(prop); // 没有直接使用外部函数中的变量，不能形成闭包。
    }
}
```

```js
// 生成闭包的两种方式
// 1、内调式（不将闭包返回出去执行）
function outer(prop) {
    // 短暂地形成了闭包【随着outer函数的执行结束，闭包函数会被立即回收】
    function inner() {
        console.log(prop);
    }
    inner(); // 必须引用一次inner（可执行，也可不执行），否则不会形成闭包。
}
outer('closure');

// 2、外调式（将闭包返回出去执行）
function outer(prop) {
    // 极易长久地形成闭包【在outer函数执行结束前，将闭包函数暴露了出去】
	return function inner() {
        console.log(prop);
    }
}

// 如果不使用变量接收闭包函数，那么它就会被垃圾回收。如果接收了闭包函数，则应在不需要时清除其引用。
outer('closure')();
```

​		外调式闭包函数才能最大限度地发挥出闭包的优势。但也要注意，在不需要闭包时及时清除其引用，否则会导致其成为永久性闭包。



##### 闭包的内容

**闭包中只存在被直接引用的外部函数的变量**，没被引用的外部函数变量不会存在其中。闭包可以通过以下两个方式查看：

- 调试工具：断点调试 ==> `[[Scope]]` 
- 原型空间：`fn.prototype` ==> `constructor` ==> `[[Scopes]]` 

```js
function outer() {
    let a, b, c;
    return function inner() {
        let c = 0; // 不属于闭包的内容
        a = 1, b = 2;
    }
}
let inner = outer(); // 引用了闭包函数，闭包生成。

// inner的执行时作用域链【调试工具中】
Scope {
    Local: {
        this: Window,
        c: 0
    },
    Closure (outer) {
        a: 1,
        b: 2
    },
    Script: {
        inner: f inner()
    }
    Global: Window
}

// 原型空间中
[[Scopes]]: Scopes[3] [
    0: Local {...},
    1: Closure (outer) {...}, // 闭包
    2: Script {...},
    3: Global {window: Window, ...}
]
```

​		从原型空间中，可知：作用域链其实是一个包含指针的列表，指针从上到下，从本作用域依次指向其父级作用域，直至全局作用域。

​		函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。正常来说，每个函数执行完毕后，其局部的活动对象会被立即销毁，其作用域链中就只剩下脚本作用域和全局作用域了。而如果函数成为了闭包函数，则其作用域链中还会一直存在一个闭包。



##### 闭包的问题

​		闭包函数最大的问题在于，每执行一次 `outer` 函数并引用一次 `inner` 函数，就会产生一个闭包。如果在短时间内频繁这样做，而又不及时清除闭包，就会造成大量的内存泄漏，甚至是内存爆满。

**注释**：

- 在过去，由于 `inner` 成为闭包函数后会一直引用 `outer` 函数的活动对象，所以 `outer` 函数的整个活动对象都会得不到释放。
- 而现在，`JS` 引擎已针对这一点做了优化，它将 `outer` 中被引用的变量复制到闭包中，使得 `outer` 的活动对象可以如期释放。

**清除闭包**：要清除闭包，只需要清除闭包函数即可。因为闭包只存在于闭包函数的作用域链中，闭包函数被清除了，闭包自然消失。

```js
function outer() {
    let a, b, c;
    return function inner() {
        let c = 0;
        a = 1, b = 2;
    }
}

let inner = outer(); // 保留了闭包函数，否则它会被清除。

// outer的作用域链【outer的活动对象已被释放】
[[Scopes]]: Scopes[2] [
    0: Script {inner: f inner()},
    1: Global {window: Window}
]

// inner的作用域链【闭包存在inner作用域链中】
[[Scopes]]: Scopes[3] [
    0: Closure (outer) {a: undefined, b: undefined},
    1: Script {inner: f inner()},
    2: Global {window: Window}
]
```



##### 常见的闭包

​		所有的函数都会继承全局作用域，而由函数表达式或函数声明定义的函数还会继承当前作用域。也就是说，函数形成一个闭包。

​		需要特别注意的是，回调函数（事件处理程序、定时器回调等）很容易在无意间就成为了闭包函数，并且还容易阻止引用计数归零。

​		由于 `IE` 在 `IE9` 之前对 `JScript` 对象和 `COM` 对象使用了不同的垃圾回收机制，所以闭包在这些旧版本 `IE` 中可能会导致更多的问题。比如：在这些版本的 `IE` 中，把 `HTML` 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。

```js
function handler() {
    let oDiv = document.getElememtById('div-box');
    
    // 给元素添加事件回调（引用了闭包函数，闭包已经生成）。
    oDiv.onclick = () => {
        console.log(oDiv.id); // 该函数已经在无意间成为了闭包函数，而且它一直引用着oDiv对象，使得该对象的引用计数无法归零。
    }
}
------------------------------------------------------------------------------------------------------------

// 如果将oDiv提取到外面，而不作为函数的局部变量，则不会形成闭包。
let oDiv = document.getElementById('div-box');

function handler() {
    oDiv.onclick = () => {
        console.log(oDiv.id); // 因为oDiv不属于父函数的局部变量，因此不会形成闭包。
    }
}
```

​		关于给 `oDiv` 元素添加事件回调时，易造成循环引用 `oDiv` 对象的这个问题，可以使用匿名函数中的 `this` 对象来解决。

```js
// 使用this来代替引用元素，可以尽可能避免引用父函数的局部变量。运用恰当时，还可以直接避免形成闭包。
function handler() {
    let oDiv = document.getElementById('div-box');
    
    // 因为箭头函数引用的是父作用域中的this，因此使用箭头函数：1、不仅不能正确引用元素，2、还会形成闭包。
    oDiv.onclick = function() {
        console.log(this.id); // 使用自身this变量，既没有形成闭包，也不会造成oDiv对象引用无法归零。
    }
    
    // 因为没有形成闭包，所以将该函数返回出去执行，也没有任何影响。
    return oDiv.onclick;
}
```

​		在过去，由于闭包函数会引用父函数的整个活动对象，而父活动对象中包含对 `oDiv` 对象的引用，所以还需要对其手动解除引用。

更多参考：[`Closures`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) 



#### 私有变量

​		严格来讲，`JavaScript` 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。



##### 特权方法

​		特权方法：将一些私有数据封装到闭包中，那么就只有通过相应的闭包函数才能访问这个闭包及其数据。因为只有这种闭包函数才拥有对私有数据的访问权，所以被称为“特权方法”。

​		虽然在函数外部无法直接访问其内部的私有变量，但可以利用闭包的机制，建立函数内部与外部沟通的桥梁。

​		特权方法（`privileged method`）正是利用闭包，成为了能够访问函数私有变量（及私有函数）的公有方法。

​		特权方法可以使用构造函数或原型模式通过自定义类型中实现，也可以使用模块模式或模块增强模式在单例对象上实现。

​		在对象上有两种方式创建特权方法。第一种是在构造函数中实现，比如：

```js
// 私有的name属性既非静态属性也非实例属性，但是每个每个实例所独有的。
function Person(name) {
    // 特权方法
	this.getName = function() {
        return name; // 闭包
    };
    
    // 特权方法
    this.setName = function(value) {
        return name = value; // 闭包
    }
}

let person = new Person('wz');

// 只能通过特权方法，才能读写对象上的私有变量。
person.getName(); // 'wz'
person.setName('cy');
person.getName(); // 'cy'
```

​		这其实运用了构造函数模式，它的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。



##### 静态私有变量

​		特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：

```js
let Person = null;

(function() { 
 	let name = ''; // 静态私有变量，所有实例共享。
    // 注解：有意思的是，由于window.name = ''，因此name变量是全局的。所以在块外访问的name并非块中的name，注意辨别。
    
 	Person = function(value) { 
 		name = value; // 闭包
 	};
    
 	Person.prototype.getName = function() { 
 		return name; // 闭包
 	}; 
    
 	Person.prototype.setName = function(value) { 
 		name = value; // 闭包
 	}; 
})(); 

// Person的作用域链（Person.prototype）
[[Scopes]]: Scopes[3] {
    0: Closure {name: ''}, // 若改为块级作用域，则此处为：Block {name: ''}
    1: Script {Person: f (value)},
    2: Global {window: Window}
}

let person1 = new Person('Nicholas'); 
person1.getName(); // 'Nicholas' 
person1.setName('Matt'); 
person1.getName(); // 'Matt' 

let person2 = new Person('Michael'); 
person1.getName(); // 'Michael' 
person2.getName(); // 'Michael'
```

注意：使用闭包和私有变量会导致作用域链变长，作用域链越长，查找变量所需的时间会越多，作用域链也会更复杂。



##### 模块模式

​		前面的模式通过自定义类型创建了私有变量和特权方法。模块模式，则在一个单例对象上实现了相同的隔离和封装。单例对象（`singleton`）就是只有一个实例的对象。按照惯例，`JavaScript` 是通过对象字面量来创建单例对象的。

```js
let singleton = {
    name: '',
    method() {}
};
```

​		模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：

```js
// 单例对象
let singleton = function() {
    // 私有变量和方法
    let privateVariable = 0;
    function privateMethod() {
        return false;
    }
    
    // 返回一个单例对象
    return {
        // 公开的属性和特权方法
        publicProperty: true,
        publicMethod() {
            // 闭包函数（为了闭包数据的私密性，最好还是不要将数据暴露出去）
            privateVariable++;
            return privateMethod();
        }
    };
}();

// singleton.publicMethod的作用域链
[[Scopes]]: Scopes[3] [
    0: Closure { privateVariable: 0, privateMethod: f privateMethod()},
    1: Script {singleton: {publicProperty: true, publicMethod: f}},
    2: Global {window: Window}
]
```

​		本质上，对象字面量定义了单例对象的公共接口。如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式：

```js
// 单例对象
let application = function() { 
 	// 私有变量和私有函数 
 	let components = new Array(); 
    
 	// 初始化
 	components.push(new BaseComponent()); 
    
 	// 公共接口
 	return { 
 		getComponentCount() { 
 			return components.length; // 闭包
 		}, 
 		registerComponent(component) { 
 			if (typeof component == 'object') { 
 				components.push(component); // 闭包（引用了components变量）
 			} 
 		} 
 	}; 
}();
```

​		`Web` 开发中，经常需要使用单例对象管理应用程序级的信息。上面这个简单的例子创建了一个 `application` 单例对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组 `components`，然后将一个 `BaseComponent` 组件的新实例添加到数组中。对象字面量中定义的 `getComponentCount()` 和 `registerComponent()` 方法都是可以访问 `components` 私有数组的特权方法。前一个方法返回注册组件的数量，后一个方法负责注册新组件。

​		在模块模式中，单例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问。以这种方式创建的每个单例对象都是 `Object` 的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以可以避免使用 `instanceof` 操作符确定参数是不是对象类型的需求。



##### 模块增强模式

​		另一个利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。

```js
let singleton = function() {
    // 私有数据
    let privateVariable = 0;
    function privateMethod() {
        return false;
    }
    
    // 创建对象
    let obj = new MyObject();
    
    // 增强对象
    obj.publicProperty = true;
    obj.publicMethod = function() {
        privateVariable++;
        return privateMethod();
    };
    
    // 暴露对象
    return obj;
}();
```

​		如果前一节的 `application` 对象必须是 `BaseComponent` 的实例，那么就可以使用下面的代码来创建它：

```js
let application = function() { 
 	// 私有变量和私有函数 
 	let components = new Array(); 
    
 	// 初始化
 	components.push(new BaseComponent()); 
    
 	// 创建局部变量保存实例
 	let app = new BaseComponent(); 
    
 	// 公共接口
 	app.getComponentCount = function() { 
 		return components.length; 
 	};
    app.registerComponent = function(component) { 
 		if (typeof component == "object") { 
 			components.push(component); 
 		} 
 	}; 
    
 	// 返回实例
 	return app; 
}();
```



