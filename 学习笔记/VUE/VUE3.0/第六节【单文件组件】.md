# 单文件组件

### `vue3`新变化

##### 实例`API`

在`vue2`中，通过`new Vue()`的方式创建应用实例，其全局`API`都定义在`Vue`类的原型上。

在`vue3`中，通过`createApp()`方法创建应用实例，任何可在全局改变`Vue`行为的`API`都移动到了应用实例上。

**提示**：所有不全局改变行为的全局`API`通过具名导出。

| `2.x` 全局 `API`             | `3.x` 实例 `API` (`app`)                     |
| ---------------------------- | -------------------------------------------- |
| `Vue.config`                 | `app.config`                                 |
| `Vue.config.productionTip`   | **移除**                                     |
| `Vue.config.ignoredElements` | `app.config.compilerOptions.isCustomElement` |
| `Vue.component`              | `app.component`                              |
| `Vue.directive`              | `app.directive`                              |
| `Vue.mixin`                  | `app.mixin`                                  |
| `Vue.use`                    | `app.use`                                    |
| `Vue.prototype`              | `app.config.globalProperties`                |
| `Vue.extend`                 | **移除**                                     |

**提示**：若要了解`vue2`与`vue3`的重要区别，可查看官网的迁移指南。

地址：https://v3.cn.vuejs.org/guide/migration/introduction.html#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B



##### `$attrs`属性

在`vue2`中，`attrs`表示`props`未接收的传递属性，不包括`class`和`style`属性。在`vue3`中，包括了这两个属性。



##### 过渡的类名

过渡类名的更改：`v-enter => v-enter-from`；`v-leave => v-leave-from`【更加明确易读】



##### 被移除的`API`

- `keyCode`作为`v-on`修饰符的支持【现使用键名】
- `$on、$off、$once`实例方法
- 过滤器选项：`filter`
- `$children`实例属性
- 全局函数`set`和`delete`以及实例方法`$set`和`$delete`



##### `vuex`的变化

在`vue3`中，仍采用选项式写法书写`vuex`，与`vue2`无异。由于使用`setup`，所以导入`vuex`的方式发生了变化。

**获取全局状态实例**：通过导入`useStore`方法并执行，可获得全局状态实例。

**注释**：`vue3`中`store`的`state`属性是一个响应式的代理对象，相当于使用了`reactive`包装。

**提示**：

- 在`vue2`中，通过`map`辅助函数将`state`和`getters`导入`computed`中，将`mutations`和`actions`导入`methods`中使用。
- 在`vue3`中，也可将数据放入`computed()`的回调中返回，将修改方法的同步执行使用函数包裹。【可用`toRefs`绑定`state`】

```js
setup () {
    // 获取vuex的实例对象
    const store = useStore(),
          state = store.state,
          getters = store.getters,
          commit = store.commit,
          dispatch = store.dispatch;
    
    // 通过vue2的方式，获取state和getters的数据。【可在任何地方按需引入，且不浪费性能】
    let name = computed(() => state.name),
        age = computed(() => state.age),
        newAge = computed(() => getters.newAge);
    
    // 但state本就是响应式的代理对象，可通过toRefs直接解构取值。getters是普通对象，可先使用reactive包装。
    const {name, age} = toRefs(state),
        {newAge} = toRefs(reactive(getters)); 
    
    // 导入修改vuex数据的方法：在一个具名函数中同步执行。
    const addAgeMutations = () => {
        commit("addAge");
    }
    
    const addAgeActions = () => {
        dispatch("addAge");
    };
}
```

**提示**：`vue3`不建议在组合式`API`中使用`map`辅助函数批量导入。



##### 路由对象

在`vue3`中，使用`useRoute`和`useRouter`方法分别代替访问`$route`和`$router`属性。

```js
const route = useRoute(), // 当前激活的路由信息对象
      router = useRouter(); // 路由实例对象

router.push("/about"); // replace与push的作用相同，但它不会向历史记录中添加该条跳转的记录。
```

<hr>

### 单文件组件语法

直接在`script`元素上添加`setup`属性，代码编写更简洁，运行性能更好。



##### 使用子组件

在单文件组件中，直接导入子组件即可，无需使用`components`注册挂载。

```html
<script setup>
	import Home from "@/views/Home.vue"
</script>
```



##### 使用数据

在单文件组件中，会自动`return`数据，只返回第一层作用域（全局作用域、根属性）的数据和方法。

**注释**：定义在局部作用域和块级作用域中的数据及方法，不会被自动`return`返回。



##### `props`接收数据

在`<script setup>`中，使用`defineProps`方法代替`vue2`的`props`选项来接收传递数据。【无需导入】

注释：使用`props`接收的数据，为方便使用，建议始终保持响应式。

- 传递`reactive`包装的数据，接收到的仍然具有响应式，可直接解构使用。
- 传递`ref`包装的数据，接收到的可能失去响应式，可使用`computed`监听。

```js
const props = defineProps(["class", "style", "title"]);
console.log(props); // 代理对象

// 接收reactive的数据：直接解构
const {data} = defineProps(["data"]);

// 接收ref的数据：ref包装引用值时，多一层包裹，直接解构或使用toRef都获取不到。只能通过toRefs全部包装。
const props = defineProps(["data"]),
      {data} = toRefs(props); // 使用toRefs响应props中的每个属性（RefImpl对象）。
```



##### `attrs`未接收数据

在`<script setup>`中，使用`useAttrs`方法代替`vue2`的`attrs`选项。

**提示**：如果要关闭继承，只能在选项式`API`中单独执行。



##### `emit`自定义事件

在`<script setup>`中，使用`defineEmits`方法代替`vue2`的`emits`选项来接收自定义的事件。【无需导入】

```js
// 通过自定义的事件名接收
const emit = defineEmits(["change"]);
// 通过事件名称，触发接收到的自定义事件
emit("change");
```



##### `expose`暴露共享

使用`<script setup>`的组件，默认会封闭内部所有的数据，不对外公开。

在`<script setup>`中，使用`defineExpose`方法代替`setup`选项的`expose`方法来指定可共享的数据。【无需导入】

**提示**：当通过组件实例的引用对组件进行访问时，只能访问到指定的公开数据。

