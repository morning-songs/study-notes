# 滚动插件

推荐：`BetterScroll`插件，一款重点解决移动端各种滚动场景需求的插件，基于`iscroll`实现。【已支持`PC`端】

应用：典型的是索引栏、歌词滚动、列表滚动（类似锚点跳转功能，但具有页面滚动的效果）。

<hr>

### 索引栏【`IndexBar`】

##### 安装

输入`npm install @better-scroll/core --save`指令，安装`BetterScroll`插件的`core`核心。



##### 深度监听插件

若要监听滚动容器的子元素变化，可输入`npm install @better-scroll/observe-dom --save`指令，安装`observe-dom`插件。

注释：

- 当容器内容及其子元素的`DOM`发生变化时，将触发`scroll`的`refresh`方法【在`scroll`的动画过程中，不会触发`refresh`】
- 即：当滚动容器中新增或移除了一个子元素时，触发`refresh`方法刷新滚动容器的内容，以便于获取最新的滚动容器信息。

应用：在列表渲染中，子元素是通过请求数据来渲染的，其父元素高度随着子元素的数量而变化。此时，需要监听子元素数量的变化。

提示：在滚动容器中，滚动其内容时，需要知道容器的确切高度以计算内容相对容器的滚动距离。



#### 封装组件

页面上需要使用滚动效果的场景很多，可以将其封装为全局组件来使用。【在`components`中创建`Scroll`组件】

注释：在组件中将需要滚动的`DOM`内容使用`<scroll>`包裹，然后在`Scroll`组件中使用`<slot>`插槽来接收这些内容。

```html
<!-- 歌手组件 -->
<template>
	<Scroll>
        <!-- 使用scroll的组件标签包裹需要滚动的内容 -->
    	歌手滚动列表
    </Scroll>
</template>

<!-- 滚动组件 -->
<template>
	<div>
        <slot></slot> <!-- 在scroll组件内部，使用插槽接收滚动内容 -->
    </div>
</template>
```

提示：一般歌手列表分为：热门歌手和全部歌手，这两类的请求链接也是分开的。

##### 使用插件

在`<Scroll>`组件中配置插件。

```js
import BScroll from '@better-scroll/core';
import ObserveDom from '@better-scroll/observe-dom';
BScroll.use(ObserveDom); // 使用use方法，将ObserveDom作为BScroll的插件使用。

/*
	注意：
		BScroll默认只处理容器的第一个子元素，因此滚动容器中只能有一个根元素。
		被监听的滚动容器必须有固定的高度，以便计算内容相对于容器的滚动距离。
		实质是：在滚动容器的根元素上添加css的transform属性，控制translate的值。
*/
```

##### 监听滚动容器

通过`new BScroll()`来对监听指定的滚动容器进行监听。

参数：要监听的滚动容器，配置对象

被监听的滚动容器，必须是已经存在于页面上的`DOM`元素。【通常在`mounted`之后监听它】

配置对象：

- 若要使用`@better-scroll/observe-dom`插件，需配置`observeDOM`项的值为`true`。
- `BetterScroll`插件默认会阻止浏览器的原生`click`事件。【移动端以`touch`事件为主】
- `touch`与`click`：
  - `PC`端：主要是鼠标的`click`事件，点击的点只有一个。
  - 移动端：主要是手指的`touch`事件，触摸的点不只一个。【`touch`的单击比`click`的单击响应得更快】
- 派发`scroll`事件：通过`probeType`项决定如何派发`scroll`事件。【性能消耗大，须谨慎使用】
  - 0：任何时候都不派发。
  - 1：仅当手指按在滚动区域上时，每隔 `momentumLimitTime` 毫秒派发一次。
  - 2：仅当手指按在滚动区域上时，一直派发。
  - 3：任何时候都会派发。

**注释**：

- 执行`new BScroll()`会返回一个`BScroll`的实例对象，该对象上具有`BScroll`插件的核心属性和方法【需要暴露出去使用】

```vue
<!-- 在调用滚动容器的组件中 -->
<template>
	<!-- 滚动容器 -->
	<Scroll class="scroll-plane" :probeType="3" ref="scrollRef"> <!-- 通过属性传递值 -->
        <!-- 要滚动的列表 -->
        <ul>
    		<li></li>
    	</ul>
    </Scroll>
</template>

<script setup>
    import {ref} from 'vue'
	let scrollRef = ref(null); // 获取ref属性值为scrollRef的元素实例。
    console.log(scrollRef); // 一个RefImpl对象，其value是该组件通过expose暴露出来的Proxy代理对象。
</script>

<style>
    .scroll-plane {
        width: 100%;
        height: calc(100vh - 88px);
        overflow: hidden;
    }
</style>

<!-- 在Scroll组件中 -->
<template>
	<!-- 只能有一个根元素，否则<Scroll>会与template融合。 -->
	<div ref="scrollRootRef"> <!-- 当<Scroll>组件标签与该<div>合并之后，ref就可以获取到该滚动容器 -->
        <slot></slot> <!-- <ul>列表及其内容会被该插槽接收，因此<Scroll>中只能有一个根元素 -->
    </div>
</template>

<script setup>
    import {onMounted, onUnmounted, ref} from 'vue'
    import BScroll from '@better-scroll/core';
	import ObserveDom from '@better-scroll/observe-dom';
	BScroll.use(ObserveDom); // 使用use方法，将ObserveDom作为BScroll的插件使用。
    
    let props = defineProps({
     	probeType: {
            type: Number,
            default: 0
        }   
    })
    
    let scrollRootRef = ref(null), // 获取滚动容器
        scroll = ref(null); // 接收BScroll的实例对象 
    
    // 所有元素挂载之后
    onMounted(() => {
        // 监听滚动容器，将实例对象存入scroll中。
		scroll.value = new BScroll(scrollRootRef.value, {
            observeDOM: true, // 开启 observe-dom 插件【注意：observeDOM】
            ...props // 将props中的属性解构出来使用
        })
    })
    
    onUnmounted(() => {
        // 当组件销毁时，销毁scroll
        scroll.value.destroy();
    })
    
    // 将scroll实例对象暴露出去，方便调用者组件使用。
    defineExpose({
        scroll
    })
</script>
```

##### 索引栏锚点

调用插件实例上的`scrollToElement`方法，通过索引栏上的锚点，来控制将内容滚动到指定的元素位置处。

事件对象中的`touches`属性，记录着在当前`touch`中检测到的触摸点，每个点包含位置信息与`target`元素。

**注释**：当页面滚动需要加载很多资源时，不推荐使用索引栏来使内容滚动跳转至目标元素。

```vue
<!-- 在调用滚动容器的组件中 -->
<template>
	<!-- 滚动容器 -->
	<Scroll class="scroll-plane" :probeType="3" ref="scrollRef"> <!-- 通过属性传递值 -->
        <!-- 要滚动的列表 -->
        <ul ref="groupRef">
    		<li></li>
    	</ul>
    </Scroll>

	<!-- 固定的索引栏 -->
	<div>
        <ul>
        	<li
                v-for="(item, index) in singerList"
                :key="item.tag"
                :class="{current: currentIndex === index}" // 匹配触摸点的索引，作用高亮显示
                @touchstart.prevent.stop="touchStartHandel($event, index)"
            >
    		</li>    
    	</ul>
    </div>
</template>

<script setup>
    import Scroll from "@/components/Scroll.vue";
	import { ref } from "vue";
    
	let scrollRef = ref(null), // 获取ref属性值为scrollRef的元素实例。
        groupRef = ref(null); // 获取ul元素
    // 触摸索引栏上的锚点时，记录相关信息
    let touchPosition = {}, // 触摸的位置信息对象
        currentIndex = ref(0); // 当前触摸到的索引，默认为0
    
    // 当触摸到索引栏的某个字母时，使内容滚动到指定的元素位置处。
    function touchStartHandel(e, i) {
        currentIndex.value = i; // 将当前触摸到的索引，传递给currentIndex对象。
        // 跳转到指定的元素位置
        scrollto(i);
    }
    
    // 定义将内容滚动到指定的元素位置，即：在容器中置顶目标元素
    function scrollto (i) {
        let targetElement = groupRef.value.children[i]; // 获取字母索引在滚动容器中对应的元素
        
        let scroll = scrollRef.value.scroll; // 获取插件实例对象
        scroll.scrollToElement(targetElement); // 调用实例上的scrollToElement方法，滚动到指定元素位置。
    }
</script>
```

##### 索引栏滑动

当手指在索引栏上的某字母处按下时，可以通过继续滑动索引栏来上下选择其他的字母。

注释：

- 在滚动区域内，如何派发`scroll`事件，是由配置对象的`probeType`项决定的。
- 上下滑动是相对于被按下的字母而言的，因此无论滑到哪里，事件对象的`target`始终只记录为初始的元素。
- 索引栏上每个元素的高度必须固定且统一，否则会出现结果偏差。【根据距离差计算触摸到的是哪个元素】

```html
<!-- 在调用滚动容器的组件中 -->
<template>
	<!-- 滚动容器 -->
	<Scroll class="scroll-plane" :probeType="3" ref="scrollRef"> <!-- 通过属性传递值 -->
        <!-- 要滚动的列表 -->
        <ul ref="groupRef">
    		<li></li>
    	</ul>
    </Scroll>

	<!-- 固定的索引栏 -->
	<div>
        <ul>
        	<li
                v-for="(item, index) in singerList"
                :key="item.tag"
                :class="{current: currentIndex === index}" // 匹配触摸点的索引，作用高亮显示
                @touchstart.prevent.stop="touchStartHandel($event, index)"
                @touchmove.prevent.stop="touchMoveHandel($event, index)"
            >
    		</li>    
    	</ul>
    </div>
</template>

<script setup>
    import Scroll from "@/components/Scroll.vue";
	import {ref} from "vue";
    
	let scrollRef = ref(null), // 获取ref属性值为scrollRef的元素实例。
        groupRef = ref(null), // 获取ul元素
        liLength = 0; // 列表元素的长度 
    // 触摸索引栏上的锚点时，记录相关信息
    let touchPosition = {}, // 触摸的位置信息对象
        currentIndex = ref(0); // 当前触摸到的索引，默认为0
    
    onMounted(() => {
        liLength = groupRef.value.children.length - 1;
    })
    
    // 当触摸到索引栏的某个字母时，使内容滚动到指定的元素位置处。
    function touchStartHandel(e, i) {
        // 将触摸点的坐标记录到touchPosition对象中
        touchPosition.y1 = e.touches[0].pageY;
        // 跳转到指定的元素位置
        scrollto(i);
    }
        
    // 当在索引栏上按下某个字母时，可以继续上下滑动来选择其他字母
    function touchMoveHandel (e, i) { // i是被按下字母的索引，滑动过程中i不会改变
        // 将滑动过程中触摸点的坐标记录到touchPosition对象中
        touchPosition.y2 = e.touches[0].pageY;
        
        // 获取滑动过程中的触摸到的索引：当前索引 = 初始索引 + 索引差
  		let moveIndex = i + Math.floor((touchPosition.y2 - touchPosition.y1) / 20); 

        // 跳转到指定的元素位置
        scrollto(moveIndex);
    }
    
    // 定义将内容滚动到指定的元素位置，即：在容器中置顶目标元素
    function scrollto (i) {
        i = Math.max(0, Math.min(i, liLength)); // 0 < i < liLength
        
        currentIndex.value = moveIndex; // 将当前触摸到的索引，传递给currentIndex对象。
        
        let targetElement = groupRef.value.children[i]; // 获取字母索引在容器中对应的元素
        
        let scroll = scrollRef.value.scroll; // 获取插件实例对象
        scroll.scrollToElement(targetElement); // 调用实例上的scrollToElement方法，滚动到指定元素位置。
    }
    
    // 计算索引差：【当前索引 = 初始索引 + 索引差】
    function indexDifference (i) {
	  // 计算相对于事件源对象的索引差：Y坐标差 / 字母li的高度 = 索引差
      let difference = Math.floor((touchPosition.y2 - touchPosition.y1) / 20);
      switch (i) {
    	case 0:
      		return Math.min(Math.max(0, difference), 26); // 0 < difference < 26
    	case 26:
      		return Math.max(Math.min(0, difference), -26); // -26 < difference < 0
    	default:
      		return Math.min(Math.max(difference, -i), 26-i); // -i < difference < 26-i
  	  }
    }
    // 基本思路
    // 计算滑动过程中，触摸到的索引
    // function indexMoving(i) {
    //   let difference = 0;
    //   if (i === 0) {
    //     difference = Math.min(Math.max(0, Math.floor((touchPosition.y2 - touchPosition.y1) / 20)), 26);
    //     difference = i + difference; // 当前索引 = 初始索引0 + 索引差
    //   } else if (i === 26) {
    //     difference = Math.max(0, Math.min(Math.floor((touchPosition.y1 - touchPosition.y2) / 20), 26));
    //     difference = i - difference; // 当前索引 = 初始索引26 - 索引差
    //   } else {
    //     if (touchPosition.y2 - touchPosition.y1 >= 0) {
    //       // 向下滑动
    //       difference = Math.min(Math.floor((touchPosition.y2 - touchPosition.y1) / 20), 26 - i);
    //       difference = i + difference; // 当前索引 = 初始索引 + 索引差
    //     } else {
    //       // 向上滑动
    //       difference = Math.min(Math.floor((touchPosition.y1 - touchPosition.y2) / 20), i);
    //       difference = i - difference; // 当前索引 = 初始索引 - 索引差
    //     }
    //   }
    //   return difference;
    // }
</script>
```

##### 滚动关联索引

当滚动内容时，还需要将滚动关联到索引栏，引起在索引栏上对当前索引的高亮显示。

原理：将滚动内容划分为对应数量的区域，使每个区域的顶部与索引栏上的索引相关联。

注释：

- 由于每个区域的高度由数据来驱动，因此需要在挂载后获取每个区域的高度。
- 在滚动容器上传递一个自定义事件，在滚动组件内部设置当内容滚动时触发。

监听滚动：

- 在`BS`插件的实例上通过`on`方法，开启原生的`scroll`监听事件，默认传递一个包含实时滚动信息的对象参数。
- 需要特别注意的是，在插件中对`probeType`的配置，决定着如何派发`scroll`事件。

获取高度：

- 通过使用监听器监听请求数组的长度，来判断每一列表项是否请求到数据。
- 在每一项请求到数据后，判断是否已更新到视图，更新后获取每一个列表项的高度。
- 无固定高度：将每一项的高度值累加求取各项的Y坐标；固定高度：高度 * 列表长度。

```vue
<!-- 在调用滚动容器的组件中 -->
<template>
	<Scroll @scroll="scrolling"></Scroll>
</template>

<script setup>
    import {reactive, watch, nextTick} from "vue"
    // 定义一个接收各列表项数据的临时数组，用于监听各列表项的数据是否已被请求并填充。
    let tempArr = reactive([]);
    
    // 存储各列表项的Y轴坐标
    let liItemsY = ref([]);
    
    // 挂载后，请求数据
    onMounted(() => {
      singerList.forEach((item) => {
        if (item.tag === "热") {
          getHotSinger()
            .then((res) => {
              item.singerInfo = res.data.artists;
              tempArr.push(item.singerInfo); // 当各项数据被填充到singerInfo时，再填充到临时数组。
            })
            .catch((err) => {
              console.log("请求热门歌手失败", err);
            });
        } else {
          getSingerList(item.tag)
            .then((res) => {
              item.singerInfo = res.data.artists;
              tempArr.push(item.singerInfo); // 当各项数据被填充到singerInfo时，再填充到临时数组。
            })
            .catch((err) => {
              console.log("请求全部歌手失败", err);
            });
        }
      });
    });
    
    // 开启对tempArr临时数组长度的监听，确保各项数据已被填充到singerInfo中
    watch(() => tempArr.length, async () => {
        await nextTick(); // 确保各列表项的视图更新完成
        // 获取所有项的元素节点
        let liItems = groupRef.value.children;
        // 定义区域的初始坐标（Y轴）
        /*	各项高度固定时：
        	let liHeight = liItems[0].offsetHeight,
        		index = liItems.length,
        		temp = []; // 存储各项坐标的临时数组
        	for (let i = 0; i <= index; i++) {
        		// 当前坐标 = 固定高度 * 当前索引
        		temp.push(liHeight * i);
        	}
        */
        
        // 高度不固定时，实时获取高度
        let initHeight = 0, // 初始位置
            temp = [initHeight]; // 存储各项Y轴坐标的数组

        for (let item of liItems) {
            // 当前坐标 = 上一个坐标 + 当前高度值
            temp.push(initHeight += item.offsetHeight);
        }
        
        liItemsY.value = temp;
    })
    
	function scrolling(y) {
        y = -y;
        // 遍历坐标数组，匹配当前y所属的区域，获取该区域的索引
        liItemsY.value.forEach((item, i) => {
            // 获取下一项的坐标
            let next = liItems.value[i+1];
            if (y >= item && y < next) { // [item, next)
                currentIndex.value = i; // 将匹配到的区域索引传给索引栏。
            }
        });
    }
</script>

<!-- 在滚动组件中 -->
<script setup>
	// 接收组件标签上定义的自定义事件
    let emit = defineEmits(["scroll"]); // 接收自定义的scroll事件
    
    onMounted(() => {
        scroll.value = new BScroll();
        // 开启滚动监听
        if (props.probeType > 0) {
            scroll.value.on("scroll", (position) => {
            	emit("scroll", position.y); // 调用自定义scroll事件，传递y位置。
        	})
        }
    })
</script>
```

<hr>

### 懒加载

懒加载：滚动页面时，要根据资源是否已进入可视区来判断是否请求加载该资源。

**注释**：懒加载指令一般绑定加载资源的`url`地址。

```html
<ul>
    <li
    	v-for="item in imgList" :key="item.picUrl"
    >
    	<img v-img-lazy="picUrl"> <!-- 绑定加载资源的地址 -->
    </li>
</ul>
```



##### 安装

输入`npm i @vueuse/core -S`指令，安装一个判断资源是否进入可视区的插件。



##### 异步监听

在指令的配置文件中，从`@vueuse/core`插件中导入`useIntersectionObserver`方法，开启异步监听。

参数：`vue3`的`DOM`元素，回调处理（内置数组，……）【该回调会在元素进入或离开可视区时触发】

注释：

- 当元素获取到资源之后，应关闭对该元素的监听，避免来回滚动时不断触发监听去重新赋值加载资源。
- 开启异步监听的`useIntersectionObserver`方法，返回一个对象，对象上的`stop`方法，可关闭该监听。

```js
// 在自定义指令的index文件中
import imgLazyload from './imgLazyload'

export default {
    install(app) {
        // 注册全局的自定义指令：
        // 图片懒加载
        app.directive("img-lazy", imgLazyload);
    }
}

// 在懒加载指令的配置对象中
import defaultImg from '@/assets/lazy.jpg'
import {useIntersectionObserver} from '@vueuse/core'

export default {
    mounted(el, binding) {
        // 初始时，显示默认图片
        el.src = defaultImg;
        
        // 对指令绑定的元素开启异步监听：是否已进入或离开可视区
        let {stop} = useIntersectionObserver(el, ([{isIntersecting}]) => { 
            // 自动传递回调的第一个形参：它是一个包含当前元素信息的数组，首元素对象上有一个isIntersecting属性。
            if (isIntersecting) { // 进入可视区域时为true，离开时为false
                // 加载实际的图片资源
                el.src = binding.value;
                // 加载失败时
                el.onerror = () => {
                    el.src = defaultImg;
                }
                // 元素已加载到资源后，停止对该元素的监听处理
                stop();
            }
        })
    }
}
```

