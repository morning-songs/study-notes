# 项目构建

​		使用集成的工具链，以实现最佳的用户和开发人员体验。

​		本节将介绍一些流行的 `React` 工具链，它们有助于完成如下任务：

- 扩展文件和组件的规模。
- 使用来自 `npm` 的第三方库。
- 尽早发现常见错误。
- 在开发中实时编辑 `CSS` 和 `JS`。
- 优化生产输出。

​		本节推荐的工具链 **无需配置即可开始使用**。



### 工具链

#### 不使用

​		将 `React` 集成到现有网站最简单的方式，就是[将 `React` 作为普通的 `<script>` 标记添加到 `HTML` 页面上](https://zh-hans.reactjs.org/docs/add-react-to-a-website.html)，以及[使用可选的 `JSX`](https://zh-hans.reactjs.org/docs/add-react-to-a-website.html#optional-try-react-with-jsx)。



#### 推荐的

​		`React` 团队主要推荐这些解决方案：

- 如果你是在 **学习 `React`** 或 **创建一个新的[单页](https://zh-hans.reactjs.org/docs/glossary.html#single-page-application)应用**，请使用 [`Create React App`](https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#create-react-app)。
- 如果你是在 **用 `Node.js` 构建服务端渲染的网站**，试试 [`Next.js`](https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#nextjs)。
- 如果你是在构建 **内容主导的静态网站**，试试 [`Gatsby`](https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#gatsby)。
- 如果你是在打造 **组件库** 或 **将 `React` 集成到现有代码仓库**，尝试 [更灵活的工具链](https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#more-flexible-toolchains)。

##### `Create React App`

​		[`Create React App`](https://github.com/facebookincubator/create-react-app) 是一个用于 **学习 `React`** 的舒适环境，也是用 `React` 创建 **新的[单页](https://zh-hans.reactjs.org/docs/glossary.html#single-page-application)应用** 的最佳方式。

​		它会配置你的开发环境，以便使你能够使用最新的 `JavaScript` 特性，提供良好的开发体验，并为生产环境优化你的应用程序。你需要在你的机器上安装 [`Node >= 14.0.0` 和 `npm >= 5.6`](https://nodejs.org/en/)。要创建项目，请执行：

```shell
npx create-react-app my-app # 使用npx create-react-app指令，创建一个my-app项目。
cd my-app
npm start
```

> 注意：第一行的 `npx` 不是拼写错误 —— 它是 [`npm 5.2+` 附带的 `package` 运行工具](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b)。

​		`Create React App` 不会处理后端逻辑或操纵数据库；它只是创建一个前端构建流水线（`build pipeline`），所以你可以使用它来配合任何你想使用的后端。它在内部使用 [`Babel`](https://babeljs.io/) 和 [`webpack`](https://webpack.js.org/)，但你无需了解它们的任何细节。

​		当你准备好部署到生产环境时，执行 `npm run build` 会在 `build` 文件夹内生成你应用的优化版本。你能 [从它的 `README`](https://github.com/facebookincubator/create-react-app#create-react-app--) 和 [用户指南](https://facebook.github.io/create-react-app/) 了解 `Create React App` 的更多信息。

##### `Next.js`

​		[`Next.js`](https://nextjs.org/) 是一个流行的、轻量级的框架，用于配合 `React` 打造 **静态化和服务端渲染应用**。它包括开箱即用的 **样式和路由方案**，并且假定你使用 [`Node.js`](https://nodejs.org/) 作为服务器环境。

​		从 [`Next.js` 的官方指南](https://nextjs.org/learn/)了解更多。

##### `Gatsby`

​		[`Gatsby`](https://www.gatsbyjs.org/) 是用 `React` 创建 **静态网站** 的最佳方式。它让你能使用 `React` 组件，但输出预渲染的 `HTML` 和 `CSS` 以保证最快的加载速度。

​		从 `Gatsby` 的 [官方指南](https://www.gatsbyjs.org/docs/) 和 [入门示例集](https://www.gatsbyjs.org/docs/gatsby-starters/) 了解更多。



#### 更灵活的工具链

​		以下工具链为 `React` 提供更多更具灵活性的方案。推荐给更有经验的使用者：

- **[`Neutrino`](https://neutrinojs.org/)** 把 [`webpack`](https://webpack.js.org/) 的强大功能和简单预设结合在一起。并且包括了 [`React` 应用](https://neutrinojs.org/packages/react/)和 [`React` 组件](https://neutrinojs.org/packages/react-components/)的预设。
- **[`Nx`](https://nx.dev/react)** 是针对全栈 `monorepo` 的开发工具包，其内置了 `React`，`Next.js`，[`Express`](https://expressjs.com/) 等。
- **[`Parcel`](https://parceljs.org/)** 是一个快速的、零配置的网页应用打包器，并且可以 [搭配 `React` 一起工作](https://parceljs.org/recipes/react/)。
- **[`Razzle`](https://github.com/jaredpalmer/razzle)** 是一个无需配置的服务端渲染框架，但它提供了比 `Next.js` 更多的灵活性。



#### 从头开始打造工具链

​		一组 `JavaScript` 构建工具链通常由这些组成：

- 一个 **`package` 管理器**，比如 [`Yarn`](https://yarnpkg.com/) 或 [`npm`](https://www.npmjs.com/)。它能让你充分利用庞大的第三方 `package` 的生态系统，并且轻松地安装或更新它们。
- 一个 **打包器**，比如 [`webpack`](https://webpack.js.org/) 或 [`Parcel`](https://parceljs.org/)。它能让你编写模块化代码，并将它们组合在一起成为小的 `package`，以优化加载时间。
- 一个 **编译器**，例如 [`Babel`](https://babeljs.io/)。它能让你编写的新版本 `JavaScript` 代码，在旧版浏览器中依然能够工作。

​		如果你倾向于从头开始打造你自己的 `JavaScript` 工具链，可以 [查看这个指南](https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658)，它重新创建了一些 `Create React App` 的功能。

​		别忘了确保你自定义的工具链 [针对生产环境进行了正确配置](https://zh-hans.reactjs.org/docs/optimizing-performance.html#use-the-production-build)。



### 使用

#### 构建

​		`React` 项目也可以使用 `Vite` 工具来构建，当然官方更推荐 `create-react-app` 工具。

##### 安装工具

​		使用 `npm i create-react-app -g` 指令，全局安装 `create-react-app` 工具包。

```shell
npm i create-react-app -g
```

##### 创建项目

​		使用 `npx create-react-app <project-name>` 指令，创建并命名一个 `React` 项目。

```shell
npx create-react-app my-project # 创建my-project项目
```

​		如果没有安装 `create-react-app` 工具包，那么初次创建项目时，将会询问是否安装它。此时，输入 `y` 确认即可全局安装。

##### 开始项目

​		项目创建之后，使用 `cd <project-name>` 指令切换至项目中。然后，使用 `npm start` 指令开启该项目的运行。

```shell
cd my-project
npm start
```

​		项目成功运行之后，会提供两个（`Local` 和 `Network`）服务地址。点击任何一个都可以在浏览器中浏览项目的热更新页面。

##### 打包项目

​		项目完成之后，使用 `npm run build` 指令对该项目进行打包。

```shell
npm run build
```



#### 目录

​		一个新的 `React` 项目，应有如下的目录结构。

```diff
|- demo
	|- node_modules
	|- public
		|- favicon.ico
		|- index.html
		|- logo192.png
		|- logo512.png
		|- manifest.json
		|- robots.txt
	|- src
		|- App.css
		|- App.js
		|- App.test.js
		|- index.css
		|- index.js
		|- logo.svg
		|- reportWebVitals.js
		|- setupTests.js
	|- .gitignore
	|- package-lock.json
	|- package.json
	|- README.md
```

​		各文件的描述如下：

- `node_modules`：项目依赖的第三方包或库。
- `public`：静态资源文件夹
- `src`：源码文件夹（主要的工作目录）
- `.gitignore`：`git` 配置文件
- `package-lock.json`：`node_modules` 中所有包的配置文件
- `package.json`：包配置文件或包记录文件
- `README.md`：项目的描述文件或使用说明书

##### 静态资源

​		在 `public` 目录中，有如下文件：

- `favicon.ico`：网站图标文件
- `index.html`：入口页面文件
- `logo192.png` 和 `logo512.png`：`logo` 图标文件（`png` 格式）
- `manifest.json`：移动端配置文件
- `robots.txt`：爬虫协议文件

​		在 `index.html` 文件中，会使用 `<link>` 标签引入上述部分文件。其中，会使用 `%PUBLIC_URL%` 来表示 `public` 目录的地址。

```html
<head>
    <meta charset="utf-8" />
    
    <!-- 引入 favicon.ico 文件 -->
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    
    <!-- 引入 logo192.png 文件 -->
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    
    <!-- 引入 manifest.json 文件 -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
</body>
```

##### 源码目录

​		在 `src` 目录中，有如下文件，以 `App` 为根组件：

- `App.css`：根组件的 `css` 样式文件（定义公共样式）
- `App.js`：根组件的 `js` 逻辑文件（它定义并导出了根组件）
- `App.test.js`：根组件的测试文件
- `index.css`：入口样式文件（定义初始样式）
- `index.js`：入口逻辑文件（项目启动文件）
- `logo.svg`：`logo` 图标文件（`svg` 格式）
- `reportWebVitals.js`：`Web` 页面性能分析文件
- `setupTests.js`：组件测试文件

​		在 `index.js` 文件中，会引入上述部分文件。

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
	<React.StrictMode>
    	<App />
  	</React.StrictMode>
);

// 如果你想开始在你的应用程序中测量性能，传递一个函数来记录结果，例如：reportWebVitals(console.log)。或者发送到分析端点。了解更多信息：https://bit.ly/CRA-vitals。
reportWebVitals();
```

​		在 `index.js` 文件中，使用了一个内置的 `<React.StrictMode>` 类组件。用于开启 `React` 的严格模式，以检查潜在的危险。

- 识别不安全的生命周期（比如旧版生命周期被淘汰的 `componentWillMount`）
- 使用过时字符串 `refAPI` 的警告
- 使用废弃的 `findDOMNode` 方法的警告
- 检测意外的副作用（除了函数副作用的三点还有改变参数值和调用 `setState`）
- 检测过时的 `context` `API`（比如 `childContextTypes`）

​		严格模式无法自动检测出具有副作用的代码。因此，在严格模式下（开发阶段），组件的生命周期会被调用两次，以此来明显化副作用代码。

> 注意：
>
> ​		在 `React17` 中，`React` 会自动修改 `console.log` 方法，在第二次调用生命周期函数时，将会静默输出。
> ​		在 `React18` 中，`React` 将不会抑制任何日志，如果你安装了 `devtools`，第二次输入将会被淡化，在 `devtools` 工具中可以屏蔽第二次输出。
> ​		还要注意一下，由于 `componentDidMount` 等函数会被放入执行队列，所以就算关闭了第二次输出，函数里面的打印在严格模式下还是会输出两次。

##### 目录别名

​		目录别名，就是给一个目录的地址设置一个别名。然后，可以在项目的任意文件路径中直接这个别名，去代替该目录的地址。例如：`src` 目录的别名为 `@`，那么 `@` 就代表了 `src` 目录。然后，可以在要使用 `src` 目录的路径中，使用 `@` 来代替输入 `src` 目录的地址。

```jsx
// 导入 src 中的 index.js 文件
import '@/index.js'
```

​		首先在 `node_modules` 目录中，找到 `'react-scripts/config/webpack.config.js'` 配置文件。然后在 `alias` 节点中，定义目录的别名即可。`alias` 节点是一个对象，键是目录的别名，其值是目录的绝对路径（可使用 `path` 对象的 `resolve` 等方法获取）。

```js
{
    alias: {
        "@": path.resolve('src')
    }
}
```

​		例如，在路径中使用 `@` 来引入 `src` 目录下 `'assets/imgs'` 中的图片资源 `'demo.png'`。

```jsx
import React from 'react'

function App() {
  	return (
    	<div className="App">
      		<img src={require('@/assets/imgs/demo.png')} />
    	</div>
  	);
}
```

​		注意：与 `Vue` 处理静态资源一样，必须将静态资源的 `url` 传给 `require()` 来请求。或者将静态资源导入 `js` 中进行打包处理。



#### 组件

​		在一个 `src` 目录中，通常由以下三种格式的文件组成。

- `.jsx`：组件文件（可使用 `rfc` 命令，快速生成组件模板）
- `.css`：样式文件
- `.js`：逻辑文件

​		由于 `jsx` 是 `js` 的扩展语法，所以 `.js` 文件也可以作为 `.jsx` 组件文件使用，如：`App.js`。但不推荐这么做。

```jsx
import logo from './logo.svg';
import './App.css';

function App() {
  	return (
    	<div className="App">
      		<header className="App-header">
        		<img src={logo} className="App-logo" alt="logo" />
        		<p>
          			Edit <code>src/App.js</code> and save to reload.
        		</p>
        		<a
          			className="App-link"
          			href="https://reactjs.org"
          			target="_blank"
          			rel="noopener noreferrer"
        		>
          			Learn React
        		</a>
      		</header>
    	</div>
  	);
}

export default App;
```

##### 组件规范

​		当自定义组件时，建议首先在 `src` 目录下建立一个 `components` 目录，来统一管理项目组件。

```diff
|- src
+	|- components
```

​		然后，自定义组件时，建议为每个组件建立一个文件夹，以存放其 `.jsx`、`.css` 和 `.js` 文件。例如，自定义一个 `<Home>` 组件。

```diff
|- src
	|- components
+		|- Home
+			|- Home.jsx
+			|- Home.css
+			|- Home.js
```

​		在 `Home` 文件夹中，通常会统一使用目录名称来命名 `.jsx`、`.css` 和 `.js` 文件。也可以统一命名为 `index`，以期望被自动索引。

​		快捷生成组件模板：在 `.jsx` 文件中，输入 `rfc` 命令，再按一下 `enter` 或 `tab` 键，即可快速生成该组件的模板。

​		接下来，需要将 `.jsx`、`.css` 和 `.js` 三个文件联系起来。在 `.jsx` 文件中，通过 `import` 引入 `.css` 和 `.js` 文件即可。

```jsx
// 在 Home.jsx 文件中
import React from 'react'
import "./Home.css"
import "./Home.js"

export default function Home() {
    return (
    	<div className="Home">
        	<h1>Home</h1>
        </div>
    );
}
```

​		由上可知，自定义组件以 `.jsx` 组件文件为中心，所有与组件相关的文件（`.css` 和 `.js` 等）都应该被导入其中。

##### 组件样式

​		上级组件定义的 `css` 样式可以直接作用于下级组件，因为下级组件会继承上级组件的样式。对于单页面应用来说，所有的组件最终都会被集成到 `index.html` 入口页面中。因此，下级组件一定可以继承上级组件的样式。这样一来，根组件的样式（`App.css`）便可以作为公共样式文件使用，`index.css` 则可作为全局的初始样式文件使用。

​		`React` 建议使用 `Sass` 语法来定义 `css` 样式。首先，使用 `npm i sass -D` 指令，安装 `sass` 工具。

```shell
npm i sass -D
```

​		`sass` 文件的后缀，可为 `.sass` 或 `.scss`。`sass` 与 `scss` 的写法略有不同。其中，`scss` 与 `less` 的写法基本一致。

​		`sass` 写法：选择器后不能书写 `{}`，样式代码不能以分号来结束。即：省略 `{}` 和 `;`，这在有些框架中容易导致报错。

```sass
.home 
	color: red
	.box
		color: green
		p 
			color: blue
```

​		`scss`：与 `less` 写法相似，选择器必须使用 `{}` 来闭合，样式代码应该以 `;` 结束。这种写法更贴近 `css`，也更规范。 

```scss
.home {
	color: red;
    .box {
		color: green;
        p {
			color: blue;
        }
    }
}
```

​		还有另一种定义组件样式的方式，是在组件的虚拟 `DOM` 中使用 `<style>` 元素来定义字符串格式的 `CSS` 代码。不过，当组件被渲染后，其 `<style>` 中的样式将默认成为页面级（全局）样式，而不是独属于某个组件的。若要如此，则应在定义组件虚拟 `DOM` 时，给根节点设置一个类名，然后在 `<style>` 中始终使用根节点类名来限制样式即可。例如：定义独属于 `<Home>` 组件的 `<style>` 样式。

```jsx
export default function Home() {
    return (
    	<div className="Home">
            <style>
            	{`
            		.Home h1 {
            			color: red;
            		}
            	`}
            </style>
        	<h1>Home组件</h1>
        </div>
    );
}
```



#### 订阅

​		在 `React` 项目中，要实现全局通信需要使用 `pubsub-js` 插件。它只有订阅（接收数据）和发布（发送数据）这两个功能。

​		`PubSubJS` 是一个用 `JavaScript` 编写的 **基于主题的发布/订阅** 库。

​		`PubSubJS` 具有同步解耦功能，因此主题是异步发布的。这有助于保持程序的可预测性，因为在使用者处理主题时不会阻止主题的创建者。对于喜欢冒险的人来说，`PubSubJS` 还支持同步主题发布。这可以在某些环境（浏览器，不是全部）中提供加速，但也可能导致一些非常难以推理的程序，其中一个主题会触发同一执行链中另一个主题的发布。

##### 安装插件

​		使用 `npm i pubsub-js` 指令，安装 `pubsub-js` 插件。`pubsub` 是 `publish` 和 `subscribe` 的合并缩写。

```shell
npm i pubsub-js
```

​		安装之后，分别在发布和订阅组件中导入该插件。

```jsx
import PubSub from "pubsub-js";
```

##### 发布主题

​		发布主题，使用 `PubSub.publish()` 方法，可以给它传递两个参数：主题的名称和主题的内容。

```jsx
// 发布主题，通常由一个事件来触发，如：点击事件。
PubSub.publish('MY TOPIC', '该主题的内容');
```

##### 订阅主题

​		发布主题之后，可使用 `PubSub.subscribe()` 方法来订阅主题。它接收两个参数：

- 主题名称：指定要订阅的主题的名称。在此，指定订阅哪个已发布的主题。
- 回调函数：回调函数可接收两个参数，表示：订阅到的主题名和主题内容。

```js
// 该回调函数用于接收主题，因此，也被称为订阅者。
PubSub.subscribe('MY TOPIC', (msg, data) => {
    console.log('主题名：' + msg, '主题内容：' + data);
});
```

##### 取消订阅

​		组件挂载后，可以订阅和发布主题；当组件销毁时，应该取消订阅。因为设置订阅属于需要被清除的副作用，容易造成内存泄露。

```jsx
// 类组件
class T extends React.Component {
    // 订阅主题
    componentDidMount() {
        this.token = PubSub.subscribe('MY TOPIC', (_, data) => {
            console.log('主题内容：' + data);
        });
    }
    // 取消订阅
    componentWillUnmount() {
		PubSub.unsubscribe(this.token);
    }
}

// 函数组件
function T() {
    useEffect(() => {
        // 订阅主题
        let token = PubSub.subscribe('MY TOPIC', (_, data) => {
            console.log('主题内容：' + data);
        });
        return () => {
            // 取消订阅
            PubSub.unsubscribe(token);
        };
    }, []);
}
```

​		取消订阅指定的主题：使用 `subscribe()` 订阅主题后，它会返回一个取消令牌。将这个取消令牌传给 `PubSub.unsubscribe()` 执行，即可从指定的主题中取消该订阅（取消订阅该主题）。

```jsx
// 取消令牌
let token = PubSub.subscribe('MY TOPIC', (msg, data) => {
    console.log(msg, data);
});

// 从该主题中取消订阅
PubSub.unsubscribe(token);
```

​		取消订阅者的所有订阅：使用 `subscribe()` 订阅主题时，需要传递一个订阅者函数来接收主题。将这个函数传给 `unsubscribe()` 执行，即可从所有主题中取消该订阅者（取消订阅者订阅的所有主题）。

```jsx
// 订阅者
let mySubscriber = (msg, data) => {
    console.log(msg, data);
};

PubSub.subscribe('MY TOPIC1', mySubscriber);
PubSub.subscribe('MY TOPIC2', mySubscriber);

// 从所有主题中取消订阅者
PubSub.unsubscribe(mySubscriber);
```

​		清除主题的所有订阅：如果给 `unsubscribe()` 传入一个主题，则可以清除对该主题的所有订阅。

```jsx
PubSub.subscribe('a', myFunc1);
PubSub.subscribe('a.b', myFunc2);
PubSub.subscribe('a.b.c', myFunc3);

PubSub.unsubscribe('a.b'); // 'a.b' 和 'a.b.c' 将不再发布任何通知，'a' 仍将发布通知。
```

​		清除所有订阅：调用 `PubSub.clearAllSubscriptions()`，将清除所有订阅。

```jsx
PubSub.clearAllSubscriptions(); // 删除所有订阅
```

​		获取订阅：给 `PubSub.getSubscriptions()` 传入一个主题名，即可通过该主题名从所有主题中获取订阅【存疑】。

```jsx
PubSub.getSubscriptions('token'); // subscriptions by token from all topics
```

​		订阅数量：给 `PubSub.countSubscriptions()` 传入一个主题名，即可通过该主题名从所有主题中计数订阅【存疑】。

```jsx
// 在subscribe之后调用，才会有一次计数。
PubSub.countSubscriptions('token'); // count by token from all topics
```

​		更多参考：[`pubsub-js`](https://www.npmjs.com/package/pubsub-js?activeTab=readme) 



#### 代理

​		设置代理，以解决前端的跨域请求问题。其原理是，通过脚手架创建的服务器代理前端请求，向目标服务器发起请求。其本质是，让前端直接向代理服务器发起请求（而不是拦截前端请求）。接着代理服务器会根据前端的请求地址（经过配置后）生成代理的目标地址，然后向代理目标地址发起请求。

```jsx
function App() {
    // 使用axios向后端地址'http://localhost:5000/api/getUserInfo'发起请求
    axios.get('http://localhost:5000/api/getUserInfo')
    .then((res) => {
        console.log(res);
    }).catch((err) => {
        console.log(err);
    });
}
```

​		前端发起的请求，被脚手架提供的服务器代理，由该服务器向目标服务器发起请求。代理服务器允许前端跨域访问，然后服务器之间不存在跨域问题。因此，解决了前端向目标服务器跨域请求的问题。（即：前端 ⇌ 代理 ⇌ 后端）。

##### 代理模块

​		建议将处理代理的逻辑抽离出来，单独地作为一个功能模块使用。在 `src` 下创建 `setupProxy.js` 文件，作为代理功能模块。

```diff
|- src
+	|- setupProxy.js
```

​		注意，代理模块必须命名为 `setupProxy`。不需要将它手动引入到任何地方，插件会自动引用它。

##### 代理插件

​		接下来，使用 `npm i http-proxy-middleware -D` 指令，下载 `http-proxy-middleware` 插件。

```shell
npm i http-proxy-middleware -D
```

##### 配置代理

​		然后，在代理模块 `setupProxy.js` 文件中，对脚手架服务器（`node` 环境）进行代理设置。

​		先从 `'http-proxy-middleware'` 插件中，取出 `createProxyMiddleware` 方法。然后使用 `module.exports` 导出一个处理函数。该函数将接收到一个参数，`react` 的应用实例。在该参数上使用 `use` 方法向框架中嵌入代理请求的中间件。

​		使用 `createProxyMiddleware` 创建中间件，接收两个参数：

1. 代理路由：代理的前端请求的路由。前端直接使用代理路由或其子路由，便可向代理服务器发起请求。
2. 代理配置：对代理路由的配置对象。
   1. `target`：代理请求的目标服务器。代理服务器会结合前端请求的路由与 `target` 生成目标服务地址，并向其发起请求。
   2. `changeOrigin`：是否替换代理请求地址中的 `origin` 为 `target`。 允许后，将使用 `target` 替换代理请求的 `origin`。
   3. `pathRewrite`：对代理路由进行重写。有时，前端发起请求的路由与后端监听的路由会不一致，这个时候需要重写路由。
   4. `router`：根据前端请求重新设定目标服务器的主机（即 `target` 属性）。这样可根据不同的请求，设定多个目标服务器。
   5. `ws`：设置是否代理 `websockets`。

```js
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
    app.use(
    	createProxyMiddleware(
        	"/api", // 要代理的前端请求路由
            // 代理该路由时的配置
            {
                target: "http://localhost:5000", // 目标服务器（将请求代理到该服务器）
                changeOrigin: true, 			 // 是否修改请求中的origin为target。
                // 路由重写（为了与后端路由成功匹配）
                pathRewrite: {
                    "^/api": "" // 将请求路由中的开头/api片段重写为空，即：删除该片段。
                }
            }
        )
    );
}
```

​		前端发起请求：前端向脚手架的代理服务器发起请求时，可直接使用要代理的路由或其子路由，而不必是完整的代理服务地址。

```jsx
function App() {
    // 使用axios向代理服务器发起请求。
    // 若代理服务器为：http://localhost:3000，则完整的前端请求地址为：http://localhost:3000/api/getUserInfo。
    axios.get('/api/getUserInfo') 
         .then((res) => {
            console.log(res);
         })
         .catch((err) => {
            console.log(err);
         });
}
```

​		代理发起请求：代理服务器监听到前端发起的代理请求后，根据代理配置生成目标请求地址，然后向目标地址发起请求。

```txt
代理服务器发起请求：
	1、代理服务器使用自身主机地址与代理路由拼接成完整的前端请求地址。如：http://localhost:3000/api/getUserInfo。
	2、然后将前端请求地址中的origin替换为target得到本次代理的目标地址。如：http://localhost:5000/getUserInfo。
	3、代理服务器向目标地址http://localhost:5000/getUserInfo发起请求。
概括：代理服务器监听到http://localhost:3000/api/getUserInfo后向目标http://localhost:5000/getUserInfo发起请求。
```

​		后端监听请求：后端监听到来自代理服务器发起的代理请求之后，会根据请求将所需的内容传递给代理服务器。

```js
app.get('/getUserInfo', (req, res) => {
    console.log(req.headers.referer); // 请求源
    res.send({
        code: 0,
        data: '后端回复请求的数据'
    });
})
```

​		代理回复前端：代理服务器通过代理前端请求，向目标服务器获得请求所需数据后，将获得的内容回复给前端。

##### 代理路由

​		`createProxyMiddleware` 的第一个参数，用于设置（或匹配）要代理的路由，匹配代理路由时有如下写法：

- 省略不写：表示该中间件可匹配任何路由，所有请求将被代理后转发；
- 单个路由：表示该中间件只匹配指定路由，只有指定的请求会被转发；
  - `'/'`：如果设置为根路由，则可以匹配任何路由。
  - 其他：如果设置为具体的路由，则只匹配该路由。
- 多个路由：提供一个含多个路由的数组，表示匹配其中任何一个即可；
- 自定规则：提供一个函数，可以自定义匹配规则，要返回一个布尔值；
  - 可接收两个参数：`pathname`（请求路由）和 `req`（请求对象）。
  - 必须返回一个布尔值，以反映该路由的匹配结果（成功或失败）。
- 用通配符：在路由字符串中可使用通配符，来进行更细粒的路由匹配；
  - `'**'`：匹配任何路由，所有请求都将被转发；
  - `'**/*.html'`：匹配任何以 `.html` 结尾的路由；
  - `'/*.html')`：匹配当前路由下以 `.html` 结尾的路由；
  - `'/api/**/*.html'`：匹配 `/api` 路由下以 `.html` 为结尾的路由；
  - `['/api/**', '/ajax/**']`：以数组的形式，提供多个路由选项；
  - `['/api/**', '!**/bad.json']`：在数组中，可使用 `!` 排除路由；此处表示不包括 `**/bad.json`；

##### 重写路由

​		在代理路由的配置对象中，可使用 `pathRewrite` 来重写代理路由。其中，键用于匹配代理路由，值是重写后的路由。

```js
// 重写
pathRewrite: {'^/old/api' : '/new/api'} // 将'^/old/api'重写为'/new/api'

// 移除
pathRewrite: {'^/remove/api' : ''} // 将'^/old/api'重写为''，表示移除

// 添加
pathRewrite: {'^/' : '/basepath/'} // 将'^/'重写为'/basepath/'，表示新增

// 自定义
pathRewrite: function (path, req) { return path.replace('/api', '/base/api') }
```

​		注意，自定义函数接收两个参数，依次是请求路由和请求对象。它必须返回一个新的路由字符串。

##### 重写目标

​		在代理路由的配置对象中，可使用 `router` 来重写代理目标。其中，键用于匹配代理路由或主机，值是重写后的目标。

```js
// 使用请求的主机或者路由进行匹配，返回最先匹配到结果（所以配置的顺序很重要）
router: {
    'integration.localhost:3000' : 'http://localhost:8001',  // host only
	'staging.localhost:3000'     : 'http://localhost:8002',  // host only
	'localhost:3000/api'         : 'http://localhost:8003',  // host + path
 	'/rest'                      : 'http://localhost:8004'   // path only
}

// 自定义
router: function(req) {
    return 'http://localhost:8004';
}
```

##### 代理事件

​		在代理路由的配置对象中，还可以使用一些监听代理请求的事件。

- `option.onError`：发出错误事件。框架不对客户端和代理之间传递的消息以及代理和目标之间传递的消息进行任何错误处理，需要手动监听错误并进行处理。

```js
function (err, req, res) {
   	res.writeHead(500, {
		'Content-Type': 'text/plain'
   	});    
    res.end('Something went wrong. And we are reporting a custom error message.');
});
```

- `option.onProxyRes`：如果对目标的请求得到响应，则发出此事件。

```js
function (proxyRes, req, res) {
	console.log('RAW Response from the target', JSON.stringify(proxyRes.headers, true, 2));
});
```

- `option.onProxyReq`：在发送数据之前发出此事件。它使您有机会更改 `proxyReq` 请求对象。

```js
function onProxyReq(proxyReq, req, res) {
	proxyReq.setHeader('x-added', 'foobar');
});
```

- `option.onProxyReqWs`：在发送数据之前发出此事件。它使您有机会更改 `proxyReq` 请求对象。适用于 `"websocket"` 连接。

```js
function onProxyReqWs(proxyReq, req, socket, options, head) {
	proxyReq.setHeader('X-Special-Proxy-Header', 'foobar');
}
```

- `option.onOpen`：创建代理 `Websocket` 并将其通过管道传输到目标 `Websocket` 后（开启代理 `webscoket` 后），将发出此事件。

```js
function (proxySocket) {
	proxySocket.on('data', hybiParseAndLogMessage);
});
```

- `option.onClose`：关闭代理 `websocket` 后，将发出此事件。

```js
function (res, socket, head) {
	console.log('Client disconnected');
});
```

##### 多个代理

​		配置多个代理路由：可以给 `use()` 方法同时传入多个参数，以嵌入多个代理请求的中间件。或多次调用 `use`。

```js
// 第一种方式：
module.exports = function(app) {
    app.use(
    	createProxyMiddleware(
        	"/hot",
            {
                target: "http://localhost:5000",
                changeOrigin: true,
                pathRewrite: {
                    "^/hot": ""
                }
            }
        ),
        createProxyMiddleware(
        	"/user",
            {
                target: "http://localhost:5000",
                changeOrigin: true,
                pathRewrite: {
                    "^/user": ""
                }
            }
        )
    );
}
```

```js
// 第二种方式：
module.exports = function(app) {
    app.use(createProxyMiddleware(
        "/hot",
        {
            target: "http://localhost:5000",
            changeOrigin: true,
            pathRewrite: {
                "^/hot": ""
            }
        }
    ));
    
    app.use(createProxyMiddleware(
        "/user",
        {
            target: "http://localhost:5000",
            changeOrigin: true,
            pathRewrite: {
                "^/user": ""
            }
        }
    ));
}
```

​		更多参考：[`http-proxy-middleware` 使用方法和实现原理（源码解读）](https://www.shuzhiduo.com/A/D85401X65E/) 

