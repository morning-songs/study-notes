# 组合模式

组合模式（`Composite Pattern`），又叫部分整体模式，用于把一组相似的对象组合成一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

组合模式：使用户操作单个对象（合成对象）和操作多个对象（简单对象）的方式具有一致性。任何具有树形结构的对象组，都可以采用组合模式来进行设计。



### 介绍

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：**

- 您想表示对象的部分-整体层次结构（树形结构）。
- 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 `List`，里面放 `Component`。

**应用实例：** 

- 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。
- 在 `JAVA AWT` 和 `SWING` 中，对于 `Button` 和 `Checkbox` 是树叶，`Container` 是树枝。

**优点：** 

- 高层模块调用简单。
- 节点自由增加。

**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。

**使用场景：**部分 - 整体场景，如树形菜单，文件 - 文件夹的管理。

**注意事项：**定义时为具体类。



### 实现

```html
<div id="test">
    test
    <div class="text">text1</div>
    <div class="text">text2</div>
    <div class="text">text3</div>
</div>
```

原先操作不同的 `DOM` 需要采用不同的方法。

```js
document.querySelector("#test").style.color = "red";

let oText = document.querySelectorAll(".text");
for(let i = 0, len = oText.length; i < len; i++) {
    oText[i].style.color = "blue";
}
```

`JQuery` 内部实现了组合模式，使得操作 `DOM` 的方式具有一致性，使用起来非常简便。

```js
$("#test").css("color", "red");
$(".text").css("color", "blue");
```

##### 简单实现

首先，定义一个 `$` 方法，它创建了一个处理自己对象组的类，并返回类实例。该类提供了修改相同对象组的方式。

```js
function $(selector) {
    class Init {
		// ...
    }
    return new Init();
}
```

然后，定义 `Init` 类。它的构造器将选取到的节点统一复制到其实例身上，这样做的好处是，这些节点可以调用 `Init` 类的方法。

```js
function $(selector) {
    class Init {
		constructor(selector) {
            const nodeList = document.querySelectorAll(selector);
			return Object.assign(this, nodeList, {length: nodeList.length});
        }
    }
    return new Init(selector);
}
```

接着，为 `Init` 实例定义原型方法，以提供给节点使用。令每个原型方法都会返回 `Init` 实例，从而实现链式调用。

```js
class Init {
    constructor(selector) {
        const nodeList = document.querySelectorAll(selector);
        return Object.assign(this, nodeList, {length: nodeList.length});
    }
    each(fn) {
        // 将每个节点指定为回调函数的this，以方便各方法操作节点。
        for(let i = 0, len = this.length; i< len; i++) {
            fn.call(this[i]);
        }
    }
    css(attr, value) {
        this.each(function() {
            this.style[attr] = value;
        });
        return this;
    }
    addClass(className) {
        this.each(function() {
            this.classList.add(className);
        });
        return this;
    }
}
```

最后，将它们整合到一起，就可以像使用 `Jquery` 一样使用 `$` 方法了。

```js
function $(selector) {
    class Init {
        constructor(selector) {
            const nodeList = document.querySelectorAll(selector);
            return Object.assign(this, nodeList, { length: nodeList.length });
        }
        each(fn) {
            for (let i = 0, len = this.length; i < len; i++) {
                fn.call(this[i]);
            }
        }
        css(attr, value) {
            this.each(function () {
                this.style[attr] = value;
            });
            return this;
        }
        addClass(className) {
            this.each(function () {
                this.classList.add(className);
            });
            return this;
        }
        // ...
    }
    return new Init(selector);
}
```

```js
$("#test").css("color", "red").addClass("wanzi");
$(".text").css("color", "blue").addClass("cherry");
```

##### 组合订单

例如，用户可能需要创建一个或多个不同类型的订单。

```js
class Order1 {
    create() {
        console.log("Order1");
    }
}

class Order2 {
    create() {
        console.log("Order2");
    }
}

// ...
```

定义一个统一创建的类。

```js
class Orders {
    constructor() {
        this.orderList = []; // 订单列表
    }
    add(order) {
        this.orderList.push(order); // 添加订单
    }
    create() {
        for(let i = 0, len = this.orderList.length; i < len; i++) {
            this.orderList[i].create(); // 创建所有订单
        }
    }
}
```

然后，用户可以选择单独结算或统一结算。

```js
let order1 = new Order1();
let order2 = new Order2();
let orders = new Orders();

// 单独创建
order1.create();

// 统一创建
orders.add(order1);
orders.add(order2);
orders.create();
```

无论单独创建还是统一创建，都使用相同的 `create()` 接口。

