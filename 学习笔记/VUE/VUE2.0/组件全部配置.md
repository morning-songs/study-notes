# 组件全配置

### `name`组件名称

`name`属性为组件指定一个名称（大驼峰式或全小写短线连接式）

注释：

- 组件在全局用 `Vue.component()` 注册时，全局 `ID` （第一参数）自动作为组件的 `name`使用。

- 指定 `name` 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。
- 在`vue-devtools`插件中，未命名组件将显示成 `<AnonymousComponent>`，这很没有语义。
- 因此，通过提供 `name` 选项，可以获得更有语义信息的组件树。

```js
new Vue({
    name: "App"
})

Vue.component("my-div", {});
```

<hr>

### `el`挂载入口元素

`el`属性将一个已存在于页面上的`DOM`元素作为该`vue`实例的挂载目标，可以是`css`选择器，也可以是一个`HTMLElement`实例。

注释：

- 如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 `vm.$mount()` 手动开启编译。
- 如果 `render` 函数和 `template` 选项都不存在，挂载 `DOM` 元素的 `HTML`内容会被提取出来用作模板被解析渲染。
- 在实例挂载之后，可以通过 `vm.$el` 访问挂载的入口元素。

```js
new Vue({
    el: "#app", // css选择器，选择id为app的元素
})

new Vue({
    el: document.createElement("div"), // 直接使用元素实例，但该元素必须提前插入到页面中，否则el无效。
})
```

<hr>

### `mixins`混入 / 共用配置对象

`mixins`属性用于将一个外部的复用性高的配置对象，混入到组件中作配置对象使用。

注释：

- 当多个组件的配置对象具有相同的配置时，可以提取出来作为共用配置对象使用。
- `mixins`值为数组，可接收多个配置对象，最终按照顺序被合并到组件配置对象中。
- 选项合并：同名的钩子函数合并为一个数组，同名的对象型配置项合并为一个对象。
- 冲突的部分以组件自身的配置为主，`mixin`生命钩子按序执行且早于组件自身的钩子。

```js
let mixin1 = {
    data() {return {};},
    created() {}
}

new Vue({
    mixins: [mixin1]
})
```

<hr>

### `data`组件数据源

组件可能被用来创建多个实例，因此：

- 当`data`的值是一个对象时，该组件创建的所有实例将共享引用该对象；

- 当`data`作为函数返回一个对象时，每次创建的组件实例将独享该对象。

注释：当`data`作为`vue`实例的数据对象使用时：

- `Vue` 会递归地把 `data` 的 `property` 转换为 `getter/setter`，从而让 `data` 的 `property` 能够响应数据变化。
- 由于`data` 原型上的 `property` 会被忽略，因此，`data`只能用来存数据，而不能用来存方法。
- `vue`实例创建之后，可以通过 `vm.$data` 访问原始数据对象。一旦创建，无法再添加响应式的根属性。
- `Vue` 实例代理了 `data` 对象上所有的 `property`，因此访问 `vm.a` 等价于访问 `vm.$data.a`。
- 以 `_` 或 `$` 开头的 `property` **不会**被 `Vue` 实例代理，以避免和 `Vue` 内置的属性或方法冲突。

```js
// vue实例中的data
const vm = new Vue({
    data: {}
})

// 组件实例中的data
Vue.component("my-component", {
    data() {
        return {} // 每次创建该组件时，该组件的各个实例独享该数据对象，而不是共用一个。
    }
})
```

<hr>

### `methods`组件方法集

事件处理器`methods`中的方法，会被直接挂载到`vue`实例上，普通方法中的`this`自动指向`vue`实例。

注释：

- 由于箭头函数绑定父级作用域的上下文，因此，不要使用箭头函数来定义`methods`根方法。
- `methods`根方法内部的子函数使用箭头函数来定义，因为普通子函数的`this`指向`window`。

```js
const vm = new VUe({
    data: {
        age: 18
    },
    methods: {
        ageAdd() {
            this.age++;
            console.log(this); // vm
            // 普通子函数
            function child1() {
                console.log(this); // window
            }
            // 箭头子函数
            let child2 = () {
                console.log(this); // vm
            }
        },
        ageReduce: () => {
        	console.log(this); // undefined
    	}
        // 使用箭头函数
        newAge: vm => {
        	vm.age = 20;
        	console.log(vm); // vm
    	}
	}
})
```

<hr>

### `computed`计算属性

计算属性将被混入到 `Vue` 实例中。所有 `getter` 和 `setter` 的 `this` 上下文自动地绑定为 `Vue` 实例。

注释：

- 计算属性必须通过`return`决定最终返回的结果，当作`data`中的数据一样使用即可。
- 计算属性的结果会被缓存，只有依赖的响应式数据发生了变化才会重新计算。【响应式数据：`vue`实例上的根数据】
- 初次计算：在`vue2`中，不使用脚手架开发时会自动触发初次计算，使用脚手架开发后只有在初次使用时才触发计算。

```js
const vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        // v不是响应式依赖，this.a才是
        this.a = v - 1
      }
    }
  }
})

vm.aPlus   // get获取：2
vm.aPlus = 3 // set设值：v = 3；a = 2
vm.a       // 2
vm.aDouble // get获取：4
```

<hr>

### `template`组件模板结构

`template`属性，既可以用来直接定义组件的模板结构，也可使用以`#`开头的选择器匹配渲染指定元素的`innerHTML`内容。

注释：

- `template`的值最终将会替换页面上的组件标签（挂载元素），挂载元素的内容如不通过插槽分发，将被完全忽略。
- 选择器：通常使用`<script type="text/x-template" id="">`元素来定义模板内容，必须且只能存在一个根元素。
- 如果在`vue`的配置中定义了`render`选项，则会执行渲染函数，而`template`选项将被忽略。

```vue
<div id="app">
    <my-component>组件标签，也称为“挂载元素”。元素内容在被替换时如不被插槽分发，将被忽略。</my-component>
</div>

<!-- 通常使用script元素来定义模板内容：必须且只能存在一个根元素 -->
<script type="text/x-template" id="a">
	<div>组件</div>
</script>

<script>
    // 直接定义HTML内容
	Vue.component("my-component", {
        template: `
        	<div>模板结构，只能存在一个根元素，用于替换挂载元素及其内容
    			<slot></slot> <!--使用插槽接收挂载元素的内容。-->
    		</div>
        `
    })
    // 选择渲染指定的元素
    Vue.component("my-component", {
        template: "#a"
    })
    
    const vm = new Vue({
    	el: "#app"
    })
</script>
```

<hr>

### `render`渲染函数

`Vue` 推荐在绝大多数情况下使用模板来创建 `HTML`。

然而在一些场景中，需要展现 `JavaScript` 的完全编程的能力。此时可以用**渲染函数**，它比模板更接近编译器。

注释：`render`函数的首位参数是一个`createElement`方法（别名`h`），该方法在执行后必须通过`return`返回。

提示：将 `h` 作为 `createElement` 的别名是 `Vue` 生态系统中的一个通用惯例，实际上是 `JSX` 所要求的。

案例：通过参数选择不同的标题元素

```vue
<div id="app">
    <anchored-heading :level="1">Hello world!</anchored-heading>
</div>

<!-- 通过template定义 -->
<script type="text/x-template" id="anchored-heading-template">
	<h1 v-if="level === 1">
		<slot></slot>
	</h1>
	<h2 v-else-if="level === 2">
		<slot></slot>
	</h2>
	<h3 v-else-if="level === 3">
		<slot></slot>
	</h3>
	<h4 v-else-if="level === 4">
		<slot></slot>
	</h4>
	<h5 v-else-if="level === 5">
    	<slot></slot>
	</h5>
	<h6 v-else-if="level === 6">
    	<slot></slot>
	</h6>
</script>

<script>
    // 通过template定义
	Vue.component('anchored-heading', {
		template: '#anchored-heading-template',
		props: {
			level: {
				type: Number,
				required: true
			}
  		}
	})
    
    // 使用渲染函数
    Vue.component('anchored-heading', {
 		render: function (createElement) {
			return createElement(
				'h' + this.level,   // 标签名称
				this.$slots.default // 子节点数组（默认插槽）
			)
		},
		props: {
    		level: {
				type: Number,
				required: true
    		}
		}
	})
    
    const vm = new Vue({
        el: "app"
    })
</script>
```

##### `createElement`参数

该方法用于创建一个虚拟元素节点（`VNode`）及其相关内容，具有三个参数。

- 一：虚拟元素节点，可以是元素名、组件配置对象或者回调函数，必选。
- 二：元素属性对象，元素的属性对象（一个与模板中`attribute`对应的数据对象），可选。
- 三：子级虚拟节点，可以是字符串（文本虚拟节点）或数组（由`createElement`创建的虚拟节点数组），可选。

```js
let MyComponent = {
    data() {
        return {}
    },
    template: ""
};

render (createElement) {
	return createElement("div", // 虚拟元素节点
	// 元素属性对象
	{
		class: { // 元素类名：字符串、数组或对象
			for: true
		},
		style: { // 行间样式：字符串、数组或对象
			width: "100px"
		},
		attrs: { // 普通属性：HTML原生属性
			id: "1"
		},
        on: { // 绑定事件：事件监听器在'on'内
            click: this.clickHandler
        },
        nativeOn: { // 原生事件：onclick等
            click: this.nativeClickHandler
        },
        directives: [ // 自定义指令
            {
				name: 'my-custom-directive',
                value: '2',
                expression: '1 + 1',
                arg: 'foo',
                modifiers: {
                	bar: true
                }
            }
		],
        scopedSlots: { // 作用域插槽，格式：{ name: props => VNode | Array<VNode> }
			default: props => createElement('span', props.text), // 默认插槽
		},
        key: "", // key元素标识属性
        ref: "", // ref元素绑定属性
	}, 
	// 虚拟节点数组
    [
    	'先写一些文字', // 文本虚拟节点
		createElement('h1', '一则头条'), // 元素虚拟节点
		createElement(MyComponent, { // MyComponent是一个组件的配置对象
			props: {
				someProp: 'foobar'
            }
		})
	])
},
```

##### 虚拟节点唯一性

- 组件树中的所有 `VNode` 必须是唯一的，因此，重复创建相同的元素及内容会报错。
- 若需要重复创建相同的元素节点，可通过调用`Array`工厂函数来实现。

```js
// 在div元素中重复创建20个p段落，内容为：hi
render: function (createElement) {
	return createElement('div',
		Array.apply(null, { length: 20 }).map(function () {
			return createElement('p', 'hi')
		})
	)
}

/*	Array.apply(null, { length: 20 }) 与 new Array(20) 的区别
		Array.apply(null, { length: 20 })：用于立即创建20个元素，值为undefined
		new Array(20)：用于创建一个长度为20的空数组，值为empty，且元素并未真正地诞生
*/
```

##### `JSX`语法

安装 `Babel` 插件，用于在 `Vue` 中使用 `JSX` 语法，它可以让我们回到更接近于模板的语法上。

注释：

- 从 `Vue` 的 `Babel` 插件的 3.4.0 版本开始，`vue`会在以 `ES6` 语法声明的含有 `JSX` 的任何方法和 `getter` 中 (不是函数或箭头函数中) 自动注入 `const h = this.$createElement`，这样就可以去掉 `(h)` 参数了。

```js
import AnchoredHeading from './AnchoredHeading.vue'

new Vue({
	el: '#demo',
	render: function () {
		return (
            // 在JSX语法中，可以直接使用元素及模板标签，而无需调用createElement创建
			<AnchoredHeading level={1}>
			<span>Hello</span> world!
			</AnchoredHeading>
    	)
	}
})

// 使用JSX语法
// 创建虚拟的input:email元素
render() {
	return <input type="email" />
}
// 属性解构
render() {
	const inputAttrs = {
		type: 'email',
		placeholder: 'Enter your email'
	}

	return <input {...{ attrs: inputAttrs }} />
}
// 具名插槽
render() {
	return (
		<MyComponent>
			<header slot="header">header</header>
			<footer slot="footer">footer</footer>
    	</MyComponent>
	)
}
// 作用域插槽    
render() {
	const scopedSlots = {
    	header: () => <header>header</header>,
    	footer: () => <footer>footer</footer>
	}

	return <MyComponent scopedSlots={scopedSlots} />
}
// 自定义指令
render() {
    return <input vModel={this.newTodoText} />
}    
```

<hr>

### `components`注册子组件



### `props`接收组件标签传值



### `provide / inject`跨组件传值



### `inheritAttrs`禁止继承属性



### `model`配置v-model指令



### `watch`侦听器



### `filters`过滤器



### `directives`自定义指令



### `parent`父组件实例



### `extends`扩展 / 创建独立组件



### `functional`函数式组件



### `comments`渲染注释节点

