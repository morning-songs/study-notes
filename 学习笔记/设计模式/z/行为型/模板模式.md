# 模板模式

在模板模式（`Template Pattern`）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

模板模式：抽象父类，实现具体的子类。



### 介绍

**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。

**何时使用：**有一些通用的方法。

**如何解决：**将这些通用算法抽象出来。

**关键代码：**在抽象类实现，其他步骤在子类实现。

**应用实例：** 

- 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。
- 西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。
- `spring` 中对 `Hibernate` 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 `Session`、关闭 `Session` 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。

**优点：** 

- 封装不变部分，扩展可变部分。
- 提取公共代码，便于维护。
- 行为由父类控制，子类实现。

**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

**使用场景：** 

- 有多个子类共有的方法，且逻辑相同。
- 重要的、复杂的方法，可以考虑作为模板方法。

**注意事项：**为防止恶意操作，一般模板方法都加上 `final` 关键词。



### 实现

#### 轮播实现

##### 一般实现

例如，实现一个轮播图。

```html
<div class="banner">
    <div class="img">
        <ul>
            <li class="on"><img src="./images/1.webp"></li>
            <li><img src="./images/2.webp"></li>
            <li><img src="./images/3.webp"></li>
            <li><img src="./images/4.webp"></li>
            <li><img src="./images/5.webp"></li>
        </ul>
    </div>
    <div class="tab">
        <ul>
            <li class="on">1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
            <li>5</li>
        </ul>
    </div>
</div>

<style>
    * {
        margin: 0;
        padding: 0;
    }    
    ul, ol {
        list-style: none;
        padding-left: 0;
    }
    .banner {
        position: relative;
        width: 820px;
        height: 380px;
        margin: 50px auto;
        user-select: none;
    }
    .banner ul li {
        list-style: none;
    }
    .banner .img {
        position: relative;
        width: 100%;
        height: 340px;
    }
    .banner .img ul li {
        position: absolute;
        display: none;
        top: 0;
        left: 0;
    }
    .banner .img ul li.on {
        display: block;
    }
    .banner .img ul li img {
        display: block;
        width: 820px;
        height: 340px;
    }
    .banner .tab {
        width: 100%;
        height: 40px;
    }
    .banner .tab ul {
        display: flex;
    }
    .banner .tab ul li {
        flex: 1;
        line-height: 40px;
        text-align: center;
        background-color: #000;
        color: #eee;
        font-size: 12px;
        cursor: pointer;
    }
    .banner .tab ul li.on {
        background-color: #303030;
        color: #e9c06c;
    }
</style>
```

实现轮播图的一般逻辑如下

```js
let imgLi = document.querySelectorAll(".banner .img li"),
    tabLi = document.querySelectorAll(".banner .tab li"),
    currentIndex = 0;

tabLi.forEach((item, index) => {
    item.onclick = () => {
        // 清除上一项（点击前的当前项）
        imgLi[currentIndex].classList.remove("on");
        tabLi[currentIndex].classList.remove("on");
        // 更新当前项（点击后的当前项）
        currentIndex = index;
        imgLi[currentIndex].classList.add("on");
        tabLi[currentIndex].classList.add("on");
    }
})
```

通常，轮播图不止拥有基础选项卡，可能还会有淡入淡出的效果、前进后退按钮、水平滑动、`3D` 特效等功能。这些功能应该是在基础选项卡上可插拔的特性，而这可以通过模板模式来实现。

##### 模板模式

首先，定义一个抽象类（即：基础选项卡）。

```js
class Tab {
	constructor(imgList, tabList) {
        this.imgList = imgList;
        this.tabList = tabList;
        this.currentIndex = 0;
    }
    // 绑定事件
    addEvent() {
        this.tabList.forEach((item, i) => {
            item.addEventListener('click', () => {
                this.changeClassName(i);
            });
        });
    }
    // 修改类名
    changeClassName(i) {
        let currentIndex = this.currentIndex;
        this.imgList[currentIndex].classList.remove("on");
        this.tabList[currentIndex].classList.remove("on");
        currentIndex = this.currentIndex = i;
        this.imgList[currentIndex].classList.add("on");
        this.tabList[currentIndex].classList.add("on");
    }
	// 启动方法
	start() {
        this.addEvent();
    }
}

// 通过start启动
new Tab(
	document.querySelectorAll(".banner .img li"),
    document.querySelectorAll(".banner .tab li")
).start();
```

然后，可以在上面拓展功能。例如，增加淡入淡出的效果和前进后退的按钮。淡入淡出使用 `css` 实现即可，增设前进后退的按钮就必须增加一点结构。

```html
<style>
    /* 增加以下样式 */
    .banner .img ul li {
        display: block;
        opacity: 0;
        transition: opacity 0.5s;
    }
    .banner .img ul li.on {
        opacity: 1;
    }
    .banner .btn .arrow {
        position: absolute;
        top: 50%;
        margin-top: -30px;
        width: 30px;
        height: 60px;
        background-color: #000;
        color: #fff;
        font-weight: bold;
        line-height: 60px;
        text-align: center;
        cursor: pointer;
        font-size: 12px;   
    }
    .banner .btn .prev {
        left: 0;
    }
    .banner .btn .next {
        right: 0;
    }
</style>

<div class="banner">
    <div class="img">
        <ul>
            <li class="on"><img src="./images/1.webp"></li>
            <li><img src="./images/2.webp"></li>
            <li><img src="./images/3.webp"></li>
            <li><img src="./images/4.webp"></li>
            <li><img src="./images/5.webp"></li>
        </ul>
    </div>
    <div class="tab">
        <ul>
            <li class="on">1</li>
            <li>2</li>
            <li>3</li>
            <li>4</li>
            <li>5</li>
        </ul>
    </div>
    <div class="btn">
        <div class="arrow prev">&lt;</div>
        <div class="arrow next">&gt;</div>
    </div>
</div>
```

然后，定义一个新的类继承 `Tab` 类，以拓展前进后退的功能。

```js
class TabWithBtn extends Tab {
    constructor(imgList, tabList, btnList) {
        super(imgList, tabList);
        this.btnList = btnList;
        this.tabLen = tabList.length;
    }
    // 绑定事件
    addEvent() {
        // 用父类方法绑定事件
        super.addEvent(); // 手动启动父类（因为this指向问题，无法自动触发父类的addEvent方法，所以需要手动启动）
        // 给子类元素绑定事件
        this.btnList.forEach((item, index) => {
            item.addEventListener('click', () => {
                let tabLen = this.tabLen,
                    currentIndex = this.currentIndex;
                currentIndex = index ? (currentIndex + 1) % tabLen : (currentIndex - 1 + tabLen) % tabLen;
                this.changeClassName(currentIndex);
            })
        })
    }
}

new TabWithBtn(
	document.querySelectorAll(".banner .img li"),
    document.querySelectorAll(".banner .tab li"),
    document.querySelectorAll(".banner .btn .arrow"),
).start();
```

如果还要增加一个自动轮播的功能，则继续继承 `TabWithBtn` 即可。

```js
class TabWithBtnAuto extends TabWithBtn {
    constructor(imgList, tabList, btnList) {
        super(imgList, tabList, btnList);
    }
    // 重写启动方法（父类启动方法，在此已不适用）
    start() {
        super.start(); // 手动启动父类
        this.auto();
    }
    auto() {
        const tabLen = this.tabLen;
        setInterval(() => {
            let index = (this.currentIndex + 1) % tabLen;
            this.changeClassName(index);
        }, 1000);
    }
}

new TabWithBtnAuto(
	document.querySelectorAll(".banner .img li"),
    document.querySelectorAll(".banner .tab li"),
    document.querySelectorAll(".banner .btn .arrow"),
).start();
```

