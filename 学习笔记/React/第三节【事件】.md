# 事件

​		`React` 为解决原生事件的兼容性问题，自定义了对应的合成事件。这些合成事件只能用在虚拟 `DOM` 的事件属性上。为了应用它们，又将虚拟 `DOM` 的事件属性进行了重新命名，统一采用小驼峰式命名。同时，也解决了事件对象的兼容性问题。

```jsx
function clickFn(e) {
    console.log(e); // SyntheticBaseEvent {_reactName: 'onClick', _targetInst: null, type: 'click', ...}
}

let vnode = (
    <div>
    	<button onClick={clickFn}>点击</button>
    </div>
);
```

​		更多参考：[`React` 合成事件](https://react.docschina.org/docs/events.html) 



### 事件传参

​		在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 `id` 是你要删除那一行的 `ID`，以下两种方式都可以向事件处理函数传递参数：

```jsx
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

​		上述两种方式是等价的，分别通过柯里化箭头函数和 `Function.prototype.bind` 来实现。



#### `bind` 实现

​		使用 `bind` 实现事件传参，需要注意的是：由于 `React` 默认开启严格模式，因此 `bind` 绑定的任何值都将成为新函数的 `this`。当在不希望改变 `this` 时，可能会导致意外发生。此时，将 `bind` 的调用者改为箭头函数即可，因为箭头函数中的 `this` 不可更改。

##### 类组件

```jsx
class T extends React.Component {
    state = {
        arr: ['李居丽', '咸恩静', '朴孝敏', '朴智妍']
    }
    // 可以是箭头函数也可以是普通函数
    deleteRow(index) {
        let { arr } = this.state;
        arr.splice(index, 1);
        this.setState({arr});
    }
    render() {
        let { arr } = this.state;
        return (
        	<div>
            	{
                    arr.map((item, index) => {
                        return (<button 
                                    key = {index} 
                                    onClick = {this.deleteRow.bind(this, index)}
                                >
                                    点击删除 {item}
                                </button>);
                    })
                }
            </div>
        );
    }
}
```

##### 函数组件

```jsx
function T() {
    let [arr, setArr] = React.useState(['李居丽', '咸恩静', '朴孝敏', '朴智妍']);
    
    // 可以是箭头函数也可以是普通函数
    let deleteRow = (index) => {
        arr.splice(index, 1);
        setArr([...arr]); // 不能使用原引用值，必须覆盖它。
    }
    
    return (
        <div>
            {
                arr.map((item, index) => {
                    return (<button 
                                key = {index} 
                                onClick = {deleteRow.bind(null, index)}
                            >
                                点击删除 {item}
                            </button>);
                })
            }
        </div>
    );
}
```



#### 箭头函数

##### 类组件

​		使用柯里化箭头函数的实现：更多参考：[柯里化函数](https://blog.csdn.net/m0_52409770/article/details/123359123)、[函数柯里化详解](https://blog.csdn.net/Boale_H/article/details/126058783)。

```jsx
class T extends React.Component {
    state = {
        arr: ['李居丽', '咸恩静', '朴孝敏', '朴智妍']
    }
    // 外层可以是箭头函数也可以是普通函数
    deleteRow = (index) => {
        // 内层函数必须是箭头函数，否则this将为undefined。
        return () => {
            let { arr } = this.state;
            arr.splice(index, 1);
            this.setState({arr});
        };
    }
    render() {
        let { arr } = this.state;
        return (
        	<div>
            	{
                    arr.map((item, index) => {
                        return (<button 
                                    key = {index} 
                                    onClick = {this.deleteRow(index)}
                                >
                                    点击删除 {item}
                                </button>);
                    })
                }
            </div>
        );
    }
}
```

​		对于类组件来说，还可以在其 `constructor` 中预先为各个事件处理程序绑定 `this`。

```jsx
class T extends React.Component {
    state = {
        arr: ['李居丽', '咸恩静', '朴孝敏', '朴智妍']
    }
    constructor(props, context) {
        super(props);
        this.deleteRow.bind(this);
    }
    // 外层可以是箭头函数也可以是普通函数
    deleteRow = (index) => () => {
        let { arr } = this.state;
        arr.splice(index, 1);
        this.setState({ arr });
    }
    render() {
        let { arr } = this.state;
        return (
        	<div>
            	{
                    arr.map((item, index) => {
                        return (<button 
                                    key = {index} 
                                    onClick = {this.deleteRow(index)}
                                >
                                    点击删除 {item}
                                </button>);
                    })
                }
            </div>
        );
    }
}
```

##### 函数组件

```jsx
function T() {
    let [arr, setArr] = React.useState(['李居丽', '咸恩静', '朴孝敏', '朴智妍']);
    
    // 内外层均可以是箭头函数或普通函数，因为函数组件不需要使用this。
    let deleteRow = (index) => {
        return () => {
            arr.splice(index, 1);
        	setArr([...arr]); // 不能使用原引用值，必须覆盖它。
        };
    }
    
    return (
        <div>
            {
                arr.map((item, index) => {
                    return (<button 
                                key = {index} 
                                onClick = {deleteRow(index)}
                            >
                                点击删除 {item}
                            </button>);
                })
            }
        </div>
    );
}
```

​		为了避免不必要的麻烦，（尤其是类组件）建议始终使用箭头函数来传递参数，无论采取哪一种实现。



### 事件对象

##### 原生事件对象

​		`React` 保留了 `window.event` 这个原生事件对象，它在不同的事件中会自动呈现出不同的状态。不过，通常用处不大。

```jsx
console.log(window.event); // Event {isTrusted: true, type: 'DOMContentLoaded', target: document, ...}

function clickFn() {
    console.log(event);    // PointerEvent {isTrusted: true, pointerId: 1, width: 1, height: 1, ...}
}

let vnode = (
    <div>
        <button onClick={clickFn}>点击</button>
    </div>
);
```

##### 合成事件对象

​		`React` 封装了原生的事件对象，并称其为合成事件对象（`SyntheticEvent`）。它是自动传递的，但永远是形参中的最后一位。

```jsx
function clickFn(e) {
    console.log(e);
}

let vnode = (
    <div>
        <button onClick={clickFn}>点击</button>
    </div>
);
```

​		因为事件对象只会传递给事件处理程序，而只要给事件处理程序传参，无论通过 `bind` 还是柯里化箭头函数的方式，事件处理程序永远都是等待被用户触发的。因此它们永远都在最后执行，所以事件对象也就只能作为最后一位参数被传递。

​		在 `Function.prototype.bind` 绑定中的合成事件对象。

```jsx
class T extends React.Component {
    state = {
        arr: ['李居丽', '咸恩静', '朴孝敏', '朴智妍']
    }
    deleteRow(index, e) {
        // 事件处理程序是该函数的一个副本
		console.log(e); 
    }
    render() {
        let { arr } = this.state;
        return (
        	<div>
            	{
                    arr.map((item, index) => {
                        return (<button 
                                    key = {index} 
                                    onClick = {this.deleteRow.bind(this, index)}
                                >
                                    点击删除 {item}
                                </button>);
                    })
                }
            </div>
        );
    }
}
```

​		在柯里化箭头函数中的合成事件对象。

```jsx
class T extends React.Component {
    state = {
        arr: ['李居丽', '咸恩静', '朴孝敏', '朴智妍']
    }
    deleteRow = (index) => {
        return (e) => {
            // 内层才是真正的事件处理程序
            console.log(e); // 合成事件对象
        };
    }
    render() {
        let { arr } = this.state;
        return (
            <div>
                {
                    arr.map((item, index) => {
                        return (<button
                                    key={index}
                                    onClick={this.deleteRow(index)}
                                >
                                    点击删除 {item}
                                </button>);
                    })
                }
            </div>
        );
    }
}
```



### 事件模型

​		`React` 的事件模型与原生事件模型一样，默认是冒泡模式。

##### 事件冒泡

```jsx
function fFn(e) {
    console.log('父级事件触发');
}

function cFn(e) {
    console.log('子级事件触发');
}

let vnode = (
	<div onClick={fFn}>
        父级元素点击
    	<div onClick={cFn}>子级元素点击</div>
    </div>
);
```

​		截止 `v0.14`，当事件处理函数返回 `false` 时，不再阻止事件冒泡。应该使用 `e.stopPropagation()` 或者 `e.preventDefault()` 替代。而在 `v18.2` 中，便只能使用 `e.stopPropagation()` 来阻止冒泡了。

```jsx
function fFn(e) {
    console.log('父级事件触发');
}

function cFn(e) {
    e.stopPropagation(); // 阻止事件继续向上冒泡，冒泡阶段到此截止！
    console.log('子级事件触发');
}
```

##### 事件捕获

​		如果要改为捕获模式，只需要在合成事件属性名中后缀一个 `Capture` 即可。如：`onClick ==> onClickCapture`。

```jsx
function fFn(e) {
    console.log('父级事件触发');
}

function cFn(e) {
    console.log('子级事件触发');
}

let vnode = (
	<div onClickCapture={fFn}>
        父级元素点击
    	<div onClickCapture={cFn}>子级元素点击</div>
    </div>
);
```

​		与事件冒泡一样，事件处理函数返回 `false` 不再阻止事件捕获。应使用 `e.stopPropagation()` 或 `e.preventDefault()` 替代。

```jsx
function fFn(e) {
    e.stopPropagation(); // 阻止事件继续向下捕获，捕获阶段到此截止！
    console.log('父级事件触发');
}

function cFn(e) {
    console.log('子级事件触发');
}
```


