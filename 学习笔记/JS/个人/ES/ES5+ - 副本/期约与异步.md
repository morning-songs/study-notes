# 期约与异步

## 红宝书

​		`ECMAScript 6` 及之后的几个版本逐步加大了对异步编程机制的支持，提供了令人眼前一亮的新特性。`ECMAScript 6` 新增了正式的 `Promise`（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用 `async` 和 `await` 关键字定义异步函数的机制。

​		浏览器控制台的输出经常能打印出 JavaScript 运行中无法获取的对象信息（比如期约的状态）。这个特性在示例中广泛使用，以便辅助读者理解相关概念。

<hr>



### 异步编程

​		异步行为是为了优化因计算量大而时间长的操作。但更重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。



#### 同步和异步

​		同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。

​		在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。

​		相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。

​		异步代码不容易推断，因为它们何时触发取决于其回调何时从回调队列中出列（只有先出列了，才会被执行）。比如，定时器回调由系统计时器触发，它会生成一个入队执行的中断。到底什么时候会触发这个中断，这对 JavaScript 运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。



#### 异步编程模式

​		异步行为是 `JavaScript` 的基础，但以前的实现不理想。在早期的 `JavaScript` 中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称 “回调地狱” ）来解决。

​		假设有以下异步函数，使用了 `setTimeout` 在一秒钟之后执行某些操作：

```js
function double(value) { 
    // setTimeout(callback, delay, param1, param2, ..., paramN)
 	setTimeout(() => setTimeout(console.log, 0, value * 2), 1000); 
} 

double(3); // 6（大约1000毫秒之后）
```

​		`setTimeout` 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000 毫秒之后，`JavaScript` 运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对 `JavaScript` 代码就完全不可见了。还有一点，`double()` 函数在 `setTimeout` 成功调度异步操作之后（通常是到达指定时间之后）会立即退出。



##### 异步返回值

​		假设 `setTimeout` 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（通常是作为回调的参数传入到内部执行）。

```js
function double(value, callback) { 
 	setTimeout(() => callback(value * 2), 1000); 
} 

double(3, (x) => console.log(`I was given: ${x}`)); // "I was given: 6"（大约 1000 毫秒之后）
```

​		这里的 `setTimeout` 调用告诉 `JavaScript` 运行时在 1000 毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。



##### 失败处理

​		异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：

```js
function double(value, success, failure) { 
 	setTimeout(() => { 
 		try { 
 			if (typeof value !== 'number') { 
 				throw 'Must provide number as first argument'; 
 			} 
 			success(2 * value); 
 		} catch (e) { 
 			failure(e); 
 		} 
 	}, 1000); 
} 

const successCallback = (x) => console.log(`Success: ${x}`); 
const failureCallback = (e) => console.log(`Failure: ${e}`); 

double(3, successCallback, failureCallback); 
double('b', successCallback, failureCallback); 
// "Success: 6"（大约 1000 毫秒之后）
// "Failure: Must provide number as first argument"（大约 1000 毫秒之后）
```

​		这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。



##### 嵌套异步回调

​		如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调：

```js
function double(value, success, failure) { 
 	setTimeout(() => { 
 		try { 
 			if (typeof value !== 'number') { 
 				throw 'Must provide number as first argument'; 
 			} 
 			success(2 * value); 
 		} catch (e) { 
 			failure(e); 
 		} 
 	}, 1000);
}

const successCallback = (x) => { 
 	double(x, (y) => console.log(`Success: ${y}`)); 
}; 
const failureCallback = (e) => console.log(`Failure: ${e}`); 

double(3, successCallback, failureCallback); // // "Success: 12"（大约 1000 毫秒之后）
```

​		显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱” 这个称呼可谓名至实归，嵌套回调的代码维护起来就是噩梦。

<hr>



### 期约

​		期约是对尚不存在结果的一个替身。期约（`promise`）这个名字最早是由 `Daniel Friedman`和 `David Wise` 在他们于 1976 年发表的论文 `“The Impact of Applicative Programming on Multiprocessing”` 中提出来的。但直到十几年以后，`Barbara Liskov` 和 `Liuba Shrira` 在 1988 年发表了论文 `“Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed Systems”`，这个概念才真正确立下来。

​		同一时期的计算机科学家还使用了 “终局”（`eventual`）、“期许”（`future`）、“延迟”（`delay`）和 “迟付”（`deferred`）等术语指代同样的概念。所有这些概念描述的都是一种异步程序执行的机制。



#### `Promises/A+` 规范

​		早期的期约机制在 `jQuery` 和 `Dojo` 中是以 `Deferred API` 的形式出现的。到了 2010 年，`CommonJS` 项目实现的 `Promises/A` 规范日益流行起来。`Q` 和 `Bluebird` 等第三方 `JavaScript` 期约库也越来越得到社区认可，虽然这些库的实现多少都有些不同。为弥合现有实现之间的差异，2012 年 `Promises/A+` 组织分叉（`fork`）了 `CommonJS` 的 `Promises/A` 建议，并以相同的名字制定了 `Promises/A+` 规范。这个规范最终成为了`ECMAScript 6` 规范实现的范本。

​		`ECMAScript 6` 增加了对 `Promises/A+` 规范的完善支持，即 `Promise` 类型。一经推出，`Promise` 就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持 `ES6` 期约，很多其他浏览器 `API`（如 `fetch()` 和 `Battery Status API`）也以期约为基础。



#### 期约基础

​		`ECMAScript 6` 新增的引用类型 `Promise`，可以通过 `new` 操作符来实例化。创建新期约时需要传入执行器（`executor`）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器。

```js
let p = new Promise(() => {}); // Promise的参数必须是一个函数，它会成为该期约的执行器函数。

setTimeout(console.log, 0, p); // Promise {<pending>}
/*
Promise {
	[[Prototype]]: Promise {
		catch: f, constructor: f, finally: f, then: f, Symbol(Symbol.toStringTag): 'Promise'
	},
	[[PromiseState]]: "pending",
	[[PromiseResult]]: undefined
}
*/
```

​		之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 `TypeError`。

```js
new Promise(); 	// TypeError: Promise resolver undefined is not a function

new Promise(1); // TypeError: Promise resolver 1 is not a function
```



##### 期约状态机

​		在把一个期约实例传给 `console.log()` 时，控制台输出（可能因浏览器不同而略有差异）表明该实例处于待定（`pending`）状态。如前所述，期约是一个有状态的对象，可能处于如下 3 种状态之一：

- `pending`：待定
- `fulfilled`：兑现（有时候也称为 “解决”，`resolved`）
- `rejected`：拒绝

​		待定（`pending`）是期约的最初始状态。在待定状态下，期约可以落定（`settled`）为代表成功的兑现（`fulfilled`）状态，或者代表失败的拒绝（`rejected`）状态。无论落定为哪种状态都是不可逆的。一旦从待定转换为兑现或拒绝，期约的状态就不会再改变。不过，并不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（`resolve`）还是拒绝（`reject`），甚至永远处于待定（`pending`）状态，都应该具有恰当的行为。

​		重要的是，期约的状态（`[[PromiseState]]`）是私有的，不能直接通过 `JavaScript` 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 `JavaScript` 代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。



##### 兑现值、拒绝理由及期约用例

​		期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态（`[[PromiseState]]`）代表期约是否完成。“待定” 表示尚未开始或者正在执行中。“兑现” 表示已经成功完成，而 “拒绝” 则表示没有成功完成。

​		某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。比如，假设期约要向服务器发送一个 `HTTP` 请求。请求返回 200~299 范围内的状态码就足以让期约的状态变为 “兑现”。类似地，如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为 “拒绝”。

​		在另外一些情况下，期约封装的异步操作会实际生成某个值（`[[PromiseResult]]`），而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约向服务器发送一个 `HTTP` 请求并预定会返回一个 `JSON`。如果请求返回范围在 200~299 的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个 `JSON` 字符串。类似地，如果请求返回的状态码不在 200~299 这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 `Error`对象，包含着 `HTTP` 状态码及相关错误消息。

​		为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（`value`）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（`reason`）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 `undefined`。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

​		注释：无论是兑现值还是拒绝理由都存在于一个名为 `[[PromiseResult]]` 的内部槽位中，当状态落定后才能确定具体的值或理由。



##### 通过执行函数控制期约状态

​		由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 `resolve()` 和 `reject()`。调用 `resolve()` 会把状态切换为兑现，调用 `reject()` 会把状态切换为拒绝。另外，调用 `reject()` 还会抛出错误（后面会讨论这个错误）。

```js
let p1 = new Promise((resolve, reject) => resolve()); 
setTimeout(console.log, 0, p1); // Promise {<fulfilled>: undefined}

let p2 = new Promise((resolve, reject) => reject()); 
setTimeout(console.log, 0, p2); // Promise {<rejected>: undefined}
// Uncaught (in promise) undefined
```

​		在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：

```js
new Promise(() => setTimeout(console.log, 0, 'executor')); 
setTimeout(console.log, 0, 'promise initialized'); 
// executor 
// promise initialized
```

​		添加 `setTimeout` 可以推迟切换状态：

```js
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000)); // 一秒后改变状态为：兑现。

// 在console.log打印期约实例的时候，还不会执行超时回调（即 resolve()）
setTimeout(console.log, 0, p); // Promise {<pending>}（大约一秒后，改为："fulfilled"）
```

​		无论 `resolve()` 和 `reject()` 中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：

```js
let p = new Promise((resolve, reject) => { 
 	resolve();
 	reject(); // 没有效果
}); 

setTimeout(console.log, 0, p); // Promise {<fulfilled>: undefined}
```

​		为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 `setTimeout` 设置一个 10 秒钟后无论如何都会拒绝期约的回调：

```js
let p = new Promise((resolve, reject) => { 
 	setTimeout(reject, 10000); // 10 秒后调用 reject() 
 	// 执行函数的逻辑
}); 

setTimeout(console.log, 0, p); // Promise {<pending>}
setTimeout(console.log, 11000, p); // 11 秒后再检查状态
// (After 10 seconds) Uncaught (in promise) undefined
// (After 11 seconds) Promise {<rejected>: undefined}
```

​		因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝将会静默失败。



##### `Promise.resolve()`

​		期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 `Promise.resolve()` 静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：

```js
new Promise((resolve, reject) => resolve()); // Promise {<fulfilled>: undefined}

Promise.resolve(); // Promise {<fulfilled>: undefined}
```

​		传给 `Promise.resolve()` 的第一个参数将成为这个解决期约的值。使用这个静态方法，实际上可以把任何值都转换为一个期约：

```js
setTimeout(console.log, 0, Promise.resolve()); // Promise {<fulfilled>: undefined}

setTimeout(console.log, 0, Promise.resolve(3)); // Promise {<fulfilled>: 3}

// 多余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); // Promise {<fulfilled>: 4}
```

​		对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，`Promise.resolve()` 可以说是一个幂等方法，如下所示：

```js
let p = Promise.resolve(7); 

setTimeout(console.log, 0, p === Promise.resolve(p)); // true 
setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))); // true
```

​		这个幂等性会保留传入期约的状态：

```js
let p = new Promise(() => {}); 

setTimeout(console.log, 0, p); // Promise {<pending>}
setTimeout(console.log, 0, Promise.resolve(p)); // Promise {<pending>}
setTimeout(console.log, 0, p === Promise.resolve(p)); // true
```

​		注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：

```js
let p = Promise.resolve(new Error('foo')); 

setTimeout(console.log, 0, p); // Promise {<fulfilled>: Error: foo at <anonymous>:1:25}
```



##### `Promise.reject()`

​		与 `Promise.resolve()` 类似，`Promise.reject()` 会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过 `try/catch` 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的：

```js
new Promise((resolve, reject) => reject()); 

Promise.reject();
```

​		这个拒绝的期约的理由就是传给 `Promise.reject()` 的第一个参数。这个参数也会传给后续的拒绝处理程序：

```js
let p = Promise.reject(3); 

setTimeout(console.log, 0, p); // Promise {<rejected>: 3}
p.then(null, (e) => setTimeout(console.log, 0, e)); // 3
```

​		关键在于，`Promise.reject()` 并没有照搬 `Promise.resolve()` 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：

```js
setTimeout(console.log, 0, Promise.reject(Promise.resolve())); // Promise {<rejected>: Promise}
// Uncaught (in promise) Promise {<fulfilled>: undefined}
```



##### 同步/异步执行的二元性

​		`Promise` 的设计很大程度上会导致一种完全不同于 `JavaScript` 的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形：

```js
try { 
 	throw new Error('foo'); 
} catch(e) { 
 	console.log(e); // Error: foo 
} 

try { 
 	Promise.reject(new Error('bar')); 
} catch(e) { 
 	console.log(e); 
} 
// Uncaught (in promise) Error: bar
```

​		第一个 `try/catch` 抛出并捕获了错误，第二个 `try/catch` 抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。

​		在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，`try/catch` 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。



#### 期约的实例方法

​		期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。



##### 实现 `Thenable` 接口

​		`ECMAScript` 暴露的异步结构中，任何对象都有一个 `then()` 方法。这个方法被认为实现了 `Thenable` 接口。下面的例子展示了实现这一接口的最简单的类：

```js
class MyThenable { 
 	then() {} 
}
```

​		`ECMAScript` 的 `Promise` 类型实现了 `Thenable` 接口。这个简化的接口跟 `TypeScript` 或其他包中的接口或类型定义不同，它们都设定了 `Thenable` 接口更具体的形式。



##### `Promise.prototype.then()`

​		`Promise.prototype.then()` 是为期约实例添加处理程序的主要方法。这个 `then()` 方法接收最多两个参数：`onResolved` 处理程序和 `onRejected` 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。

```js
function onResolved(id) { 
 	setTimeout(console.log, 0, id, 'resolved');
} 
function onRejected(id) { 
 	setTimeout(console.log, 0, id, 'rejected'); 
} 

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000)); 	// 大约3秒后，改为兑现状态
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000)); 	// 大约3秒后，改为拒绝状态

// 进入哪个状态，就执行哪个处理程序。
p1.then(() => onResolved('p1'), () => onRejected('p1'));
p2.then(() => onResolved('p2'), () => onRejected('p2')); 
//（3 秒后）
// p1 resolved
// p2 rejected
```

​		因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。如前所述，两个处理程序参数都是可选的。而且，传给 `then()` 的任何非函数类型的参数都会被静默忽略。如果想只提供 `onRejected` 参数，那就要在 `onResolved` 参数的位置上传入 `undefined`。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。

```js
function onResolved(id) { 
 	setTimeout(console.log, 0, id, 'resolved'); 
} 
function onRejected(id) { 
 	setTimeout(console.log, 0, id, 'rejected'); 
} 

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000)); 
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000)); 

// 非函数处理程序会被静默忽略，可以但不推荐
p1.then('gobbeltygook'); 

// 不传 onResolved 处理程序的规范写法
p2.then(null, () => onRejected('p2')); // p2 rejected（3 秒后）
```

​		`Promise.prototype.then()` 方法返回一个新的期约实例：

```js
let p1 = new Promise(() => {}); 
let p2 = p1.then(); 

setTimeout(console.log, 0, p1); // Promise {<pending>}
setTimeout(console.log, 0, p2); // Promise {<pending>}
setTimeout(console.log, 0, p1 === p2); // false
```

​		这个新期约实例基于 `onResovled` 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 `Promise.resolve()` 包装来生成新期约。如果没有提供这个处理程序，则 `Promise.resolve()` 就会包装上一个期约解决之后的值。如果没有显式的返回语句，则 `Promise.resolve()` 会包装默认的返回值 `undefined`。

```js
let p1 = Promise.resolve('foo'); 

// 若调用then()时不传处理程序，则原样向后传
let p2 = p1.then();
setTimeout(console.log, 0, p2); // Promise {<fulfilled>: 'foo'}

// p3, p4, p5都一样
let p3 = p1.then(() => undefined); 
let p4 = p1.then(() => {}); // 这里是一个空箭头函数，而不是返回一个空对象（除非{}被小括号包裹）！
let p5 = p1.then(() => Promise.resolve()); 

setTimeout(console.log, 0, p3); // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p4); // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p5); // Promise {<fulfilled>: undefined}
```

​		如果有显式的返回值，则 `Promise.resolve()` 会包装这个值：

```js
// p6, p7都一样
let p6 = p1.then(() => 'bar'); 
let p7 = p1.then(() => Promise.resolve('bar')); 

setTimeout(console.log, 0, p6); // Promise {<fulfilled>: 'bar'}
setTimeout(console.log, 0, p7); // Promise {<fulfilled>: 'bar'}

// Promise.resolve()保留返回的期约（包括其值和状态）
let p8 = p1.then(() => new Promise(() => {}));
let p9 = p1.then(() => Promise.reject()); // Uncaught (in promise): undefined 

setTimeout(console.log, 0, p8); // Promise {<pending>}
setTimeout(console.log, 0, p9); // Promise {<rejected>: undefined}
```

​		抛出异常会返回拒绝的期约：

```js
let p10 = p1.then(() => { throw 'baz'; }); // Uncaught (in promise) baz 

setTimeout(console.log, 0, p10); // Promise {<rejected>: 'baz'}
```

​		注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：

```js
let p11 = p1.then(() => Error('qux')); 

setTimeout(console.log, 0, p11); // Promise {<fulfilled>: Error: qux at <anonymous>:1:25}
```

​		`onRejected` 处理程序也与之类似：`onRejected` 处理程序返回的值也会被 `Promise.resolve()` 包装。乍一看这可能有点违反直觉，但是想一想，`onRejected` 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。

​		下面的代码片段展示了用 `Promise.reject()` 替代之前例子中的 `Promise.resolve()` 之后的结果：

```js
let p1 = Promise.reject('foo'); // Uncaught (in promise) foo

// 调用then()时不传处理程序则原样向后传
let p2 = p1.then(); // Uncaught (in promise) foo
setTimeout(console.log, 0, p2); // Promise {<rejected>: 'foo'}

// p3, p4, p5都一样【注意状态的变化！！！】
let p3 = p1.then(null, () => undefined); 
let p4 = p1.then(null, () => {}); 
let p5 = p1.then(null, () => Promise.resolve()); 
setTimeout(console.log, 0, p3); // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p4); // Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p5); // Promise {<fulfilled>: undefined}

// p6, p7都一样【注意状态的变化！！！】
let p6 = p1.then(null, () => 'bar'); 
let p7 = p1.then(null, () => Promise.resolve('bar')); 
setTimeout(console.log, 0, p6); // Promise {<fulfilled>: 'bar'}
setTimeout(console.log, 0, p7); // Promise {<fulfilled>: 'bar'}

// Promise.resolve()保留返回的期约
let p8 = p1.then(null, () => new Promise(() => {})); 
let p9 = p1.then(null, () => Promise.reject()); // Uncaught (in promise): undefined 
setTimeout(console.log, 0, p8); // Promise <pending> 
setTimeout(console.log, 0, p9); // Promise <rejected>: undefined 

let p10 = p1.then(null, () => { throw 'baz'; }); // Uncaught (in promise) baz 
setTimeout(console.log, 0, p10); // Promise {<rejected>: 'baz'}

let p11 = p1.then(null, () => Error('qux')); // 【注意状态的变化！！！】
setTimeout(console.log, 0, p11); // Promise {<fulfilled>: Error: qux at <anonymous>:1:31}
```



##### `Promise.prototype.catch()`

​		`Promise.prototype.catch()` 方法用于给期约添加拒绝处理程序。它只接收一个参数：`onRejected` 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 `Promise.prototype.then(null, onRejected)`。下面的代码展示了这两种同样的情况：

```js
let p = Promise.reject(); // Uncaught (in promise) undefined

// 拒绝处理程序
let onRejected = function(e) { 
 	setTimeout(console.log, 0, 'rejected'); 
}; 

// 这两种添加拒绝处理程序的方式是一样的：
p.then(null, onRejected); 	// rejected
p.catch(onRejected); 		// rejected
```

​		`Promise.prototype.catch()` 返回一个新的期约实例：

```js
let p1 = new Promise(() => {}); 
let p2 = p1.catch();

setTimeout(console.log, 0, p1); // Promise {<pending>} 
setTimeout(console.log, 0, p2); // Promise {<pending>}
setTimeout(console.log, 0, p1 === p2); // false
```

​		在返回新期约方面，`Promise.prototype.catch()` 的行为与 `Promise.prototype.then()` 的 `onRejected` 处理程序大致一样。

```js
let p1 = Promise.reject('foo'); // Uncaught (in promise) foo

// 调用catch()时不传处理程序则原样向后传
let p2 = p1.catch(); // Uncaught (in promise) foo
setTimeout(console.log, 0, p2); // Promise {<rejected>: 'foo'}

// p3, p4, p5都一样
let p3 = p1.catch(null, () => undefined); 			// Uncaught (in promise) foo
let p4 = p1.catch(null, () => {}); 					// Uncaught (in promise) foo
let p5 = p1.catch(null, () => Promise.resolve()); 	// Uncaught (in promise) foo
setTimeout(console.log, 0, p3); // Promise {<rejected>: 'foo'}
setTimeout(console.log, 0, p4); // Promise {<rejected>: 'foo'}
setTimeout(console.log, 0, p5); // Promise {<rejected>: 'foo'}

// p6, p7都一样
let p6 = p1.catch(null, () => 'bar'); 					// Uncaught (in promise) foo
let p7 = p1.catch(null, () => Promise.resolve('bar')); 	// Uncaught (in promise) foo
setTimeout(console.log, 0, p6); // Promise {<rejected>: 'foo'}
setTimeout(console.log, 0, p7); // Promise {<rejected>: 'foo'}

// Promise.catch()保留返回的期约
let p8 = p1.catch(null, () => new Promise(() => {})); 	// Uncaught (in promise) foo
let p9 = p1.catch(null, () => Promise.reject()); 		// Uncaught (in promise) foo
setTimeout(console.log, 0, p8); // Promise {<rejected>: 'foo'}
setTimeout(console.log, 0, p9); // Promise {<rejected>: 'foo'}

let p10 = p1.then(null, () => { throw 'baz'; }); // Uncaught (in promise) baz
setTimeout(console.log, 0, p10); // Promise {<rejected>: 'baz'}

let p11 = p1.then(null, () => Error('qux')); // 【注意状态的变化！！！】
setTimeout(console.log, 0, p11); // Promise {<fulfilled>: Error: qux at <anonymous>:1:31}
```



##### `Promise.prototype.finally()`

​		`Promise.prototype.finally()` 方法用于给期约添加 `onFinally` 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 `onResolved` 和 `onRejected` 处理程序中出现冗余代码。但 `onFinally` 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码（即：最终的处理程序）。

```js
let p1 = Promise.resolve(); 
let p2 = Promise.reject(); // Uncaught (in promise) undefined

let onFinally = function() { 
 	setTimeout(console.log, 0, 'Finally!') 
} 

p1.finally(onFinally); // "Finally!"
p2.finally(onFinally); // "Finally!"
```

​		`Promise.prototype.finally()` 方法返回一个新的期约实例：

```js
let p1 = new Promise(() => {});
let p2 = p1.finally();

setTimeout(console.log, 0, p1); // Promise {<pending>}
setTimeout(console.log, 0, p2); // Promise {<pending>}
setTimeout(console.log, 0, p1 === p2); // false
```

​		这个新期约实例不同于 `then()` 或 `catch()` 方式返回的实例。因为 `onFinally` 被设计为一个状态无关的方法，所以在大多数情况下它都表现为对父期约（包括状态和值）的传递。对于已解决状态和被拒绝状态都是如此。

```js
let p1 = Promise.resolve('foo');

// 这里都会原样后传
let p2 = p1.finally(); 
let p3 = p1.finally(() => undefined); 
let p4 = p1.finally(() => {}); 
let p5 = p1.finally(() => Promise.resolve()); 
let p6 = p1.finally(() => 'bar'); 
let p7 = p1.finally(() => Promise.resolve('bar')); 
let p8 = p1.finally(() => Error('qux')); 

setTimeout(console.log, 0, p2); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p3); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p4); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p5); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p6); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p7); // Promise {<fulfilled>: 'foo'}
setTimeout(console.log, 0, p8); // Promise {<fulfilled>: 'foo'}
```

​		如果返回的是一个待定的期约，或者 `onFinally` 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：

```js
// Promise.finally()保留返回的期约
let p9 = p1.finally(() => new Promise(() => {})); 
let p10 = p1.finally(() => Promise.reject()); // Uncaught (in promise): undefined 
setTimeout(console.log, 0, p9);  // Promise {<pending>} 
setTimeout(console.log, 0, p10); // Promise {<rejected>: undefined}

let p11 = p1.finally(() => { throw 'baz'; }); // Uncaught (in promise) baz 
setTimeout(console.log, 0, p11); // Promise {<rejected>: 'baz'}
```

​		返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：

```js
let p1 = Promise.resolve('foo'); 

// 忽略解决的值
let p2 = p1.finally(() => new Promise((resolve, reject) => setTimeout(() => resolve('bar'), 100))); 

setTimeout(console.log, 0, p2); // Promise {<pending>} 
setTimeout(() => setTimeout(console.log, 0, p2), 200); 
// Promise {<fulfilled>: 'foo'}（大约200毫秒之后）
```



##### 非重入特性

​		当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由 `JavaScript` 运行时保证，被称为 “非重入”（`non-reentrancy`）特性。下面的例子演示了这个特性：

```js
// 创建解决的期约
let p = Promise.resolve();

// 添加解决处理程序
// 直觉上，这个处理程序会等期约一解决就执行
p.then(() => console.log('onResolved handler'));

// 同步输出，证明then()已经返回
console.log('then() returns'); 
// 实际的输出：
// then() returns 
// onResolved handler
```

​		在这个例子中，在一个解决期约上调用 `then()` 会把 `onResolved` 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在 `then()` 后面的同步代码一定先于处理程序执行。

​		先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。下面的例子展示了即使先添加了 `onResolved` 处理程序，再同步调用 `resolve()`，处理程序也不会进入同步线程执行：

```js
let synchronousResolve;

// 创建一个期约并将触发解决函数的方法保存在一个外部变量中
let p = new Promise((resolve) => { 
 	synchronousResolve = function() { 
 		console.log('1: invoking resolve()'); 
 		resolve(); // 改为兑现状态
 		console.log('2: resolve() returns'); 
 	}; 
});

p.then(() => console.log('4: then() handler executes')); // 添加处理程序
synchronousResolve(); // 改变期约状态（同步）
console.log('3: synchronousResolve() returns'); // 同步执行代码
// 实际的输出：
// 1: invoking resolve() 
// 2: resolve() returns 
// 3: synchronousResolve() returns 
// 4: then() handler executes
```

​		在这个例子中，即使期约状态变化发生在添加处理程序之后，处理程序也会等到运行的消息队列让它出列时才会执行。

​		非重入适用于 `onResolved/onRejected` 处理程序、`catch()` 处理程序和 `finally()` 处理程序。下面的例子演示了这些处理程序都只能异步执行：

```js
let p1 = Promise.resolve(); 
p1.then(() => console.log('p1.then() onResolved')); 
console.log('p1.then() returns'); 

let p2 = Promise.reject(); 
p2.then(null, () => console.log('p2.then() onRejected')); 
console.log('p2.then() returns'); 

let p3 = Promise.reject(); 
p3.catch(() => console.log('p3.catch() onRejected')); 
console.log('p3.catch() returns'); 

let p4 = Promise.resolve(); 
p4.finally(() => console.log('p4.finally() onFinally')); 
console.log('p4.finally() returns'); 

// p1.then() returns 
// p2.then() returns 
// p3.catch() returns 
// p4.finally() returns 
// p1.then() onResolved 
// p2.then() onRejected 
// p3.catch() onRejected 
// p4.finally() onFinally
```

​		如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 `then()`、`catch()` 还是 `finally()` 添加的处理程序都是如此。

```js
let p1 = Promise.resolve(); 
let p2 = Promise.reject(); // Uncaught (in promise) undefined

p1.then(() => setTimeout(console.log, 0, 1)); 
p1.then(() => setTimeout(console.log, 0, 2)); 
// 1 
// 2 

p2.then(null, () => setTimeout(console.log, 0, 3)); 
p2.then(null, () => setTimeout(console.log, 0, 4)); 
// 3 
// 4 

p2.catch(() => setTimeout(console.log, 0, 5)); 
p2.catch(() => setTimeout(console.log, 0, 6)); 
// 5 
// 6 

p1.finally(() => setTimeout(console.log, 0, 7)); 
p1.finally(() => setTimeout(console.log, 0, 8)); 
// 7 
// 8
```



##### 传递解决值和拒绝理由

​		到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的 `JSON` 是发送第二次请求必需的数据，那么第一次请求返回的值就应该传给 `onResolved` 处理程序继续处理。当然，失败的网络请求也应该把 `HTTP` 状态码传给 `onRejected` 处理程序。

​		在执行函数（`executor`）中，解决的值和拒绝的理由是分别作为 `resolve()` 和 `reject()` 的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 `onResolved` 或 `onRejected` 处理程序的唯一参数。下面的例子展示了这个传递过程：

```js
// 执行函数：指new Promise()的首参。即：new Promise(executor);
let p1 = new Promise((resolve, reject) => resolve('foo'));
p1.then((value) => console.log(value)); // 'foo'

let p2 = new Promise((resolve, reject) => reject('bar')); 
p2.catch((reason) => console.log(reason)); // 'bar'
```

​		`Promise.resolve()` 和 `Promise.reject()` 在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 `onResolved` 或 `onRejected` 处理程序：

```js
let p1 = Promise.resolve('foo'); 
p1.then((value) => console.log(value)); // 'foo' 

let p2 = Promise.reject('bar'); 
p2.catch((reason) => console.log(reason)); // 'bar'
```



##### 拒绝期约与拒绝错误处理

​		拒绝期约类似于 `throw()` 表达式，因为它们都代表一种程序状态，即：需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：

```js
let p1 = new Promise((resolve, reject) => reject(Error('foo'))); 	// Uncaught (in promise) Error: foo
let p2 = new Promise((resolve, reject) => { throw Error('foo'); }); // Uncaught (in promise) Error: foo
let p3 = Promise.resolve().then(() => { throw Error('foo'); }); 	// Uncaught (in promise) Error: foo
let p4 = Promise.reject(Error('foo')); 								// Uncaught (in promise) Error: foo

setTimeout(console.log, 0, p1); // Promise {<rejected>: Error: foo ...}
setTimeout(console.log, 0, p2); // Promise {<rejected>: Error: foo ...}
setTimeout(console.log, 0, p3); // Promise {<rejected>: Error: foo ...}
setTimeout(console.log, 0, p4); // Promise {<rejected>: Error: foo ...}
```

​		期约可以以任何理由拒绝，包括 `undefined`，但最好统一使用错误对象（即：`Error(msg)`）。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的 4 个错误的栈追踪信息如下：

```js
// p1
Uncaught (in promise) Error: foo
    at <anonymous>:1:50
    at new Promise (<anonymous>)
    at <anonymous>:1:10
// p2     
Uncaught (in promise) Error: foo
    at <anonymous>:2:51
    at new Promise (<anonymous>)
    at <anonymous>:2:10 
// p4
Uncaught (in promise) Error: foo
    at <anonymous>:4:25
// p3
Uncaught (in promise) Error: foo
    at <anonymous>:3:47
```

​		所有错误都是异步抛出且未捕获（`Uncaught`）处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。

​		注意错误的顺序：`Promise.resolve().then()` 的错误最后才出现，这是因为它需要在运行时消息队列中添加处理程序；也就是说，它还需再次入列等待，并且在最终抛出未捕获错误之前它还会创建另一个期约。

​		这个例子同样揭示了异步错误一个有意思的副作用。正常情况下，在通过 `throw()` 关键字抛出错误时，`JavaScript` 运行时的错误处理机制会停止执行抛出错误之后的任何指令：

```js
throw Error('foo'); 
console.log('bar'); // 本行代码因前面代码的报错而不会被执行。

// Uncaught Error: foo
```

​		但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：

```js
// 异步报错：不仅不会阻止同步代码，也不会阻止异步代码。
Promise.reject(Error('foo'));
Promise.reject(Error('bar'));
console.log('qux'); 
// 'qux'
// Uncaught (in promise) Error: foo
// Uncaught (in promise) Error: bar
```

​		正如前面的 `Promise.reject()` 示例所示，异步错误只能通过异步的 `onRejected` 处理程序捕获：

```js
// 正确的方式：异步捕获 -- pme.catch(onRejected);
Promise.reject(Error('foo')).catch((e) => {});

// 错误的方式：同步捕获 -- try...catch
try {
 	Promise.reject(Error('foo')); 
} catch(e) {}
```

​		这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用 `try/catch` 在执行函数中捕获错误：

```js
// 因为执行函数是同步执行的，所以可以被同步捕获。
let p = new Promise((resolve, reject) => { 
 	try { 
 		throw Error('foo'); 
 	} catch(e) {} 
    
 	resolve('bar'); // 改为兑现状态，并传入兑现值。
});

setTimeout(console.log, 0, p); // Promise {<fulfilled>: 'bar'}
```

​		`then()` 和 `catch()` 的 `onRejected` 处理程序在语义上相当于 `try/catch`。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，`onRejected` 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：

```js
// 同步错误处理
console.log('begin synchronous execution'); 
try { 
 	throw Error('foo'); 
} catch(e) { 
 	console.log('caught error', e); 
}
console.log('continue synchronous execution'); 
// begin synchronous execution 
// caught error Error: foo 
// continue synchronous execution 

// 异步错误处理
new Promise((resolve, reject) => { 
 	console.log('begin asynchronous execution'); 
 	reject(Error('bar')); 
}).catch((e) => { 
 	console.log('caught error', e); 
}).then(() => { 
 	console.log('continue asynchronous execution'); 
});
// begin asynchronous execution 
// caught error Error: bar 
// continue asynchronous execution
```

​		注意：为模拟 `try...catch` 的捕获机制，异步捕获中 `catch()` 必须在 `then()` 之前。这样不仅更加符合 `try...catch` 的结构，还能避免 `then()` 处理程序被忽略。

```js
// 调换顺序后，then不会被执行。
new Promise((resolve, reject) => { 
 	console.log('begin asynchronous execution'); 
 	reject(Error('bar')); 
}).then(() => { 
 	console.log('continue asynchronous execution'); 
}).catch((e) => { 
 	console.log('caught error', e); 
});
/*
> begin asynchronous execution
> caught error Error: bar
*/
```



#### 期约的连锁与合成

​		多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。



##### 期约连锁

​		把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（`then()`、`catch()` 和 `finally()`）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的 “期约连锁”。比如：

```js
let p = new Promise((resolve, reject) => { 
 	console.log('first'); 
 	resolve(); 
}); 

// 期约连锁：默认将上一个期约一直向下传递。
p.then(() => console.log('second'))
 .then(() => console.log('third'))
 .then(() => console.log('fourth'));
// 'first' 
// 'second' 
// 'third' 
// 'fourth'
```

​		这个实现最终执行了一连串异步任务。过去，因它不符合严谨的串行化异步任务的要求，以这种方式执行的任务并没有那么地有用。

```js
let p = new Promise((resolve, reject) => { 
 	console.log('first'); 
 	resolve(); 
}); 

// 现在这种方式，较之过去，已经严谨了许多。
p.then(() => console.log('second'))
 .then(() => console.log('third'))
 .then(() => console.log('fourth'));

console.log('sync');

/*
> 'first'
> 'sync'
> 'second' 
> 'third' 
> 'fourth'
*/
```

​		在过去，要真正执行异步任务，可以改写前面的例子，让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务。比如，可以像下面这样让每个期约在一定时间后解决：

```js
let p1 = new Promise((resolve, reject) => { 
 	console.log('p1 executor'); 
 	setTimeout(resolve, 1000); 
}); 

p1.then(() => new Promise((resolve, reject) => { 
 	console.log('p2 executor'); 
 	setTimeout(resolve, 1000); 
})).then(() => new Promise((resolve, reject) => { 
 	console.log('p3 executor'); 
 	setTimeout(resolve, 1000); 
})).then(() => new Promise((resolve, reject) => { 
 	console.log('p4 executor'); 
 	setTimeout(resolve, 1000); 
})); 
// p1 executor（1 秒后）
// p2 executor（2 秒后）
// p3 executor（3 秒后）
// p4 executor（4 秒后）
```

​		把生成期约的代码提取到一个工厂函数中，就可以写成这样：

```js
function delayedResolve(str) { 
 	return new Promise((resolve, reject) => { 
 		console.log(str); 
 		setTimeout(resolve, 1000); 
	 }); 
}

delayedResolve('p1 executor')
 .then(() => delayedResolve('p2 executor')) 
 .then(() => delayedResolve('p3 executor')) 
 .then(() => delayedResolve('p4 executor'));
// p1 executor（1 秒后）
// p2 executor（2 秒后）
// p3 executor（3 秒后）
// p4 executor（4 秒后）
```

​		每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题。假如这种情况下不使用期约，那么前面的代码可能就要这样写了：

```js
function delayedExecute(str, callback = null) { 
 	setTimeout(() => { 
 		console.log(str); 
 		callback && callback(); 
 	}, 1000);
} 

delayedExecute('p1 callback', () => { 
 	delayedExecute('p2 callback', () => { 
 		delayedExecute('p3 callback', () => { 
 			delayedExecute('p4 callback'); 
 		}); 
	}); 
});
// p1 callback（1 秒后）
// p2 callback（2 秒后）
// p3 callback（3 秒后）
// p4 callback（4 秒后）
```

​		心明眼亮的开发者会发现，这不正是期约所要解决的回调地狱问题吗？

​		因为 `then()`、`catch()` 和 `finally()` 都返回期约，所以串联这些方法也很直观。下面的例子同时使用这 3 个实例方法：

```js
let p = new Promise((resolve, reject) => { 
 	console.log('initial promise rejects'); 
 	reject(); 
}); 

// 同样地，catch要处于then之前，finally应始终位于最后。
p.catch(() => console.log('reject handler')) 
 .then(() => console.log('resolve handler')) 
 .finally(() => console.log('finally handler')); 
// initial promise rejects 
// reject handler 
// resolve handler 
// finally handler
```



##### 期约图

​		因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。

​		下面的例子展示了一种期约有向图，也就是二叉树：

```js
/*
       A 
      / \ 
     B   C 
    / \ / \ 
   D  E F  G 
*/

let A = new Promise((resolve, reject) => { 
 	console.log('A'); 
 	resolve(); 
}); 

let B = A.then(() => console.log('B')); 
let C = A.then(() => console.log('C')); 

B.then(() => console.log('D')); 
B.then(() => console.log('E')); 
C.then(() => console.log('F')); 
C.then(() => console.log('G')); 
// A 
// B 
// C 
// D 
// E 
// F 
// G
```

​		注意，日志的输出语句是对二叉树的层序遍历。如前所述，期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历。

​		树只是期约图的一种形式。考虑到根节点不一定唯一，且多个期约也可以组合成一个期约（通过 `all()` 和 `race()` 静态方法），所以有向非循环图是体现期约连锁可能性的最准确表达。



##### `Promise.all`

​		`Promise` 类提供两个将多个期约实例组合成一个期约的静态方法：`Promise.all()` 和 `Promise.race()`。而合成后期约的行为取决于内部期约的行为。

​		`Promise.all()` 静态方法创建的期约会在一组期约全部兑现之后再兑现。这个静态方法接收一个可迭代对象，返回一个新期约：

```js
// Promise.all()只接受一个参数，首参中的每个元素都会被Promise.resolve()包装，其值将被数组收集并赋予[[PromiseResult]]槽位
Promise.all([ 
 	Promise.resolve(), 
 	Promise.resolve() 
]); 
/*
Promise {
	[[Prototype]]: Promise,
	[[PromiseState]]: "fulfilled",
	[[PromiseResult]]: [undefined, undefined]
}
*/

Promise.all([3, 4]); 
/*
Promise {
	[[Prototype]]: Promise,
	[[PromiseState]]: "fulfilled",
	[[PromiseResult]]: [3, 4]
}
*/

Promise.all([]);
/*
Promise {
	[[Prototype]]: Promise,
	[[PromiseState]]: "fulfilled",
	[[PromiseResult]]: []
}
*/

// 传入一个非可迭代对象，将得到一个拒绝期约，并伴随着一个未捕获的错误。
Promise.all(); // 默认传入：undefined。
/* 
> Promise {<rejected>: TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))}
> Uncaught (in promise) TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))
*/
```

​		合成的期约只会在每个包含的期约都兑现之后才兑现：

```js
let p = Promise.all([ 
 	Promise.resolve(), 
 	new Promise((resolve, reject) => setTimeout(resolve, 1000)) 
]);

setTimeout(console.log, 0, p); // Promise {<pending>}
p.then(() => setTimeout(console.log, 0, 'all() resolved!')); // "all() resolved!"（大约 1 秒后）
```

​		如果至少有一个包含的期约处于待定或拒绝状态，那么合成的期约也会待定或拒绝，且 `[[PromiseResult]]` 以非数组记录当前值：

```js
// 永远待定
let p1 = Promise.all([new Promise(() => {})]); 
setTimeout(console.log, 0, p1); // Promise {<pending>}

// 一次拒绝会导致最终期约拒绝
let p2 = Promise.all([ 
 	Promise.resolve(0), 
 	Promise.reject(1), 
 	Promise.resolve(2) 
]); 
setTimeout(console.log, 0, p2); 
/*
> Promise {<rejected>: 1}
> Uncaught (in promise) 1
*/
```

​		如果所有期约都成功兑现，则合成期约的兑现值就是所有包含期约兑现值的数组，按照迭代器顺序：

```js
let p = Promise.all([ 
 	Promise.resolve(3), 
 	Promise.resolve(), 
 	Promise.resolve(4) 
]); 

p.then((values) => setTimeout(console.log, 0, values)); // [3, undefined, 4]
```

​		如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：

```js
// 只有第一个期约的拒绝理由会进入拒绝处理程序，后续期约的拒绝会被静默处理，但不会成为拒绝理由。
let p = Promise.all([ 
	Promise.reject(3), 
 	new Promise((resolve, reject) => setTimeout(reject, 1000, 4)) // 静默处理，不会报错
]);

p.catch((reason) => setTimeout(console.log, 0, reason)); // 3
```



##### `Promise.race()`

​		`Promise.race()` 静态方法返回一个包装期约，是一组集合中最先兑现或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：【注：`race` 是**竞赛**的意思，在这里指 “竞争第一”，谁最先落定状态，新的合成期约就是谁】

```js
// 传入的迭代对象中的每个元素默认被Promise.resolve()包装，若是传入空对象，则进入待定状态。
Promise.race([ 
 	Promise.resolve(), 
 	Promise.resolve() 
]); // Promise {<fulfilled>: undefined}

Promise.race([3, 4]); // Promise {<fulfilled>: 3}

Promise.race([]); // Promise {<pending>}（相当于：new Promise(() => {})）

// 传入一个非可迭代对象，与all相似，将得到一个拒绝期约，并伴随着一个未捕获的错误。
Promise.race();
/*
> Promise {<rejected>: TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))}
> Uncaught (in promise) TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))
*/
```

​		`Promise.race()` 不会对兑现或拒绝的期约区别对待。无论是兑现还是拒绝，只要是第一个落定的期约，`Promise.race()` 就会包装其兑现值或拒绝理由并返回新期约：

```js
// 兑现先发生，超时后的拒绝被忽略
let p1 = Promise.race([ 
 	Promise.resolve(3), 
 	new Promise((resolve, reject) => setTimeout(reject, 1000)) 
]); 
setTimeout(console.log, 0, p1); // Promise {<fulfilled>: 3}

// 拒绝先发生，超时后的兑现被忽略
let p2 = Promise.race([ 
 	Promise.reject(4), 
 	new Promise((resolve, reject) => setTimeout(resolve, 1000)) 
]); 
setTimeout(console.log, 0, p2); // Promise {<rejected>: 4}

// 迭代顺序决定了落定顺序
let p3 = Promise.race([ 
 	Promise.resolve(5), 
 	Promise.resolve(6), 
 	Promise.resolve(7) 
]); 
setTimeout(console.log, 0, p3); // Promise {<fulfilled>: 5}
```

​		如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 `Promise.all()` 类似，合成的期约会静默处理所有包含期约的拒绝操作，如下所示：

```js
let p = Promise.race([ 
 	Promise.reject(3), 
 	new Promise((resolve, reject) => setTimeout(reject, 1000)) 
]);
p.catch((reason) => setTimeout(console.log, 0, reason)); // 3
```



##### 串行期约合成

​		到目前为止，我们讨论期约连锁一直围绕期约的串行执行，忽略了期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数，比如：

```js
function addTwo(x) {return x + 2;} 
function addThree(x) {return x + 3;} 
function addFive(x) {return x + 5;} 
function addTen(x) {return addFive(addThree(addTwo(x)));} 

console.log(addTen(7)); // 17
```

​		在这个例子中，有 3 个函数基于一个值合成为一个函数。类似地，期约也可以像这样合成起来，渐进地消费一个值，并返回最终值：

```js
function addTwo(x) {return x + 2;} 
function addThree(x) {return x + 3;} 
function addFive(x) {return x + 5;} 
function addTen(x) {
    // 默认将上一个期约向下传递：then()的新期约是基于上一个期约来进行创建的，新期约的值可以通过其回调值来指定。
 	return Promise.resolve(x) 		// Promise {<fulfilled>: x} ==> value: x
 				  .then(addTwo) 	// Promise {<fulfilled>: x + 2} == > value: x + 2
 				  .then(addThree) 	// Promise {<fulfilled>: x + 2 + 3} ==> value: x + 5
 				  .then(addFive); 	// Promise {<fulfilled>: x + 2 + 3 + 5} ==> value: x + 10
} 

addTen(8).then(console.log); // 18
```

​		使用 `Array.prototype.reduce()` 可以写成更简洁的形式：

```js
function addTwo(x) {return x + 2;} 
function addThree(x) {return x + 3;} 
function addFive(x) {return x + 5;} 
function addTen(x) {
    // 通过数组归并的方式，将多个期约合并成一个新的期约：reduce((既有归并值, 当前数组元素) => 计算归并值, 归并起点);
 	return [addTwo, addThree, addFive].reduce((promise, fn) => promise.then(fn), Promise.resolve(x)); 
} 

addTen(8).then(console.log); // 18
```

​		这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：

```js
function addTwo(x) {return x + 2;} 
function addThree(x) {return x + 3;} 
function addFive(x) {return x + 5;} 
function compose(...fns) { 
 	return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x)); 
}

// 传入任意多个处理程序，最终返回一个合成函数。
let addTen = compose(addTwo, addThree, addFive);
addTen(9).then(console.log); // 19
```



#### 期约扩展

​		`ES6` 期约实现是很可靠的，但它也有不足之处。比如，很多第三方期约库实现中具备而 `ECMAScript` 规范却未涉及的两个特性：期约取消和进度追踪。



##### 期约取消

​		我们经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。这时候如果能够取消期约就好了。某些第三方库，比如 `Bluebird`，就提供了这个特性。实际上，`TC39` 委员会也曾准备增加这个特性，但相关提案最终被撤回了。结果，`ES6` 期约被认为是“激进的”：只要期约的逻辑开始执行，就没有办法阻止它执行到完成。

​		实际上，可以在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。这可以用到 `Kevin Smith` 提到的**取消令牌**（`cancel token`）。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。下面是 `CancelToken` 类的一个基本实例：

```js
class CancelToken {
    // 生成一个取消令牌实例时，传入一个回调函数以获取取消期约的处理程序。
 	constructor(cancelFn) { 
 		this.promise = new Promise((resolve, reject) => { 
			cancelFn(resolve); // 传递取消期约的处理程序。
 		}); 
 	} 
}
```

​		这个类包装了一个期约，把解决方法暴露给了 `cancelFn` 参数。这样，外部代码就可以向构造函数中传入一个函数，从而控制什么情况下可以取消期约。这里期约是令牌类的公共实例成员，因此可以给它添加处理程序以取消期约。这个类大概可以这样使用：

```html
<button id="start">Start</button> 
<button id="cancel">Cancel</button> 

<script>
    // 定义一个构造取消令牌的类（工厂）
	class CancelToken {
        // 创建取消令牌时，传入一个回调。
     	constructor(cancelFn) { 
            // 在取消令牌实例上，添加一个promise属性，以维系一个取消期约。
     		this.promise = new Promise((resolve, reject) => { 
                // 执行回调，并向外传递取消处理程序。
    			cancelFn(() => { 
    				setTimeout(console.log, 0, "delay cancelled"); // 取消成功的提示信息
    				resolve(); // 兑现期约（提前兑现，相当于取消了期约）
    			}); 
     		}); 
     	} 
    } 
    
    const startButton = document.querySelector('#start'); 
    const cancelButton = document.querySelector('#cancel'); 
    
    // 定义一个可取消的延迟兑现处理程序，将其由start按钮触发。
    function cancellableDelayedResolve(delay) { 
     	setTimeout(console.log, 0, "set delay"); // 设置延迟的提示信息
        // 返回一个延迟期约
     	return new Promise((resolve, reject) => {
            // 延迟兑现该期约。
     		const id = setTimeout((() => { 
    			setTimeout(console.log, 0, "delayed resolve"); // 已延迟兑现的提示信息
    			resolve(); // 兑现
     		}), delay);
            // 创建一个取消令牌，传入一个回调，并期望获得一个取消处理程序。
          	const cancelToken = new CancelToken((cancelCallback) => {
                // 将获得的取消处理程序设置由cancel按钮触发。
            	return cancelButton.addEventListener("click", cancelCallback);
            });
            // 取消令牌被兑现之后，清除start按钮设置的超时。
     		cancelToken.promise.then(() => clearTimeout(id)); 
     	}); 
    } 
    
    // 将可取消的延迟兑现处理程序，添加到start按钮上。
    startButton.addEventListener("click", () => cancellableDelayedResolve(1000)); 
</script>
```

​		每次单击 `"Start"` 按钮都会开始计时，并实例化一个新的 `CancelToken` 的实例。此时，`"Cancel"` 按钮一旦被点击，就会触发令牌实例中的期约兑现。而兑现之后，单击 `"Start"` 按钮设置的超时（`setTimeout`）也会被取消。



##### 期约进度通知

​		执行中的期约可能会有不少离散的 “阶段”，在最终兑现之前必须依次经过。某些情况下，监控期约的执行进度会很有用。`ES6` 期约并不支持进度追踪，但是可以通过扩展来实现。一种实现方式是扩展 `Promise` 类，为它添加 `notify()` 方法，如下所示：

```js
class TrackablePromise extends Promise {
    // 创建一个可以被跟踪进度的期约，传入一个executor函数。
 	constructor(executor) { 
 		const notifyHandlers = []; // 创建一个收集跟踪回调的数组
        // 调用Promise的构造器，传入一个执行函数
 		super((resolve, reject) => {
            // 执行executor函数，传入三个回调：resolve、reject、(status) => {}
 			return executor(resolve, reject, (status) => {
                // 传入一个回调，为notifyHandlers数组中每个回调传递状态
 				notifyHandlers.map((handler) => handler(status)); // 执行回调，传递状态
 			}); 
 		}); 
 		this.notifyHandlers = notifyHandlers; 
 	} 
 	notify(notifyHandler) { 
 		this.notifyHandlers.push(notifyHandler); // 收集回调
 		return this; // 返回期约
 	} 
}
```

​		这样，`TrackablePromise` 就可以在执行函数中使用 `notify()` 函数了。可以像下面这样使用这个函数来实例化一个期约：

```js
let p = new TrackablePromise((resolve, reject, notify) => { 
 	function countdown(x) { 
 		if (x > 0) { 
 			notify(`${20 * x}% remaining`); // 传入状态
 			setTimeout(() => countdown(x - 1), 1000); // 每秒递归一次
 		} else { 
 			resolve(); // 递归完毕，兑现期约
 		} 
 	} 
 	countdown(5); // 递归5次
});
```

​		这个期约会连续 5 次递归地设置 1 秒的超时。每个超时回调都会调用 `notify()` 并传入状态值。假设通知处理程序简单地这样写：

```js
p.notify((x) => setTimeout(console.log, 0, 'progress:', x)); 
p.then(() => setTimeout(console.log, 0, 'completed')); 

// （约 1 秒后）progress: 80% remaining
// （约 2 秒后）progress: 60% remaining
// （约 3 秒后）progress: 40% remaining
// （约 4 秒后）progress: 20% remaining
// （约 5 秒后）completed
```

​		`notify()` 会返回期约，所以可以连缀调用，连续添加处理程序。多个处理程序会针对收到的每条消息分别执行一遍，如下所示：

```js
p.notify((x) => setTimeout(console.log, 0, 'a:', x)) 
 .notify((x) => setTimeout(console.log, 0, 'b:', x));

p.then(() => setTimeout(console.log, 0, 'completed'));

// （约 1 秒后） a: 80% remaining 
// （约 1 秒后） b: 80% remaining 
// （约 2 秒后） a: 60% remaining 
// （约 2 秒后） b: 60% remaining 
// （约 3 秒后） a: 40% remaining 
// （约 3 秒后） b: 40% remaining 
// （约 4 秒后） a: 20% remaining 
// （约 4 秒后） b: 20% remaining 
// （约 5 秒后） completed
```

​		总体来看，这还是一个比较粗糙的实现，但应该可以演示出如何使用通知报告进度了。

​		注意：`ES6` 不支持取消期约和进度通知，一个主要原因就是这样会导致期约连锁和期约合成过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了通知，那么接下来应该发生什么完全说不清楚。毕竟，如果取消了 `Promise.all()` 中的一个期约，或者期约连锁中前面的期约发送了一个通知，那么接下来应该怎么办才比较合理呢？

<hr>



### 异步函数

​		异步函数，也称为 `"async/await"`（语法关键字），是 `ES6` 期约模式在 `ECMAScript` 函数中的应用。`async/await` 是 `ES8` 规范新增的。这个特性从行为和语法上都增强了 `JavaScript`，让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会兑现为一个值：

```js
new Promise((resolve, reject) => setTimeout(resolve, 1000, 3)); // Promise {<pending>}（约1秒后，更改状态及值）
/*
Promise {
	[[Prototype]]: Promise,
	[[PromiseState]]: "fulfilled",
	[[PromiseResult]]: 3
}
*/
```

​		这个期约在 1000 毫秒之后兑现为数值 3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个兑现处理程序：

```js
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3)); 

// 通过then中的onResolved回调来接受兑现值
p.then((x) => console.log(x)); // 3
```

​		这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序抽取为一个函数：

```js
function handler(x) { console.log(x); } 

let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3)); 

p.then(handler); // 3
```

​		这个改进其实也不大。因为任何需要访问这个期约兑现值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。`ES8` 为此提供了 `async/await` 关键字。



#### 异步函数

​		`ES8` 的 `async/await` 旨在解决利用异步结构组织代码的问题。为此，`ECMAScript` 对函数进行了扩展，为其增加了两个新关键字：`async` 和 `await`。



##### `async`

​		`async` 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：

```js
async function foo() {} 

let bar = async function() {}; 
let baz = async () => {}; 

class Qux { 
 	async qux() {} 
}
```

​		使用 `async` 关键字可以让函数**具有异步特征**，但总体上其代码仍然是**同步求值**的。而在参数或闭包方面，异步函数仍然具有普通 `JavaScript` 函数的正常行为。正如下面的例子所示，`foo()` 函数仍然会在后面的指令之前被求值：

```js
async function foo() { 
 	console.log(1); 
}

foo();
console.log(2); 
// 1
// 2
```

​		不过，异步函数的返回值会被 `Promise.resolve()` 包装成一个期约对象。异步函数始终返回该期约对象。在函数外部调用这个函数可以得到它返回的期约：

```js
async function foo() { 
 	console.log(1); 
 	return 3; 
}

foo(); // 1, Promise {<fulfilled>: 3}

// 给返回的期约添加一个解决处理程序
foo().then(console.log);
console.log(2); 
// 1 
// 2 
// 3
```

​		当然，直接返回一个期约对象也是一样的：

```js
async function foo() { 
 	console.log(1); 
 	return Promise.resolve(3); 
}

foo(); // 1, Promise {<fulfilled>: 3}

// 给返回的期约添加一个解决处理程序
foo().then(console.log); 
console.log(2); 
// 1 
// 2 
// 3
```

​		异步函数期待（实际上并不要求）返回一个实现 `thenable` 接口的对象值，但常规的值也可以。如果返回的是实现 `thenable` 接口的对象，则这个对象可以由提供给 `then()` 的处理程序 “解包”。如果不是，那么返回值就会被当作已经兑现了的期约值。下面的代码演示了这些情况：

```js
// 返回一个原始值 
async function foo() { 
 	return 'foo'; 
} 
foo().then(console.log); // foo

// 返回一个没有实现 thenable 接口的对象
async function bar() { 
 	return ['bar']; 
} 
bar().then(console.log); // ['bar']

// 返回一个实现了 thenable 接口的非期约对象
async function baz() { 
 	const thenable = { 
 		then(callback) { callback('baz'); } 
 	}; 
 	return thenable; 
} 
baz().then(console.log); // baz

// 返回一个期约
async function qux() { 
 	return Promise.resolve('qux'); 
} 
qux().then(console.log); // qux
```

​		与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：

```js
async function foo() { 
 	console.log(1); 
 	throw 3; 
} 

// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log);
console.log(2); 
// 1 
// 2 
// 3
```

​		不过，拒绝期约所产生的错误不会被异步函数捕获：

```js
async function foo() { 
 	console.log(1); 
 	Promise.reject(3); 
} 

foo().catch(console.log); 
console.log(2); 
// 1 
// 2 
// Uncaught (in promise): 3
```



##### `await`

​		因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 `await` 关键字可以暂停异步函数代码的执行，等待期约兑现（**对于 `await` 来说，期约才是它的最想等待的人**）。来看下面这个出现过的例子：

```js
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3)); 

// 等待状态转为：兑现，然后执行回调
p.then((x) => console.log(x)); // 3
```

​		使用 `async/await` 可以写成这样：

```js
async function foo() { 
 	let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3)); 
 	console.log(await p); // 等待兑现状态，然后打印兑现值
}

foo(); // 3
```

​		注意，`await` 关键字会暂停执行异步函数后面的代码，让出 `JavaScript` 运行时的执行线程。这个行为与生成器函数中的 `yield` 关键字是一样的。`await` 关键字同样是尝试 “解包” 对象的值，然后将这个值传给表达式执行，再异步恢复异步函数的执行。

```js
async function foo() {
   	console.log(2); // 注意：2！！！
    let p = new Promise((resolve, reject) => setTimeout(resolve, 0, 4));
    console.log(await p); // 暂停函数的执行（立即退出执行栈并进入异步线程）！等待兑现状态，然后打印兑现值
    console.log(5);
    setTimeout(console.log, 0, 7);
}

console.log(1);
foo();
setTimeout(console.log, 0, 6);
console.log(3); // 注意：3！！！

/*
> 1
> 2
> 3
> 4
> 5
> 6
> 7
*/
```

​		`await` 关键字的用法与 `JavaScript` 的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示：

```js
// await之后必须要有一个值（在控制台中）
await; // Uncaught SyntaxError: Unexpected end of input

await undefined; // undefined

await 1; // 1

await [1, 2]; // [1, 2]

await new Promise((resolve, reject) => resolve('end')); // 'end'

await { then(callback) { callback('foo'); }} // 'foo'
```

```js
// 异步打印"foo" 
async function foo() { 
 	console.log(await Promise.resolve('foo')); 
} 
foo(); // foo 

// 异步打印"bar" 
async function bar() { 
 	return await Promise.resolve('bar'); 
} 
bar().then(console.log); // bar 

// 1000 毫秒后异步打印"baz" 
async function baz() { 
 	await new Promise((resolve, reject) => setTimeout(resolve, 1000)); 
 	console.log('baz'); 
} 
baz(); // baz（1000 毫秒后）
```

​		`await` 关键字期待（但实际上并不要求）一个实现 `thenable` 接口的对象，但常规的值也可以。如果是实现 `thenable` 接口的对象，则这个对象可以由 `await` 来 “解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：

```js
// 等待一个原始值 
async function foo() { 
 	console.log(await 'foo'); 
} 
foo(); // foo

// 等待一个没有实现 thenable 接口的对象
async function bar() { 
 	console.log(await ['bar']); 
} 
bar(); // ['bar']

// 等待一个实现了 thenable 接口的非期约对象
async function baz() { 
 	const thenable = { 
 		then(callback) { callback('baz'); } // 禁止callback(this)，否则会进入死循环状态（详见下文）。
 	}; 
 	console.log(await thenable); // 自动解包调用then方法，实际上相当于：thenable.then(console.log);
} 
baz(); // baz 

// 等待一个期约
async function qux() { 
 	console.log(await Promise.resolve('qux')); 
} 
qux(); // qux
```

```js
function fn(x) {
    console.log(x);
}

// 在async函数中：fn(await thenable);相当于thenable.then(fn);，但它们有一个重要的区别。
// 这个区别就是：await禁止在执行thenable接口的callback时，传出该接口，否则会进入死循环状态。
async function baz() { 
 	const thenable = { 
 		then(callback) { callback('baz'); } // 禁止在此：callback(this);或callback(thenable);
 	}; 
 	fn(await thenable);
} 
baz(); // baz

// 使用thenable.then(fn)替换：
async function baz() { 
 	const thenable = { 
 		then(callback) { callback('baz'); }
 	}; 
 	thenable.then(fn);
} 
baz(); // baz
```

​		等待一个将抛出错误的同步操作，会返回拒绝的期约：

```js
async function foo() { 
 	console.log(1); 
 	await (() => { throw 3; })(); // throw的值，将成为新期约的拒绝理由
}

foo();
/*
> Promise {<rejected>: 3}
> Uncaught (in promise) 3
*/

foo().catch(console.log);
console.log(2); 
// 1 
// 2 
// 3
```

​		如前面的例子所示，`Promise.reject()` 所产生的错误不会被异步函数捕获，会抛出未捕获错误。不过，对拒绝的期约使用 `await` 则会释放（`unwrap`）错误值（将拒绝期约返回），而不会报错：

```js
async function foo() { 
 	console.log(1); 
 	await Promise.reject(3); // 基于拒绝理由，创建并返回一个新的拒绝期约，且错误可以被捕获。
 	console.log(4); // 这行代码不会执行
}

foo();
/*
> Promise {<rejected>: 3}
> Uncaught (in promise) 3
*/

foo().catch(console.log); 
console.log(2); 
// 1 
// 2 
// 3
```



##### `await` 的限制

​		通常，`await` 关键字只能在异步函数中使用，不能在顶级上下文如 `<script>` 标签或模块中使用。

```js
async function foo() { 
 	console.log(await Promise.resolve(3)); 
} 
foo(); // 3 

// 立即调用的异步函数表达式
(async function() { 
 	console.log(await Promise.resolve(3)); 
})(); // 3
```

​		不过，其实在 `console` 控制台中也可以直接使用 `await` 关键字。

![image-20221103221430487](images/%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5/image-20221103221430487.png)

​		此外，异步函数的特质（指：异步特征）不会扩展到嵌套函数。因此，`await` 关键字也只能直接出现在 `async` 函数的定义中。在同步函数内部使用 `await` 会抛出 `SyntaxError`。下面展示了一些会出错的例子：

```js
// 合法的
(async function () {
    return await 1; // return值将成为兑现值
})(); // Promise {<fulfilled>: 1}

// 合法的
(async function () {
    return (async function () {
    	return await 1; // return值将成为兑现值
	})();
})(); // Promise {<fulfilled>: 1}

// 非法的
(async function () {
    return (function () {
    	return await 1; // return值将成为兑现值
	})();
})(); // Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules
```

```js
// 如上所示，await不允许出现在同步函数中：只在异步函数和模板的顶层主体中才是合法的！！！
// 箭头函数
function foo() { 
 	const syncFn = () => { 
 		return await Promise.resolve('foo'); 
 	}; 
 	console.log(syncFn());
} // Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules

// 普通函数
function bar() { 
 	function syncFn() { 
 		return await Promise.resolve('bar'); 
 	} 
 	console.log(syncFn()); 
} // Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules

// 函数表达式
function baz() { 
 	const syncFn = function() { 
 		return await Promise.resolve('baz'); 
 	}; 
 	console.log(syncFn()); 
} // Uncaught SyntaxError: await is only valid in async functions and the top level bodies of modules

// IIFE同步函数表达式或箭头函数
function qux() { 
 	(function () { console.log(await Promise.resolve('qux')); })(); 
 	(() => console.log(await Promise.resolve('qux')))(); 
} // Uncaught SyntaxError: missing ) after argument list
```



#### 暂停与恢复

​		使用 `await` 关键字之后的区别其实比看上去的还要微妙一些。比如，下面的例子中按顺序调用了 3 个函数，但它们的输出结果顺序却出人意外：

```js
async function foo() { 
 	console.log(await Promise.resolve('foo')); 
}

async function bar() { 
 	console.log(await 'bar'); 
}

async function baz() { 
 	console.log('baz'); 
} 
foo(); // 执行，异步暂停等待（首先进入异步线程的任务，首先恢复执行）
bar(); // 执行，异步暂停等待
baz(); // 执行，同步输出打印
// baz
// foo
// bar
```

​		`async/await` 中真正起作用的是 `await`。`async` 关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含 `await` 关键字，其执行基本上跟普通函数没有什么区别，除了返回值不同之外：

```js
async function foo() { 
 	console.log(2); 
}

console.log(1); 
foo(); 
console.log(3);
/*
> 1
> 2
> 3
*/
```

​		要完全理解 `await` 关键字，必须知道它并非只是等待一个可用值那么简单。`JavaScript` 运行时在碰到 `await` 关键字时，会记录在哪里暂停执行。等到 `await` 右边的值可用了，`JavaScript` 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。

​		因此，即使 `await` 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。下面的例子演示了这一点：

```js
async function foo() { 
 	console.log(2); // 同步执行(3) 
 	await null; // 暂定执行，跳出函数，异步等待(4)
 	console.log(4); // 同步执行，退出函数(6)
}

console.log(1); // 同步执行(1)
foo(); // 同步执行(2)
console.log(3); // 同步执行，执行栈空，异步恢复(5)
// 1 
// 2 
// 3 
// 4
```

​		如果 `await` 后面是一个期约，则问题会稍微复杂一些。过去，为了执行异步函数，实际上会有两个任务被添加到消息队列并被异步求值。现在，则遵循 "先等待，先恢复" 的基本准则，如果恢复后还有异步任务，依旧如此。

```js
async function foo() { 
 	console.log(2); 
 	console.log(await Promise.resolve(6)); // 即使立即兑现，仍须异步等待
 	console.log(7); 
}

async function bar() {
	console.log(4); 
 	console.log(await 8); // 与立即兑现一样，即使立即获得可用值，仍须异步等待
 	console.log(9); 
}

console.log(1); 
foo(); 
console.log(3); 
bar(); 
console.log(5); 
// 1 
// 2 
// 3 
// 4 
// 5 
// 6 
// 7 
// 8 
// 9
```

​		`TC39` 对 `await` 后面是期约的情况做过一次优化。修改后，本例中的 `await Promise.resolve(6)` 只会生成一个异步任务。因此在新版浏览器中，这个示例的输出结果为 123458967。实际开发中，对于并行的异步操作我们通常更关注其结果，而不依赖执行顺序。



#### 异步函数策略

​		由于简单实用，异步函数很快成为 `JavaScript` 项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。



##### 实现 `sleep()`

​		很多人在刚开始学习 `JavaScript` 时，想找到一个类似 `Java` 中 `Thread.sleep()` 之类的函数，好在程序中加入非阻塞的暂停。以前，这个需求基本上都通过 `setTimeout()` 利用 `JavaScript` 运行时的行为来实现的。

​		有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 `sleep()`：

```js
async function sleep(delay) { 
 	return new Promise((resolve) => setTimeout(resolve, delay)); // 延迟兑现期约
} 

async function foo() { 
 	const t0 = Date.now(); 
 	await sleep(1500); // 同步执行sleep，异步等待，恢复执行
 	console.log(Date.now() - t0); 
} 

foo(); // 1514
```



##### 利用平行执行

​		如果使用 `await` 时不留心，则很可能错过平行加速的机会。来看下面的例子，其中顺序等待了 5 个随机的超时：

```js
async function randomDelay(id) { 
 	// 随机延迟 0~1000 毫秒
 	const delay = Math.random() * 1000; // 范围：[0, 1000)
    // 返回一个延迟兑现的期约
 	return new Promise((resolve) => setTimeout(() => { // 定时器开启异步线程（执行栈转而执行异步函数外部的同步代码）
 		console.log(`${id} finished`); 
 		resolve(); 
 	}, delay)); 
} 

async function foo() { 
 	const t0 = Date.now(); 
    // 注意：一旦等待就意味着进入异步线程，连续执行多个await时，必须在上一个await恢复并执行完毕之后，才开始下一个await语句。
 	await randomDelay(0); // 同步线程中，执行randomDelay(0)，暂停执行，异步等待，异步恢复，下一行代码。
 	await randomDelay(1); // 异步线程中，执行randomDelay(1)，暂定执行，异步等待，恢复执行，下一行代码。
 	await randomDelay(2); // 异步线程中，执行randomDelay(2)，暂定执行，异步等待，恢复执行，下一行代码。
 	await randomDelay(3); // 异步线程中，执行randomDelay(3)，暂定执行，异步等待，恢复执行，下一行代码。
 	await randomDelay(4); // 异步线程中，执行randomDelay(4)，暂定执行，异步等待，恢复执行，下一行代码。
 	console.log(`${Date.now() - t0}ms elapsed`); // 异步线程中，打印输出，退出函数，释放线程。
} 

foo(); 
// 0 finished 
// 1 finished 
// 2 finished 
// 3 finished 
// 4 finished 
// 2502ms elapsed
```

​		注释：异步函数一旦进入等待状态或遇到异步任务，就意味着它（整个函数）已经进入了异步线程（如果有的话将转而执行外部的同步代码，直至同步执行栈清空后，才会得到恢复）。因此，当在异步函数中执行多个等待时，其实也会发生异步阻塞等待。也就是说，多个等待将会在异步线程中依次执行：必须在上一个等待恢复并执行完毕（即：释放异步线程）之后，才会开始执行下一个等待。

​		用一个 `for` 循环重写，就是：

```js
async function randomDelay(id) { 
 	// 延迟 0~1000 毫秒
 	const delay = Math.random() * 1000; 
 	return new Promise((resolve) => setTimeout(() => { 
 		console.log(`${id} finished`); 
 		resolve(); 
 	}, delay)); 
} 

async function foo() { 
 	const t0 = Date.now(); 
 	for (let i = 0; i < 5; ++i) { 
 		await randomDelay(i); 
 	} 
 	console.log(`${Date.now() - t0}ms elapsed`); 
}

foo(); 
// 0 finished 
// 1 finished 
// 2 finished 
// 3 finished 
// 4 finished 
// 2387ms elapsed
```

​		就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成并转换状态。这样可以保证执行顺序，但总执行时间会变长。如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。比如：

```js
async function randomDelay(id) { 
 	// 延迟 0~1000 毫秒
 	const delay = Math.random() * 1000; 
 	return new Promise((resolve) => setTimeout(() => { 
 		setTimeout(console.log, 0, `${id} finished`); 
 		resolve(); 
 	}, delay)); 
}

async function foo() { 
 	const t0 = Date.now(); 
 	const p0 = randomDelay(0); // 初始化期约
 	const p1 = randomDelay(1); // 初始化期约
 	const p2 = randomDelay(2); // 初始化期约
 	const p3 = randomDelay(3); // 初始化期约
 	const p4 = randomDelay(4); // 初始化期约
 	await p0; // 异步等待状态
 	await p1; // 异步等待状态
 	await p2; // 异步等待状态
 	await p3; // 异步等待状态
 	await p4; // 异步等待状态
 	setTimeout(console.log, 0, `${Date.now() - t0}ms elapsed`); // 异步输出打印
}

foo(); 
// 2 finished
// 1 finished 
// 3 finished 
// 0 finished 
// 4 finished 
// 888ms elapsed
```

​		用数组和 `for` 循环再包装一下就是：

```js
async function randomDelay(id) { 
 	// 延迟 0~1000 毫秒
 	const delay = Math.random() * 1000; 
 	return new Promise((resolve) => setTimeout(() => { 
 		console.log(`${id} finished`); 
 		resolve(); 
 	}, delay)); 
}

async function foo() { 
 	const t0 = Date.now(); 
 	const promises = Array(5).fill(null).map((_, i) => randomDelay(i)); 
 	for (const p of promises) { 
 		await p; 
 	} 
 	console.log(`${Date.now() - t0}ms elapsed`); 
}

foo(); 
// 2 finished 
// 3 finished 
// 4 finished 
// 1 finished 
// 0 finished 
// 505ms elapsed
```

​		注意，虽然由于随机延时，期约没有固定的兑现顺序，但 `await` 按顺序执行并接收每个期约的值：

```js
async function randomDelay(id) { 
 	// 延迟 0~1000 毫秒
 	const delay = Math.random() * 1000; 
 	return new Promise((resolve) => setTimeout(() => { 
 		console.log(`${id} finished`); 
 		resolve(id); // 期约按照延迟随机兑现
 	}, delay)); 
} 

async function foo() { 
 	const t0 = Date.now(); 
 	const promises = Array(5).fill(null).map((_, i) => randomDelay(i)); 
 	for (const p of promises) { 
 		console.log(`awaited ${await p}`); // 按照顺序，依次等待
 	} 
 	console.log(`${Date.now() - t0}ms elapsed`); 
} 

foo();
// 0 finished
// awaited 0
// 2 finished
// 1 finished
// awaited 1
// awaited 2
// 3 finished
// awaited 3
// 4 finished
// awaited 4
// 978ms elapsed
```



##### 串行执行期约

​		在前面，我们讨论过如何串行执行期约并把值传给后续的期约。使用 `async/await`，期约连锁会变得很简单：

```js
function addTwo(x) {return x + 2;} 
function addThree(x) {return x + 3;} 
function addFive(x) {return x + 5;} 

async function addTen(x) { 
 	for (const fn of [addTwo, addThree, addFive]) { 
 		x = await fn(x); // 立即可用的值
 	} 
 	return x; // x = x + 2 + 3 + 5;
} 

addTen(9).then(console.log); // 19
```

​		这里，`await` 直接传递了每个函数的返回值，结果通过迭代产生。当然，这个例子并没有使用期约，如果要使用期约，则可以把所有函数都改成异步函数。这样它们就都返回期约了：

```js
async function addTwo(x) {return x + 2;} 
async function addThree(x) {return x + 3;} 
async function addFive(x) {return x + 5;} 

async function addTen(x) { 
 	for (const fn of [addTwo, addThree, addFive]) { 
 		x = await fn(x); // 待兑现的期约
 	} 
 	return x; 
} 

addTen(9).then(console.log); // 19
```



##### 栈追踪与内存管理

​		期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。看看下面的例子，它展示了拒绝期约的栈追踪信息：

```js
function fooPromiseExecutor(resolve, reject) { 
 	setTimeout(reject, 1000, 'bar');
} 

function foo() { 
 	new Promise(fooPromiseExecutor); 
}

foo(); 
/* 
⨂  ▼ Uncaught (in promise) bar
 	setTimeout (async) 
 	fooPromiseExecutor 
 	foo
 	(anonymous) 
*/
```

​		根据对期约的不同理解程度，以上栈追踪信息可能会让某些读者不解。**栈追踪信息**应该相当直接地表现 `JavaScript` 引擎当前栈内存中**函数调用之间的嵌套关系**。在超时处理程序执行时和拒绝期约时，我们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这些函数已经返回了，因此栈追踪信息中不应该看到它们。

​		答案很简单，这是因为 `JavaScript` 引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。如果在前面的例子中使用的是异步函数，那又会怎样呢？比如：

```js
function fooPromiseExecutor(resolve, reject) { 
 	setTimeout(reject, 1000, 'bar'); 
} 

async function foo() { 
 	await new Promise(fooPromiseExecutor); 
} 

foo(); 
/* 
⨂  ▼ Uncaught (in promise) bar
	foo
	await in foo (async)
	(anonymous)
*/
```

​		这样一改，栈追踪信息就准确地反映了当前的调用栈。`fooPromiseExecutor()` 已经返回，所以它不在错误信息中。但 `foo()` 此时被挂起了，并没有退出。`JavaScript` 运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。

更多参考：[错误和堆栈跟踪](https://www.51cto.com/article/538067.html)、[内存管理分析和 `V8` 堆栈执行](https://blog.csdn.net/qq_34051666/article/details/125485128)、[`console.trace`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace)

调用栈：直观展示函数调用之间的嵌套关系；其实描述了程序控制权的流动过程。

栈信息：某一时刻，函数之间的调用关系，栈帧；使用 `console.trace` 来查看。

执行流：调用顺序：从栈顶（朝下）到栈底（朝上）；返回顺序：从栈底到栈顶。

<hr>



## `MDN`

### 描述

​		`Promise` 对象表示一个异步操作的最终完成（或失败）及其结果值。**备注：** 此特性在 [`Web Worker`](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API) 中可用。

​		要了解承诺的工作方式以及如何使用它们，我们建议您先阅读 [`Using promises`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)。

​		期约是一个在它被创建时不必要知道其值的代理。它允许您将处理程序与异步操作的最终成功值或失败原因关联起来。这使得异步方法像同步方法一样返回值：异步方法不是立即返回最终值，而是返回一个在未来的某个时刻提供该值的期约。

​		一个期约将始终处于以下状态之一：

- `pending`：初始状态，它可以一直保持该状态，或者要么转为 `fulfilled`，要么转为 `rejected`。
- `fulfilled`：当转为该状态，意味着操作已经成功完成。
- `rejected`：当转为该状态，意味着操作因意外失败了。

​		待定（`pending`）期约的最终状态要么用一个值来兑现（`fulfilled`），要么用一个原因（`error`）来拒绝（`rejected`）。当出现这两个选项中的任何一个时，将调用由 `promise` 的 `then` 方法排队等候的相关处理程序。如果在附加相应的处理程序时承诺已经实现或拒绝，则该处理程序将被调用，因此在异步操作完成和附加其处理程序之间不存在竞态条件。

​		如果一个承诺被履行（`fulfilled`）或被拒绝（`rejected`），而非悬而未决时（`pending`），就会被称为已落定（`settled`）。

​                 ![Flowchart showing how the Promise state transitions between pending, fulfilled, and rejected via then/catch handlers. A pending promise can become either fulfilled or rejected. If fulfilled, the "on fulfillment" handler, or first parameter of the then() method, is executed and carries out further asynchronous actions. If rejected, the error handler, either passed as the second parameter of the then() method or as the sole parameter of the catch() method, gets executed.](images/%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5/promises.png) 

​		你还会听到一个经常与承诺一起使用的 `resolved` 术语 —— 它意味着承诺已落定（`settled`）或为了匹配另一个承诺的最终状态而被 “锁定”，并且进一步解决（`resolving`）或拒绝（`rejecting`）它不会产生任何效果。最初 `Promise` 提案中的 [`States and fates`](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md) 文档包含关于 `Promise` 术语的更多细节。通俗地讲，`resolved` 的承诺通常等同于 `fulfilled` 的承诺，但正如 `"States and fates"` 中所说明的那样，已解决（`resolved`）的承诺也可以是待决的（`pending`）或被拒绝的（`rejected`）。例如：

```js
new Promise((resolveOuter) => {
  	resolveOuter(
    	new Promise((resolveInner) => {
      		setTimeout(resolveInner, 1000);
    	})
  	);
});
```

​		这个承诺在创建时就已经被解决（`resolved`）了（因为 `resolveOuter` 是同步调用的），但它是用另一个承诺来 `resolved` 的，因此直到约 1 秒后的内部承诺履行（`fulfills`）时它才会被兑现（`fulfilled`）。在实践中，“解决”（`resolution`）往往是在幕后完成且不可观察的，只有它的兑现（`fulfillment`）或拒绝（`rejection`）才会被看到。

​		注意：其他一些语言有惰性计算和延迟计算的机制，它们也叫做“承诺”（`promises`），例如 `Scheme`。在 `JavaScript` 中，承诺表示可以用回调函数链起来（即：链式调用）的已经发生的进程（`processes`）。如果你想对一个表达式进行惰性求值，你可以考虑使用一个不带参数的函数，例如 `f = () => expression` 来创建惰性求值的表达式，然后 `f()` 用来立即求值表达式。



#### 链式承诺

​		`Promise.prototype.then()`、`Promise.prototype.catch()` 和 `Promise.prototype.finally()` 方法用于将进一步的操作与已落定的承诺关联起来。由于这些方法返回承诺，所以可以将它们链接起来（链式调用）。

​		`then()` 方法最多接受两个参数：第一个参数是承诺兑现（`fulfilled`）情况的回调函数，第二个参数是拒绝（`rejected` ）情况的回调函数。每个 `then()` 返回一个新生成的 `promise` 对象，它可以可选地用于链式调用；例如：

```js
const myPromise = new Promise((resolve, reject) => {
  	setTimeout(() => {
    	resolve("foo");
  	}, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);
```

​		即使 `then()` 缺少返回 `Promise` 对象的回调函数，处理也会继续进行到调用链的下一个链环。因此，调用链可以安全地忽略每个拒绝回调函数，直到最后的 `catch()`。

```js
const promise = new Promise((resolve) => {
    setTimeout(() => resolve("foo"), 500);
});

promise.then().then().then(); // Promise {<fulfilled>: 'foo'}
```

​		在每个 `then()` 中处理一个被拒绝的承诺会对承诺链的下游产生影响。有时毫无选择，因为必须立即处理错误。在这种情况下，我们必须抛出某种类型的错误，以维护错误状态沿链向下。另一方面，在没有立即需要的情况下，将错误处理保留到最后的 `catch()` 语句更简单。`catch()` 实际上只是一个没有为承诺兑现情况的回调函数提供插槽的 `then()`。

```js
// 注释：catch实际上是then，只是它不像then那样，为承诺兑现情况的回调函数提供插槽。
// 简单地说，then具有两个插槽：onFufilled和onRejected，而catch只有一个onRejected插槽。
myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC)
  .catch(handleRejectedAny);
```

​		注意：为了更快地执行，最好在一个处理程序中完成所有同步操作，否则将需要数个瞬间（`ticks`）来按序执行所有处理程序。

​		承诺的终止条件决定了链中下一个承诺的落定状态。`"fulfilled"` 状态表示承诺成功完成，而 `"rejected"` 状态表示没有成功。链中每个已兑现的承诺的返回值会沿着链被传递给下一个 `then()`，而拒绝的原因被传递给链中的下一个拒绝处理函数。

​		链条上的承诺像俄罗斯套娃一样嵌套，但却像在栈顶一样被弹出。链上的第一个承诺嵌套最深，也是最先弹出的（类似层层汇报）。

```js
new Promise((resolve, rejecte) => resolve("A"))
	.then(() => "B")
	.then(() => "C")
	.then(() => "D");

// 层层嵌套，层层汇报 —— 上层的决定取决于下层的汇报。
(promise D, (promise C, (promise B, (promise A) ) ) ) // 嵌套关系：A被B包裹、B被C包裹、C被D包裹。
```

​		当 `nextValue` 是一个承诺时，其效果是动态替换。`return` 导致一个承诺被弹出，但 `nextValue` 承诺被推到它的位置。对于上面所示的嵌套，假设与 `"promise B"` 关联的 `then()` 返回一个 `"promise X"` 的 `nextValue`。合成的嵌套看起来会像这样：

```js
(promise D, (promise C, (promise X) ) )
```

​		一个承诺可以参与多个嵌套。对于下面的代码，将 `promise A` 转换为落定状态将导致 `then()` 的两个实例被执行。

```js
const promiseA = new Promise(myExecutorFunc);

const promiseB = promiseA.then(handleFulfilled1, handleRejected1);
const promiseC = promiseA.then(handleFulfilled2, handleRejected2);
```

​		一个操作可以分配给一个已落定的承诺。在这种情况下，操作（如果合适）将在第一次异步时执行。注意，承诺肯定是异步的。因此，对已落定承诺的操作只会在栈被清空并经过一个时钟周期之后发生。其效果非常类似于 `setTimeout(action, 10)`。

```js
const promiseA = new Promise((resolutionFunc, rejectionFunc) => {
  	resolutionFunc(777); // 在同步执行中兑现
});

// 此时，"promiseA" 已落定为兑现
promiseA.then((val) => console.log("asynchronous logging has val:", val)); // 异步执行回调
console.log("immediate logging"); // 同步执行输出
// immediate logging
// asynchronous logging has val: 777
```



#### `Thenables`

​		早在 `Promise` 成为该语言的一部分之前，`JavaScript` 生态系统就已经有了多种承诺实现。尽管在内部表示方式不同，但至少，所有类 `promise` 对象都实现了 `Thenable` 接口。`thenable` 实现了 `then()` 方法，该方法由两个回调函数调用：一个用于兑现承诺时，一个用于拒绝承诺时。承诺同样也是 `thenables`。

​		为了与现有的 `Promise` 实现进行互操作，该语言**允许使用 `thenables` 来代替 `Promise`**。例如， `Promise.resolve` 不仅会解决承诺，也会追踪 `thenables`。

```js
const aThenable = {
  	then(onFulfilled, onRejected) {
    	onFulfilled({
      		// The thenable is fulfilled with another thenable
      		then(onFulfilled, onRejected) {
        		onFulfilled(42);
      		},
    	});
  	},
};

Promise.resolve(aThenable); // A promise fulfilled with 42
```



#### 承诺并发

`Promise` 类提供了四种静态方法来推进异步任务并发：

- `Promise.all`：在所有承诺都兑现（`fulfill`）时兑现；在任何一个承诺被拒绝（`rejects`）时拒绝。
- `Promise.allSettled`：在所有承诺都落定（`settle`）时兑现。
- `Promise.any`：在任何一个承诺兑现时兑现；在所有承诺都拒绝时拒绝。
- `Promise.race`：在任何一个承诺落定时落定。换句话说，在任何一个承诺兑现时兑现；在任何一个承诺被拒绝时拒绝。

​		所有这些方法都接受一个承诺（确切地说，是 `thenables`）的可迭代对象，并返回一个新的承诺。它们都支持子类化，这意味着可以在 `Promise` 的子类上调用它们，然后结果将是一个子类类型的 `promise`。为此，子类的构造函数必须实现与 `Promise()` 构造函数相同的签名——接受一个唯一的执行器函数，该函数可以用 `resolve` 和 `reject` 回调作为参数调用。子类还必须有一个 `resolve` 静态方法，它要可以像 `Promise.resolve()` 那样调用以将值 `resolve` 为 `promise`。

​		注意，`JavaScript` 本质上是单线程的，因此在给定的时刻，只会有一个任务正在执行，尽管控制流可以在不同的承诺之间转移，使得承诺的执行看起来是并发的。`JavaScript` 中的并行执行只能通过工作者线程（[`worker threads`](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)）实现。



#### 构造器

`Promise()`：创建一个新的 `Promise` 对象。构造函数主要用于包装不支持承诺的函数。



#### 静态方法

​		`Promise` 目前共有 6 个静态方法：`all`，`allSettled`，`any`，`race`，`reject` 和 `resolve`。

##### `Promise.all`

​		等待所有的承诺都被兑现，或任何一个被拒绝。最终，返回一个新的承诺。

​		如果所有承诺都兑现，则使用一个聚合了各个承诺兑现值的数组来兑现它，其顺序与多个承诺的可迭代对象中定义的顺序相同。

​		如果它拒绝，则以被拒绝的可迭代对象中第一个承诺的理由拒绝它。



##### `Promise.allSettled`

​		等到所有的承诺都落定（每个都可能兑现或拒绝）。

​		返回一个 `Promise`，该 `Promise` 在所有给定的 `Promise` 都被要么兑现或要么拒绝后兑现，并带有一个对象数组，每个对象描述每个 `Promise` 的结果。



##### `Promise.any`

​		接受 `Promise` 对象的迭代对象，一旦迭代对象中的一个 `Promise` 兑现，就返回一个包含该 `Promise` 兑现值的单一 `Promise`。



##### `Promise.race`

​		等待任何一个承诺被兑现或拒绝。

​		如果返回的承诺兑现了，则用所兑现的可迭代对象中第一个承诺的值来兑现它。

​		如果它拒绝，那么它将以第一个被拒绝的承诺的理由拒绝。



##### `Promise.reject`

​		返回一个新的 `Promise` 对象，该对象以给定的原因被拒绝。



##### `Promise.resolve`

​		返回一个被给定值 `resolve` 的新 `Promise` 对象。如果该值是一个 `thenable`（即有一个 `then` 方法），那么返回的 `promise` 将跟随（`follow`）那个 `thenable`，采用它的最终状态；否则，返回的承诺将被这个值兑现。

​		通常，如果您不知道一个值是否是一个承诺，则 `Promise.resolve(value)` 它，并将返回值作为一个承诺。



#### 实例方法

​		`Promise.prototype` 上具有三个原型方法供所有实例使用：`catch`、`then` 和 `finally`。

​		请参阅 [`Microtask` 指南]([Microtask guide](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide))，了解更多关于这些方法如何使用 `Microtask` 队列和服务的信息。



##### `catch`

​		向承诺附加一个拒绝的回调处理程序，并返回一个新的 `promise`，如果回调函数被调用，则 `resolving` 其返回值；如果承诺被兑现，则 `resolving` 其原始兑现值。



##### `then`

​		将兑现和拒绝的处理程序附加到承诺，并返回一个新承诺，`resolving` 被调用处理程序的返回值，或者如果承诺没有被处理（例如，如果相关的处理程序 `onfulfillment` 或 `onRejected` 不是函数），则 `resolving` 它的原始落定值。



##### `finally`

​		将处理程序附加到承诺，并返回一个新承诺，在原始承诺被解决时解决。当承诺落定时，无论兑现或拒绝，都会调用该处理程序。



#### 案例演示

##### 基本示例

```js
const myFirstPromise = new Promise((resolve, reject) => {
  // 当我们异步执行的操作成功时，我们调用 resolve(...)，当它失败时，调用 reject(...)。
  // 在本例中，我们使用 setTimeout(...) 来模拟异步代码。
  // 实际上，您可能会使用 XHR 或 HTML API 之类的东西。
  	setTimeout(() => {
    	resolve("Success!"); // 解决成功，以给定值兑现。
  	}, 250);
});

myFirstPromise.then((successMessage) => {
  // successMessage 是我们在上面的 resolve(...) 函数中传递的兑现值。
  // 它不一定是一个字符串（但如果它只是一条成功消息，那它可能会是）。
  	console.log(`Yay! ${successMessage}`);
});
```



##### 不同示例

​		这个示例展示了使用 `Promise` 功能的各种技术以及可能意外发生的各种情况。要理解这一点，首先滚动到代码块的底部，并检查承诺链。在提供的最初的承诺之上，可以出现一连串的承诺。该链由 `then()` 调用组成，通常（但不一定）在末尾有一个 `catch()`，后面可选地跟着 `finally()`。在本例中，承诺链由自定义编写的 `new Promise()` 构造启动；但在实际操作中，承诺链更典型地从一个返回承诺的 `API` 函数（由其他人编写）开始。

​		示例函数 `tetheredGetNumber()` 展示承诺生成器将在设置异步调用时或在回调中使用 `reject()`，或两者都使用。函数 `promiseGetWord()` 演示了 `API` 函数如何以自包含的方式生成和返回承诺。

​		注意，函数 `troubleWithGetNumber()` 以一个 `throw` 结束。这是被迫的，因为承诺链会遍历所有的 `then()` 承诺，即使是在发生错误之后，如果没有抛出，错误就会看起来像是 “已修复”（`fixed`）。这是一个麻烦，由于这个原因，通常在 `then()` 的承诺链中省略 `rejectionFunc`，而只在最后的 `catch()` 中有一个 `rejectionFunc`。

​		这段代码可以在 `NodeJS` 下运行。通过看到错误的实际发生，理解力会得到增强。若要强制产生更多错误，请更改 `threshold` 值。

```js
// 为了试验错误处理，threshold（阈）值会随机导致错误。
const THRESHOLD_A = 8; // 可以使用 Zero 0 保证出错。

function tetheredGetNumber(resolve, reject) {
  	setTimeout(() => {
    	const randomInt = Date.now();
    	const value = randomInt % 10;
    	if (value < THRESHOLD_A) {
      		resolve(value);
    	} else {
      		reject(`Too large: ${value}`);
    	}
  	}, 500);
}

function determineParity(value) {
  	const isOdd = value % 2 === 1; // 奇数：odd，偶数：even
  	return { value, isOdd };
}

function troubleWithGetNumber(reason) {
  	const err = new Error("Trouble getting number", { cause: reason });
  	console.error(err);
  	throw err;
}

function promiseGetWord(parityInfo) {
  	return new Promise((resolve, reject) => {
    	const { value, isOdd } = parityInfo;
    	if (value >= THRESHOLD_A - 1) {
      		reject(`Still too large: ${value}`);
    	} else {
      		parityInfo.wordEvenOdd = isOdd ? "odd" : "even";
      		resolve(parityInfo);
    	}
  	});
}

new Promise(tetheredGetNumber)
  	.then(determineParity, troubleWithGetNumber)
  	.then(promiseGetWord)
  	.then((info) => {
    	console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);
    	return info;
  	})
  	.catch((reason) => {
    	if (reason.cause) {
      		console.error("Had previously handled error");
    	} else {
      		console.error(`Trouble with promiseGetWord(): ${reason}`);
    	}
  	})
  	.finally((info) => console.log("All done"));
```



##### 高级示例

​		这个小示例展示了 `Promise` 的机制。每次单击 `<button>` 时，都会调用 `testPromise()` 方法。它创建一个将被兑现的承诺，在每次随机的 1-3 秒后使用 `setTimeout()` 为承诺兑现计数结果（数字从 1 开始）。`Promise()` 构造函数用于创建 `promise`。

​		通过使用 `p1.then()` 的兑现回调集记录承诺的兑现。一些日志展示了该方法的同步部分如何从承诺的异步完成中解耦。

​		通过在短时间内多次点击按钮，你甚至会看到不同的承诺被一个接一个地兑现。

```html
<button id="make-promise">Make a promise!</button>
<div id="log"></div>
```

```js
"use strict";

let promiseCount = 0;

function testPromise() {
  	const thisPromiseCount = ++promiseCount;
  	const log = document.getElementById("log");
  	// 开始
  	log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Started<br>`);
  	// 创建一个新的承诺：我们承诺这个承诺的数量，从1开始（在等待3秒后）
  	const p1 = new Promise((resolve, reject) => {
    	// 执行器函数被调用的能力是resolve或reject该promise。
    	log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise constructor<br>`);
    	// 这只是创建异步的一个例子
    	setTimeout(() => {resolve(thisPromiseCount);}, Math.random() * 2000 + 1000);}); // 兑现承诺

  	// 我们定义了当承诺被兑现时要用then()调用做什么，以及当承诺被拒绝时要用catch()调用做什么。
  	p1.then((val) => {
    	// 记录兑现值
    	log.insertAdjacentHTML("beforeend", `${val}) Promise fulfilled<br>`);
  	}).catch((reason) => {
    	// 打印拒绝理由
    	console.log(`Handle rejected promise (${reason}) here.`);
  	});
  	// 结束
  	log.insertAdjacentHTML("beforeend", `${thisPromiseCount}) Promise made<br>`);
}

const btn = document.getElementById("make-promise");
btn.addEventListener("click", testPromise);
```



##### 用 `XHR` 加载图像

​		另一个使用 `Promise` 和 [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) 加载图像的简单示例可以在 `MDN GitHub` [`js-examples`](https://github.com/mdn/js-examples/tree/master/promises-test) 存储库中找到。您还可以看到它的[实际运行情况](https://mdn.github.io/js-examples/promises-test/)。每个步骤都有注释，允许您密切关注 `Promise` 和 `XHR` 体系结构。

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>Promise example</title>

    <link rel="stylesheet" href="">
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>

  <body>
    <h1>Promise example</h1>

    <p>Darth Vader image by 
        <a href="https://www.flickr.com/photos/digital_stability/">
            Shawn Taylor
        </a>
        , published under a 
        <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">
            Attribution-NonCommercial-NoDerivs 2.0 Generic
        </a>
        license.
    </p>
  </body>

  <script>
      function imgLoad(url) {
        // Create new promise with the Promise() constructor;
        // This has as its argument a function
        // with two parameters, resolve and reject
        return new Promise(function(resolve, reject) {
          // Standard XHR to load an image
          var request = new XMLHttpRequest();
          request.open('GET', url);
          request.responseType = 'blob';
          // When the request loads, check whether it was successful
          request.onload = function() {
            if (request.status === 200) {
            // If successful, resolve the promise by passing back the request response
              resolve(request.response);
            } else {
            // If it fails, reject the promise with a error message
              reject(Error('Image didn\'t load successfully; error code:' + request.statusText));
            }
          };
          request.onerror = function() {
          // Also deal with the case when the entire request fails to begin with
          // This is probably a network error, so reject the promise with an appropriate message
              reject(Error('There was a network error.'));
          };
          // Send the request
          request.send();
        });
      }

      // Get a reference to the body element, and create a new image object
      var body = document.querySelector('body');
      var myImage = new Image();
      // Call the function with the URL we want to load, but then chain the
      // promise then() method on to the end of it. This contains two callbacks
      imgLoad('myLittleVader.jpg').then(function(response) {
        // The first runs when the promise resolves, with the request.response
        // specified within the resolve() method.
        var imageURL = window.URL.createObjectURL(response);
        myImage.src = imageURL;
        body.appendChild(myImage);
        // The second runs when the promise
        // is rejected, and logs the Error specified with the reject() method.
      }, function(Error) {
        console.log(Error);
      });
  </script>
</html>
```



##### 追踪现任设置对象

​		设置对象（`settings object`）是在 `JavaScript` 代码运行时提供附加信息的环境。它包括领域和模块映射，以及特定于 `HTML` 的信息，如来源。跟踪当前设置对象，以确保浏览器知道对于用户给定的代码片段，要使用哪一个（领域、模板映射或 `HTML` 信息）。

​		为了更好地描述这一点，我们可以更仔细地看看领域是如何成为一个问题的。领域（`realm`）可以被粗略地认为是全局对象。领域的独特之处在于，它们持有运行 `JavaScript` 代码的所有必要信息。这包括像 `Array` 和 `Error` 这样的对象。每个设置对象对此都有自己的“副本”且它们与副本之间是不共享的。这可能会导致一些与承诺相关的意外行为。为了解决这个问题，我们跟踪所谓的现任设置对象（`incumbent settings object`）。它表示特定于负责某个函数调用的用户代码上下文的信息。

​		为了进一步说明这一点，我们可以看一下嵌入在文档中的 `<iframe>` 是如何与其宿主通信的。由于所有的 `web APIs` 都知道当前设置对象，下面的代码将能够在所有浏览器中工作：

```html
<!DOCTYPE html> <iframe></iframe>
<!-- 这里有一个领域 -->
<script>
  // 这里也有一个领域
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // Bound是一个内置函数——栈上没有用户代码，那么我们使用哪个领域呢？
  setTimeout(bound);
  // 这仍然有效，因为我们在栈上使用最年轻的（即：排在最后的）领域（现任领域）。
</script>
```

​		同样的概念也适用于承诺。如果我们稍微修改一下上面的例子，我们会得到这样：

```html
<!DOCTYPE html> <iframe></iframe>
<!-- 这里有一个领域 -->
<script>
  // 这里也有一个领域
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  // Bound是一个内置函数——栈上没有用户代码，那么我们使用哪个领域呢？
  Promise.resolve(undefined).then(bound);
  // 这仍然有效，因为我们在栈上使用最年轻的（即：排在最后的）领域（现任领域）。
</script>
```

​		如果我们改变它，使文档中的 `<iframe>` 监听 `post` 消息，我们可以观察到当前设置对象的作用或效果：

```html
<!-- y.html -->
<!DOCTYPE html>
<iframe src="x.html"></iframe>
<script>
  const bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  Promise.resolve(undefined).then(bound);
</script>
```

```html
<!-- x.html -->
<!DOCTYPE html>
<script>
  window.addEventListener(
    "message",
    (event) => {
      document.querySelector("#text").textContent = "hello";
      // 这段代码只会在跟踪当前Settings对象的浏览器中运行
      console.log(event);
    },
    false
  );
</script>
```

​		在上面的例子中，只有在当前设置对象被跟踪时，`<iframe>` 的内部文本才会被更新。这是因为如果不跟踪现任者，我们可能最终会使用错误的环境来发送信息。

​		注意：目前，现任领域跟踪已经在 `Firefox` 中完全实现了，在 `Chrome` 和 `Safari` 中已有部分实现。

<hr>



### 属性

#### 静态属性

##### `get Promise[@@species]`

​		`Promise[@@species]` 访问器属性返回构造函数，用于从 `Promise` 方法中构造返回值。

​		警告：`@@species` 的存在允许执行任意代码，并可能产生安全漏洞。这也使得某些优化变得更加困难。引擎实现者[正在研究是否要删除这一功能]([investigating whether to remove this feature](https://github.com/tc39/proposal-rm-builtin-subclassing))。如果可能的话，避免依赖它。

返回值：在 `get @@species` 上被调用的构造函数（`this`）的值。该返回值用于从创建新承诺的承诺链方法中构造返回值。

​		`@@species` 访问器属性返回 `Promise` 对象的默认构造函数。子类构造函数可能重写它以更改构造函数的赋值。默认的实现基本上是：

```js
// 用于说明底层实现的假设
class Promise {
  	static get [Symbol.species]() {
    	return this;
  	}
}
```

​		由于这种多态实现，派生子类的 `@@species` 在默认情况下也会返回构造函数本身。

```js
class SubPromise extends Promise {}

SubPromise[Symbol.species] === Promise; // false
SubPromise[Symbol.species] === SubPromise; // true
```

​		当链接像 `then()`，`finally()` 等承诺方法时，实例的 `constructor[@@species]` 将被访问。返回的构造函数将用于构造`promise` 方法的返回值。

​		`Symbol.species` 属性返回默认的构造函数，它是 `Promise` 的 `Promise` 构造函数。

```js
Promise[Symbol.species] === Promise; // true
```

​		在自定义 `Promise` 子类的实例中，例如 `MyPromise`，`MyPromise` 种类（`species`）是 `MyPromise` 构造函数。但是，为了在派生类方法中返回父 `Promise` 对象，您可能想要重写它。

```js
class MyPromise extends Promise {
  	// 重写MyPromise的species到父Promise构造函数
  	static get [Symbol.species]() {
    	return Promise;
  	}
}
```

​		默认情况下，`promise` 方法将返回子类型的 `promise`。

```js
class MyPromise extends Promise {
  	someValue = 1;
}

MyPromise.resolve().then(() => {}).someValue; // 1
```

​		通过重写 `@@species`，`promise` 方法将返回基本 `Promise` 类型。

```js
class MyPromise extends Promise {
  	someValue = 1;
  	static get [Symbol.species]() {
    	return Promise;
  	}
}

MyPromise.resolve().then(() => {}).someValue; // undefined
```

<hr>



### 方法

#### 静态方法

​		`Promise` 的静态方法有 6 个：`all`、`allSettled`、`any`、`race`、`reject`、`resolve`。



##### `all`

​		`Promise.all()` 方法以一个 `Promise` 的可迭代对象作为输入，并返回一个单独的 `Promise`。当输入的所有承诺都兑现时（包括传递空可迭代对象时），返回的承诺就会被兑现，并带有一个兑现值数组。当输入的任何承诺被拒绝时，它会拒绝，使用第一个拒绝原因。

参数：

- `iterable`：一个承诺的可迭代对象（如数组）。

返回值：一个新承诺

- 如果传入的可迭代对象为空，则表示已兑现。
- 异步兑现，当给定可迭代对象中的所有承诺都兑现时。兑现值是一个兑现值数组，按照传递的承诺的顺序，而不是完成的顺序。如果传递的可迭代对象非空但不包含待定的承诺，则返回的承诺仍然是异步（而不是同步）兑现的。
- 异步拒绝，当给定可迭代对象中的任何一个承诺被拒绝时。拒绝原因是被拒绝的第一个承诺的拒绝原因。

​		`Promise.all()` 方法是 `promise` 并发方法之一。它对于聚合多个承诺的结果很有用。通常在有多个相关的异步任务，整个代码依赖于它们才能成功地工作时使用——我们希望在代码继续执行之前兑现这些所有任务。

​		`Promise.all()` 返回的承诺将会在任何输入承诺一被拒绝时就立即拒绝。相比之下，`Promise.allSettled()` 返回的 `promise` 将等待所有输入 `promise` 完成，而不管任何一个是否拒绝。如果需要可迭代对象中每个 `promise` 的最终结果，则使用 `allSettled()`。

​		`Promise.all()` 等待着所有兑现（或第一个拒绝）。

```js
const p1 = Promise.resolve(3);
const p2 = 1337;
const p3 = new Promise((resolve, reject) => {
  	setTimeout(() => {
    	resolve("foo");
  	}, 100);
});

Promise.all([p1, p2, p3]).then((values) => {
  	console.log(values); // [3, 1337, "foo"]
});
```

​		如果 `iterable` 包含非承诺值，它们将被忽略，但仍被算入返回的承诺数组中（如果承诺已经兑现）：

```js
// 所有的值都是非承诺值，因此返回的承诺将得到兑现。
const p = Promise.all([1, 2, 3]);
// 唯一的输入承诺已经兑现，因此返回的承诺得到兑现。
const p2 = Promise.all([1, 2, 3, Promise.resolve(444)]);
// 一个（也是唯一的）输入承诺被拒绝，因此返回的承诺得到拒绝。
const p3 = Promise.all([1, 2, 3, Promise.reject(555)]);

// 使用setTimeout，我们可以在队列为空后执行代码。
setTimeout(() => {
  	console.log(p);
  	console.log(p2);
  	console.log(p3);
});

/* 
> Promise { <fulfilled>: [1, 2, 3]] }
> Promise { <fulfilled>: [1, 2, 3, 444] }
> Promise { <rejected>: 555 }
> Uncaught (in promise) 555
*/
```

`Promise.all` 的异步性或同步性：

​		下面的示例演示 `Promise` 的异步性。当传入一个非空可迭代对象时：

```js
// 通过一个已经解决的承诺数组，去尽快触发Promise.all。
const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

const p = Promise.all(resolvedPromisesArray);
// 立即打印p的值
console.log(p);

// 使用setTimeout，在队列为空后执行代码
setTimeout(() => {
  	console.log("the queue is now empty");
  	console.log(p);
});

/*
> Promise { <pending> }
> "the queue is now empty"
> Promise { <fulfilled>: [33, 44] }
*/
```

​		如果 `Promise.all` 拒绝，也会发生同样的事情。

```js
const mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)];
const p = Promise.all(mixedPromisesArray);
console.log(p);
setTimeout(() => {
  	console.log("the queue is now empty");
  	console.log(p);
});

/*
> Promise { <pending> }
> "the queue is now empty"
> Promise { <rejected>: 44 }
> Uncaught (in promise) 44
*/
```

​		当且仅当传入的可迭代对象为空时，`Promise.all` 才会同步解决：

```js
const p = Promise.all([]); // 将会立即resolve解决
const p2 = Promise.all([1337, "hi"]); // 非承诺值被忽略，但计算是异步完成的。
console.log(p);
console.log(p2);
setTimeout(() => {
  	console.log("the queue is now empty");
  	console.log(p2);
});

/*
> Promise { <fulfilled>: Array[0] }
> Promise { <pending> }
> "the queue is now empty"
> Promise { <fulfilled>: Array[2] }
*/
```

使用 `Promise.all()` 和异步函数

​		在异步函数中，“过度等待”（`over-await`）代码是很常见的。例如，给定以下函数：

```js
// 选菜提示函数
function promptForDishChoice() {
  return new Promise((resolve, reject) => {
    // 创建一个对话框，填充内容选项。
    const dialog = document.createElement("dialog");
    dialog.innerHTML = `
        <form method="dialog">
          <p>What would you like to eat?</p>
          <select>
            <option value="pizza">Pizza</option>
            <option value="pasta">Pasta</option>
            <option value="salad">Salad</option>
          </select>
          <menu>
            <li><button value="cancel">Cancel</button></li>
            <li><button type="submit" value="ok">OK</button></li>
          </menu>
        </form>
    `;
    // 监听关闭对话框事件
    dialog.addEventListener("close", () => {
      // 用户是否提交菜单。
      if (dialog.returnValue === "ok") {
        resolve(dialog.querySelector("select").value); // 使用菜单上的选中项作为值兑现
      } else {
        reject(new Error("User cancelled dialog")); // 给出拒绝理由
      }
    });
    document.body.appendChild(dialog); // 插入对话框
    dialog.showModal(); // 展开模态
  });
}

async function fetchPrices() {
  const response = await fetch("/prices"); // 等待获取价格
  return await response.json();
}
```

​		你可以这样写一个函数：

```js
async function getPrice() {
  const choice = await promptForDishChoice(); // 等待用户选择：提交菜单或取消菜单。
  const prices = await fetchPrices(); // 等待后台价格
  return prices[choice];
}
```

​		但是，请注意 `promptForChoice` 和 `fetchPrices` 的执行不依赖于彼此的结果。当用户选择他们的菜肴时，适合在后台获取价格，但在上面的代码中，`await` 操作符导致 `async` 函数暂停，直到做出选择，然后再次暂停，直到获得价格。我们可以使用 `Promise.all` 并行地运行它们，这样用户就不必在结果被给出之前等待价格被获取：

```js
async function getPrice() {
  const [choice, prices] = await Promise.all([
    // 同时（并行）等待用户选择和后台价格。
    promptForDishChoice(),
    fetchPrices(),
  ]);
  return pricesValue[choiceValue];
}
```

​		`Promise.all` 是这里并发方法的最佳选择，因为错误处理是直观的——任何一个承诺被拒绝，结果将不再可用，导致整个 `await` 表达式将被抛出。

​		`Promise.all` 接受承诺的可迭代对象，因此，如果使用它来并行执行多个异步函数，则需要调用异步函数并使用返回的承诺。直接将函数传递给 `Promise.all` 不会起作用，因为它们都不是承诺。

```js
async function getPrice() {
  const [choice, prices] = await Promise.all([
    promptForDishChoice,
    fetchPrices,
  ]);
  // choice和prices仍然是最初的异步函数，Promise.all()对非promise不做任何操作。
}
```

`Promise.all` 快速失败行为：

​		任何一个元素被拒绝，`Promise.all` 都会被拒绝。例如，如果您传入四个在超时后解决的承诺和一个立即拒绝的承诺，那么`Promise.all` 将会立即被拒绝。

```js
const p1 = new Promise((resolve, reject) => {
  	setTimeout(() => resolve("one"), 1000); // 超时解决
});
const p2 = new Promise((resolve, reject) => {
  	setTimeout(() => resolve("two"), 2000); // 超时解决
});
const p3 = new Promise((resolve, reject) => {
  	setTimeout(() => resolve("three"), 3000); // 超时解决
});
const p4 = new Promise((resolve, reject) => {
  	setTimeout(() => resolve("four"), 4000); // 超时解决
});
const p5 = new Promise((resolve, reject) => {
  	reject(new Error("reject")); // 立即拒绝
});

// 使用catch：
Promise.all([p1, p2, p3, p4, p5])
  	.then((values) => {
    	console.log(values);
  	})
  	.catch((error) => {
    	console.error(error.message); // 打印拒绝理由
  	});
// "reject"
```

​		可以通过处理可能的拒绝来改变这种行为：

```js
const p1 = new Promise((resolve, reject) => {
  	setTimeout(() => resolve("p1_delayed_resolution"), 1000); // 超时解决
});

const p2 = new Promise((resolve, reject) => {
  	reject(new Error("p2_immediate_rejection")); // 立即拒绝
});

// 提前处理拒绝回调
Promise.all([p1.catch((error) => error), p2.catch((error) => error)]).then(
  	(values) => {
    console.log(values[0]); 	// "p1_delayed_resolution"
    console.error(values[1]); 	// "Error: p2_immediate_rejection"
  	}
);
```



##### `allSettled`

​		`Promise.allSettled()` 方法接受 `Promise` 的可迭代对象作为输入，并返回单个 `Promise`。当输入的所有承诺都落定时（包括传递空可迭代对象时），返回的承诺就会兑现，并带有描述每个承诺结果的对象数组。

参数：

- `iterable`：承诺的可迭代对象（如数组）。

返回值：一个新承诺：

-  如果传入的可迭代对象为空，则表示已兑现。
- 异步兑现，当给定可迭代对象中的所有承诺都已落定（兑现或拒绝）。兑现值是一个对象数组，每个对象描述迭代对象中一个承诺的结果，按照传递的承诺的顺序，不是完成的顺序。每个结果对象具有以下属性：
  - `status`：一个字符串，要么 `"fulfilled"`，要么 `"rejected"`，指示承诺的最终状态。
  - `value`：只有当 `status` 为 `"fulfilled"` 时才会出现。承诺的兑现值。
  - `reason`：只有当 `status` 为 `"rejected"` 时才会出现。承诺的拒绝原因。

如果传递的可迭代对象非空但不包含待定的承诺，则返回的承诺仍然是异步（而不是同步）兑现的。

​		`Promise.allSettled()` 方法是承诺的并发方法之一。`Promise.allSettled()` 通常用于多个异步任务，这些任务不依赖于彼此去成功地完成，或者您总是想知道每个承诺的结果。

​		相比之下，如果任务是相互依赖的，或者如果您希望在其中任何一个拒绝时就立即拒绝，则 `Promise.all()` 的返回值可能更合适。

```js
// 等待所有承诺的结果，无论兑现或拒绝。
Promise.allSettled([
  	Promise.resolve(33),
  	new Promise((resolve) => setTimeout(() => resolve(66), 0)),
  	99,
  	Promise.reject(new Error("an error")),
]).then((values) => console.log(values));

/*
[
	{ status: 'fulfilled', value: 33 },
	{ status: 'fulfilled', value: 66 },
	{ status: 'fulfilled', value: 99 },
	{ status: 'rejected', reason: Error: an error }
]
*/
```



##### `any`

​		`Promise.any()` 方法接受 `Promise` 的可迭代对象作为输入，并返回单个 `Promise`。当输入的任何一个承诺兑现时，这个返回的承诺就会使用第一个兑现值来兑现。当所有输入的承诺都被拒绝时（包括传递空可迭代对象时），它会拒绝，使用一个包含拒绝原因数组的 `AggregateError`。

参数：

- `iterable`：承诺的可迭代对象（如数组）。

返回值：一个新承诺：

- 拒绝，如果传入的可迭代对象为空。
- 异步实现，当给定可迭代对象中的任何一个承诺兑现时。兑现值是被兑现的第一个承诺的兑现值。
- 异步拒绝，当给定可迭代对象中的所有承诺都拒绝时。拒绝原因是一个 `AggregateError`，在其 `errors` 属性中包含一个拒绝原因数组。`errors` 按照所传递的承诺的顺序排列，而不是完成的顺序。如果传递的可迭代对象非空但不包含待定的承诺，返回的承诺仍然会被异步（而不是同步）拒绝。

​		`Promise.any()` 方法是 `Promise` 的并发方法之一。此方法用于返回第一个兑现的承诺。它会在一个承诺被兑现后短路（`short-circuits`），所以一旦找到这样的一个承诺，它就不会等待其他承诺的完成。

​		与 `Promise.all()` 不同的是（`Promise.all()` 返回一个兑现值数组），我们只得到一个兑现值（假设至少有一个承诺兑现了）。如果我们只需要兑现一个承诺，而不在乎哪个承诺兑现了，那么这是有益的。注意另一个区别：该方法在接收空可迭代对象时会得到拒绝，因为实际上，可迭代对象不包含已兑现的项。你可以将 `Promise.any()` 和 `Promise.all()` 与 `Array.prototype.some()` 和  `Array.prototype.every()` 进行比较。

​		另外，与 `Promise.race()` 返回第一个落定值（兑现或拒绝）不同的是，此方法返回第一个兑现值。此方法忽略所有被拒绝的承诺，直到第一个承诺兑现为止。

​		`Promise.any()` 兑现第一个要兑现的承诺，即使一个承诺首先被拒绝。这与 `Promise.race()` 相反，`Promise.race()` 用第一个落定的承诺来兑现或拒绝。

```js
const pErr = new Promise((resolve, reject) => {
  	reject("Always fails");
});

const pSlow = new Promise((resolve, reject) => {
  	setTimeout(resolve, 500, "Done eventually");
});

const pFast = new Promise((resolve, reject) => {
  	setTimeout(resolve, 100, "Done quick");
});

Promise.any([pErr, pSlow, pFast]).then((value) => {
  	console.log(value); // pFast首先被兑现
});
// "Done quick"
```

使用 `AggregateError` 拒绝：如果没有承诺兑现，`Promise.any()` 会以一个 `AggregateError` 来拒绝。

```js
const failure = new Promise((resolve, reject) => {
  	reject("Always fails");
});

Promise.any([failure]).catch((err) => {
  	console.log(err);
});
// AggregateError: All promises were rejected
```

显示加载的第一个图像：在本例中，我们有一个函数，它获取图像并返回一个 `blob`（二进制对象）。我们使用 `Promise.any()` 来获取一对图像并显示第一个可用的图像（即：其承诺已解决）。

```js
async function fetchAndDecode(url, description) {
  	const res = await fetch(url);
  	if (!res.ok) {
    	throw new Error(`HTTP error! status: ${response.status}`);
  	}
  	const data = await response.blob();
  	return [data, description];
}

const coffee = fetchAndDecode("coffee.jpg", "Coffee");
const tea = fetchAndDecode("tea.jpg", "Tea");

Promise.any([coffee, tea])
	.then(([blob, description]) => {
    	const objectURL = URL.createObjectURL(blob);
    	const image = document.createElement("img");
    	image.src = objectURL;
    	image.alt = description;
    	document.body.appendChild(image);
  	})
  	.catch((e) => {
    	console.error(e);
  	});
```



##### `race`

​		`Promise.race()` 方法接受 `Promise` 的可迭代对象作为输入，并返回单个 `Promise`。这个 `promise` 使用第一个落定的 `promise` 的最终状态进行落定。

参数：

- `iterable`：承诺的可迭代对象（如数组）。

返回值：一个异步落定的承诺，它落定为可迭代对象中第一个落定的 `Promise` 的最终状态。换句话说，如果第一个落定的承诺被兑现，它就兑现，如果第一个落定的承诺被拒绝，它就拒绝。如果传递的可迭代对象为空，则返回的承诺将永远保持待定状态。如果传递的可迭代对象非空但不包含待定的承诺，则返回的承诺仍然是异步（而不是同步）落定的。

​		`Promise.race()` 方法是承诺的并发方法之一。当你想要完成第一个异步任务，但不关心它的最终状态（成功或失败）时，它很有用。

​		如果 `iterable` 包含一个或多个非承诺值和 / 或一个已落定的承诺，则 `Promise.race()` 将落定为在其中找到的第一个值。

​		这个例子展示了如何使用 `Promise.race()` 对由 `setTimeout()` 实现的多个计时器进行竞争。时间最短的计时器总是赢得比赛，并成为结果承诺的状态。

```js
function sleep(time, value, state) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (state === "fulfill") {
        return resolve(value);
      } else {
        return reject(new Error(value));
      }
    }, time);
  });
}

const p1 = sleep(500, "one", "fulfill");
const p2 = sleep(100, "two", "fulfill");

Promise.race([p1, p2]).then((value) => {
  console.log(value); // "two"
  // 两者都兑现，但p2更快。
});

const p3 = sleep(100, "three", "fulfill");
const p4 = sleep(500, "four", "reject");

Promise.race([p3, p4]).then(
  (value) => {
    console.log(value); // "three"
    // p3更快，因此它兑现。
  },
  (error) => {
    // 没有调用
  }
);

const p5 = sleep(500, "five", "fulfill");
const p6 = sleep(100, "six", "reject");

Promise.race([p5, p6]).then(
  (value) => {
    // 没有调用
  },
  (error) => {
    console.error(error.message); // "six"
    // p6更快，因此它拒绝
  }
);
```

`Promise.race` 的异步性：下面的示例演示 `Promise.race` 的异步性。与其他 `Promise` 并发方法不同，`Promise.race` 总是异步的：它从不同步落定，即使 `iterable` 为空。

```js
// 通过一个已经解决的承诺数组，去尽快触发Promise.race。
const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];

const p = Promise.race(resolvedPromisesArray);
// 立即打印p的值
console.log(p);

// 使用setTimeout，在栈空后执行代码。
setTimeout(() => {
  console.log("the stack is now empty");
  console.log(p);
});

/* 
> Promise {<pending>}
> "the stack is now empty"
> Promise {<fulfilled>: 33}
*/
```

​		空迭代对象会导致返回的 `promise` 永远处于待定状态：

```js
const foreverPendingPromise = Promise.race([]);

console.log(foreverPendingPromise);

setTimeout(() => {
  	console.log("the stack is now empty");
  	console.log(foreverPendingPromise);
});

/*
> Promise {<pending>}
> "the stack is now empty"
> Promise {<pending>}
*/
```

​		如果可迭代对象包含一个或多个非承诺值和 / 或一个已经落定的承诺，则 `Promise.race` 将落定为在数组中找到的第一个值：

```js
const foreverPendingPromise = Promise.race([]);
const alreadyFulfilledProm = Promise.resolve(100);

const arr = [foreverPendingPromise, alreadyFulfilledProm, "non-Promise value"];
const arr2 = [foreverPendingPromise, "non-Promise value", Promise.resolve(100)];
const p = Promise.race(arr);
const p2 = Promise.race(arr2);

console.log(p);
console.log(p2);

setTimeout(() => {
  	console.log("the stack is now empty");
  	console.log(p);
  	console.log(p2);
});

/*
> Promise {<pending>}
> Promise {<pending>}
> "the stack is now empty"
> Promise {<fulfilled>: 100}
> Promise {<fulfilled>: 'non-Promise value'}
*/
```

​		使用 `Promise.race()` 实现请求超时：您可以用一个拒绝的计时器来测试一个可能持久的请求，这样当时间限制过去时，生成的承诺就会自动拒绝。

```js
const data = Promise.race([
  	fetch("/api"),
  	new Promise((resolve, reject) => {
    	// 5秒后拒绝
    	setTimeout(() => reject(new Error("Request timed out")), 5000);
  	}),
])
	.then((res) => res.json())
  	.catch((err) => displayError(err));
```

​		如果 `data` 承诺兑现，它将包含从 `/api` 获取的数据；否则，如果 `fetch` 持续待定 5 秒并与 `setTimeout` 定时器竞争失败，它将拒绝。

​		使用 `Promise.race()` 检测一个 `promise` 的状态：因为 `Promise.race()` 会解决到可迭代对象中第一个非待定的承诺，所以我们可以检查承诺的状态，包括它是否待定。这个例子改编自 [`promise-status-async`](https://github.com/kudla/promise-status-async/blob/master/lib/promiseState.js)。

```js
function promiseState(promise) {
  	const pendingState = { status: "pending" }; // 非promise值对象

  	return Promise.race([promise, pendingState]).then(
    	(value) => value === pendingState ? value : { status: "fulfilled", value },
    	(reason) => ({ status: "rejected", reason }),
  	);
}
```

​		在此函数中，如果 `promise` 是待定的，则第二个非 `promise` 值 `pendingState` 将成为竞争的结果；否则，如果 `promise` 已经落定，我们可以通过 `onFulfilled` 和 `onRejected` 处理程序知道它的状态。例如：

```js
const p1 = new Promise((res) => setTimeout(() => res(100), 100));
const p2 = new Promise((res) => setTimeout(() => res(200), 200));
const p3 = new Promise((res, rej) => setTimeout(() => rej(300), 100));

async function getStates() {
  	console.log(await promiseState(p1));
  	console.log(await promiseState(p2));
  	console.log(await promiseState(p3));
}

console.log("Immediately after initiation:");
getStates();

setTimeout(() => {
  	console.log("After waiting for 100ms:");
  	getStates();
}, 100);

/*
> "Immediately after initiation:"
> {status: 'pending'}
> {status: 'pending'}
> {status: 'pending'}
> "After waiting for 100ms:"
> {status: 'fulfilled', value: 100}
> {status: 'pending'}
> {status: 'rejected', reason: 300}
*/
```

​		注意：`promiseState` 函数仍然是异步运行的，因为没有办法同步获取 `promise` 的值（即没有 `then()` 或 `await`），即使它已经落定了。然而，`promiseState()` 总是在一瞬间完成，实际上它从不等待任何 `promise` 的落定。



##### `reject`

​		`Promise.reject()` 方法返回一个被给定理由拒绝的 `Promise` 对象。

参数：

- `reason`：该承诺被拒绝的原因。

返回值：一个因特定原因而被拒绝的承诺。

​		`Promise.reject` 返回一个被拒绝的 `promise`。为了调试目的和选择性错误捕获，使 `reason` 成为 `Error` 的实例是很有用的。

```js
Promise.reject(new Error("fail")).then(
  () => {
    // 没有调用
  },
  (error) => {
    console.error(error); // 栈跟踪：Stacktrace
  },
);
```



##### `resolve`

​		`Promise.resolve()` 方法将一个给定值解析成一个 `Promise`。如果这个值是一个承诺，则返回该承诺；如果该值是 `thenable`, `Promise.resolve()` 将调用 `then()` 方法，使用它准备好的两个回调函数；否则返回的承诺将以该值来兑现。

​		这个函数将类承诺对象的嵌套层（例如一个承诺兑现成另一个承诺兑现成某物）压扁为一个单层（兑现非 `thenable` 值的承诺）。

参数：

- `value`：参数将由本承诺解决。也可以是一个承诺或一个可解决的 `thenable` 。

返回值：一个用给定值解决的承诺，或者如果该值是一个承诺对象，则将该承诺作为值传递。它可能被兑现了，也可能被拒绝了——例如，解决一个被拒绝的承诺的结果仍然会是一个被拒绝的承诺。

```js
// 解决非承诺值
Promise.resolve('Success').then(
  	(value) => {
    	console.log(value); // "Success"
  	},
  	(reason) => {
    	// 不执行
  	},
);

const p = Promise.resolve([1, 2, 3]);
p.then((v) => {
  	console.log(v); // [1, 2, 3]
});

// 解决另一个承诺
const original = Promise.resolve(33);
const cast = Promise.resolve(original);
cast.then((value) => { // 异步执行then的回调
  	console.log(`value: ${value}`);
});
console.log(`original === cast ? ${original === cast}`);
/*
> "original === cast ? true"
> "value: 33"
*/
```

​		解决 `thenable` 和抛出错误

```js
// 解决一个thenable对象
const p1 = Promise.resolve({
  	then(onFulfill, onReject) {
    	onFulfill('fulfilled!');
  	},
});
console.log(p1 instanceof Promise) // true, 对象转换为承诺

p1.then(
  	(v) => {
    	console.log(v); // "fulfilled!"
  	},
  	(e) => {
    	// not called
  	},
);

// Thenable在回调前抛出错误
// Promise拒绝
const thenable = {
  	then(onFulfilled) {
    	throw new TypeError('Throwing');
    	onFulfilled('Resolving');
  	},
};

const p2 = Promise.resolve(thenable);
p2.then(
  	(v) => {
    	// not called
  	},
  	(e) => {
    	console.error(e); // TypeError: Throwing
  	},
);

// Thenable在回调后抛出错误
// Promise解决
const thenable = {
  	then(onFulfilled) {
    	onFulfilled('Resolving');
    	throw new TypeError('Throwing');
  	},
};

const p3 = Promise.resolve(thenable);
p3.then(
  	(v) => {
    	console.log(v); // "Resolving"
  	},
  	(e) => {
    	// not called
  	},
);
```

​		嵌套的 `thenable` 将被“深深地夷平”（`deeply flattened`）为单个承诺。

```js
const thenable = {
  	then(onFulfilled, onRejected) {
    	onFulfilled({
      		// 该thenable用另一个thenable兑现
      		then(onFulfilled, onRejected) {
        		onFulfilled(42);
      		},
    	});
  	},
};

Promise.resolve(thenable)
  	.then((v) => {
    	console.log(v); // 42
  	});
```

​		警告：不要在解决自身的 `thenable` 上调用 `Promise.resolve()`。这将导致无限递归，因为它会试图压平无限嵌套的承诺。

```js
const thenable = {
  	then(onFulfilled, onRejected) {
    	onFulfilled(thenable);
  	},
};

Promise.resolve(thenable)  // 将会导致无限循环（infinite recursion）
```



#### 原型方法

​		`Promise` 的原型上具有三个方法：`then`、`catch` 和 `finally`。



##### `then`

​		`then()` 方法返回一个 `Promise`。它有两个参数：`Promise` 兑现和拒绝情况的回调函数。

参数：

- `onFulfilled`：一个在承诺被兑现时异步调用的函数。这个函数有一个参数，即兑现值。如果该参数不是一个函数，则在内部用一个恒等函数（`(x) => x`）来替换它，仅仅将兑现值向前传递。
- `onRejected`：一个在承诺被拒绝时异步调用的函数。这个函数有一个参数，即拒绝原因。如果该参数不是函数，则在内部用一个抛出函数（`(x) => {throw x;}`）来替换它，抛出它所收到的拒绝原因。

返回值：立即返回一个新的 `Promise`。这个新承诺在返回时总是待定，而不管当前承诺的状态如何。

​		`onFulfilled` 和 `onRejected` 处理程序中的一个将被执行来处理当前承诺的兑现或拒绝。调用总是异步发生的，即使当前承诺已经落定。返回承诺（称为 `p`）的行为取决于处理程序的执行结果，遵循一套特定的规则。如果处理程序函数：

- 返回一个值：`p` 使用该返回值作为其值来兑现。
- 不返回任何东西：`p` 使用 `undefined` 来兑现。
- 抛出一个错误：`p` 使用抛出的错误作为其值来拒绝。
- 返回一个已被兑现的承诺：`p` 使用该承诺的值作为其值来兑现。
- 返回一个已被拒绝的承诺：`p` 使用该承诺的值作为其值来拒绝。
- 返回另一个正待定的承诺：由 `then` 返回的承诺的兑现或拒绝将发生在由处理程序返回的承诺的解决或拒绝之后。此外，由 `then` 返回的承诺的解决值将与由处理程序返回的承诺的解决值相同。

​		像 `then` 和 `Promise.prototype.catch()` 方法返回的承诺，它们可以被链接起来——一个被称为复合（`composition`）的操作。

```js
const p1 = new Promise((resolve, reject) => {
  	resolve("Success!"); // 或 reject(new Error("Error!"));
});

p1.then(
  	(value) => {
    	console.log(value); // Success!
  	},
  	(reason) => {
    	console.error(reason); // 或 Error!
  	},
);
```

​		使用非函数参数 —— 将上一个期约继续向下传递。

```js
Promise.resolve(1).then(2).then(console.log); // 1
Promise.reject(1).then(2, 2).then(console.log, console.log); // 1
```

链式调用：`then` 方法返回一个新的 `Promise`，允许方法链锁化。

​		如果作为处理程序传递给 `then` 的函数返回一个 `Promise`，则一个等效的 `Promise` 将被暴露给方法链中的后续 `then` 。下面的代码片段使用 `setTimeout` 函数模拟异步代码。

```js
Promise.resolve("foo")
  	// 1. 接收"foo"，将"bar"连接到它，然后将其解决给下一个then
  	.then((string) =>
    	new Promise((resolve, reject) => {
      		setTimeout(() => {
        		string += "bar";
        		resolve(string);
      		}, 1);
    	})
  	)
  	// 2. 接收"foobar"，注册一个回调函数来处理该字符串并将其打印到控制台，但不是在返回未处理的字符串到下一个then之前。
  	.then((string) => {
    	setTimeout(() => {
      		string += "baz";
      		console.log(string); // foobarbaz
    	}, 1);
    	return string;
  	})
  	// 3. 打印有用的消息，说明在前面then块中的模拟异步代码实际处理字符串之前，将如何运行本节中的代码。
  	.then((string) => {
    	console.log("Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising",);

    	// 注意，此时此刻，string将不会有它的"baz"片段。这是因为我们使用一个setTimeout函数模拟了这种情况的异步发生。
    	console.log(string); // foobar
  	});

/*
> "Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising"
> "foobar"
> "foobarbaz"
*/
```

​		`then()` 返回值被解决的方式与 `Promise.resolve()` 相同。这意味着 `thenable` 对象是被支持的，且如果返回值不是 `promise`，它将隐式地被封装在一个 `Promise` 中并且被解决。

```js
const p2 = new Promise((resolve, reject) => {
  	resolve(1);
});

p2.then((value) => {
  	console.log(value); // 1
  	return value + 1;
}).then((value) => {
  	console.log(value, " - A synchronous value works"); // 2 - A synchronous value works
});

p2.then((value) => {
  	console.log(value); // 1
});
/*
> 1
> 1
> 2 ' - A synchronous value works'
*/
```

​		`then` 调用返回一个 `promise`，如果函数抛出一个错误或返回一个被拒绝的 `promise`，该 `promise` 最终将被拒绝。

```js
Promise.resolve()
  	.then(() => {
    	// 使then返回一个被拒绝的承诺
    	throw new Error("Oh no!");
 	 })
  	.then(
    	() => {
      		console.log("Not called.");
    	},
    	(error) => {
      		console.error(`onRejected function called: ${error.message}`);
    	},
  	);
// onRejected function called: Oh no!
```

​		在实践中，通常更可取的是 `catch()` 拒绝的承诺，而不是使用 `then()` 的两种案例式的语法，如下所示。

```js
Promise.resolve()
  	.then(() => {
    	// 使then返回一个被拒绝的承诺
    	throw new Error("Oh no!");
  	})
  	.catch((error) => {
    	console.error(`onRejected function called: ${error.message}`);
  	})
  	.then(() => {
    	console.log("I am always called even if the prior then's promise rejects");
  	});

/*
> "onRejected function called: Oh no!"
> "I am always called even if the prior then's promise rejects"
*/
```

​		在所有其他情况下，返回的承诺最终会兑现。在下面的例子中，第一个 `then()` 返回 42，被封装一个已兑现的 `Promise` 中，即使链中的前一个 `Promise` 被拒绝了。

```js
Promise.reject()
  	.then(
    	() => 99,
    	() => 42,
  	) // onRejected返回42，它被包装在一个已兑现的承诺中
  	.then((solution) => console.log(`Resolved with ${solution}`)); 

// "Resolved with 42"
```

​		如果 `onFulfilled` 返回一个承诺，那么 `then` 的返回值将根据该承诺的最终状态被兑现或拒绝。

```js
function resolveLater(resolve, reject) {
  	setTimeout(() => {
    	resolve(10);
  	}, 1000);
}
function rejectLater(resolve, reject) {
  	setTimeout(() => {
    	reject(new Error("Error"));
  	}, 1000);
}

const p1 = Promise.resolve("foo");
const p2 = p1.then(() => {
  	// 在此返回承诺，它将在1秒后被解决为10
  	return new Promise(resolveLater);
});
p2.then(
  	(v) => {
    	console.log("resolved", v); // "resolved", 10
  	},
  	(e) => {
    	// 不会调用
    	console.error("rejected", e);
  	},
);

const p3 = p1.then(() => {
  	// 在此返回承诺，它将在1秒后以'Error'被拒绝
  	return new Promise(rejectLater);
});
p3.then(
  	(v) => {
    	// 不会调用
    	console.log("resolved", v);
  	},
  	(e) => {
    	console.error("rejected", e); // "rejected", 'Error'
  	}
);
```

​		您可以使用链在另一个这样的函数顶端使用基于承诺的 `API` 去实现一个函数。

```js
function fetchCurrentData() {
  	// fetch() API返回一个Promise。这个函数公开了一个类似的API，只是这个函数的Promise的兑现值在它上面做了更多的工作。
  	return fetch("current-data.json").then((response) => {
    	if (response.headers.get("content-type") !== "application/json") {
      		throw new TypeError();
    	}
    	const j = response.json();
   		// maybe do something with j

    	// fulfillment value given to user of fetchCurrentData().then()
    	return j;
  	});
}
```

​		`then()` 的异步性

```js
// 使用一个已解决的承诺，例如resolvedProm，函数调用resolvedProm.then(...)会立即返回一个新的承诺，但它的回调(value) => {}将被异步调用，正如console.logs所演示的那样。
const resolvedProm = Promise.resolve(33);
console.log(resolvedProm);

// 新的承诺被赋值给thenProm，并且thenProm将被handler返回的值解决。
const thenProm = resolvedProm.then((value) => {
  	console.log(`this gets called after the end of the main stack. the value received is: ${value}, the value returned is: ${value + 1}`);
  	return value + 1;
});
console.log(thenProm);

// 使用setTimeout，可以将函数的执行延迟到栈为空的一瞬间。
setTimeout(() => {
  	console.log(thenProm);
});

/*
> Promise {<fulfilled>: 33}
> Promise {<pending>}
> "this gets called after the end of the main stack. the value received is: 33, the value returned is: 34"
> Promise {<fulfilled>: 34}
*/
```



##### `catch`

​		`catch()` 方法返回一个 `Promise` 并只处理被拒绝的情况。它的行为与调用 `Promise.prototype.then(undefined, onRejected)` 相同（实际上，调用 `obj.catch(onRejected)` 会在内部调用 `obj.then(undefined, onRejected)`）。这意味着你必须提供一个`onRejected` 函数，即使你想退回到一个 `undefined` 的结果值——例如 `obj.catch(() =>{})`。

参数：

- `onRejected`：承诺被拒绝时调用的函数。这个函数有一个 `reason` 参数——拒绝原因。

如果 `onRejected` 抛出错误或返回一个本身被拒绝的 `Promise`， 由 `catch()` 返回的 `Promise` 将被拒绝；否则，它就会被兑现。

返回值：在被调用的对象上内部调用 `Promise.prototype.then` ，传递 `undefined` 参数和接收到的 `onRejected` 处理程序。返回该调用的值，它是一个 `Promise`。

​		`catch` 方法用于 `promise` 复合中的错误处理。因为它返回一个 `Promise`，所以它可以像它的姊妹方法 `then()` 一样被链接起来。

​		`catch()` 在内部调用 `then()`。如果封装该方法，这是可以观察到的。

```js
// 重写原始的Promise.prototype.then/catch，仅仅添加一些log
((Promise) => {
  	const originalThen = Promise.prototype.then;
  	const originalCatch = Promise.prototype.catch;

  	Promise.prototype.then = function (...args) {
    	console.log("Called .then on %o with arguments: %o", this, args);
    	return originalThen.apply(this, args);
  	};
  	Promise.prototype.catch = function (...args) {
    	console.error("Called .catch on %o with arguments: %o", this, args);
    	return originalCatch.apply(this, args);
  	};
})(Promise);

// 在一个已解决的承诺上调用catch
Promise.resolve().catch(function XXX() {});

/*
> Called .catch on Promise {<fulfilled>: undefined} with arguments: [0: ƒ XXX()]
> Called .then on Promise {<fulfilled>: undefined} with arguments: (2) [0: undefined, 1: ƒ XXX()]
*/
```

注意：下面的例子抛出 `Error` 的实例。与抛出字符串相比，这被认为是很好的实践；否则，执行捕获的部分将不得不执行检查，去查看参数是 `string` 还是 `error`，并且您可能会丢失像堆栈跟踪这样的有价值的信息。

​		使用并链接 `catch` 方法

```js
const p1 = new Promise((resolve, reject) => {
  	resolve("Success");
});

p1.then((value) => {
  	console.log(value); // "Success!"
  	throw new Error("oh, no!");
})
 .catch((e) => {
    console.error(e.message); // "oh, no!"
 }) // catch处理后，返回一个新的兑现承诺。
 .then(
    () => console.log("after a catch the chain is restored"),
    () => console.log("Not fired due to the catch")
 );
/*
> "Success"
> "oh, no!"
> "after a catch the chain is restored"
*/

// 下面的行为与上面相同
p1.then((value) => {
  console.log(value); // "Success!"
  return Promise.reject("oh, no!");
})
 .catch((e) => {
    console.error(e); // "oh, no!"
 })
 .then(
    () => console.log("after a catch the chain is restored"),
    () => console.log("Not fired due to the catch")
 );
```

抛出错误时的陷阱（`gotchas`）：

​		抛出错误将在大多数情况下调用 `catch` 方法：

```js
const p1 = new Promise((resolve, reject) => {
  	throw new Error("Uh-oh!");
});

p1.catch((e) => {
  	console.error(e); // "Uh-oh!"
});
/*
Error: Uh-oh!
    at <anonymous>:2:10
    at new Promise (<anonymous>)
    at <anonymous>:1:12
*/
```

​		在异步函数内部抛出的错误将表现为未捕获的错误：

```js
const p2 = new Promise((resolve, reject) => {
  	setTimeout(() => {
    	throw new Error("Uncaught Exception!");
  	}, 1000);
});

p2.catch((e) => {
  	console.error(e); // 这个从来没有被调用过
});

// Uncaught Error: Uncaught Exception!
```

​		在调用 `resolve` 后抛出的错误将被静默处理

```js
const p3 = new Promise((resolve, reject) => {
  	resolve();
  	throw new Error("Silenced Exception!");
});

p3.catch((e) => {
  	console.error(e); // 这个从来没有被调用过
});
```

​		如果承诺是已兑现的，则不会调用 `catch()`。

```js
// 创建一个不会调用onReject的承诺
const p1 = Promise.resolve("calling next");

const p2 = p1.catch((reason) => {
  	// 这个永远不会被调用
  	console.error("catch p1!");
  	console.error(reason);
});

p2.then(
  	(value) => {
    	console.log("next promise's onFulfilled");
    	console.log(value); // calling next
  	},
  	(reason) => {
    	console.log("next promise's onRejected");
    	console.log(reason);
  	}
);

/*
> "next promise's onFulfilled"
> "calling next"
*/
```



##### `finally`

​		`Promise` 的 `finally()` 方法调度一个函数，即回调函数，在 `Promise` 落定时调用它。与 `then()` 和 `catch()` 一样，它立即返回一个等价的 `Promise` 对象，允许您链式调用另一个 `Promise` 方法，这个操作称为 `composition`（复合）。

​		这使您可以避免在 `promise` 的 `then()` 和 `catch()` 处理程序中重复代码。

参数：

- `onFinally`：承诺落定时调用的函数。此处理程序不接收任何参数。

返回值：返回一个等效的 `Promise`，使用其指定的 `finally` 处理程序。如果处理程序抛出错误或返回被拒绝的承诺，则使用该值拒绝由`finally()` 返回的承诺。否则，处理程序的返回值不会影响原始承诺的状态。

​		如果您希望在承诺一旦落定后就执行一些处理或清理，而不管其结果如何，`finally()` 方法是很有用的。

​		`finally()` 方法非常类似于调用 `then(onFinally, onFinally)`，然而，它们有一些区别：

- 当内联创建一个函数时，您可以传递它一次，而不必被迫声明它两次，或者为它创建一个变量。
- `finally` 回调函数不会接收任何参数。当您不关心拒绝原因或兑现值时，此用例对此是恰当的，因此不需要提供它。
- `finally` 调用通常可以通过一个与原始承诺等价的进行连锁。例如，
  - 与 `Promise.resolve(2).then(() => 77, () =>{})`（返回一个解决承诺，结果为 77）不同，`Promise.resolve(2). finally(() => 77)` 将返回一个新的解决承诺，结果为 2。
  - 同样，与 `Promise.reject(3).then(() =>{}, () => 88)`（将返回一个值为 88 的解决承诺）不同，`Promise.reject(3). finally(() => 88` 将返回一个被拒绝的承诺，其原因为 3。
  - 但是，`Promise.reject(3).finally(() => {throw 99})` 和 `Promise.reject(3).finally(() => Promise.reject(99))` 都将拒绝返回的 `promise`，原因是 99。

注意：在 `finally` 回调函数中抛出（或返回被拒绝的承诺）将拒绝返回的承诺，并在抛出时指定原因，如上一个示例所示。

```js
let isLoading = true;

fetch(myRequest)
  	.then((response) => {
    	const contentType = response.headers.get("content-type");
    	if (contentType && contentType.includes("application/json")) {
      		return response.json();
    	}
    	throw new TypeError("Oops, we haven't got JSON!");
  	})
  	.then((json) => {
    	/* 进一步处理你的JSON */
  	})
  	.catch((error) => {
    	console.error(error); // this line can also throw, e.g. when console = {}
  	})
  	.finally(() => {
    	isLoading = false;
  	});
```

<hr>



### 异步函数

​		异步函数是用 `async` 关键字声明的函数，允许在其中使用 `await` 关键字。`async` 和 `await` 关键字支持以更简洁的风格编写基于承诺的异步行为，避免了显式配置承诺链的需要。当然，异步函数也可以被定义为表达式。

参数与形式：异步函数就是在同步函数声明的前面加上 `async` 关键字。其参数等很多方面其实与同步函数无异。

返回值：一个承诺，它将被 `async` 函数返回的值解决，或者被 `async` 函数抛出的异常或在 `async` 函数中未捕获的异常拒绝。

​		异步函数可以包含零或多个 `await` 表达式。`await` 表达式通过暂停执行直到返回的承诺被兑现或拒绝，使承诺返回函数的行为看起来像是同步的。承诺的解决值被视为 `await` 表达式的返回值。使用 `async` 和 `await` 可以在异步代码周围使用普通的 `try...catch`。

注意：在常规 `JavaScript` 代码中 `await` 关键字只在 `async` 函数中有效。如果在异步函数体之外使用它，则会得到 `SyntaxError`。`await` 可以单独与 `JavaScript` 模块一起使用。

注意：`async/await` 的目的是简化必须使用的基于承诺 `API` 的语法。`async/await` 的行为类似于生成器和承诺的组合。

​		`Async` 函数总是返回一个 `promise`。如果 `async` 函数的返回值不是显式的 `promise`，它将隐式地被包装在 `promise` 中。

```js
async function foo() {
  	return 1;
}

// 类似于：
function foo() {
  	return Promise.resolve(1);
}
```

注意：尽管异步函数的返回值表现得就像被包装在 `Promise.resolve` 中一样，但它们不是等同的。如果给定值是一个承诺，异步函数将返回一个不同的引用，而 `Promise.resolve` 将返回相同的引用。当您想要检查承诺和异步函数的返回值是否相等时，可能会出现问题。

```js
const p = new Promise((res, rej) => {
  	res(1);
});

async function asyncReturn() {
  	return p; // 包装成一个新的承诺
}

function basicReturn() {
  	return Promise.resolve(p); // 向下传递该承诺
}

console.log(p === basicReturn()); // true
console.log(p === asyncReturn()); // false
```

​		异步函数的主体可以被认为是被零或多个 `await` 表达式分割的。顶级代码，直到并包括第一个 `await` 表达式（如果有的话），是同步运行的。这样，没有 `await` 表达式的 `async` 函数将同步运行。但是，如果函数体中有 `await` 表达式，异步函数将始终异步完成。

```js
async function foo() {
  	await 1;
}

// 等价于：
function foo() {
  	return Promise.resolve(1).then(() => undefined);
}
```

​		每个 `await` 表达式之后的代码可以被认为是存在于一个 `then` 回调中。在这种方式下，一个承诺链将通过函数的每一个可重入步骤被逐步构建。返回值塑造了链中的最后一环。

在下面的示例中，我们依次等待两个承诺。进程在函数 `foo` 中分三个阶段进行：

- `foo` 的第一行是同步执行的，`await` 表达式配置了待定的承诺。然后，贯穿 `foo` 的进程被暂停，控制权返回给调用 `foo` 的函数。
- 一段时间后，当第一个承诺已经被兑现或拒绝时，控制权就会移回到 `foo` 中。`await` 表达式返回第一个承诺兑现的结果（如果它没有被拒绝）。这里 1 被赋值给 `result1`。进程继续，第二个 `await` 表达式被求值。贯穿 `foo` 的进度再次被挂起，控制权被放回。
- 一段时间后，当第二个承诺被兑现或拒绝时，控制权重新进入 `foo`。第二个承诺解决的结果从第二个 `await` 表达式中返回。这里 2 被赋值给 `result2`。控制权移动到 `return` 表达式（如果有的话）。默认返回值 `undefined` 作为当前承诺的解决值被返回。

```js
async function foo() {
  	const result1 = await new Promise((resolve) =>
    	setTimeout(() => resolve("1"))
  	);
  	const result2 = await new Promise((resolve) =>
   	 	setTimeout(() => resolve("2"))
  	);
}
foo();
```

​		请注意，承诺链不是一次就建立起来的。相反，承诺链是分阶段构建的，因为控制权先后从异步函数中获得和返回。因此，在处理并发的异步操作时，必须留意对错误的处理行为。

​		例如，在下面的代码中，将抛出一个未处理的承诺拒绝错误，即使在承诺链中进一步配置了 `catch` 处理程序。这是因为 `p2` 将不会“连接到”承诺链，直到控制权从 `p1` 返回。

```js
async function foo() {
  	const p1 = new Promise((resolve) => setTimeout(() => resolve("1"), 1000));
  	const p2 = new Promise((_, reject) => setTimeout(() => reject("2"), 500));
  	const results = [await p1, await p2]; // 不要这样做！使用Promise.all或Promise.allSettled代替。
}

foo().catch(() => {}); // 尝试吞下所有错误……
```

​		`Async` 函数声明被提升到作用域的顶部，可以在作用域中的任何地方调用。



#### 异步函数和执行顺序

```js
function resolveAfter2Seconds() {
  console.log("starting slow promise");
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("slow");
      console.log("slow promise is done");
    }, 2000);
  });
}

function resolveAfter1Second() {
  console.log("starting fast promise");
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("fast");
      console.log("fast promise is done");
    }, 1000);
  });
}

async function sequentialStart() {
  console.log("==SEQUENTIAL START==");

  // 1. 执行几乎是瞬间发生的
  const slow = await resolveAfter2Seconds();
  console.log(slow); // 2. 在1.之后2秒运行

  const fast = await resolveAfter1Second();
  console.log(fast); // 3. 在1.之后3秒运行
}

async function concurrentStart() {
  console.log("==CONCURRENT START with await==");
  const slow = resolveAfter2Seconds(); 	// 立即启动计时器
  const fast = resolveAfter1Second(); 	// 立即启动计时器

  // 1. 执行几乎在瞬间发生
  console.log(await slow); // 2. 在1.之后2秒运行
  console.log(await fast); // 3. 在1.之后2秒运行，在2.之后立即运行，因为fast已经resolved了。
}

function concurrentPromise() {
  console.log("==CONCURRENT START with Promise.all==");
  return Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then(
    (messages) => {
      console.log(messages[0]); // slow
      console.log(messages[1]); // fast
    }
  );
}

async function parallel() {
  console.log("==PARALLEL with await Promise.all==");

  // 并行启动两个“任务”并等待它们都完成
  await Promise.all([
    (async () => console.log(await resolveAfter2Seconds()))(),
    (async () => console.log(await resolveAfter1Second()))(),
  ]);
}

sequentialStart(); // 2秒后打印"slow"，然后再过1秒，打印"fast"

// 等待上面完成
setTimeout(concurrentStart, 4000); // 2秒后，先打印"slow"，然后打印"fast"

// 再次等待
setTimeout(concurrentPromise, 7000); // 与concurrentStart相同

// 再次等待
setTimeout(parallel, 10000); // 真正的并行：1秒后，打印"fast"，然后再过1秒，打印"slow"
```



#### 等待和并行

​		在 `sequentialStart` 中，执行在第一个 `await` 时暂停 2 秒，在第二个 `await` 时再暂停 1 秒。第二个定时器直到第一个已经触发时才会创建，因此代码在 3 秒后完成。

​		在 `concurrentStart` 中，创建两个计时器，然后等待。计时器同时运行，这意味着代码在 2 秒而不是 3 秒内完成，如最慢的计时器。但是，`await` 调用仍然是串联运行的，这意味着第二个 `await` 将等待第一个 `await` 的完成。在这种情况下，最快的计时器的结果在最慢的计时器结果之后处理。

​		如果希望安全地并行执行两个或更多任务，则必须等待一个 `Promise.all` 或 `Promise.allSettled` 的调用。

警告：函数 `concurrentStart` 和 `concurrentPromise` 在功能上是不相等的。

​		在 `concurrentStart` 中，如果 `fast` 承诺在 `slow` 承诺兑现之前被拒绝，那么将会引发一个未处理的承诺拒绝错误，而不管调用方是否配置了 `catch` 从句。

​		在 `concurrentPromise` 中，`Promise.all` 一次性连接到承诺链上，这意味着无论拒绝承诺的顺序如何，该操作都将快速失败，并且错误总是发生在配置的承诺链中，从而能够以正常的方式捕获它。



#### 用异步函数重写承诺链

​		一个能够返回 `Promise` 的 `API` 将会产生一条承诺链，并且它将函数分成许多部分。考虑以下代码：

```js
function getProcessedData(url) {
  return downloadData(url) // returns a promise
    .catch((e) => downloadFallbackData(url)) // returns a promise
    .then((v) => processDataInWorker(v)); // returns a promise
}
```

​		它可以用一个异步函数重写，如下所示：

```js
async function getProcessedData(url) {
  let v;
  try {
    v = await downloadData(url);
  } catch (e) {
    v = await downloadFallbackData(url);
  }
  return processDataInWorker(v);
}
```

​		或者，您可以用 `catch()` 链接该承诺：

```js
async function getProcessedData(url) {
  const v = await downloadData(url).catch((e) => downloadFallbackData(url));
  return processDataInWorker(v);
}
```

​		注意，在这两个重写的版本中，`return` 关键字后面没有 `await` 语句，尽管这也是有效的：`async` 函数的返回值隐式地被包装在`Promise.resolve` 中 —— 如果它本身还不是（`not already`）一个承诺（如例子中所示）。

<hr>



### 异步生成器函数

​		`async function*` 声明定义了一个异步生成器函数，它返回一个 `AsyncGenerator` （异步生成器）对象。

​		你还可以使用 `AsyncGeneratorFunction` 构造函数或 `async function*` 表达式语法定义异步生成器函数。

注意：异步生成器函数没有与箭头函数相对应的事物。

​		异步生成器函数（`async generator function`）结合了 `async` 函数和 `generator` 函数的特性。可以在函数体中同时使用 `await` 和 `yield` 关键字。这使您能够在利用生成器函数的惰性特性的同时，还能使用 `await` 处理 `ergonomically`（符合人体工程学、能发挥工作者最大效能）的异步任务。

​		与用 `function*` 声明的普通生成器函数不同，`async` 生成器函数返回一个 `AsyncGenerator` 对象，该对象符合异步可迭代协议。每次调用 `next()` 都会返回一个被解析为迭代器结果对象的 `Promise`。

​		当从异步生成器中产生（`yield`）一个承诺时，迭代器结果承诺的最终状态将与产生的承诺的最终状态匹配。例如：

```js
async function* foo() {
  	yield Promise.reject(1);
}

foo()
  .next()
  .catch((e) => console.error(e));
```

​		1 将被打印出来，因为如果产生的承诺拒绝，迭代器的结果也会拒绝。异步生成器的解析结果的 `value` 属性将不会是另一个承诺。

​		`async function*` 声明会被提升到作用域的顶部，可以在作用域中的任何地方被调用。



#### 声明异步生成器函数

​		异步生成器函数总是产生结果的承诺 —— 即使每个产出（`yield`）步骤是同步的。

```js
async function* myGenerator(step) {
  	await new Promise((resolve) => setTimeout(resolve, 10));
  	yield 0;
  	yield step;
  	yield step * 2;
}

const gen = myGenerator(2);
gen
  	.next()
  	.then((res) => {
    	console.log(res); // { value: 0, done: false }
    	return gen.next();
  	})
  	.then((res) => {
    	console.log(res); // { value: 2, done: false }
    	return gen.next();
  	})
  	.then((res) => {
    	console.log(res); // { value: 4, done: false }
    	return gen.next();
  	})
  	.then((res) => {
    	console.log(res); // { value: undefined, done: true }
    	return gen.next();
  	});
```



#### 读取一系列文件

​		在本例中，我们使用 `Node` 的 `fs/promises` 模块读取一系列文件，并只在请求时访问其内容。

```js
async function* readFiles(directory) {
  	const files = await fs.readdir(directory);
  	for (const file of files) {
    	const stats = await fs.stat(file);
    	if (stats.isFile()) {
      		yield {
        		name: file,
        		content: await fs.readFile(file, "utf8"),
      		};
    	}
  	}
}

const files = readFiles(".");
console.log((await files.next()).value);
// 可能输出：{ name: 'file1.txt', content: '...' }
console.log((await files.next()).value);
// 可能输出：{ name: 'file2.txt', content: '...' }
```

