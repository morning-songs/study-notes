# 适配器模式

适配器模式（`Adapter Pattern`）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

适配器模式的表象就是将一种类的接口转换成另一种类的接口，起到转换器的作用。简单地说，就是统一接口。



### 介绍

**意图：**将一个类的接口转换成客户希望的另外一个接口。从而使原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 

- 系统需要使用现有的类，而此类的接口不符合系统的需要。
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。
- 通过接口转换，将一个类插入另一个类系中（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口）。

**如何解决：**继承或依赖（推荐）。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**应用实例：**

- 美国电器 `110V`，中国 `220V`，就要有一个适配器将 `110V` 转化为 `220V`。
- 在 `LINUX` 上运行 `WINDOWS` 程序。
- 将苹果充电头转为安卓充电头。

**优点：**

- 可以让任何两个没有关联的类一起运行。
- 提高了类的复用。
- 增加了类的透明度。
- 灵活性好。

**缺点：** 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 `A` 接口，其实内部被适配成了 `B` 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

**注意事项：**适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。



### 实现

当两个接口的功能相同，但互不兼容时，就可以使用适配器模式来统一差异。通常，将其中一个统一成另一个即可。

##### 简单实现

首先，定义一个需要被兼容的接口（如苹果充电插头）和一个想要的接口（如华为充电插头）。

```js
class Apple {
    ApplePort() {
        // ...
        console.log("需要被兼容的接口 --- 苹果接口");
    }
}

class Huawei {
    HuaweiPort() {
        // ...
        console.log("想要的接口 --- 华为接口");
    }
}
```

然后，定义一个适配器，将 `ApplePort` 转换为 `HuaweiPort`。

```js
class HuaweiAdapter {
    constructor() {
        this.adapter = new Apple(); // 将不兼容的接口实例存到适配器中。
    }
    // 转换方法
    HuaweiPort() {
        this.adapter.ApplePort; // 取得需要被兼容的接口

        // 执行转换逻辑，将需要被兼容的接口转换成想要的接口...

        console.log("转换成功：需要被兼容的接口 ---> 适配器 ---> 想要的接口");
    }
}
```

最后，实例化适配器进行使用即可。

```js
let adapter = new HuaweiAdapter();
let huawei = new Huawei();

adapter.HuaweiPort(); // "转换成功：需要被兼容的接口 ---> 适配器 ---> 想要的接口"
huawei.HuaweiPort();  // "想要的接口 --- 华为接口"
```

##### 方法接口

```js
let a = {
    show() {
        // 显示一个元素...
    }
}

let b = {
    display() {
        // 显示一个元素...
    }
}

/* 
若直接使用，接口不一致。
    a.show();
    b.display();
*/

// 使用适配器
let c = {
    show() {
        b.display();
    }
}

// 接口一致
a.show();
c.show();
```

##### 数据接口

```js
let a = {
    id: 1
}

let b = {
    ID: 2
}

// 使用适配器
function adapter(data) {
    return { id: data.ID };
}

let c = adapter(b);

// 接口一致
a.id;
c.id;
```

统一接口的好处在于，可以像下面这样使用方法。

```js
function logId(data) {
    console.log(data.id);
}

logId(a); // 1
logId(c); // 2
```

