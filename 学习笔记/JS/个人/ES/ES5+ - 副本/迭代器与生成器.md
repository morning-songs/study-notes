# 迭代器与生成器

​		迭代的英文`“iteration”`源自拉丁文 `itero`，意思是“重复”或“再来”。在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会**有明确的终止条件**。`ECMAScript 6` 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。

​		处理集合中的每个项是很常见的操作。`JavaScript` 提供了许多迭代集合的方法，从简单的 `for` 循环到 `map()` 和 `filter()`。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 `for...of` 循环的行为。

更多参考：[迭代器与生成器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_generators) 、 [`for...of`循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)



## 迭代器

### 理解迭代

​		在 `JavaScript` 中，`for`系列的计数循环就是一种最简单的迭代。循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。

​		迭代会在一个有序集合上进行，（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是对开始项和结束项都有明确的定义）数组是 `JavaScript` 中有序集合的最典型例子。因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。

然而，这种计数循环并不适用于所有的数据结构，有两大主要原因：

- 迭代前需要知道如何迭代数据结构：比如，数组中的每一项都只能先通过引用取得数组对象，然后再通过`[]`操作符取得特定索引位置上的项。这种情况自然不适用于所有数据结构。
- 遍历顺序并不是数据结构固有的：通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。

​		`ES5` 新增了 `Array.prototype.forEach()` 方法，向通用迭代需求迈进了一步，但仍然不够理想。这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。

<hr>

### 迭代器

在 `JavaScript` 中，迭代器是一个对象，它定义一个序列，并在终止时可能返回一个值。 

具体来说，`iterator`是任何通过使用`next()`方法来实现`iterator`协议的对象，该方法返回一个具有两个属性的对象：

- `value`：迭代序列中的下一个值。
- `done`：如果序列中的最后一个值已经被消耗，则为`true`。如果`value`和`done`一起出现，那它就是迭代器的默认返回值。

​		迭代器对象一旦创建，就可以通过反复调用 `next()` 来显式地进行迭代。在一个迭代器上迭代被称为**消耗这个迭代器**，因为它通常只能执行一次。 在产生终止值之后，对 `next()` 的额外调用应该继续返回`{done：true}`。

​		`JavaScript` 中最常见的迭代器是 `Array` 迭代器，它按顺序返回相关数组中的每个值。**虽然很容易想象所有的迭代器都可以表示为数组，但这并不是真的**。数组必须全部分配，但迭代器只在必要时使用。因此，迭代器可以表示无限大的序列，例如从0到∞之间的整数范围。

​		这里有一个例子可以做到这一点。它允许创建一个简单的范围迭代器，该迭代器定义了一个整数序列，从开始（包括）到结束（排除），间隔为一步。它的最终返回值是它创建的序列的大小，由变量 `iterationCount` 跟踪。

```js
// 定义一个可生成范围迭代器的方法
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  	let nextIndex = start;
  	let iterationCount = 0; // 迭代次数，也是最终的返回值。

  	const rangeIterator = {
    	next() {
      		let result;
      		if (nextIndex < end) {
        		result = { value: nextIndex, done: false }; // 非最后一个元素的done属性值均为false
        		nextIndex += step;
        		iterationCount++;
        		return result;
      		}
      		return { value: iterationCount, done: true }; // 最后一个元素的done属性值为true，表示迭代结束
    	}
  	};
  	return rangeIterator;
}

// 使用这个范围迭代器
const it = makeRangeIterator(1, 10, 2); // 范围：[1, 10)，步长：2
// 获取next方法
let result = it.next();

while (!result.done) {
 	console.log(result.value); // 1 3 5 7 9
 	result = it.next();
}

console.log("迭代序列的尺寸: ", result.value); // 5
```

注意：不可能反射性地知道指定对象是否为迭代器。如果需要这样做，请使用`Iterables`。

<hr>

### 迭代器模式

​		在 `ECMAScript` 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。`Python`、`Java`、`C++`，还有其他很多语言都对这个模式提供了完备的支持。`JavaScript` 在 `ECMAScript 6` 以后也支持了迭代器模式。

​		迭代器模式（特别是在 `ECMAScript` 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（`iterable`），因为它们实现了正式的 `Iterable` 接口，而且可以通过迭代器 `Iterator` 消耗。可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。**它们包含的元素都是有限的，而且都具有无歧义的遍历顺序**。

​		不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如前面提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。临时性可迭代对象可以实现为生成器。

​		任何实现 `Iterable` 接口的数据结构都可以被实现 `Iterator` 接口的结构“消耗”（`consume`）。**迭代器（`iterator`）是按需创建的一次性对象**。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 `API`。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是 `Iterable` 和 `Iterator` 的强大之处。



#### 迭代协议

​		迭代协议不是新的内置或语法，而是协议。这些协议可以由任何对象通过遵循一些约定来实现。

​		有两种协议：可迭代协议（`the iterable protocol`）和迭代器协议（`the iterator protocol`）。

更多参考：[迭代协议 `MDN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)

##### 可迭代协议

​		可迭代协议允许`JavaScript`对象定义或自定义它们的迭代行为，例如，在`for-of`结构中，哪些值可以被被遍历到。一些内置类型同时是内置可迭代对象，并且具有默认的迭代行为，比如`Array`或`Map`，而其他类型（如`Object`）则没有。

​		**要成为可迭代对象，一个对象必须实现`@@iterator`方法**，这意味着该对象（或其原型链上的某个对象）必须具有一个带有`@@iterator`键的属性，该键可以通过常量`Symbol.iterator`获得：`[Symbol.iterator]` 是一个没有参数的函数，它返回一个符合迭代器协议的对象。

​		当一个对象需要被迭代的时候（比如在 `for...of` 循环开始时），首先，它会不带参数地调用其 `@@iterator` 方法，然后使用返回的迭代器获得要迭代的值。

​		请注意，当调用这个零参数函数时，它是作为可迭代对象上的一个方法调用的。因此，在函数内部，`this` 关键字可用于访问该可迭代对象的属性，以决定在迭代期间提供什么。该函数可以是普通函数，也可以是生成器函数，因此在调用时，返回一个迭代器对象。在这个生成器函数内部，可以使用`yield`提供每个条目。

​		实现 `Iterable` 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现 `Iterator` 接口的对象的能力。在 `ECMAScript` 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 `Symbol.iterator` 作为键。这个默认迭代器属性还需引用一个迭代器工厂函数（字符串除外），以获得创建新迭代器的能力。

​		很多内置类型都实现了 `Iterable` 接口：字符串、数组、映射、集合、`arguments` 对象、`NodeList` 等 `DOM` 集合类型。

```js
// 调用对象上的默认迭代器属性（Symbol.iterator），可以判断是否存在其迭代器工厂函数，若存在可以获得它。
// 原始值和对象没有实现迭代器工厂函数
let num = 1,
    obj = {};

num[Symbol.iterator]; // undefined
obj[Symbol.iterator]; // undefined

// 字符串、数组、集合、映射、DOM元素节点集合都实现了各自的迭代器工厂函数。
let str = 'abc'; 
let arr = ['a', 'b', 'c']; 
let map = new Map().set('a', 1).set('b', 2).set('c', 3); 
let set = new Set().add('a').add('b').add('c'); 
let els = document.querySelectorAll('div');

str[Symbol.iterator];	// f [Symbol.iterator]() { [native code] }，字符串的迭代器工厂函数就是[Symbol.iterator]
arr[Symbol.iterator];	// f values() { [native code] }
map[Symbol.iterator];	// f entries() { [native code] }，Map的迭代器工厂函数是entries，因为它默认需要迭代条目。
set[Symbol.iterator];	// f values() { [native code] }
els[Symbol.iterator];	// f values() { [native code] }

// 调用这些迭代器工厂函数，可以创建各自的迭代器。
str[Symbol.iterator]();	// StringIterator {}
arr[Symbol.iterator]();	// Array Iterator {}
map[Symbol.iterator]();	// MapIterator {'a' => 1, 'b' => 2, 'c' => 3}
set[Symbol.iterator]();	// SetIterator {'a', 'b', 'c'}
els[Symbol.iterator](); // Array Iterator {}

// 注意，DOM元素节点集合使用的是数组的迭代器工厂函数。
arr[Symbol.iterator] === els[Symbol.iterator];
```

​		实际写代码过程中，通常不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：

- `for-of` 循环
- 数组解构
- 扩展运算符
- `Array.from()`
- 创建集合和映射
- `Promise.all()` 和 `Promise.race()` 都接收由期约组成的可迭代对象
- `yield*`操作符，在生成器中使用

这些原生语言结构会在后台调用可迭代对象的迭代器工厂函数，从而创建一个相应的迭代器。

```js
// 数组解构：使用数组来批量声明变量，还可以很方便地交换两个变量的值。
let [a, b, c] = ['foo', 'bar', 'baz']; // a === 'foo', b === 'bar', c === 'baz';
[b, a] = [a, b]; // 交换两个变量的值

// 如果对象原型链上的父类实现了Iterable接口（构造器工厂函数），那这个对象也就自然而然地继承了这个接口。
class FooArray extends Array {}; 
let fooArr = new FooArray('foo', 'bar', 'baz'); // FooArray(3) ['foo', 'bar', 'baz']
fooArr[Symbol.iterator] === Array.prototype[Symbol.iterator]; // true
```



##### 迭代器协议

​		迭代器协议定义了一种标准的方法来生成一个值序列（有限或无限），并可能在所有值都生成后返回一个值。

​		**当对象实现了拥有如下语义的`next()`方法时，它就成为了一个迭代器**。

​		`next()` 方法接受 0 或 1 个参数，返回一个符合`IteratorResult`接口的对象（见下文）。如果内置语言特性（如`for…of`）使用迭代器时返回非对象值（如`false`或`undefined`），则会抛出 `TypeError` （并提示："`iterator.next()`返回非对象值"）。

所有迭代器协议方法（`next()`、`return()`和`throw()`）都应该返回一个实现`IteratorResult`接口的对象，它必须具有以下属性：

- `done`：一个表示序列是否被迭代完毕的布尔值，如果迭代器还能够生成序列中的下一个值，则为`false`（相当于没有`done`属性）。如果迭代器完成了它的序列，则返回`true`。在这种情况下，`value`可以可选地指定迭代器的返回值。
- `value`：迭代器返回的任何`JavaScript`值。当`done`为`true`时也可以选择不返回任何值。

实际上，这两种属性都不是严格必须的，如果返回一个没有这两个属性的对象，它实际上等价于`{done: false, value: undefined}`。

如果迭代器返回带有`done: true`的结果，那么任何对`next()`的后续调用也应该返回`done: true`，尽管这在语言级别上没有强制要求。

```js
/* 创建迭代器并调用 next() 方法按顺序迭代数组，直至不再产生新值。但迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了 */

let arr = ['foo'],
	iter = arr[Symbol.iterator](); // 调用iterable接口，返回一个iterator迭代器。

iter.next(); // {value: 'foo', done: false}
iter.next(); // {value: undefined, done: true}
iter.next(); // {value: undefined, done: true}
```

​		`next()`方法可以接收一个对它可用的值，任何内置语言特性都不会传递任何值。传递给生成器`next`方法的值将成为相应的`yield`表达式的值。

​		迭代器还可以可选地实现`return(value)`和`throw(exception)`方法，当调用它们时，它们会告诉迭代器：调用者已经完成了对它的迭代，可以执行任何必要的清理（例如关闭数据库连接）。

​		`return(value)`方法接受 0 或 1 个参数，并返回一个符合`IteratorResult`接口的对象。通常，设置其`value`与传入的`value`相等，并将`done`的值设为`true`。调用这个方法会告诉迭代器：调用者不打算再进行`next()`调用，可以执行任何清理操作。

​		`throw(exception)`方法接受 0 或 1 个参数，并返回一个符合`IteratorResult`接口的对象，通常设置`done`为`true`。调用这个方法会告诉迭代器：调用者检测到一个错误状态，而`exception`通常是一个`error`实例。

注意：不可能反射性地（例如不实际调用`next()`并验证返回结果）知道指定对象是否实现了迭代器协议。

另外，让迭代器也成为可迭代对象是非常容易的：只需实现一个可以返回`this`的`[@@iterator]`方法即可。

```js
// 同时满足Iterator和Iterable的协议（可迭代迭代器）
const myIterator = {
  	next() {
    	// ...
  	},
  	[Symbol.iterator] () {
    	return this;
  	},
};
```

​		这种对象被称为`iterable iterator`。这样做允许迭代器被**期望可迭代对象的各种语法**消耗。因此，在不同时实现`Iterable`的情况下，只实现`iterator`协议是没什么用的（事实上，几乎所有的语法和`api`都在期望可迭代对象，而不是迭代器）。`generator`对象就是一个例子：

```js
const aGeneratorObject = (function* () {
  yield 1;
  yield 2;
  yield 3;
})();

typeof aGeneratorObject.next;
// "function" — it has a next method (which returns the right result), so it's an iterator

typeof aGeneratorObject[Symbol.iterator];
// "function" — it has an @@iterator method (which returns the right iterator), so it's an iterable

aGeneratorObject[Symbol.iterator]() === aGeneratorObject;
// true — its @@iterator method returns itself (an iterator), so it's an iterable iterator
```

​		然而，如果有可能的话，最好使用 `iterable[Symbol.iterator]` 返回总是从头开始的不同的迭代器，就像`Set.prototype[@@iterator]()`所做的那样。

​		每个迭代器都表示对可迭代对象的一次性有序遍历。同一迭代器工厂创建的各个迭代器相互独立，都可以独立地遍历可迭代对象。

​		迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。

```js
// 迭代过程中，若数组被修改，这些变化将会反映到迭代器身上。
let arr = ['foo', 'baz'],
	iter = arr[Symbol.iterator]();

iter.next(); // {value: 'foo', done: false}
arr.splice(1, 0, 'bar'); // 在数组中间插入新值
iter.next(); // {value: 'bar', done: false}
```

注意：由于`[Symbol.iterator]()`函数是作为可迭代对象上的一个方法来调用的，因此在迭代器工厂内部可以通过`this`来访问可迭代对象，以获取有用的信息。也就是说，每个迭代器都维护着对可迭代对象的引用，因此，**迭代器会阻止垃圾回收程序回收可迭代对象**。

```js
// 通常，我们都不会显示地创建迭代器。不过当显示地创建迭代器后，要在使用完迭代器之后，及时将其清除。
let arr = ['foo', 'baz'],
	iter = arr[Symbol.iterator]();

iter.next(); // {value: 'foo', done: false}
iter.next(); // {value: 'baz', done: false}
iter.next(); // {value: undefined, done: true}
iter = null;
```

##### 自定义迭代器

与 `Iterable` 接口（`[Symbol.iterator]`）类似，任何实现 `Iterator` 接口（`next`）的对象都可以作为迭代器使用。

当在对象中定义不同形式的函数时，这些函数在内部继承到的`this`也是不同的：

- 普通函数：内部`this`指向包含它的对象。形如：`{next: function () {}}`。
- 箭头函数：内部`this`指向其包含对象所在作用域中的`this`。形如：`{next: () => {}}`
- 简写函数：是普通函数的简写形式，`this`同样指向其包含对象。形如：`{next() {}}`

```js
// 对象相当于一个块级作用域，而块级作用域中的this指向它的外部。
{
    console.log(this); // Window
}

// 浅层嵌套
let obj = {
    name: 'obj',
    sub: {
        name: 'sub',
        // 简写函数（本质上是普通函数）
    	fn1() {
        	return this; // 指向其包含对象sub
    	},
        // 箭头函数
    	fn2: () => {
            return this; // 指向其包含对象所在的作用域中的this，即：Window对象。对象自身并没有this，函数才有this。
        }
    }
}

obj.sub.fn1() === obj.sub; 	// true
obj.sub.fn2() === Window; 	// true

// 深层嵌套
let obj = {
    name: 'obj',
    sub() {
        // sub()中的this指向其包含对象obj
        return {
            name: 'sub',
        	// 简写函数（本质上是普通函数）
    		fn1() {
        		return this; // 指向其包含对象{name: 'sub', fn1: f, fn2: f}
    		},
        	// 箭头函数
    		fn2: () => {
            	return this; // 指向其包含对象所在的作用域中的this，即：obj对象。
        	}
        };
    }
}

obj.sub().fn1(); // {name: 'sub', fn1: f, fn2: f}
obj.sub().fn2() === obj; // true
// 总之，箭头函数的this总是在普通函数this的上一层。
```

```js
// 初步设计一个可迭代对象的类（它实际上是一个迭代器工厂）
class Counter {
    // 可迭代实例（即：迭代器）的基本属性
 	constructor(limit) { 
 		this.count = 1; 
 		this.limit = limit; 
 	}
    // 迭代器接口
 	next() { 
 		if (this.count <= this.limit) { 
 			return { done: false, value: this.count++ }; 
 		} else { 
 			return { done: true, value: undefined }; 
 		} 
 	}
    // 可迭代接口
 	[Symbol.iterator]() { 
 		return this; // 直接返回可迭代实例（即：迭代器）自身
 	} 
}

let counter = new Counter(3); // 创建一个可迭代实例（它实际上是一个迭代器）
for (const i of counter) {
    console.log(i); // 1, 2, 3
}
// 这个类实现了Iterator接口，但并不理想，因为它的每个实例（即：每个迭代器）只能被迭代一次。
for (const i of counter) {
    console.log(i); // 没有打印任何内容，因为该迭代器已不可迭代。
}


// 为了让一个可迭代对象（即：迭代器）能够创建多个独立的迭代器（即：分身），必须每创建一个迭代器（即：分身）就对应一个新计数器。
// 为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器（即：分身）：
class Counter {
    // 可迭代实例（即：迭代器）的基本属性
 	constructor(limit) { 
 		this.limit = limit; 
 	}
    // 可迭代接口（创建迭代器分身的工厂）
 	[Symbol.iterator]() {
        // 这里的this指向创建的可迭代实例。
 		let count = 1, // 每次创建迭代器分身时，都要创建一个新的独立计数器。
            limit = this.limit; // 由于返回的是一个对象，两者的this不一样，因此必须提前保存this.limit的值。
 		return {
            // 迭代器接口
 			next() { 
                // 如果想要这里的this也指向可迭代实例，该方法应该使用箭头函数的形式。
 				if (count <= limit) { 
 					return { done: false, value: count++ }; 
 				} else { 
 					return { done: true, value: undefined }; 
 				} 
 			} 
 		}; 
 	} 
}

/*class Counter {
 	constructor(limit) { 
 		this.limit = limit; 
 	}
 	[Symbol.iterator]() {
        // 这里的this指向创建的可迭代实例。
 		let count = 1;
 		return {
 			next: () => { 
                // 使用箭头函数，继承其包含对象所在作用域中的this（即：可迭代实例）。
 				if (count <= this.limit) { 
 					return { done: false, value: count++ }; 
 				} else { 
 					return { done: true, value: undefined }; 
 				} 
 			} 
 		}; 
 	} 
}*/

let counter = new Counter(3); // 创建一个可迭代对象（它实际上是一个迭代器）
for(const i of counter) {
    console.log(i); // 1, 2, 3
}
for(const i of counter) {
    console.log(i); // 1, 2, 3
}
```

​		每个以这种方式创建的迭代器也实现了 `Iterable` 接口。`Symbol.iterator` 属性引用的迭代器工厂函数会返回相同但各自独立的迭代器。因为每个迭代器也实现了 `Iterable` 接口，所以它们可以用在任何期待可迭代对象的地方，比如 `for-of` 循环。

##### 提前终止迭代器

可选的 `return()` 方法，用于指定在迭代器提前关闭时要执行的逻辑。调用者可以在消耗完可迭代对象之前，关闭迭代器，情况如下：

- `for-of` 循环通过 `break`、`continue`、`return` 或 `throw` 提前退出；
- 解构操作并不打算消耗完所有值。

`return()` 方法必须返回一个有效的 `IteratorResult` 对象。简单一点，可以只返回`{ done: true }`。因为**这个返回值只会用在生成器的上下文中**。在内置语言结构（如`for-of`循环体）中，提前结束迭代，会自动调用 `return()` 方法以告知迭代器“不再执行迭代”。

```js
// 定义一个可关闭迭代器的类
// 关闭迭代器：是指当接受到的done状态为true时，该迭代器应该立即失效或在下次迭代时从头开始，而不是从上次停止的位置继续向下迭代。
class Counter { 
 	constructor(limit) { 
 		this.limit = limit; 
 	} 
 	[Symbol.iterator]() { 
 		let count = 1, 
 		limit = this.limit; 
 		return { 
			 next() { 
 				if (count <= limit) { 
 					return { done: false, value: count++ }; 
 				} else { 
 					return { done: true }; 
 				} 
 			}, 
 			return() { 
 				console.log('提前退出'); 
 				return {done: true}; 
 			} 
 		}; 
 	} 
}

let counter = new Counter(5); 

// 首次调用
for (let i of counter) { 
 	if (i > 2) { 
 		break; // 在3的位置停止
 	} 
 	console.log(i); // 1, 2, "提前退出"
}

// 再次调用迭代器（从头开始）
for (let i of counter) { 
 	console.log(i); // 1, 2, 3, 4, 5
}
```

如果迭代器没有关闭，则还可以继续从上次停止的地方继续迭代。比如，**数组的迭代器就是不能关闭的**。

```js
let a = [1, 2, 3, 4, 5],
	iter = a[Symbol.iterator](); // 获取一个数组迭代器

// 首次调用迭代器
for (let i of iter) { 
 	console.log(i); // 1, 2, 3
 	if (i > 2) { 
 		break; // 在3的位置停止
 	} 
} 

// 再次调用迭代器（从上次停止的地方继续向下迭代）
for (let i of iter) { 
 	console.log(i); // 4, 5
}

// 第三次调用迭代器（迭代器已被消耗完毕）
for (let i of iter) { 
 	console.log(i); // 无任何打印内容
}
```

​		因为 `return()` 方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 `return` 属性是不是函数对象。不过，**就算是给一个不可关闭的迭代器重写这个方法也不能让它变得可关闭**。这是因为调用 `return()` 不会强制迭代器进入关闭状态。即便如此，`return()` 方法还是会被调用。

```js
let a = [1, 2, 3, 4, 5],
	iter = a[Symbol.iterator](); // 获取一个数组迭代器

// 重写return()方法
iter.return = function () {
    console.log("提前退出");
    return {value: undefined, done: true};
}

// 首次调用迭代器
for (let i of iter) { 
 	console.log(i); // 1, 2, 3, "提前退出"
 	if (i > 2) { 
 		break; // 在3的位置停止
 	} 
} 

// 再次调用迭代器（从上次停止的地方继续向下迭代）
for (let i of iter) { 
 	console.log(i); // 4, 5
}
```



##### 异步迭代器与异步可迭代协议

​		还有另外一对用于异步迭代的协议，分别名为`async iterator`和`async iterable`协议。与`iterable`和`iterator`协议相比，它们有非常相似的接口，除了调用`iterator`方法的每个返回值都包装在一个`promise`中之外。

​		当一个对象实现以下方法时，它就实现了`async iterable` 协议：

- [`[Symbol.asyncIterator]`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator) ：一个零参数函数，它返回一个对象，符合`async iterator`协议。

​		当一个对象实现以下方法时，它就实现了`async iterator`协议：

- `next()`：该方法接受  0 或 1 个参数并返回一个`promise`。该`promise`实现了一个符合`IteratorResult`接口的对象，并且属性具有与`sync`迭代器相同的语义。
- `return(value)`：同上
- `throw(exception)`：同上



#### 语言和迭代协议之间的交互

该语言指定了生成或使用可迭代对象和迭代器的`api`。

##### 内置可迭代对象

**`String, Array, TypedArray, Map, Set` 和 `Intl.Segments` 都是内置的可迭代对象**，因为它们的每个原型对象都实现了一个`@@iterator`方法。此外，`arguments` 对象和一些 `DOM` 集合类型（如`NodeList`）也是可迭代对象。**目前没有内置的异步可迭代对象**。

​		生成器函数返回生成器对象，它们是可迭代的迭代器。异步生成器函数返回异步生成器对象，它们是异步的可迭代迭代器。

​		**从内置可迭代对象返回的迭代器实际上都继承自一个公共类（目前未公开）**，它实现了前面提到的`[Symbol.iterator]() {return this;}`方法，使它们都成为可迭代的迭代器。将来，除了迭代器协议所需的`next()`方法之外，这些内置迭代器可能还有其他辅助方法。您可以通过**在图形控制台中记录迭代器的原型链**来检查它。



##### 期待可迭代对象的内置`API`

有许多内置的`api`都接受（期待）可迭代对象，包括以下几个：

- `Map()` 和 `WeakMap()`
- `Set()` 和 `WeakSet()`
- `Promise.all()`、`Promise.allSettled()`、`Promise.race()` 以及 `Promise.any()`
- `Array.from`



##### 期待可迭代对象的内置语法

有些语句和表达式接受可迭代对象，例如：

- `for…of`循环
- 数组
- 扩展运算符
- `yield*`
- 数组解构

`for await...of` 循环和异步生成器函数中的 `yield*` 是与异步可迭代对象交互的唯一方式。在一个异步可迭代对象（即：它有`[@@asyncIterator]()`但没有`[@@iterator]()`）上使用 `for-of` 循环和数组解构等，将会导致抛出 `TypedError`。



##### 不完整的可迭代对象

如果可迭代对象的`@@iterator`方法没有返回迭代器对象（例如返回原始值），那么它就会被认为是不完整（格式不好）的可迭代对象。

<hr>

## 生成器

### 生成器函数

​		虽然自定义迭代器是一种有用的工具，但由于需要显式地维护其内部状态，因此创建它们需要仔细编程。生成器函数提供了一个强大的替代方案：它们允许您**通过编写一个非连续执行的简单函数来定义迭代算法**。生成器函数使用`function*`语法编写。

​		最初调用时，生成器函数不执行任何代码，而是返回一种特殊类型的迭代器，被称为 `Generator`。**当通过调用这个生成器的`next`方法来消耗一个值时，`generator`函数将得到激活并一直执行，直至遇到`yield`关键字。**

​		生成器函数函数可以被调用任意多次，每次都返回一个新的`Generator`。每个`Generator`只能迭代一次。

​		生成器是 `ECMAScript 6` 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如：使用生成器可以自定义迭代器和实现协程。

```js
// 无限生成器函数
function* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  	let iterationCount = 0;
  	for (let i = start; i < end; i += step) {
    	iterationCount++;
    	yield i;
  	}
  	return iterationCount;
}
```



##### 生成器函数的形式

生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。**只要是可以定义函数的地方，就可以定义生成器**。

注意：

- 箭头函数不能用来定义生成器函数。
- 标识生成器函数的星号不受两侧空格的影响。

```js
// 生成器函数声明
function* generatorFn() {} 

// 生成器函数表达式
let generatorFn = function* () {} 

// 作为对象字面量方法的生成器函数
let foo = { 
 	* generatorFn() {} 
} 

// 作为类实例方法的生成器函数
class Foo { 
 	* generatorFn() {} 
} 

// 作为类静态方法的生成器函数
class Bar { 
 	static * generatorFn() {} 
}
```



##### 生成器对象

​		调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（`suspended`）的状态。与迭代器相似，生成器对象也实现了 `Iterator` 接口，因此具有 `next()` 方法。调用这个方法会让生成器开始或恢复执行。

​		`next()` 方法的返回值类似于迭代器，有一个 `done` 属性和一个 `value` 属性。函数体为空的生成器函数中间没有停留，因此，调用一次 `next()` 就会让生成器到达 `done: true` 状态。

```js
// 定义一个空的生成器函数
function* generatorFn() {};

// 调用生成器函数，获取一个生成器
let generatorObject = generatorFn();

// 打印该生成器
generatorObject; 		// generatorFn {<suspended>}【初始状态：suspended暂停】

// 初次调用生成器的next方法
generatorObject.next(); // { done: true, value: undefined }
```

​		`value` 属性是生成器函数的返回值，默认值为 `undefined`，可以通过生成器函数的返回值来指定：

```js
function* generatorFn() { 
 	return 'foo'; 
} 

let generatorObject = generatorFn(); 

generatorObject.next(); // { done: true, value: 'foo' }
```

​		生成器函数只会在初次调用 `next()` 方法后开始执行。生成器对象同时也实现了 `Iterable` 接口，它们默认的迭代器是自引用的。

```js
function* generatorFn() {}

// 查看生成器对象上的Iterable接口
generatorFn()[Symbol.iterator]; // [Symbol.iterator]() { [native code] }

// 通过接口创建一个生成器
generatorFn()[Symbol.iterator](); // generatorFn {<suspended>}

// 通过生成器函数创建一个生成器
const g = generatorFn();
g === g[Symbol.iterator](); // true（return this）
```

<hr>

### 中断生成器

​		`yield` 关键字可以让生成器停止执行，是生成器最有用的地方。生成器函数在遇到 `yield` 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 `next()` 方法来恢复执行。

```js
function* generatorFn() { 
 	yield; 
} 

let generatorObject = generatorFn();

// 初次执行，开启生成器函数
generatorObject.next(); // { done: false, value: undefined }
// 中断后，恢复执行
generatorObject.next(); // { done: true, value: undefined }
```

​		此时的 `yield` 关键字有点像函数的中间返回语句，它生成的值会出现在 `next()` 方法返回的对象里。通过 `yield` 关键字退出的生成器函数会处在 `done: false` 状态；通过 `return` 关键字退出的生成器函数会处于 `done: true` 状态。

```js
// 生成器函数内部，可以设置多个yield字段。当调用next方法时，将依次输出每个字段的值。
function* generatorFn() { 
 	yield 'foo'; 
 	yield 'bar'; 
 	return 'baz'; 
} 

let generatorObject = generatorFn();

generatorObject.next(); // {value: 'foo', done: false}

generatorObject.next(); // {value: 'bar', done: false}

generatorObject.next(); // {value: 'baz', done: true}
```

生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 `next()` 不会影响其他生成器。

```js
// 各个生成器相互独立，互不影响。
function* generatorFn() { 
 	yield 'foo'; 
 	yield 'bar'; 
 	return 'baz'; 
} 

let generatorObject1 = generatorFn(); 
let generatorObject2 = generatorFn(); 

generatorObject1.next(); // { done: false, value: 'foo' } 
generatorObject2.next(); // { done: false, value: 'foo' }
```

​		`yield` 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 `return` 关键字，`yield` 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：

```js
// yield关键字必须直接定义在生成器函数中，否则会抛出语法错误。

// 有效
function* validGeneratorFn() { 
 	yield; 
}

// 无效
function* invalidGeneratorFnA() { 
 	function a() { 
 		yield; 
 	} 
} 

// 无效
function* invalidGeneratorFnB() { 
 	const b = () => { 
 		yield; 
 	} 
} 

// 无效
function* invalidGeneratorFnC() { 
 	(() => { 
 		yield; 
 	})(); 
}
```



##### 作为可迭代对象

直接在生成器对象上显式调用 `next()` 方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：

```js
// 只要使用yield关键字来定义每次迭代的返回值即可
function* generatorFn() { 
 	yield 1; // 第一次迭代
 	yield 2; // 第二次迭代
 	yield 3; // 第三次迭代
} 

for (const x of generatorFn()) { 
 	console.log(x); // 1, 2, 3
}
```

​		在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器只执行指定的次数。使用生成器，可以通过一个简单的循环来实现：

```js
// 每个生成器只执行指定的次数
function* nTimes(n) {
    while(n--) {
        yield;
    }
}

// 该生成器只执行3次
for (let _ of nTimes(3)) {
    console.log('foo'); // 'foo' × 3
}
```



##### 实现输入和输出

​		除了可以作为函数的中间返回语句使用，`yield` 关键字还可以作为函数的中间参数使用。 `yield` 关键字会接收到传给 `next()` 方法的第一个参数，该参数也会成为相应 `yield` 表达式的返回值。但是第一次调用 `next()` 传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：

```js
function* generatorFn(initial) { 
 	console.log(initial); // 第一次的操作被忽略
 	console.log(yield); // 第二次
 	console.log(yield); // 第三次
} 
let generatorObject = generatorFn('foo'); 

// yield只接受next传递的首个参数。
generatorObject.next('bar', 'a'); // foo，首次执行next，传递的参数不会被使用，其他的语句（除yield中断外）也会被忽略。 
generatorObject.next('baz', 'b'); // baz 
generatorObject.next('qux', 'c'); // qux


// yield可以在接收值的同时返回值。
function* generatorFn(initial) { 
 	console.log(initial); // 第一次的操作被忽略
 	console.log(yield 1); // 第二次，但返回值时，它对应第一个next方法。
 	console.log(yield 2); // 第三次
    yield 3;
}
let generatorObject = generatorFn('foo'); 

generatorObject.next('baa', 'a'); // foo, {value: 1, done: false}
generatorObject.next('bab', 'b'); // bab, {value: 2, done: false}
generatorObject.next('bac', 'c'); // bac, {value: 3, done: false}
```

`yield` 关键字可以同时用于输入和输出：

```js
// 因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到yield关键字时暂停执行并计算出要产生的值："foo"。
function* generatorFn() { 
 	return yield 'foo'; // 首次执行完yield 'foo'后暂停，第二次执行return yield（yield接受next的首参）后才结束。
} 

let generatorObject = generatorFn(); 

generatorObject.next(); 		// {value: 'foo', done: false} 
generatorObject.next('bar'); 	// {value: 'bar', done: true}
```

另外，`yield` 关键字在循环结构体中可以被重复使用（大致原因是：循环体是块级作用域，每次循环完毕都会创建新的作用域）。

```js
function* generatorFn() { 
 	for (let i = 0;;++i) { 
 		yield i; 
 	} 
} 

let generatorObject = generatorFn();

generatorObject.next(); // {value: 0, done: false}
generatorObject.next(); // {value: 1, done: false}
generatorObject.next(); // {value: 2, done: false}

// 范围控制
function* range(start, end) { 
 	while(end > start) { 
 		yield start++; 
 	} 
} 
for (const x of range(4, 7)) { 
 	console.log(x); // 4, 5, 6
} 

// 填充数组
function* zeroes(n) { 
 	while(n--) { 
 		yield 0; 
 	} 
} 
Array.from(zeroes(8)); // [0, 0, 0, 0, 0, 0, 0, 0]
```



#### 增强 `yield`

##### 委托其他生成器

可以在 `yield` 后面使用星号来增强 `yield` 的行为，使它能够迭代一个可迭代对象或其他生成器，以便从中一次取出一个值：

```js
function* g1() {
    yield 2;
    yield 3;
    yield 4;
}

function* g2() {
    yield 1;
    yield* g1(); // 委托给g1的生成器
    yield 5;
}

let iter = g2();

iter.next(); // {value: 1, done: false}
iter.next(); // {value: 2, done: false}
iter.next(); // {value: 3, done: false}
iter.next(); // {value: 4, done: false}
iter.next(); // {value: 5, done: false}
```



##### 委托可迭代对象

除了生成器对象这一种可迭代对象，`yield*` 还可以 `yield` 其它任意的可迭代对象，比如说数组、字符串、`arguments` 对象等等。

```js
// 增强yield，使它可以迭代可迭代对象
function* generatorFn() {
    yield* [1, 2, 3]; // 迭代该数组，每次迭代取出一个元素
}

// 等价于：
function* generatorFn() {
    for (const ele of [1, 2, 3]) {
        yield ele;
    }
}

for (const x of generatorFn()) { 
 	console.log(x); // 1, 2, 3
}
```



##### `yield*` 返回值

`yield*` 表达式本身的值是当迭代器关闭时返回的值（即`done`为`true`时）。

```js
// 对于普通迭代器来说，这个值是undefined
let result;

function* g1() {
    result = yield* [1, 2, 3]; // 委托给可迭代对象时，yield*表达式的值为undefined
}

for (const x of g1()) {
    console.log(x);
}

result; // undefined

// 对于生成器来说，这个值是生成器函数return的值。
let result;

function* g1() {
    yield* [1, 2, 3];
    return 'foo';
}

function* g2() {
    result = yield* g1(); // 委托给其他生成器时，yield*表达式的值为生成器函数return的值
}

for (const x of g2()) {
    console.log(x);
}

result; // 'foo'
```



##### 实现递归算法

`yield*` 最有用的地方是实现递归操作，生成器函数会递归地减少计数器值，并实例化另一个生成器对象。

注释：

- `yield` 是中断生成器的关键，也是改变 `next` 返回值的状态，从而使得 `next` 方法能够持续迭代的关键。
- `yield*` 是持续递归地调用生成器函数的关键，没有它生成器函数将只能被递归一次且变量副本无法保留。

```js
// 生成器函数的代码，只在初次调用next方法之后才开始执行，直至遇到yield之后才停止。
function* nTimes(n) {
 	if (n > 0) {
        // 递归地创建n的变量副本
        // yield*运算符，用于递归地调用生成器函数，并递归地产生和返回n的副本。如果没有它，将只能递归一次且无法保留n的副本。
 		yield* nTimes(n - 1); // 递归地调用生成器函数nTimes(n - 1)，依次创建n的副本：2, 1, 0。递归地返回0, 1, 2副本。
        // 递归完成后，执行的语句
        console.log(n); // 1, 2, 3【n = 0的副本被舍弃，因此n剩余的副本依次为：1, 2, 3】
        yield n - 1; // 依次yield递归产生的n的副本，一次取一个。
 	}
    console.log(n); // 依次打印n的所有副本：0, 1, 2, 3
} 

// 从最顶层来看，相当于创建一个可迭代对象并递增地返回[0, n)内的整数。
for (const x of nTimes(3)) { 
 	console.log(x); // 0, 1, 2
}

// 如果没有yield*运算符
function* nTimes(n) {
    if (n > 0) {
        nTimes(n - 1); 	// 只递归一次，产生了一个n = 2的副本，但它并没有被保留下来。
        // 递归完成后
        console.log(n); // n的副本只有一个：最初值3
        yield n - 1; 	// yield 2;
    }
}

for (const x of nTimes(3)) {
    console.log(x); // 2
}

// 如果没有yield运算符
function* nTimes(n) {
    if (n > 0) {
        yield* nTimes(n - 1); 	// 只递归一次，产生了一个n = 2的副本，但它并没有被保留下来。
        // 递归完成后
        console.log(n); // n的副本有3个：1, 2, 3
    }
}

for (const x of nTimes(3)) {
    console.log(x); // nothing，因为没有找到yield语句的返回值，无法开启迭代。
}
```

使用递归生成器结构和 `yield*` 可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：

```js
// 创建节点的类
class Node { 
    // 节点基本属性
 	constructor(id) { 
 		this.id = id; // 每个节点的标识属性
 		this.neighbors = new Set(); // 连接节点的集合
 	}
    // 连接节点（将自己放在后面）
 	connect(node) { 
 		if (node !== this) { 
 			this.neighbors.add(node); 
 			node.neighbors.add(this); 
 		} 
 	} 
} 

// 创建随机图的类
class RandomGraph { 
 	constructor(size) { 
 		this.nodes = new Set(); // 节点的集合
 		// 创建指定数量的节点
 		for (let i = 0; i < size; ++i) { 
 			this.nodes.add(new Node(i)); // 调用Node类创建节点
 		} 
 		const threshold = 1 / size; // 指定一个随机阈值（当随机数小于该值时，连接两个节点）
 		// 阵列式（二维数组的形式）遍历节点集合
        for (const x of this.nodes) { 
 			for (const y of this.nodes) { 
				if (Math.random() < threshold) { 
 					x.connect(y); // 一个节点可能有多个相邻节点，也可能有0个
 				} 
 			} 
 		} 
	 } 
 	// 调试方法
 	print() {
        // 遍历节点集合，以逗号连接节点及其相邻节点的id属性（节点自身位于最后）
 		for (const node of this.nodes) { 
 			const ids = [...node.neighbors].map((n) => n.id).join(','); 
 			console.log(`${node.id}: ${ids}`); 
 		} 
 	} 
} 

const g = new RandomGraph(6); 

g.print(); 
// 示例输出：
// 0: 1, 2, 4
// 1: 0, 2, 4
// 2: 1, 0 
// 3: 5
// 4: 0, 1
// 5: 3
```

​		图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：

```js
class Node { 
 	constructor(id) { 
 		... 
 	} 
 	connect(node) { 
 		... 
 	} 
} 
        
class RandomGraph { 
 	constructor(size) { 
 		... 
 	} 
 	print() { 
 		... 
 	}
    // 检测该图是否连通
 	isConnected() { 
 		const visitedNodes = new Set(); 
		function* traverse(nodes) { 
			for (const node of nodes) { 
				if (!visitedNodes.has(node)) { 
					yield node; 
					yield* traverse(node.neighbors); 
				} 
			} 
 		} 
 		// 取得集合中的第一个节点
 		const firstNode = this.nodes[Symbol.iterator]().next().value; 
 		// 使用递归生成器迭代每个节点
 		for (const node of traverse([firstNode])) { 
			visitedNodes.add(node); 
 		} 
 		return visitedNodes.size === this.nodes.size; 
 	} 
}
```

<hr>

### 默认迭代器

因为生成器对象实现了 `Iterable` 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。

下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：

```js
class Foo {
    constructor(args) {
        this.values = new Set(args);
    }
    *[Symbol.iterator]() {
        yield* this.values;
    }
}

const f = new Foo([1, 2, 3]); // 只接收可迭代对象

for (const x of f) { 
 	console.log(x); // 1, 2, 3
}
```

<hr>

### 关闭生成器

​		与迭代器类似，生成器也支持“可关闭”的概念。一个实现 `Iterator` 接口的对象一定有 `next()` 方法，还有两个可选的 `return()` 方法和 `throw()` 方法，其中 `return()` 方法用于提前终止迭代器。这两个方法都可以强制生成器进入关闭状态。

##### `return()`

```js
// 提供给return()方法的参数，会成为迭代器终止时的值。
function* generatorFn() { 
 	for (const x of [1, 2, 3]) { 
 		yield x; 
 	} 
} 
const g = generatorFn();

g.next(); 		// {value: 1, done: false}
g.next(); 		// {value: 2, done: false}
g.return(4); 	// {value: 4, done: true}
g.next(); 		// {value: undefined, done: true}
```

​		与迭代器不同的是，所有生成器对象都有 `return()` 方法，只要通过它进入关闭状态，就无法恢复了。后续调用 `next()` 只会显示 `done: true` 状态，且提供的任何返回值都不会被存储或传播。

​		`for-of` 循环等内置语言结构会忽略（即：不会遍历）状态为 `done: true` 的 `IteratorObject` 内部的`value`值。

```js
function* generatorFn() { 
 	for (const x of [1, 2, 3]) { 
 		yield x; 
 	} 
} 
const g = generatorFn(); 

for (const x of g) { 
 	if (x > 1) { 
 		g.return(4); 
 	} 
 	console.log(x); // 1, 2
}

g; // generatorFn {<closed>}
```



##### `throw()`

​		`throw()` 方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭。

```js
function* generatorFn() { 
 	for (const x of [1, 2, 3]) { 
 		yield x; 
 	} 
} 
const g = generatorFn(); 
g; // generatorFn {<suspended>} 

g.next(); // {value: 1, done: false}

// 在生成器函数外部捕获错误，生成器一定进入关闭状态。
try { 
 	g.throw('foo'); 
} catch (e) { 
 	console.log(e); // foo 
} 
g; // generatorFn {<closed>}
```

​		不过，如果在生成器函数内部捕获这个错误，那么生成器就不会被关闭，而且还可以恢复执行。

```js
function* generatorFn() { 
 	for (const x of [1, 2, 3]) { 
 		try { 
 			yield x; 
 		} catch(e) {} 
 	} 
}
const g = generatorFn(); 

g.next(); 		// {value: 1, done: false} 
g.throw('foo'); // {value: 2, done: false}
g.next(); 		// {value: 3, done: false}
```

注意：如果生成器对象还没有开始执行，调用 `throw()` 抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。

```js
function* generatorFn() { 
 	for (const x of [1, 2, 3]) { 
 		try { 
 			yield x; 
 		} catch(e) {} 
 	} 
}
const g = generatorFn();

// 抛出错误
g.throw('foo'); // VM4300:1 Uncaught foo

// 捕获错误
try { 
 	g.throw('foo'); 
} catch (e) { 
 	console.log(e); // foo 
}
```

<hr>

### 高级生成器

​		生成器会根据需要计算它们 `yield` 的值，这使它们能够高效地表示计算成本较高的序列，甚至是无限序列。

​		`next()` 方法也接受一个值，该值可用于修改生成器的内部状态。传递给 `next()` 的值将由相应 `yield` 接收。不过，传递给 `next()` 的第一次调用的值总是被忽略。

更多参考：[高级生成器 `MDN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators#advanced_generators)

下面是使用 `next(x)` 重新启动序列的斐波那契生成器：

```js
function* fibonacci() {
  	let current = 0,
  		next = 1;
  	while (true) {
    	const reset = yield current; // 将重置状态设为yield表达式的结果，并且每次迭代返回current的值。
    	[current, next] = [next, next + current]; // 依次更新current和next的值
    	if (reset) {
      		current = 0;
      		next = 1;
    	}
  	}
}

const sequence = fibonacci();

// 启动序列：如果无参调用next()，那么重置状态为undefined。如果传参调用，则重置状态为传递的参数。
console.log(sequence.next().value);     // 0
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 2
console.log(sequence.next().value);     // 3
console.log(sequence.next().value);     // 5
console.log(sequence.next().value);     // 8
console.log(sequence.next(true).value); // 0，重新启动
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 1
console.log(sequence.next().value);     // 2
```

<hr>

### 小结

​		迭代是一种所有编程语言中都可以看到的模式。`ES6` 正式支持迭代模式并引入了两个新的语言特性：迭代器和生成器。

​		迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 `Iterable` 接口的对象都必须有一个 `Symbol.iterator` 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂函数，调用之后会产生一个实现 `Iterator` 接口的迭代器对象。

​		迭代器必须通过连续调用 `next()` 方法才能连续取得值，这个方法返回一个 `IteratorObject`。该对象包含一个 `done` 属性和一个 `value` 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动调用 `next()`方法来消耗，也可以通过原生的消耗者来自动消耗，比如 `for-of` 循环。

​		生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 `Iterable` 接口，因此可用在任何消耗可迭代对象的地方。生成器的独特之处在于支持 `yield` 关键字，这个关键字能够暂停执行生成器函数。使用 `yield` 关键字还可以通过 `next()` 方法接收输入和产生输出。在加上星号之后，`yield` 关键字可以将跟在它后面的可迭代对象序列化为一连串值。

