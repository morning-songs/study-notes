# 中介者模式

中介者模式（`Mediator Pattern`）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。

中介者模式：用于解除多个对象和多个类之间的直接关联性，将多个类和多个对象直接与中介者关联起来，形成两边的一对多关系。简单地说，就是将网状关系解耦成伞状关系。



### 介绍

**意图：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

**主要解决：**对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。

**何时使用：**多个类相互耦合，形成了网状结构。

**如何解决：**将上述网状结构分离为星型结构。

**关键代码：**对象 `Colleague` 之间的通信封装到一个类中单独处理。

**应用实例：** 

- 中国加入 `WTO` 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 `WTO` 来互相贸易。 
- 机场调度系统。 
- `MVC` 框架，其中`C`（控制器）就是 `M`（模型）和 `V`（视图）的中介者。

**优点：** 

- 降低了类的复杂度，将一对多转化成了一对一。 
- 各个类之间的解耦。 
- 符合迪米特原则。

**缺点：**中介者会庞大，变得复杂难以维护。

**使用场景：** 

- 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 
- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

**注意事项：**不应当在职责混乱的时候使用。



### 实现

#### 对局挑战

##### 单人对局

```js
class Player {
    constructor(name) {
        this.name = name;
        this.enemy = null;
    }
    win() {
        console.log(`${this.name}，恭喜你，获得胜利`);
    }
    lose() {
        console.log(`${this.name}，很遗憾，挑战失败`);
    }
    die() {
        // 阵亡时：己方失败，对方获胜。
        this.lose();
        this.enemy.win();
    }
}
```

使用

```js
let wz = new Player("wz");
let cy = new Player("cy");

// 匹配对手，建立对局
wz.enemy = cy;
cy.enemy = wz;

// 一方阵亡，游戏结束
cy.die();
```

##### 多人对局

如果开启多人团战对局，则每个玩家都需要与其他所有人建立敌友关系，对象之间的关系就会像网状一样错综复杂。此时，就可以通过中介者模式来解决这个问题。

```js
class Player {
    constructor(palyerName, teamName) {
        this.palyerName = palyerName; 	// 玩家名称
        this.teamName = teamName; 		// 队伍名称
        this.teammates = []; 			// 队友列表
        this.enemies = []; 				// 敌人列表
        this.liveState = true; 			// 存活状态
    }
    win() {
        console.log(`${this.palyerName}，恭喜你，获得胜利`);
    }
    lose() {
        console.log(`${this.palyerName}，很遗憾，对局失败`);
    }
    die() {
        this.liveState = false;
        
        let teammates = this.teammates,
            enemies = this.enemies,
            teamLiveState = false;

        for(let i = 0, len = teammates.length; i < len; i++) {
            // 有存活，则继续。
            if(teammates[i].liveState) {
                teamLiveState = true;
                break;
            }
        }
        
        console.log(`${this.teamName}玩家-${this.palyerName}阵亡，${teamLiveState ? "队友存活，游戏继续" : "全队阵亡，游戏结束"}`);
        
        if(!teamLiveState) {
            // 无存活，则结束。
            this.lose();
            teammates.forEach(item => item.lose());
            enemies.forEach(item => item.win());
        }
    }
}
```

定义一个建立玩家关系的函数。

```js
let players = [
    // 红队选手
    new Player("甲", "红队"),
    new Player("乙", "红队"),
    new Player("丙", "红队"),
    new Player("丁", "红队"),
    new Player("戊", "红队"),
    // 蓝队选手
    new Player("己", "蓝队"),
    new Player("庚", "蓝队"),
    new Player("戌", "蓝队"),
    new Player("壬", "蓝队"),
    new Player("癸", "蓝队"),
];

function createConnection(players) {
    players.forEach(player => {
        const teammates = player.teammates,
              enemies = player.enemies;
        players.forEach(otherPlayer => {
            if (player === otherPlayer) return;
            if (player.teamName === otherPlayer.teamName) {
                return teammates.push(otherPlayer);
            } else {
                return enemies.push(otherPlayer);
            }
        })
    })
}

createConnection(players);
```

##### 使用中介

多人对局中，玩家之间的关系呈现网状结构，使系统的复杂度增加。此时，可以使用中介者模式来改造结构，降低这种复杂度。

首先，将玩家的敌友列表抽取出来，交给中介者去维护。敌友关系、胜负关系等也都由中介者进行确定，玩家只保持基本信息。

```js
class Player {
    constructor(palyerName, teamName, mediator) {
        this.palyerName = palyerName; 	// 玩家名称
        this.teamName = teamName; 		// 队伍名称
        this.liveState = true; 			// 存活状态
        this.mediator = mediator;
        // 将玩家交给中介者去进行处理
        mediator.addPlayer(this);
    }
    win() {
        console.log(`${this.palyerName}，恭喜你，获得胜利`);
    }
    lose() {
        console.log(`${this.palyerName}，很遗憾，对局失败`);
    }
    die() {
        this.liveState = false;
        // 告知中介，玩家阵亡
        this.mediator.playerDead(this);
    }
}
```

然后，定义一个中介者类。

```js
class Mediator {
    constructor() {
        // 团队信息
        this.teams = {};
        this.survivingTeams = [];
    }
    // 添加玩家
    addPlayer(player) {
        const teamName = player.teamName,
              teams = this.teams;
        if (!teams[teamName]) {
            teams[teamName] = []; 				// 创建团队
            teams[teamName].liveState = true; 	// 团队状态
            this.survivingTeams.push(teamName);
        }
        teams[teamName].push(player); // 将玩家加入队伍
    }
    // 玩家阵亡
    playerDead(player) {
        const teamName = player.teamName,
              team = this.teams[teamName];
        let teamLive = false;
        for (let player of team) {
            if (player.liveState) {
                teamLive = true;
                break;
            }
        }
        // 游戏播报
        console.log(`${teamName}队玩家-${player.palyerName}阵亡，${teamLive ? "队伍存活" : "队伍阵亡"}`);
        // 全队阵亡
        if (!teamLive) {
            team.forEach(player => player.lose());
            team.liveState = false;
            this.teamDead(teamName);
        }
    }
    // 队伍阵亡
    teamDead(fallenTeam) {
        const survivingTeams = this.survivingTeams;
        survivingTeams.splice(survivingTeams.findIndex(item => item === fallenTeam), 1);
        if (survivingTeams.length === 1) {
            const winningTeam = survivingTeams[0];
            this.teams[winningTeam].forEach(player => player.win());
            console.log(`游戏结束，${winningTeam}队获胜`);
        }
    }
}
```

使用

```js
const mediator = new Mediator();

let p1 = new Player("甲", "red", mediator),
    p2 = new Player("乙", "red", mediator),
    p3 = new Player("丙", "red", mediator),
    p4 = new Player("丁", "red", mediator),
    p5 = new Player("戊", "red", mediator),
    p6 = new Player("己", "blue", mediator),
    p7 = new Player("庚", "blue", mediator),
    p8 = new Player("辛", "blue", mediator),
    p9 = new Player("壬", "blue", mediator),
    p10 = new Player("癸", "blue", mediator);

p1.die();
p6.die();
p7.die();
p3.die();
p2.die();
p4.die();
p5.die();
```

##### 中介内置

可以将中介者类内置到玩家类当中，在类型上进行绑定，就不必绑定到每一个实例身上了。

```js
class Player {
    constructor(palyerName, teamName) {
        this.palyerName = palyerName; 	// 玩家名称
        this.teamName = teamName; 		// 队伍名称
        this.liveState = true; 			// 存活状态
        // 将玩家交给中介者去进行处理
        mediator.addPlayer(this);
    }
    win() {
        console.log(`${this.palyerName}，恭喜你，获得胜利`);
    }
    lose() {
        console.log(`${this.palyerName}，很遗憾，对局失败`);
    }
    die() {
        this.liveState = false;
        // 告知中介，玩家阵亡
        mediator.playerDead(this);
    }
}

class Mediator {
    constructor() {
        // 团队信息
        this.teams = {};
        this.survivingTeams = [];
    }
    // 添加玩家
    addPlayer(player) {
        const teamName = player.teamName,
              teams = this.teams;
        if (!teams[teamName]) {
            teams[teamName] = []; 				// 创建团队
            teams[teamName].liveState = true; 	// 团队状态
            this.survivingTeams.push(teamName);
        }
        teams[teamName].push(player); // 将玩家加入队伍
    }
    // 玩家阵亡
    playerDead(player) {
        const teamName = player.teamName,
              team = this.teams[teamName];
        let teamLive = false;
        for (let player of team) {
            if (player.liveState) {
                teamLive = true;
                break;
            }
        }
        // 游戏播报
        console.log(`${teamName}队玩家-${player.palyerName}阵亡，${teamLive ? "队伍存活" : "队伍阵亡"}`);
        // 全队阵亡
        if (!teamLive) {
            team.forEach(player => player.lose());
            team.liveState = false;
            this.teamDead(teamName);
        }
    }
    // 队伍阵亡
    teamDead(fallenTeam) {
        const survivingTeams = this.survivingTeams;
        survivingTeams.splice(survivingTeams.findIndex(item => item === fallenTeam), 1);
        if (survivingTeams.length === 1) {
            const winningTeam = survivingTeams[0];
            this.teams[winningTeam].forEach(player => player.win());
            console.log(`游戏结束，${winningTeam}队获胜`);
        }
    }
}

const mediator = new Mediator();

let p1 = new Player("甲", "red"),
    p2 = new Player("乙", "red"),
    p3 = new Player("丙", "red"),
    p4 = new Player("丁", "red"),
    p5 = new Player("戊", "red"),
    p6 = new Player("己", "blue"),
    p7 = new Player("庚", "blue"),
    p8 = new Player("辛", "blue"),
    p9 = new Player("壬", "blue"),
    p10 = new Player("癸", "blue");

p1.die();
p6.die();
p7.die();
p3.die();
p2.die();
p4.die();
p5.die();
```

##### 静态私有

```js
class Mediator {
    constructor() {
        // 团队信息
        this.teams = {};
        this.survivingTeams = [];
    }
    // 添加玩家
    addPlayer(player) {
        const teamName = player.teamName,
              teams = this.teams;
        if (!teams[teamName]) {
            teams[teamName] = []; 				// 创建团队
            teams[teamName].liveState = true; 	// 团队状态
            this.survivingTeams.push(teamName);
        }
        teams[teamName].push(player); // 将玩家加入队伍
    }
    // 玩家阵亡
    playerDead(player) {
        const teamName = player.teamName,
              team = this.teams[teamName];
        let teamLive = false;
        for (let player of team) {
            if (player.liveState) {
                teamLive = true;
                break;
            }
        }
        // 游戏播报
        console.log(`${teamName}队玩家-${player.palyerName}阵亡，${teamLive ? "队伍存活" : "队伍阵亡"}`);
        // 全队阵亡
        if (!teamLive) {
            team.forEach(player => player.lose());
            team.liveState = false;
            this.teamDead(teamName);
        }
    }
    // 队伍阵亡
    teamDead(fallenTeam) {
        const survivingTeams = this.survivingTeams;
        survivingTeams.splice(survivingTeams.findIndex(item => item === fallenTeam), 1);
        if (survivingTeams.length === 1) {
            const winningTeam = survivingTeams[0];
            this.teams[winningTeam].forEach(player => player.win());
            console.log(`游戏结束，${winningTeam}队获胜`);
        }
    }
}

class Player {
    static #mediator = new Mediator()
    constructor(palyerName, teamName) {
        this.palyerName = palyerName; 	// 玩家名称
        this.teamName = teamName; 		// 队伍名称
        this.liveState = true; 			// 存活状态
        // 将玩家交给中介者去进行处理
        this.constructor.#mediator.addPlayer(this);
    }
    win() {
        console.log(`${this.palyerName}，恭喜你，获得胜利`);
    }
    lose() {
        console.log(`${this.palyerName}，很遗憾，对局失败`);
    }
    die() {
        this.liveState = false;
        // 告知中介，玩家阵亡
        this.constructor.#mediator.playerDead(this);
    }
}

let p1 = new Player("甲", "red"),
    p2 = new Player("乙", "red"),
    p3 = new Player("丙", "red"),
    p4 = new Player("丁", "red"),
    p5 = new Player("戊", "red"),
    p6 = new Player("己", "blue"),
    p7 = new Player("庚", "blue"),
    p8 = new Player("辛", "blue"),
    p9 = new Player("壬", "blue"),
    p10 = new Player("癸", "blue");

p1.die();
p6.die();
p7.die();
p3.die();
p2.die();
p4.die();
p5.die();
```



