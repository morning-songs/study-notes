# 队列

队列，就像排队中的一条长列一样，它只在队尾插入数据，且只在队首删除数据。于是，呈现出：先进先出，后进后出的规律。



### 实现

##### 简单实现

```js
class Queue {
    constructor() {
        this.queue = [];
    }
    // 入队
    enqueue(...items) {
        this.queue.push(...items);
    }
    // 静态出队
    getFirst() {
        if(!this.size()) return console.warn("队已空");
        return this.queue[0];
    }
    // 动态出队
    dequeue() {
        if(!this.size()) return console.warn("队已空");
        return this.queue.shift();
    }
    // 清空队列
    clear() {
        this.queue = [];
    }
    // 队长
    size() {
        return this.queue.length;
    }
}
```

使用

```js
let queue = new Queue();

// 单条存储
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);

// 批量存储
queue.enqueue(1, 2, 3);

// 静态读取
queue.getFirst(); // 1

// 动态读取
console.log(queue.dequeue()); // 1
console.log(queue.dequeue()); // 2
console.log(queue.dequeue()); // 3
console.log(queue.dequeue()); // "队已空", undefined

// 清空队
queue.clear();

// 队长度
queue.size(); // 0
```

##### 隐藏封装

```js
const Queue = (function() {
    let sym = Symbol();
    return class Queue {
        constructor() {
            this[sym] = [];
        }
        // 入队
        enqueue(...items) {
            this[sym].push(...items);
        }
        // 静态出队
        getFirst() {
            if(!this.size()) return console.warn("队已空");
            return this[sym][0];
        }
        // 动态出队
        dequeue() {
            if(!this.size()) return console.warn("队已空");
            return this[sym].shift();
        }
        // 清空队列
        clear() {
            this[sym] = [];
        }
        // 队长
        size() {
            return this[sym].length;
        }
    }
})();
```



### 应用

##### 动画队列

模拟实现 `JQuery` 的 `animate()` 动画 `API`。

```js
// queue.js
(function() {
    const Queue = (function () {
        let sym = Symbol();
        return class Queue {
            constructor() {
                this[sym] = [];
            }
            // 入队
            enqueue(...items) {
                this[sym].push(...items);
            }
            // 静态出队
            getFirst() {
                if (!this.size()) return console.warn("队已空");
                return this[sym][0];
            }
            // 动态出队
            dequeue() {
                if (!this.size()) return console.warn("队已空");
                return this[sym].shift();
            }
            // 清空队列
            clear() {
                this[sym] = [];
            }
            // 队长
            size() {
                return this[sym].length;
            }
        }
    })();

    // 动画队列
    class AnimateQueue extends Queue {
        constructor() {
            super()
            this.isRun = false;
        }
        // 入队
        enqueue(...items) {
            // 入队
            super.enqueue(...items);
            // 执行
            this.run();
        }
        // 执行动画
        run() {
            if(this.isRun) return;
            this.isRun = true;
            // 等待动画执行完毕
            new Promise(this.dequeue()).then(() => {
                this.isRun = false; // 执行完毕后
                this.size() && this.run(); // 继续执行下一个
            })
        }
    }

    // 单位补全
    function addPx(value) {
        value += "";
        if(/^\d+$/.test(value)) value += "px";
        return value;
    }

    // 动画队列集合
    let animateMap = new Map();

    class Init {
        constructor(selector) {
            const type = typeof selector;
            let dom = [];
            if(type === "string") {
                dom = document.querySelectorAll(selector);
            }
            if(type === "object") {
                dom = [selector];
            }
            dom.forEach((item, i) => {
                this[i] = item;
            })
            this.length = dom.length;
        }
        each(fn) {
            for(let i = 0, len = this.length; i < len; i++) {
                fn.call(this[i], i);
            }
            return this;
        }
        css(attr, value) {
            const typeA = typeof attr,
                  typeB = typeof value;

            // 设置单条样式
            if(typeA === "string" && (typeB === "string" || typeB === "number")) {
                this.each(function() {
                    this.style[attr] = addPx(value);
                });
            }
            // 设置多条样式
            if(typeA === "object") {
                const keys = Object.keys(attr);
                this.each(function() {
                    for(let key of keys) {
                        this.style[key] = addPx(attr[key]); 
                    }
                });
            }
            // 获取单条样式
            if (typeA === "string" && value === undefined) {
                if(this.length) {
                    return getComputedStyle(this[0])[attr];
                } else {
                    return;
                }
            }
            return this;
        }
        animate(options, time = 1000) {
            this.each(function() {
                let animateQueue = animateMap.has(this) ? animateMap.get(this) : new AnimateQueue();
                animateMap.set(this, animateQueue);
                const ele = $(this);
                const initTranstion = ele.css("transition");
                // 若在这里：ele.css(options)，则一次触发所有动画。

                animateQueue.enqueue((resolve, reject) => {
                    ele.css("transition", time + "ms");
                    ele.css(options);

                    setTimeout(() => {
                        ele.css("transition", initTranstion);
                        resolve();
                    }, time);
                })
            });
            return this;
        }
    }

    window.$ = function(selector) {
        return new Init(selector);
    } 
})();
```

使用

```html
<div id="wrap">
    <div class="color"></div>
</div>

<script src="./queue.js"></script>
<script>
    $("#wrap")
        .css({
            position: "absolute",
            left: 0,
            top: 0,
            width: 300,
            height: 200,
            backgroundColor: "red"
        })
        .animate({
            left: 200
        }, 5000);

    $(".color")
        .css({
            width: 100,
            height: 100
        })
        .css("background-color", "blue")
        .animate({
            backgroundColor: "green"
        }, 3000)
        .animate({
            backgroundColor: "red"
        }, 2000);
</script>
```

##### 优先队列

优先队列：一种抽象数据类型，其中每个元素都有一个优先级。元素按优先级顺序出队，优先级最高的元素最先出队。

优先队列根据优先级决定入队的顺序。例如：在排队抢票时，`VIP` 用户会比普通用户先得到抢购的机会 —— 先进入队列。

```js
const PriorityQueue = (function() {
    const sym = Symbol();
    return class PriorityQueue {
        constructor() {
            this[sym] = [];
        }
        // 入队（降序，优先级高的先入队）
        enqueue(data, priority = 0) {
            const queue = this[sym];
            let i = 0;

            for(const len = this.size(); i < len; i++) {
                // 从优先级最高的开始比较，寻找插入项的位置。
                if (queue[i].priority < priority) {
                    break;
                }
            }
            // 如果插入项优先级高于当前项，则在当前项前面插入。
            queue.splice(i, 0, {data, priority});
        }
        // 出队
        dequeue() {
            if(!this.size()) return console.warn("队已空");
            return this[sym].shift();
        }
        getFirst() {
            if(!this.size()) return console.warn("队已空");
            return this[sym][0];
        }
        clear() {
            this[sym] = [];
        }
        size() {
            return this[sym].length;
        }
    }
})();
```

使用

```js
const priorityQueue = new PriorityQueue();

priorityQueue.enqueue("甲", 3);
priorityQueue.enqueue("乙", 1);
priorityQueue.enqueue("丙", 4);
priorityQueue.enqueue("丁", 8);
priorityQueue.enqueue("戊", 4);
priorityQueue.enqueue("己", 0);
priorityQueue.enqueue("庚", 0);
```

##### 双向队列

双向队列（`Deque`），是栈和队列的结合体。它允许在任意一端进行插入和删除，数组是天然的双向队列。

