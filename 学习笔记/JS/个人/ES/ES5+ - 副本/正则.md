# `RegExp`正则

`ECMAScript` 通过 `RegExp` 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：`/pattern/flags`

模式与标记：

- `pattern`（模式）：可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。
- `flags`（标记）：每个正则表达式可以带零个或多个 `flags`（标记），用于改变正则表达式的默认行为。

默认行为：匹配到第一个符合规则的、区分大小写、单行模式、只有开始索引。

常用标记：

- g：全局模式，全局匹配符合规则的片段，而不仅仅是找到第一个。
- i：忽略大小写模式，在查找匹配时不区分 `pattern` 和字符串的大小写。
- m：多行模式，查找到一行文本末尾时还会继续查找。
- y：粘附模式，从 `lastIndex` 开始查找，`lastIndex` 的字符必须是要匹配片段的开头，否则返回`null`。【覆盖全局标记】
- u：`Unicode` 模式，启用 `Unicode` 匹配。
- s：`dotAll` 模式，使 `"."` 可以匹配任意单个字符，包括元字符。
- d：匹配的结果数组中应该包含每个捕获组的子字符串的开始和结束索引。【最明显的是，结果数组中多了 **`indices`** 属性】

捕获组：在正则中，小括号具有特殊的含义，它表示一个捕获组。其匹配的结果可以被特定的符号引用。

元字符：元字符在正则中具有特殊的功能和意义，包括：`( [ { \ ^ $ | ) ] } ? * + .` ，要匹配这些字符本身，就必须要转义。

```js
// 匹配元字符
let reg = /\./,
    str = ".";
reg.exec(str); // ['.', index: 0, input: '.', groups: undefined]

// 开启dotAll模式，使"."可匹配任何字符，并且无需转义
let reg = /./s,
    str = ".";
reg.exec(str); // ['.', index: 0, input: '.', groups: undefined]

reg = /.*/s;
reg.exec(str); // ['( [ {  ^ $ | ) ] } ? * + .', index: 0, input: '( [ {  ^ $ | ) ] } ? * + .']
```



##### 创建正则实例

正则表达式可以使用 `RegExp` 构造函数来创建，它接收两个参数：

- 一：模式字符串或正则表达式，模式字符串中的特殊字符需要转义。
- 二：标记字符串（可选的），覆盖原有的标记。

任何使用字面量定义的正则表达式都可以通过构造函数来创建。

```js
let reg1 = /[bc]at/g;

let reg2 = new RegExp("[bc]at", "g"); // 结果与reg1一样：/[bc]at/g

let reg3 = new RegExp(reg1, "i"); // 修改了标记：/[bc]at/i

// 转义特殊字符
let reg1 = /\.at/g; // 等效实例：new RegExp("\\.at", "g");
```



##### 正则实例属性

每个 `RegExp` 实例都有下列属性，提供有关模式的各方面信息：

- `global`：布尔值，检查是否设置了 g 标记。

- `ignoreCase`：布尔值，检查是否设置了 i 标记。

- `unicode`：布尔值，检查是否设置了 u 标记。
- `sticky`：布尔值，检查是否设置了 y 标记。
- `lastIndex`：整数，表示在源字符串中下一次搜索的开始位置【即上次搜索的结束位置】，默认值：0。
- `multiline`：布尔值，检查是否设置了 m 标记。
- `dotAll`：布尔值，检查是否设置了 s 标记。
- `source`：正则表达式的模式字符串。
- `flags`：正则表达式的标记字符串。

通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中直接包含了这些信息。

```js
// source 返回的是模式字符串。
let reg1 = /\[bc\]at/i;
reg1.source; // "\\[bc\\]at"

let reg2 = new RegExp("\\[bc\\]at", "i");
reg2.source; // "\[bc\]at"
```



##### 正则实例方法

每一个正则实例都具有两个检测方法，主要的方法是`exec()`，另一个是`test()`。

- `exec`：返回包含第一个匹配项信息的数组，用于获取实质的信息。
- `test`：返回一个布尔值，用于判断输入的文本是否与模式相匹配。

`exec`方法：

- 只接受一个字符串参数，返回包含第一个匹配项信息的数组，没匹配到则返回`null`。
- 数组中包含两个额外的属性：`index` 【匹配片段的起始位置】和 `input` 【被传入的字符串】
- 第一个元素是被匹配到的片段，其他元素是各捕获组的匹配结果。没有捕获组则只有第一个元素。

```js
let str = "abcabc",
    reg = /b(ca)/gi;

let matches = reg.exec(str);
// 结果：
[
    0: "bca", 			// 匹配片段
    1: "ca",			// 第一个捕获组
    groups: undefined,
    index: 1, 			// 匹配片段的起始位置
    input: "abcabc",	// 传入的字符串参数，【原始字符串、输入字符串】
    length: 2, 			// 元素个数
]
```

全局模式：

- 如果设置为全局匹配模式，则每次调用 `exec()` 都会在字符串中向右搜索下一个匹配项【以 `lastIndex` 为起始的搜索位置】
- 在该模式下，每次调用 `exec()` 都会更新 `lastIndex` 值，以反映上次匹配的最后一个字符的索引。

```js
// 全局匹配
let str = "cat, bat, sat, fat",
    reg = /.at/g;

// 初次调用：lastIndex：0，index：0，lastIndex：3
reg.laseIndex; // 0，调用前lastIndex为默认值：0
reg.exec(str); // ['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 3，调用后修改为本次匹配片段的结束索引，它将是下次搜索的起始位置。

// 第二次调用：lastIndex：3，index：5，lastIndex：8
reg.exec(str); // ['bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 8

// 第三次调用：lastIndex：8，index：10，lastIndex：13
reg.exec(str); // ['sat', index: 10, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 13

// 第四次调用：lastIndex：13，index：15，lastIndex：18
reg.exec(str); // ['fat', index: 15, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 18
```

粘附模式：每次调用 `exec()` 就只会在 `lastIndex` 的位置上寻找匹配项。粘附标记覆盖全局标记。

```js
// 粘附模式：在lastIndex的位置上寻找匹配项，lastIndex字符必须是匹配项的首字符，否则返回null。
let str = "cat, bat, sat, fat",
    reg = /.at/y;

// 首次调用：lastIndex：0，index：0，lastIndex：3
reg.lastIndex; // 0，调用前。如果lastIndex的字符不是匹配项的首字符，则返回null。
reg.exec(str); // ['cat', index: 0, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 3

// 第二次调用：lastIndex: 3，index：5，lastIndex：0
reg.exec(str); // null，因为lastIndex字符不是匹配项的首字符，所以返回null
reg.lastIndex; // 0，匹配失败后，lastIndex将被重置为默认值

// 如果手动将lastIndex修改为下一项首字符的index，那么就可以匹配成功了。
reg.lastIndex = 5;
reg.exec(str); // ['bat', index: 5, input: 'cat, bat, sat, fat', groups: undefined]
reg.lastIndex; // 8
```

`test` 方法：接收一个字符串参数。如果输入的文本与模式匹配，则返回 `true`，否则返回 `false`。

```js
// test方法：用于检查字符串中是否包含指定的片段，常被用于验证用户输入、文件后缀名等业务中。
let reg = /\d{3}-\d{2}-\d{4}/,
    str = "000-00-0000";

reg.test(str); // true，说明str中包含reg的片段。
```

重写的方法：`toLocaleString()` 、`toString()` 和 `valueOf()` 方法都返回正则表达式的字面量表示。

```js
let reg1 = /abc/g,
    reg2 = new RegExp("bar", "i");

// 获取字面量表示
reg1.toString(); // "/abc/g"
reg2.toString(); // "/bar/i"
```

几个符号方法：这几个方法的参数都是字符串，主要是在后台被字符串调用的。但可以重写它们以获得想要的返回值。

- `[@@match]`：获取 `match` 匹配的结果，在 `String.prototype.match()` 的内部调用。
- `[@@matchAll]`：获取 `matchAll` 匹配的结果，在 `String.prototype.matchAll()` 的内部调用。
- `[@@replace]`：获取 `replace` 替换的结果，在 `String.prototype.replace()` 的内部调用。
- `[@@search]`：获取 `search` 搜索的结果，在 `String.prototype.search()` 的内部调用。
- `[@@split]`：获取 split 切隔的结果，在 `String.prototype.split()` 的内部调用。

```js
// 获取match匹配结果
reg[@@match](str); // 等效于：str.match(reg);

// 这个方法为自定义 RegExp 子类中的匹配行为而存在。
class MyRegExp extends RegExp {
    // 重写[@@match]方法，自定义返回值
    [Symbol.match](str) {
        // 获取匹配的结果数组
        let result = RegExp.prototype[Symbol.match].call(this, str);
        // 根据结果返回不同值
        if (!result) return null;
        // 返回一个对象
        return {
            // 定义group方法，返回各元素
            group(n) {
                return result[n];
            }
        }
    }
}
// 调用自定义的子类
let myReg = new MyRegExp("([0-9]+)-([0-9]+)-([0-9]+)"),
    str = "2022-8-16";
let result = str.match(myReg); // 或者：myReg[@@match](str);
result.group(1); // "2022"
result.group(2); // "8"
result.group(3); // "16"
// 解除result引用
result = null;
------------------------------------------------------------------------------------------------------------

// 重写[@@matchAll]方法
class MyRegExp extends RegExp {
	[Symbol.matchAll](str) {
        let result = RegExp.prototype[Symbol.matchAll].call(this, str);
        if (!result) {
            return null;
        } else {
            return Array.from(result);
        }
 	}
}

let re = new MyRegExp('([0-9]+)-([0-9]+)-([0-9]+)', 'g');
let str = '2016-01-02|2019-03-07';
let result = str.matchAll(re);
console.log(result[0]); // [ "2016-01-02", "2016", "01", "02" ]
console.log(result[1]); // [ "2019-03-07", "2019", "03", "07" ]
------------------------------------------------------------------------------------------------------------

// 重写[@@replace]方法
class MyRegExp extends RegExp {
	constructor(pattern, flags, count) {
        super(pattern, flags);
        this.count = count;
	}
	[Symbol.replace](str, replacement) {
        // Perform @@replace |count| times.
        let result = str;
        for (let i = 0; i < this.count; i++) {
            result = RegExp.prototype[Symbol.replace].call(this, result, replacement);
        }
        return result;
	}
}

let re = new MyRegExp('\\d', '', 3);
let str = '01234567';
let newstr = str.replace(re, '#'); // String.prototype.replace calls re[@@replace].
console.log(newstr); // ###34567
------------------------------------------------------------------------------------------------------------

// 重写[@@search]方法
class MyRegExp extends RegExp {
	constructor(str) {
        super(str)
        this.pattern = str;
	}
  	[Symbol.search](str) {
        return str.indexOf(this.pattern);
  	}
}

let re = new MyRegExp('a+b');
let str = 'ab a+b';
let result = str.search(re); // String.prototype.search calls re[@@search].
console.log(result); // 3
------------------------------------------------------------------------------------------------------------

// 重写[@@split]方法
class MyRegExp extends RegExp {
  	[Symbol.split](str, limit) {
        let result = RegExp.prototype[Symbol.split].call(this, str, limit);
        return result.map(x => "(" + x + ")");
  	}
}

let re = new MyRegExp('-');
let str = '2016-01-02';
let result = str.split(re); // String.prototype.split calls re[@@split].
console.log(result); // ["(2016)", "(01)", "(02)"]
```



##### 构造函数属性

`RegExp` 构造函数本身也有几个属性【静态属性】。

这些属性适用于所有的正则表达式，且每一次执行匹配后它们的值都会发生变化。

并且，每个属性都有一个全名和一个简写。【简写形式要通过中括号语法来访问】

- `input`：最后一次使用的原始字符串（非标准特性），简写：`$_`；访问：`RegExp.$_`
- `lastMatch`：最后一次匹配的片段，简写：`$&`；访问：`RegExp["$&"]`
- `lastParen`：最后一次匹配的最后一个捕获组，简写：`$+`；访问：`RegExp["$+"]`
- `leftContext`：`input` 字符串中位于 `lastMatch` 左边的文本，简写：$`；
- `rightContext`：`input` 字符串中位于 `lastMatch` 右边的文本，简写：`$'`；访问：`RegExp["$&"]`
- `$1~$9`：分别包含第 1~9 个捕获组的匹配项。

```js
let str = "cat, bat, sat, fat",
    reg = /([bs])at(.)/g;

// 首次匹配
reg.exec(str); 			//  ['bat,', 'b', ',', index: 5, input: 'cat, bat, sat, fat']
RegExp.input; 			// "cat, bat, sat, fat"
RegExp.lastMatch; 		// "bat,"
RegExp.lastParen; 		// ","
RegExp.leftContext; 	// "cat, "
RegExp.rightContext; 	// " sat, fat"
RegExp.$1; 				// "b"
RegExp.$2; 				// ","

// 第二次匹配
reg.exec(str); 			// ['sat,', 's', ',', index: 10, input: 'cat, bat, sat, fat']
RegExp.input; 			// "cat, bat, sat, fat"
RegExp.lastMatch; 		// "sat,"
RegExp.lastParen; 		// ","
RegExp.leftContext; 	// "cat, bat, "
RegExp.rightContext; 	// " fat"
RegExp.$1; 				// "s"
RegExp.$2; 				// ","
```

注意：`RegExp` 构造函数的所有属性都没有任何 `Web` 标准出处，因此不建议在生产环境中使用它们。



##### 模式局限

虽然 `ECMAScript` 对正则表达式的支持有了长足的进步，但仍然缺少 `Perl` 语言中的一些高级特性。

- \A 和\Z 锚（分别匹配字符串的开始和末尾）
- 联合及交叉类
- 原子组
- x（忽略空格）匹配模式
- 条件式匹配
- 正则表达式注释

虽然还有这些局限，但 `ECMAScript` 的正则表达式已经非常强大，可以用于大多数模式匹配任务。

更多参考：[正则表达式](Regular-Expressions.info)