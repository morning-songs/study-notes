# 组件进阶

### 配置`model`

`v-model`默认绑定控件的`value`属性，默认使用`input`事件监听`value`值的输入。

而这对于使用`checked`属性，或者使用`change`事件监听的控件来说并不友好。因此，需要配置`model`选项。

`model`配置项

- prop：指定使用`v-model`时绑定的属性，如："value"，"checked"
- event：指定使用`v-model`时监听的事件，如："input"，"change"

当然，也可以在组件标签中直接使用 `:` 以及 `@` 来指定属性和事件，如：`<btn :checked = "checked" @change = ""></btn>`

```html
// 子组件通知父组件修改数据
<div id = "app">
    <input-text v-model = "value"></input-text>
    <input-checkbox v-model = "checked"></input-checkbox>
    <!--直接写：<input-checked :checked = "checked" @change = "checked = $event"></input-checked>-->
</div>
<script>
	Vue.component('input-text', { // 单组件可以不绑定属性，但必须设置监听事件。
        template : ` 
        	<input type = "text" @input = "$emit('input', $event.target.value)">
        `
    });
    Vue.component('input-checkbox', {
        props : ['checked'],
        model : {
            prop : "checked",
            event : "change"
        },
        template : `<input type = "checkbox" :checked = "checked" 
        					@change = "$emit('change', $event.target.checked)">`
    })
	const vm = new Vue({
        el : "#app",
        data : {
            value : "text",
            checked : true
        }
    })
</script>
```

<hr>

### 属性继承

组件标签中的没有被`props`选项接收的属性，会自动被保存到`$attrs`项中，然后被组件的根标签继承显示。

继承属性中，`class`和`style`会合并融合，相同的样式或其他属性的值会被继承的覆盖【继承的值放在后面】

注意：

- 被保存到`$attrs`中的数据，不会被直接挂载到实例对象上。【在`vue2`中，`class`和`style`只属于`$attrs`】
- 这种继承指的是组件根标签上会不会显示出这些属性，因为这些非`props`数据会一直存在实例的`$attrs`属性中。



##### 禁止继承【`inheritAttrs`】

组件根标签继承组件标签上的属性及值，能很方便地解决很多`UI`框架的设计问题。

当不希望继承时，可以配置`inheritAttrs`选项的值为`false`，即：`inheritAttrs : false`【只是不展示在根标签上了】

但要注意的是，禁止继承并不会阻止组件根元素继承并展示`class`和`style`属性。

<hr>

### 局部组件

过多的全局组件会导致页面加载或运行时卡顿，带来不好的效果体验。因此，一般常用局部的组件。

注意：局部组件只能在其注册时的组件中使用，即：在`A`中注册`B`，`B`只能在`A`中使用，`B`的兄弟组件和子组件都不可使用。



##### 注册局部组件【`components`】

每一个组件都可以在其内部注册局部组件，这些局部组件只供给其注册组件来使用。

```html
<div id = "app">
    <!--注意局部组件在使用时，只能在注册时的组件中使用-->
    <c-btn></c-btn>
</div>
<script>
	const vm = new Vue({
        el : "#app",
        data : {},
        components : { // 在当前组件中注册局部组件
            "c-btn" : { // 属性名为组件名，值为其组件的配置对象
                data () {
                    return {
                        num : 10
                    }
                },
                template : `<button @click = "num++">点击num++{{num}}</button>`
            }
        }
    })
</script>
```

当然，将大量代码堆砌到一个页面中是非常臃肿的，也不便于维护。一般，会封装成`vue`文件，通过导入编译后渲染到页面中。

<hr>

### ref获取元素

`ref`属性可以作用在任何元素或组件标签上，它用来获取该元素节点的引用并设为指定属性的值，如：`<p ref = "text"></p>`

例如：作用在`DOM`元素上得到该`DOM`元素的引用，作用在组件上得到该组件的实例对象。

使用了`ref`属性的元素或组件，其引用会被挂载到父组件实例对象的`$refs`属性上，如：`$refs : {text: p}`

那么，在父组件内部可以通过`$refs`属性访问到其组件范围内，所有绑定了`ref`属性的子元素 / 子组件实例对象。

注意：`vue`中凡是带有`$`符号的属性，表示每个组件都具有，但不代表是全局属性。

意义：在父组件实例中可以通过子元素 / 子组件的引用，直接操作它们而无需获取，如：`this.$refs.text.style="color: red;"`

案例：通过父级修改子级样式

```html
<div id = "app">
    <p ref = "text">p段落</p>
    <button @click = "getRefs">点击</button>
    <c-btn ref = "cbtn"></c-btn>
</div>
<script>
	const vm = new Vue({
        el : "#app",
        methods : {
            getRefs () {
                // 打印this.$refs，它是一个对象：以ref属性值为属性名，其元素/组件名（引用）为属性值。
                this.$refs.text.style = "color : red;"
                // 原生写法：使用document.getElements的方法来获取元素，相对麻烦。
            }
        },
        components : { // 在当前组件中注册局部组件
            "c-btn" : { // 属性名为组件名，值为其组件的实例对象
                data () {
                    return {
                        num : 10
                    }
                },
                template : `<button @click = "num++">点击num++{{num}}</button>`
            }
        }
    })
</script>
```

应用：常用在`UI`框架设计，对元素进行原生的操作或校验等情况，一般很少使用。

