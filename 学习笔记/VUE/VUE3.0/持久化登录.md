# 持久化登录

持久化登录：前端首次发起登录请求，后端会返回一个限时的`token`。前端保存`token`，在`token`有效期间，用户可以免登录。

基本步骤：

- 后端生成一个用于持久化登录的`token`，且设置其有效时间。
- 前端初次登录，发起登录请求。
- 后端验证完用户信息（账号密码）后，给前端返回设置好的`token`。
- 前端接收到`token`后，存储在本地。以后每次请求都必须携带该`token`来验证有效性与身份。
- 在`token`有效期间，用户在前端页面上免登录，即：无需输入账号密码来提交登录请求。



##### 首次登录

通过`axios`发起`post`登录请求，提交用户账号及密码信息。

```js
// 前端
// 引入axios：<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

// 初始化token值
let token = null;

// 首次登录
axios.post("http://localhost:5000/api/login", {
    username: "wanzi",
    password: 123456
})
.then(req => {
    token = req.data.data.token; // 获取token值
    
    // 发起获取用户信息的请求，携带token
    axios.get("http://localhost:5000/api/user", {
        // 前端携带token，应处于请求头中，方便后端获取。
        // 在请求拦截器中，添加上Authorization请求头。
        headers: {
            "Authorization" : token
        },
        params: {
            ID: 12345
        }
    })
})
.catch(err => {
    console.log(err);
})
```

```js
// 后端，app.js中
const express = require("express"),
      app = express(),
      cors = require("cors"),
      {verifyToken} = require("./utils/authorization"); // 获取中间件

// 快速格式化请求携带的数据
app
.use(cors())
.use(express.json())
.use(express.urlencoded({extended: false}))
.use("/api", verifyToken, require("./router/login")) // 路由挂载(父路由/api)，先经过verifyToken中间件处理

// 监听向5000端口发起的请求
app.listen(5000, () => {
    console.log("向5000端口发起了请求")
})
---------------------------------------------------------------------

// 新建router目录，在其login.js中
const express = require("express"),
      router = express.Router(),
	  {generatorToken} = require("../utils/authorization"); // 导入生成token的方法

// 监听向/login发起的post请求
router.post("/login", (req, res) = > {
    let {username, password} = req.body;
    // 账号和密码验证通过之后，返回登录成功的提示以及token
    const token = generatorToken({username}); // 传入对象，生成token
	// 将token返回给前端
	res.status(200).send({
        code: 200,
        data: {
            token
        }
    })
})

// 监听向/user发起的get请求
router.get("/user", (req, res) => {
    res.status(200).send({code: 200, data: {money: "$4000"}});
})

module.exports = router;
---------------------------------------------------------------------

// 新建utils目录，在其authorization.js中
const jwt = require("jsonwebtoken");
let secretKey = "secretKey"; // 密钥

// 生成一个加密的token值：传入一个自定义字符串（载荷），混入加密以提升token的安全性
function generatorToken (payload) { // payload：载荷对象
    // 生成token，token不只是由载荷和密钥合成，还包括签名等其他信息。
    const token = "Bearer" + jwt.sign(payload, secretKey, {expiresIn: '1h'}); // 加上"Bearer"的身份标识
    return token;
}

// 验证前端请求中的token值：拿到合成token关键的载荷和密钥，合成之后进行比对。
function verifyToken (req, res, next) {
    // 取出请求头里的token
    let token = req.headers.authorization;
    
    jwt.verify(token, secretKey, (err, decoded) => {
        if(err) {
            console.log("验证失败", err);
            return res.status(401).send({code: 401, msg: "token过期或失效，请重新登录"});
        }
        console.log("验证通过", decoded);
        next();
    })
}

module.exports = {
    generatorToken,
    verifyToken
}
```



##### 生成`token`

输入`npm i jsonwebtoken`指令，安装`jsonwebtoken`插件，调用其`sign`方法来快速生成一段加密的`token`值。

`sign`参数：载荷（对象包裹）、密钥、有效时间（在对象中配置`expiresIn`属性）、加密算法（在对象中配置`algorithm`属性）。

```js
const jwt = require("jsonwebtoken");
let secretKey = "secretKey"; // 密钥

function generatorToken (payload) {
    jwt.sign(payload, secretKey, {expiresIn: 1h});
}
```

验证`token`：可以通过`jsonwebtoken`的`verify`方法验证`token`。

`verify`参数：前端`token`、密钥、回调（err、载荷）

```js
function verifyToken (req, res, next) {
    // 获取token
    let token = req.headers.authorization;
    
    // 进行验证
    jwt.verify(token, secretKey, (err, decoded) => { // decoded：包括载荷、有效时间
        if (err) {
            console.log("验证失败", err);
            return res.status(401).send({code: 401, msg: "token过期或无效，请重新登录");
        }
        console.log("验证通过", decoded);
        next(); // 放行，让请求前往下一个中间件的处理。
    })
}
```

