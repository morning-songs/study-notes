# `VueX`全局状态管理

当传递的层级比较多（大于`3`层），或者组件需要共享大量数据时，可以使用`vuex`全局状态管理【`vuex`中的状态：指的是数据】

##### 安装`vuex`

在输入`vue create 项目名`指令，创建并配置项目时，可以勾选`Vuex`插件项，直接安装到当前项目中。

通常项目中需要：`Choose Vue version`，`Babel`，`Router`，`Vuex`，`CSS Pre-processors`五个插件

<hr>

### 项目变化

##### `store`目录

安装`Vuex`后，项目的`src`目录下会新增一个`store`目录，内置一个`index.js`文件。

##### `index.js`文件

`store`目录下的`index.js`文件，用来管理全局的共享 / 仓库数据。

注意：`vue`中的数据最好是提前定义好，不建议后期再往里添加新数据，可以提前定义空位。

```js
// 导入vue和vuex两个模块
import Vue from 'vue'
import Vuex from 'vuex'
// 将vuex添加到Vue中使用
Vue.use(Vuex);

// 导出store实例对象，通过Vuex.Store方法创建
export default new Vuex.Store({
    // 状态：数据源。类似于vuex的data选项，数据要提前定义好
    state: {},
    // 突变：类似于vuex的methods计算方法，用来修改state的状态【谁提供的数据，谁管理】
    mutations: {}, // mutations中只能定义同步执行的方法，异步的请定义在actions中
    // 获得者：类似于vuex的computed计算属性，惰性求值
    getters: {},
    // 弥补mutations的不足，用来执行异步任务，但不可用来修改数据【修改数据只能由mutations执行】
    actions: {},
    // 模块：导入数据模块
    modules: {},
})
```

##### `main.js`文件

`main.js`文件会自动导入`store`目录下`index.js`文件导出的`Sotre`实例对象，并将其挂载到根实例上。

```js
// 在main.js文件中
// 导入store目录下index.js导出的Sotre实例
import store from './store'
// 挂载到根组件实例上
new Vue({
    store // 将store实例注入到所有的组件中。
}).$mount('#app')
```

<hr>

### 使用`Vuex`

#### 使用数据

##### 直接使用数据

当只需要使用某条数据，而不会对它做任何修改时，可以直接通过插值表达式使用它，如：`{{$store.state.name}}`

访问全局状态：通过`$store.state`可以在`template`的任何位置访问全局状态，实质是通过`this.$store.state`访问的。

##### 利用计算属性

每次通过`$store.state`访问数据，数据显得很长，不美观。可以将数据名作为计算属性来使用，方便使用。

```js
// Home组件中
export default {
    name : 'Home',
    computed : {
        name () {
            return this.$store.state.name;
        }
    }
}
```

这种方式，当数据量不多时，能哦勉强应付。而数据量一旦大了起来，反而显得得不偿失。此时，可以使用`vuex`提供的辅助函数。

##### 使用`mapState`

使用辅助函数首先要在组件中导入对应的方法，如：`import {mapState} from 'vuex'; // 解构从vuex中获取mapState方法`

`mapState`方法，只能在组件的`computed`计算属性中使用。传入一个数组，该数组包含当前组件所需的`state`源中的数据名称。

返回值：`mapState`方法返回一个对象，以传参数组中的元素作为属性名称，值分别对应着一个获取其状态的`mappedState`方法。

```js
// 在store下的index.js中
export default new Vuex.Store({
    state: {
        goods_name: "兰蔻196h胡萝卜色",
        goods_price: 320,
        goods_num: 200
    }
})
// 在组件中
export default {
    computed: {
        // 使用扩展运算符将数组展开，使其中的每个元素作为计算属性来使用。
        ...mapState(["goods_name","goods_price","goods_num"]); // 注意保持与state中的数据同名
        // ...mapState解构获取状态的实质
        goods_name: mapState(["goods_name"]).goods_name, // 一条条解套
        goods_price: mapState(["goods_price"]).goods_price,
        goods_num: mapState(["goods_num"]).goods_num,
    }
}
```



#### 修改数据

##### 定义修改方法

在组件中通过`this.$store.state`修改`state`数据时，虽然页面可以响应，但不建议这么做【数据不好管控】

要修改`state`全局共享数据，只能在`store`的`index.js`中，通过`mutations`定义方法修改。

注意：

- 在`mutations`中定义的所有方法，第一个形参都是`state`，就是当前的`state`对象。
- 定义在`mutations`中的方法也只能接收一个实参，意思是：最多有两个参数。

```js
// 在index.js中，配置mutations项
mutations: {
    addGoodsNum(state) {
        state.goods_num++;
    },
    redGoodsNum(state) {
        state.goods_num--;
    }
}
```

##### 触发修改方法

在组件中，通过`$store`的`commit`方法，触发`mutations`中修改数据的同名方法。如：`this.$store.commit("addGoodsNum");`

注意：由于`mutations`中的方法，只接受一个实参，使用`commit`也只传递一个参数（任意数据类型）。

```js
// 组件中，使用修改数据的方法
export default {
    mounted() {
        this.$store.commit("addGoodsNum"); // 同步执行
    }
}
```

##### 使用`mapMutations`

与使用数据类似，当修改方法过多时，要借用`vuex`提供的`mapMutations`辅助方法来批量导入到`methods`中。

注意：`mapMutations`方法，只能在组件的`methods`选项中使用，使用方法及原理与`mapState`类似。

```js
// 在组件中，使用`mapMutations`方法
export default {
    methods: {
        ...mapMutations(["addGoodsNum", "redGoodsNum"]); // 解构数组，使元素作为methods的方法使用
    }
}
```



#### 计算属性

配置`vuex`实例对象的`getters`选项，可以定义全局共享的计算属性，从`state`中衍生出新的复杂的状态。

##### 定义计算属性

在`getters`中定义的所有计算属性，它们的第一个形参也是`state`。

典型应用：当需要对`state`中的数据进行处理，但又不能修改源时，配置`getters`就显得尤为重要。

```js
getters: {
    newStr(state) {
        return `想买${state.goods_num}只${state.goods_name}口红`;
    }
}
```

##### 使用`mapGetters`

`mapGetters`方法与`mapState`一样，只能在组件的`computed`中使用。

```js
export default {
	computed: {
		...mapGetters(["newStr"]); // 解构，作为当前组件的计算属性使用		
	}
}
```



#### 异步任务

配置`vuex`实例对象的`actions`选项，可以定义全局共享的异步方法，很少使用。

##### 定义异步任务

在`actions`中定义的所有异步任务，它们的第一个形参是`context`，一个上下文对象（与`store`实例类似）。

`context`上下文对象：包含`commit`，`dispatch`，`getters`，`state`，`rootGetters`和`rootState`属性。

这就意味着，利用`context`对象可以调用`vuex`实例对象上的任何属性和方法。

```js
// 定义异步任务
export default new Vuex.Store({
    state: {
        goods_num: 200
    },
    mutations: {
        addGoodsNum(state) {
            state.goods_num++;
        }
    },
    actions: {
        asyncChangeGoodsNum(context) {
            setInterval(() => {
                context.commit("addGoodsNum"); // 同步触发mutations中的addGoodsNum方法
            }, 1000)
        }
    }
})
```

##### 触发异步任务

在组件中，通过`$store`的`dispatch`方法，触发`actions`中异步任务的同名方法。如：`this.$store.dispatch("异步任务名称");`

##### 使用`mapActions`

`mapActions`方法与`mapMutations`一样，只能在组件的`methods`中使用，将异步任务解构到当前组件的`methods`中作为方法使用。

```js
// 在组件中，批量导入异步方法
methods: {
    ...mapAction(["asyncChangeGoodsNum"]); // 导入actions中的异步方法，作为该组件的methods方法使用。
}
```

传参：无论是同步方法，还是异步方法，都可以在调用时传递参数。【定义时接收，调用时传参】



#### 模块

##### 定义模块

`vuex`适用于中大型项目的数据管理，但将所有数据都堆砌在`index.js`文件中，并未实现便于管理的原则。

此时，需要将数据根据业务逻辑划分为多个模块，然后在`index.js`文件中导入这些数据模块使用即可。

模块管理：将划分好的数据模块以`js`文件形式，统一存储在`store`目录下（与`index.js`文件同级）。

注意：

- 数据模块中的`state`与组件的`data`一样，必须使用函数返回对应的数据对象【数据模块中可以配置`vuex`的所有选项】
- `vuex`使用一个单一的数据树，各数据模块必须挂载到`vuex`实例的`modules`上，才可使用。
- 挂载到`vuex`实例`modules`上的数据模块，最终会被直接挂载到该实例的`state`状态项中【在组件中通过`state`属性访问】

##### 命名空间

为了批量导入数据模块，要借助`vuex`的`mapState`等辅助函数，但首先要在各模块中开启`namespaced`命名空间。

```js
// 模块管理
// 首先在moduleA.js文件中，定义moduleA数据模块
export default {
    namespaced: true, // 开启该模块的命名空间，以便使用辅助函数
    state () {
        return {
            userName: "wanzi",
            age: 14
        };
    },
    mutations: {
        changeA(state) {
            state.age = 10;
        }
    }
}
// 然后在index.js文件中，导入并挂载moduleA数据模块
import moduleA from "./moduleA"
export default new Vuex.Store({
    modules: {
        moduleA, // 挂载到store实例上
    }
})
```

##### 使用数据

挂载好各数据模块后，在组件借助辅助函数来批量导入模块数据，使用方法基本一致。

使用方法：以`mapstate`为例，`...mapState("数据模块名", ["数据1", "数据2", ...])`

```js
// 在组件中
export default {
    computed: {
        ...mapState("moduleA", ["userName", "age"]), // 导入moduleA数据模块中的指定数据
    },
    methods: {
        ...mapMutations("moduleA", ["changeA"]), // 导入moduleA数据模块中的mutations方法
    }
}
```

注意：在同一组件中若导入了同名的模块数据，会发生覆盖，后者覆盖前者。

