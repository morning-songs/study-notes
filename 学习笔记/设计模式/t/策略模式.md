# 策略模式

策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

目的：实现某一个功能有多种方案可以选择，要求算法灵活多样，而且可以随意地互相替换。

`JavaScript` 中的“**可以相互替换使用**”表现为，它们具有相同的目标和意图。



### 初步实现

案例：

​		很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为 S 的人年终奖有 4 倍工资，绩效为 A 的人年终奖有 3 倍工资，而绩效为 B 的人年终奖是 2 倍工资。假设财务部要求我们提供一段代码，来方便他们计算员工的年终奖。

##### 使用组合函数

```js
// 定义各个小的算法
var performanceS = function( salary ){ 
	return salary * 4; 
}; 
var performanceA = function( salary ){ 
	return salary * 3; 
}; 
var performanceB = function( salary ){ 
	return salary * 2; 
}; 
// 在最终的执行函数中，通过逻辑组合起来
var calculateBonus = function( performanceLevel, salary ){ 
	if ( performanceLevel === 'S' ){ 
		return performanceS( salary ); 
 	} 
	if ( performanceLevel === 'A' ){ 
 		return performanceA( salary ); 
 	} 
 	if ( performanceLevel === 'B' ){ 
 		return performanceB( salary ); 
 	} 
}; 
// 通过传入不同的参数，调用不同的方法。
calculateBonus( 'A' , 10000 ); // 输出：30000
```

缺点：

- 函数包含了大量的流程控制语句，这些分支必须涵盖所有的逻辑。
- 函数缺乏弹性，违反程序设计“开放-封闭”的原则。

##### 使用策略模式

策略模式的目的：就是将算法的使用与算法的实现分离开来，算法的使用方式是固定不变的，但算法的实现是各异变化的。

策略模式的组成：

​		一个基于策略模式的程序至少由两部分组成。

​		第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。

​		第二个部分是环境类 `Context`，`Context` 接受客户的请求，随后把请求委托给某一个策略类。

要做到这点，说明 `Context` 中要维持对某个策略对象的引用。

```js
// 使用JS的策略模式
// 将各种方法，定义在一个对象中。
var strategies = { 
	"S": function( salary ){ 
 		return salary * 4; 
 	}, 
 	"A": function( salary ){ 
 		return salary * 3; 
 	}, 
 	"B": function( salary ){ 
 		return salary * 2; 
 	} 
};
// 设计通过对象的键来调用对应的方法。
var calculateBonus = function( level, salary ){ 
 	return strategies[ level ]( salary ); 
}; 
// 通过传入对应的键来调用指定的方法，并传入计算必要的参数。
console.log( calculateBonus( 'S', 20000 ) ); // 输出：80000 
console.log( calculateBonus( 'A', 10000 ) ); // 输出：30000
```

函数式对象：在接下来的缓动动画和表单验证的例子中，我们用到的都是这种函数形式的策略对象。