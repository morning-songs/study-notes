# 享元模式

享元模式（`Flyweight Pattern`）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。例如，通过创建 5 个对象来画出 20 个分布于不同位置的圆。

享元模式：使用共享技术来共享大量细粒度的对象，避免使用相同的内容造成额外开销。简单来说，就是使大量的相似对象共享一些共同的特性。

享元模式将对象的状态分为内部和外部。内部状态是大量对象都相同的，外部状态是每个对象都不同的。对象可根据内部状态被划分为不同的种类，而这些种类的外部状态是不同的。



### 介绍

**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**在有大量对象时，有可能会造成内存溢出。我们把其中共同的部分抽象出来，如果有相同的业务请求，则直接返回在内存中已有的对象，避免重新创建。

**何时使用：**

- 系统中有大量对象。
- 这些对象消耗大量内存。
- 这些对象的状态大部分可以外部化。
- 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。
- 系统不依赖于这些对象身份，这些对象是不可分辨的。

**如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

**关键代码：**用一个东西来存储这些对象。

**应用实例：**

- `JAVA` 中的 `String`，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。
- 数据库的连接池。

**优点：**大大减少对象的创建，降低系统的内存，使效率提高。

**缺点：**提高了系统的复杂度，**需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化**，否则会造成系统的混乱。

**使用场景：** 

- 系统有大量相似对象。
- 需要缓冲池的场景。

**注意事项：** 

- 注意划分外部状态和内部状态，否则可能会引起线程安全问题。
- 这些类必须有一个工厂对象加以控制。



### 实现

享元模式的核心，就是共享相同的部分，以避免内存和性能的浪费。例如，多个不同的事件绑定多个功能相同的处理程序。

```js
a.onclick = function() {console.log("click")};
b.onclick = function() {console.log("click")};
c.onclick = function() {console.log("click")};
```

使用享元模式

```js
let clickFn = function() {console.log("click")};

a.onclick = b.onclick = c.onclick = clickFn;
```

##### 简单实现

例如，让 50 个男模和 50 个女模来分别试穿 50 件衣服，并进行拍照。

不使用享元模式的做法是，创建 50 个男模和 50 个女模，一人试穿一件。

```js
class Model {
    constructor(sex, clothes) {
        this.sex = sex;
        this.clothes = clothes;
    }
    takePhoto() {
        console.log(`sex: ${this.sex} 服装: ${this.clothes}`);
    }
}

// 创建 50 个男模，一人试穿一件
for(let i = 1; i <= 50; i++) {
    let maleModel = new Model("男", `第${i}款男装`);
    maleModel.takePhoto();
}

// 创建 50 个女模，一人试穿一件
for(let i = 1; i <= 50; i++) {
    let femaleModel = new Model("女", `第${i}款女装`);
    femaleModel.takePhoto();
}
```

使用享元模式，则首先要区分内部状态（基本相同的部分）和外部状态（基本不同的部分）。例如，将性别设为内部状态，服装视为外部状态，只创建一个男模和一个女模，然后让两人分别试穿 50 件衣服并完成拍照。

```js
class Model {
    constructor(sex) {
        this.sex = sex;
    }
    takePhoto() {
        console.log(`sex: ${this.sex} 服装: ${this.clothes}`);
    }
}

// 根据性别创建模特，一样一个
let maleModel = new Model("男");
let femaleModel = new Model("女");

// 让一个男模试穿 50 件
for(let i = 1; i <= 50; i++) {
    maleModel.clothes = `第${i}款男装`;
    maleModel.takePhoto();
}

// 让一个女模试穿 50 件
for(let i = 1; i <= 50; i++) {
    femaleModel.clothes = `第${i}款女装`;
    femaleModel.takePhoto();
}
```

##### 封装优化

可优化的点：使创建的对象成为单例；定义一个管理器统一地管理外部状态，并负责将内外部状态合并以组成完整的对象。

```js
class Model {
    constructor(sex) {
        this.sex = sex;
    }
    takePhoto() {
        console.log(`sex: ${this.sex} 服装: ${this.clothes}`);
    }
}
```

首先，使用单例模式定义一个可根据内部状态创建模特的单例工厂。例如，根据性别创建模特单例。

```js
let getSingletonModel = (function() {
    let model = {}; // 模特库
    return function(sex) {
        // 确保模特库中同性别的模特只有一个。
        return model[sex] || (model[sex] = new Model(sex));
    }
})();
```

然后，定义一个管理器，用于管理跟共享对象相关的外部状态。

```js
let modelManager = (function() {
    let modelState = {}; // 外部状态库
    // 返回管理外部状态的方法库
    return {
        // 获取模特
        create(sex) {
            return getSingletonModel(sex);
        },
        // 添加外部状态
        addState(id, sex) {
            // 可以一次性添加很多条
            modelState[id] = {clothes: `第${id}款${sex}装`};
        },
        // 使用外部状态（将外部状态复刻到模特单例上，与内部状态共同组成完整的模特实例）
        wear(id, model) {
            model.clothes = modelState[id].clothes;
        }
    }
})();
```

最后，使用管理器即可。

```js
function useModelManager(sex) {
    for(let i = 1; i <= 50; i++) {
        const model = modelManager.create(sex); // 获得模特
        modelManager.addState(i, sex); 	// 添加外部状态
        modelManager.wear(i, model); 	// 整合外部状态
        model.takePhoto(); 				// 执行模特方法（此时，模特已成为一个完整体）
    }
}

// 通过使用管理器来达到目的。
useModelManager("男");
useModelManager("女");
```

##### 抽象封装

```js
class Model {
    constructor(sex) {
        this.sex = sex;
        // ...
    }
    takePhoto() {
        console.log(`sex: ${this.sex} 服装: ${this.clothes}`);
    }
}

let getSingletonModel = (function () {
    let model = {}; // 模特库
    return {
        bySex(sex) {
            // 确保模特库中同性别的模特只有一个。
            return model[sex] || (model[sex] = new Model(sex));
        }
        // ...
    }
})();

let modelManager = (function () {
    let modelState = {}; // 外部状态库
    // 返回管理外部状态的方法库
    return {
        // 获取模特
        create(method, sex) {
            modelState[method] = {};
            return getSingletonModel[method](sex);
        },
        // 添加外部状态
        addState(storage, id, sex) {
            // 可以一次性添加很多条
            modelState[storage][id] = { clothes: `第${id}款${sex}装` };
        },
        createBySex(sex) {
            return this.create("bySex", sex);
        },
        addStateBySex(id, sex) {
            this.addState("bySex", id, sex);
        },
        // 使用外部状态（将外部状态复刻到模特单例上，与内部状态共同组成完整的模特实例）
        wear(storage, id, model) {
            model.clothes = modelState[storage][id].clothes;
        },
        wearBySex(id, model) {
            this.wear("bySex", id, model);
        }
    }
})();

function useModelManager(key, value) {
    key = key.split("");
    key[0] = key[0].toUpperCase();
    key = key.join("");

    let create = "createBy" + key,
        addState = "addStateBy" + key,
        wear = "wearBy" + key;
    // ...
    for (let i = 1; i <= 50; i++) {
        const model = modelManager[create](value); // 获得模特
        modelManager[addState](i, value); 	// 添加外部状态
        modelManager[wear](i, model); 		// 整合外部状态
        model.takePhoto(); 					// 执行模特方法（此时，模特已成为一个完整体）
    }
}

useModelManager("sex", "男");
useModelManager("sex", "女");
```

再次封装

```js
const capitalize = function (value) {
    value = value.split("");
    value[0] = value[0].toUpperCase();
    return value.join("");
}

class Model {
    constructor(data) {
        return Object.assign(this, data);
    }
    takePhoto() {
        console.log(`sex: ${this.sex} 服装: ${this.clothes}`);
    }
}

const getSingletonModel = (function () {
    const model = {}; 
    return function (data) {
        const key = data[0], value = data[1];
        model[key] = {};
        return model[key][value] || (model[key][value] = new Model({[key]: value}));
    }
})();

const modelManager = (function () {
    const internalState = ["sex"];
    const modelState = {}; 
    const result = {
        create(method, value) {
            modelState[method] = {};
            return getSingletonModel([method, value[0]]);
        },
        addState(storage, value) {
            let key = value[0];
            modelState[storage][key] = { clothes: `第${key}款${value[1]}装` };
        },
        wear(storage, value) {
            value[1].clothes = modelState[storage][value[0]].clothes;
        }
    };

    for(const key of (Object.keys(result))) {
        internalState.forEach((item) => {
            const methodName = key + "By" + capitalize(item);
            result[methodName] = function (...args) {
                return result[key](item, args);
            }
        })
    }
    
    return result;
})();

function useModelManager(key, value) {
    key = capitalize(key);

    const create = "createBy" + key,
          addState = "addStateBy" + key,
          wear = "wearBy" + key;
    // ...

    for (let i = 1; i <= 50; i++) {
        const model = modelManager[create](value);
        modelManager[addState](i, value); 
        modelManager[wear](i, model); 	
        model.takePhoto(); 				
    }
}

useModelManager("sex", "男");
useModelManager("sex", "女");
```

优化

```js
const capitalize = function (value) {
    value = value.split("");
    value[0] = value[0].toUpperCase();
    return value.join("");
}

class Model {
    constructor(data) {
        return Object.assign(this, data);
    }
    takePhoto(value, fn) {
        fn.call(this, value);
    }
}

const getSingletonModel = (function () {
    const model = {}; 
    return function (data) {
        const key = data[0], value = data[1];
        model[key] = {};
        return model[key][value] || (model[key][value] = new Model({[key]: value}));
    }
})();

const modelManager = (function () {
    const internalState = ["sex"];
    const externalState = {}; 
    const result = {
        create(method, value) {
            externalState[method] = {};
            return getSingletonModel([method, value[0]]);
        },
        addState(storage, value) {
            externalState[storage][value[0]] = value[1];
        },
        wear(storage, value) {
            value[1][value[2]] = externalState[storage][value[0]][value[2]];
        }
    }

    for(const key of (Object.keys(result))) {
        internalState.forEach((item) => {
            const methodName = key + "By" + capitalize(item);
            result[methodName] = function (...args) {
                return result[key](item, args);
            }
        })
    }

    return result;
})();

let useModelManagerBySex = (value) => {
    const cb = function(arr) {
        let key = arr[0], value = arr[1];
        console.log(`${key}: ${this[key]} ${[value]}: ${this[value]}`);
    }
    
    const takePhoto = function(model) {
        console.log(`sex: ${model.sex} clothes: ${model.clothes}`);
    }
    
    for (let i = 1; i <= 50; i++) {
        const model = modelManager.createBySex(value);
        const state = {clothes: `第${i}款${value}装`};
        modelManager.addStateBySex(i, state);
        modelManager.wearBySex(i, model, "clothes");
        // 使用原型的方法
        model.takePhoto(["sex", "clothes"], cb); 
        // 使用管理器方法
        takePhoto(model);
    }
}

useModelManagerBySex("男");
useModelManagerBySex("女");
```

