# 框架

### 介绍

小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 `APP` 体验的服务。

整个小程序框架系统分为两部分：**[逻辑层](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/)**（`App Service`）和 **[视图层](https://developers.weixin.qq.com/miniprogram/dev/framework/view/)**（`View`）。小程序提供了自己的视图层描述语言 `WXML` 和 `WXSS`，以及基于 `JavaScript` 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

##### 响应的数据绑定

框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。

```html
<!-- 视图层 -->
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
```

```js
// 逻辑层
// 定义数据
var helloData = {
  	name: 'Weixin'
}

// 注册页面
Page({
  	data: helloData,
  	changeName: function(e) {
    	// 修改数据以更新视图
    	this.setData({
      		name: 'MINA'
    	})
  	}
})
```

- 开发者通过框架将逻辑层数据中的 `name` 与视图层的 `name` 进行了绑定，所以在页面一打开的时候会显示 `Hello Weixin!`；
- 当点击按钮的时候，视图层会发送 `changeName` 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
- 回调函数触发后，逻辑层执行 `setData` 的操作，随即将 `data` 中的 `name` 从 `Weixin` 变为 `MINA`。因为该数据和视图层已经绑定了，所以视图层会自动改变为 `Hello MINA!`。

##### 页面管理

框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。

##### 基础组件

框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑。开发者可以通过自由地组合这些基础组件，创建出强大的微信小程序。

##### 丰富的 `API`

框架提供了丰富的微信原生 `API`，开发者可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。



### 视图层

框架的视图层由 `WXML` 与 `WXSS` 编写，由组件来进行展示。它将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

- `WXML`（`WeiXin Markup language`）用于描述页面的结构。
- `WXS`（`WeiXin Script`）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。
- `WXSS`（`WeiXin Style Sheet`）用于描述页面的样式。
- 组件（`Component`）是视图的基本组成单元。



#### `WXML`

`WXML`（`WeiXin Markup Language`）是框架设计的一套标签语言，结合 [基础组件](https://developers.weixin.qq.com/miniprogram/dev/component/)、[事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，可以构建出页面的结构。

##### 数据绑定

`WXML` 中的动态数据均来自对应 `Page` 的 `data`。

###### 简单绑定

数据绑定使用 `Mustache` 语法（即双大括号 `{{}}`）将变量包裹起来，可作用于组件内容、组件属性和组件指令。如下所示：

（1）组件内容：将组件的内容绑定为 `data`。

```html
<view> {{ message }} </view>
```

```js
Page({
  	data: {
    	message: 'Hello MINA!'
  	}
})
```

（2）组件属性（需要在双引号之内）：将组件的属性值绑定为 `data`。

```html
<view id="item-{{id}}"> </view>
```

```js
Page({
  	data: {
    	id: 0
  	}
})
```

（3）组件指令（需要在双引号之内）：将组件的指令（亦称控制属性）值绑定为 `data`。

```html
<view wx:if="{{condition}}"> </view>
```

```js
Page({
  	data: {
    	condition: true
  	}
})
```

###### 表达式

可以在 `{{}}` 内插入任何 `js` 表达式来进行简单的运算，然后将其结果作为绑定值。由于小程序仅支持通过事件来调用函数，因此不支持在 `{{}}` 插入任何的函数或 `API` 调用（`WXS` 脚本导出的函数除外）。但它支持如下几种方式：

（1）字面量：支持直接使用字面量作为绑定值。

- 原始值：仅支持数字、字符串和布尔值。
- 数组：支持数组，且会自动展开它。
- 对象：支持对象，但不能单独使用。`Mustache` 语法只允许两个 `{{}}`，因此对象直接插入属性即可，如 `{{foo: 'foo'}}`。

```html
<checkbox checked="{{false}}"></checkbox>
```

***特别注意：这里不要直接写 `checked="false"`（尽管没有 `{{}}`），其计算结果是一个字符串，转成 `boolean` 类型后是真值。***

（1）三元运算

```html
<view hidden="{{flag ? true : false}}"> Hidden </view>
```

```js
Page({
 	data: {
		flag: true
  	}
})
```

（2）基本运算

```html
<view> {{a + b}} + {{c}} + d </view>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2,
    	c: 3
  	}
})
```

（3）逻辑判断

```html
<view wx:if="{{length > 5}}"> </view>
```

```js
Page({
  	data: {
    	length: 1
  	}
})
```

（5）路径运算

```html
<view>{{object.key}} {{array[0]}}</view>
```

```js
Page({
  	data: {
    	object: {
      		key: 'Hello '
    	},
    	array: ['MINA']
  	}
})
```

###### 组合

也可以在 `Mustache` 内直接进行组合，构成新的对象或者数组。

（1）数组：不支持调用任何数组 `API`。

```html
<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
```

```js
Page({
  	data: {
    	zero: 0
  	}
})
```

最终组合成的数组是 `[0, 1, 2, 3, 4]`。

（2）对象：不支持调用任何对象 `API`，且直接书写属性即可。对象通常用来传递数据，单独定义成其他属性的值是没有意义的。

```html
<!-- 关于此元素的用法，详见本节-模板 -->
<template is="objectCombine" data="{{foo: a, bar: b}}"></template>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2
  	}
})
```

最终组合成的对象是 `{foo: 1, bar: 2}`。

（3）扩展运算符：可以用扩展运算符 `...` 来将一个对象展开：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
      		b: 2
    	},
    	obj2: {
      		c: 3,
      		d: 4
    	}
  	}
})
```

最终组合成的对象是 `{a: 1, b: 2, c: 3, d: 4, e: 5}`。

（4）同名简写：如果对象的 `key` 和 `value` 相同，也可以间接地表达。

```html
<template is="objectCombine" data="{{foo, bar}}"></template>
```

```js
Page({
  	data: {
    	foo: 'my-foo',
    	bar: 'my-bar'
  	}
})
```

最终组合成的对象是 `{foo: 'my-foo', bar:'my-bar'}`。

（5）随意组合：上述方式可以随意组合，但是如果有存在变量名相同的情况，则后边的会覆盖前面的，如：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
     		b: 2
    	},
    	obj2: {
      		b: 3,
      		c: 4
    	},
    	a: 5
  	}
})
```

最终组合成的对象是 `{a: 5, b: 3, c: 6}`。

**注意：** 花括号和引号之间如果有空格，将最终被解析成为字符串，如下所示。

```html
<view wx:for="{{[1,2,3]}} ">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{[1,2,3] + ' '}}">{{item}}</view>
```

这样做会带来一些渲染意外，即：将数组的元素分隔符（`,`）也视作元素，而空格（也可换做其他字符）则被视作最后一个元素。

```html
<view>1</view>
<view>,</view>
<view>2</view>
<view>,</view>
<view>3</view>
<view> </view>
```

##### 条件渲染

###### `wx:if`

在框架中，可在某元素上使用 `wx:if` 指令，然后根据其值的布尔性来决定是否渲染该元素：

```html
<view wx:if="{{true}}"> True —— 被渲染的元素 </view>
<view wx:if="{{false}}"> false —— 不被渲染的元素 </view>
```

当然，也可以用 `wx:elif` 和 `wx:else` 来添加其他条件块。同样的，`elif` 块可以有多个，而 `else` 块只能有一个。

```html
<view wx:if="{{1 > 3}}"> 1 </view>
<view wx:elif="{{2 > 3}}"> 2 </view>
<view wx:elif="{{3 > 3}}"> 3 </view>
<view wx:else> 4 </view>
```

###### `block wx:if`

因为 `wx:if` 是一个控制属性，所以需要将它添加到一个标签上。如果要一次性判断多个组件标签，则可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```html
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

**注意：** `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，且只接受控制属性（即：组件指令）。

###### `wx:if` 与 `hidden`

因为 `wx:if` 中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架会有一个局部渲染的过程，以此来确保条件块在切换时被销毁或重新渲染。

同时 `wx:if` 也是 **惰性的**，如果在初始渲染条件为 `false`，则框架什么也不会做，只在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 属性就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏而已。

```html
<view hidden> 被隐藏的组件 </view> 
<view hidden="{{false}}"> 被显示的组件 </view> <!-- 注意：与hidden="false"的区别 -->
```

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁的切换，用 `hidden` 会更好；如果在运行时条件不大可能会改变（即切换不频繁），则用 `wx:if` 比较好。

##### 列表渲染

###### `wx:for`

在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中的每个元素来重复渲染该组件。

通常，数组当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`。因此，不需要额外定义，直接使用它们即可。

```html
<view wx:for="{{array}}">
  	{{index}}: {{item.message}}
</view>
```

```js
Page({
 	data: {
    	array: [
            {
      			message: 'foo',
    		}, {
      			message: 'bar'
    		}
        ]
  	}
})
```

不过，使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  	{{idx}}: {{itemName.message}}
</view>
```

`wx:for` 也可以嵌套，例如下边是一个九九乘法表：

```html
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  	<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    	<view wx:if="{{j <= i}}">
      		{{j}} * {{i}} = {{i * j}}
    	</view>
  	</view>
</view>
```

###### `block wx:for`

类似 `block wx:if`，也可以将 `wx:for` 用在 `<block/>` 标签上，以渲染一个包含多节点的结构块。例如：

```html
<block wx:for="{{[1, 2, 3]}}">
  	<view> {{index}}: {{item}}</view>
</block>
```

###### `wx:key`

如果列表中项目的位置会动态改变或者会有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [`input`](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[`switch`](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），则需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供：

1. 字符串：代表 `item` 的某个属性。该属性的值必须是在此列表中唯一的字符串或数字值，且不能动态改变。
2. 保留关键字 `*this`（带星号）：代表 `item` 本身。这种表示须要 `item` 本身是一个唯一的字符串或者数字。

```html
<view wx:for="{{arr1}}" wx:key="id">{{item.id}}</view> <!-- 绑定：item.id -->

<view wx:for="{{arr2}}" wx:key="*this">{{item}}</view> <!-- 绑定：item自身 -->
```

```js
Page({
    data: {
        arr1: [
            {id: 0},
            {id: 1},
            {id: 2}
        ],
        arr2: [0, 1, 2]
    }
})
```

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，从而确保使组件保持自身的状态，并且提高列表渲染时的效率。

**注意：如果不提供 `wx:key`，会报一个 `warning`。 但如果明确知道该列表是静态的，或者不必关注其顺序，则可以选择忽略它。**

###### 示例代码

```html
<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>

<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
<button bindtap="addNumberToFront"> Add to the front </button>
```

```js
Page({
  	data: {
    	objectArray: [
      		{id: 5, unique: 'unique_5'},
      		{id: 4, unique: 'unique_4'},
      		{id: 3, unique: 'unique_3'},
      		{id: 2, unique: 'unique_2'},
      		{id: 1, unique: 'unique_1'},
      		{id: 0, unique: 'unique_0'},
    	],
    	numberArray: [1, 2, 3, 4]
  	},
  	switch: function(e) {
    	const length = this.data.objectArray.length
    	for (let i = 0; i < length; ++i) {
      		const x = Math.floor(Math.random() * length)
      		const y = Math.floor(Math.random() * length)
      		const temp = this.data.objectArray[x]
      		this.data.objectArray[x] = this.data.objectArray[y]
      		this.data.objectArray[y] = temp
    	}
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addToFront: function(e) {
    	const length = this.data.objectArray.length
    	this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addNumberToFront: function(e){
    	this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    	this.setData({
      		numberArray: this.data.numberArray
    	})
  	}
})
```

###### 注意事项

当 `wx:for` 的值为字符串时，会将这个字符串拆分解析成字符串数组。

```html
<view wx:for="array">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{['a', 'r', 'r', 'a', 'y']}}">{{item}}</view>
```

##### 模板

`WXML` 提供了模板（`<template>`），可以在模板中定义代码片段，然后在不同的地方调用。

###### 定义模板

使用 `name` 属性，作为模板的名字（其他模板可通过该名字来调用此模板）。然后在 `<template/>` 内定义代码片段，如：

```html
<!--
  	index: int
  	msg: string
  	time: string
-->
<template name="msgItem">
  	<view>
    	<text> {{index}}: {{msg}} </text>
    	<text> Time: {{time}} </text>
  	</view>
</template>
```

此模板（无 `is` 属性）代码不会被显示，其中的数据（如这里的 `index`、`msg`、`time`）均由使用者模板通过其 `data` 属性来传入。

###### 使用模板

使用 `is` 属性（值为模板名）来表示当前模板使用指定模板中的代码。然后，将模板所需要的数据通过 `data` 属性传入，如：

```html
<template is="msgItem" data="{{...item}}"/> <!-- 模板中的代码会被显示，模板本身不显示 -->
```

```js
Page({
  	data: {
    	item: {
            index: 0,
            msg: 'this is a template',
            time: '2023-05-02'
    	}
  	}
})
```

`is` 属性也可以使用 `Mustache` 语法，来动态决定具体渲染哪个模板：

```html
<template name="odd">
  	<view> odd </view>
</template>
<template name="even">
  	<view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
  	<template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
</block>
```

###### 模板的作用域

模板拥有自己的作用域，只能访问使用者模板通过 `data` 属性传入的数据以及模板定义文件 `WXML` 中定义的 `<wxs>` 模块数据。

```html
<wxs module="log">
    var foo = 'foo';

    module.exports = {
    	foo: foo
    }
</wxs>

<template name="Log">
  	<view>{{log.foo}} -- log</view>
</template>

<template is="Log"></template>
```

关于 `<wxs>` 的用法，参见下节 `WXS`。

##### 引用

`WXML` 提供了两种文件引用的方式：`import` 和 `include`。

###### `import`

`import` 可以在该文件中使用目标文件定义的 `template`，如：

在 `item.wxml` 中定义一个叫 `item` 的 `template`：

```html
<!-- item.wxml -->
<template name="item">
  	<text>{{text}}</text>
</template>
```

在 `index.wxml` 中引用 `item.wxml`，就可以使用此文件定义的 `item` 模板：

```html
<!-- index.wxml -->
<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>
```

###### `import` 的作用域

`import` 有作用域的概念，即只会 `import` 目标文件中定义的 `template`，而不会 `import` 目标文件 `import` 的 `template`。

**如：`C import B`，`B import A`，则在 `C` 中可以使用 `B` 定义的`template`，在 `B` 中可以使用 `A` 定义的`template`，但是 `C` 不能使用 `A` 定义的`template`。因为这种 `import` 对 `template` 只有使用权，而没有所有权**。

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<import src="b.wxml"/>
<template is="B"/>
<template is="A"/>  <!-- Error! Can not use tempalte when not import A. -->
```

###### `include`

而 `include` 可以将目标文件的整个代码（除了 `<template/>` 和 `<wxs/>` 之外）引入，相当于是拷贝到 `include` 的位置，如：

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 却没有了！ -->
```

上述引用关系为：`C include B`，`B import A`。这样一来，`B` 就将自身对 `A` 的使用权分享给了 `C`，但由于 `<template/>` 不被包含，因此 `C` 对 `B` 没有使用权（除非又 `import` 它）。

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<import src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 也能被正常使用了！ -->
```



#### `WXSS`

`WXSS`（`WeiXin Style Sheets`）是一套样式语言，用于描述 `WXML` 的组件样式。也就是，用来决定 `WXML` 的组件应该怎么显示。

为了适应广大的前端开发者，`WXSS` 具有 `CSS` 大部分特性。同时为了更适合开发微信小程序，`WXSS` 对 `CSS` 进行了扩充以及修改。

与 `CSS` 相比，`WXSS` 扩展的特性有：

- 尺寸单位
- 样式导入

##### 尺寸单位

`rpx`（`responsive pixel`，响应式像素）可以根据屏幕宽度进行自适应，官方规定屏幕宽为 `750rpx`。如在 `iPhone6` 上，屏幕宽度为 `375px` 且共有 750 个物理像素，则 `750rpx` = `375px` = 750 物理像素，即 `1rpx` = `0.5px` = 1 物理像素。

|      设备      | `rpx` 换算 `px`（屏幕宽度/750） | `px` 换算 `rpx`（750/屏幕宽度） |
| :------------: | :-----------------------------: | :-----------------------------: |
|   `iPhone5`    |         `1rpx = 0.42px`         |         `1px = 2.34rpx`         |
|   `iPhone6`    |         `1rpx = 0.5px`          |          `1px = 2rpx`           |
| `iPhone6 Plus` |        `1rpx = 0.552px`         |         `1px = 1.81rpx`         |

**建议：** 开发微信小程序时设计师可以用 `iPhone6` 作为视觉稿的标准。

```css
/* 以 iPhone6 为标准开发(1px = 2rpx): 原先写 100px，现在可写成 200rpx */
view {
    width: 200rpx; /* => 100px */
}
```

**注意：** 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

此外，还有三个跟像素相关的专业术语，`DPR`、`DPI` 和 `PPI`。分别是指：

- `DPR`：设备像素比（`Device Pixel Ratio`），是物理像素和 `CSS` 像素的比例。
- `DPI`：设备独立像素（`Device Independent Pixel`），也称逻辑像素（每英寸像素点，跟 `CSS` 像素很像），与设备无关。
- `PPI`：每英寸像素（`Pixels Per Inch`），亦称像素密度（即屏幕一英寸有多少个物理像素点）。

|    机型    | 物理像素分辨率（设备） | 逻辑像素分辨率（`CSS`） | `PPI` | `DPR` |
| :--------: | :--------------------: | :---------------------: | :---: | :---: |
| `iPhone4`  |       640 × 960        |        320 × 480        |  326  |   2   |
| `iPhone5`  |       640 × 1136       |        320 × 568        |  326  |   2   |
| `iPhone6`  |       750 × 1334       |        375 × 667        |  326  |   2   |
| `iPhone6p` |      1242 × 2208       |        414 × 736        |  401  |   3   |

##### 样式导入

使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，且必须用 `;` 表示语句结束。

```less
/** common.wxss **/
.small-p {
  	padding: 5px;
}
```

```less
/** app.wxss **/
@import "common.wxss";
.middle-p {
  	padding: 15px;
}
```

注意：在不加重 `CSS` 权重的情况下，导入的样式优先级低于本文件中的样式，但高于全局样式。

##### 内联样式

框架组件上支持使用 `style` 属性来直接定义组件的样式，被称为内联样式，优先级很高。

注意：静态的样式应统一写到 `class` 中，`style` 通常接收动态的样式（通过使用 `{{}}`）。在运行时会对其进行解析，因此要尽量避免将静态的样式写进 `style` 中，以免影响渲染速度。

```html
<view style="color:{{color}};" />
```

##### 选择器

`WXSS` 并未支持全部 `CSS` 选择器，目前支持的选择器有：

| 选择器                           | 样例             | 样例描述                                   |
| :------------------------------- | :--------------- | :----------------------------------------- |
| `.class`（类选择器）             | `.intro`         | 选择所有拥有 `class="intro"` 的组件        |
| `#id`（`ID` 选择器）             | `#firstname`     | 选择拥有 `id="firstname"` 的组件           |
| `element`（元素选择器）          | `view`           | 选择所有 `view` 组件                       |
| `element, element`（并集选择器） | `view, checkbox` | 选择所有 `view` 组件和所有 `checkbox` 组件 |
| `::after`（伪对象选择器）        | `view::after`    | 在 `view` 组件后边插入内容                 |
| `::before`（伪对象选择器）       | `view::before`   | 在 `view` 组件前边插入内容                 |

##### 样式覆盖

定义在 `app.wxss` 中的样式为全局样式，作用于每一个页面。在 `page` 的 `wxss` 文件中定义的样式为页面样式，只作用在对应的页面，并会覆盖 `app.wxss` 中相同的选择器。另外，组件样式会覆盖页面样式。于是，组件样式 > 页面样式 > 导入样式 > 全局样式。



#### `WXS`

`WXS`（`WeiXin Script`）是小程序独有的一套脚本语言，结合 `WXML`，可以构建出页面的结构。

`WXS` 之于 `WXML` 的作用如同 `JavaScript` 之于 `HTML`，同样拥有 `.wxs` 文件和 `<wxs>` 标签。其中，`.wxs` 文件相当于 `.js` 文件，而 `<wxs>` 标签则相当于 `<script type="module">` 标签。尽管如此，`WXS` 与 `JavaScript` 也是两种不同的语言，它有自己的语法。虽然借鉴了 `JavaScript`，但并不总和 `JavaScript` 一致。

##### 简介

首先，`WXS` 有以下几个特点：

1. `WXS` 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
2. `WXS` 与 `JavaScript` 是不同的语言，有自己的语法，并不和 `JavaScript` 一致。`WXS` 中没有全局对象，虽然其 `this` 也默认指向 `Window`，但 `Window` 并未被定义，因此使用 `this` 会报 `ReferenceError`。
3. `WXS` 的运行环境和其他 `JavaScript` 代码是隔离的，`WXS` 中不能调用其他 `JavaScript` 文件中定义的函数，也不能调用小程序提供的 `API`。
4. 由于运行环境的差异，在 `iOS` 设备上小程序内的 `WXS` 会比 `JavaScript` 代码快 2 ~ 20 倍。在 `android` 设备上二者的运行效率无差异。

其次，它并不会显示在页面上，主要用来做页面渲染和简单的页面数据处理。

###### 页面渲染

```html
<!--wxml-->
<wxs module="m1">
	var msg = "hello world";

	module.exports.message = msg;
</wxs>

<view> {{m1.message}} </view>
```

最终渲染：

```html
<view> hello world </view>
```

###### 数据处理

```js
// page.js
Page({
  	data: {
    	array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  	}
})
```

```html
<!--wxml-->
<!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
<wxs module="m1">
	var getMax = function(array) {
  		var max = undefined;
  		for (var i = 0; i < array.length; ++i) {
    		max = max === undefined ? array[i] : (max >= array[i] ? max : array[i]);
  		}
  		return max;
	}

	module.exports.getMax = getMax;
</wxs>
    
<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
<view> {{m1.getMax(array)}} </view> <!-- {{}}支持调用WXS脚本导出的函数 -->
```

最终输出：

```html
<view> 5 </view>
```

##### 模块

每一个 `.wxs` 文件和 `<wxs>` 标签都是一个单独的模块。每个模块都有自己独立的作用域，即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。如前所述， `<wxs>` 模块中 `this` 也默认指向 `Window`，但 `Window` 并未被定义。

```html
<wxs module="m1">
	console.log(this); // ReferenceError: Window is not defined
</wxs>
```

一个模块要想对外暴露其内部的私有变量与函数，就只能通过 `module.exports` 来实现（这是类似 `Node` 的风格）。

###### `.wxs` 文件

在微信开发者工具里面，右键可以直接创建 `.wxs` 文件，然后在其中直接编写 `WXS` 脚本代码（具体语法参见下文）即可。

```js
// /pages/comm.wxs

// 仅支持var关键字
var foo = "'hello world' from comm.wxs";

// 未支持箭头函数
var bar = function(d) {
  	return d;
}

// 未支持ES6同名简写
module.exports = {
  	foo: foo,
  	bar: bar
};
```

上例在 `/pages/comm.wxs` 的文件中编写了 `WXS` 代码。该 `.wxs` 文件可以被其他的 `.wxs` 文件或 `WXML` 中的 `<wxs>` 标签引用。

###### `<wxs>` 标签

在 `WXML` 文件中嵌入 `<wxs>` 标签，就如同在 `HTML` 文件中嵌入 `<script type="module">` 标签一样。这虽是一个不太恰当的比喻（因为框架的帮助，`WXML` 可以通过模块名和 `{{}}` 来使用 `<wxs>` 导出的数据和方法，而 `HTML` 不可以），但有助于理解 `<wxs>` 标签。

|  属性名  |   类型   | 默认值 | 说明                                                         |
| :------: | :------: | :----: | :----------------------------------------------------------- |
| `module` | `String` |        | 当前 `<wxs>` 标签的模块名。必填字段。                        |
|  `src`   | `String` |        | 引用 `.wxs` 文件的相对路径。仅当本标签为 **单闭合标签** 或 **标签的内容为空** 时有效。 |

（1）**`module` 属性**

`module` 属性是当前 `<wxs>` 标签的模块名。在同一 `WXML` 文件内，建议其值唯一，如有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同 `WXML` 文件之间的 `wxs` 模块名不会相互覆盖。

`module` 属性值的命名必须符合下面两个规则：

- 首字符必须是：字母（`a-z, A-Z`）、下划线（`_`），二者之一。
- 剩余字符可是：字母（`a-z, A-Z`）、下划线（`_`）、数字（0 - 9），三者之一。

```html
<wxs module="foo">
    // 与在.wxs文件中书写是一样的。
	var some_msg = "hello world";
    var fn = function() {
    	return 'fn';
    };
	module.exports = {
  		msg : some_msg,
    	fn: fn
	}
</wxs>
<view> {{foo.msg}} -- {{foo.fn()}}</view> <!-- {{}}支持调用WXS脚本导出的函数 -->
```

最终输出：

```html
<view> hello world -- fn </view>
```

上面例子声明了一个名为 `foo` 的模块，它将 `some_msg` 变量暴露出来，供当前页面使用，而未导出的内容对外部是不可见的。

（2）**`src` 属性**

`src` 属性可以用来引用其他的 `wxs` 模块文件。

引用的时候，要注意如下几点：

- 相对路径：只能引用 `.wxs` 模块文件，且必须使用相对路径和后缀名。
- 单例对象：`wxs` 模块均为单例，`wxs` 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 `wxs` 模块对象。
- 惰性计算：如果一个 `wxs` 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

```js
// /pages/index/index.js

Page({
  	data: {
    	msg: "'hello wrold' from js",
  	}
})
```

```html
<!-- /pages/index/index.wxml -->

<wxs src="./../comm.wxs" module="some_comms"></wxs>

<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo -->
<view> {{some_comms.bar(some_comms.foo)}} </view>

<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg -->
<view> {{some_comms.bar(msg)}} </view>
```

页面输出：

```html
<view> 'hello world' from comm.wxs </view>
<view> 'hello wrold' from js </view>
```

上述例子在文件 `/pages/index/index.wxml` 中通过 `<wxs>` 标签引用了 `/pages/comm.wxs` 模块。

（3）**作用域**

`<wxs>` 模块是只属于且直接属于定义它的 `WXML` 文件的，只能在定义此模块的 `WXML` 文件中被访问到。

```html
<template name="Log">
  	<wxs module="log">
      	var foo = 'foo';

      	module.exports = {
        	foo: foo
      	}
  	</wxs>
  	<view>{{log.foo}} -- log</view>
</template>

<view>{{log.foo}} -- log</view>
<template is="Log"></template>
```

最终渲染：

```html
<view>foo -- log</view>
<view>foo -- log</view>
```

因此，当其他 `WXML` 文件使用 `<include>` 或 `<import>` 引用本 `WXML` 中的代码时，`<wxs>` 模块不会被引入到目标 `WXML` 文件中。

```html
<!-- pages/log/index.wxml -->

<wxs module="log">
  	var foo = 'foo';
  	module.exports = {
    	foo: foo
  	}
</wxs>

<view>{{log.foo}} -- log</view>
```

```html
<!-- pages/index/index.wxml -->

<include src="../log/index" />
```

最终渲染：

```html
<view> -- log</view>
```

即使定义在 `<template>` 标签中，也是带不走的，虽然它依然可以访问此模块导出的数据。

```html
<!-- pages/log/index.wxml -->

<template name="Log">
    <!-- <wxs>是只属于定义它的WXML文件的，因此，定义在<template>内或外都是一样带不走的 -->
    <wxs module="log">
        var foo = 'foo';

        module.exports = {
            foo: foo
        }
	</wxs>
    
  	<view>{{log.foo}} -- log</view>
</template>

<view>{{log.foo}} -- log</view>
```

```html
<!-- pages/index/index.wxml -->

<import src="../log/index" />
<template is="Log"></template>
<include src="../log/index" />
```

最终渲染：

```html
<view>foo -- log</view>
<view> -- log</view>
```

###### `module` 对象

每个 `wxs` 模块均有一个内置的 `module` 对象，它拥有一个 `exports` 属性，通过该属性，可以对外共享本模块的私有变量与函数。

```js
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}

// module对象跟Node中的用法相似。
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```html
<!-- page/index/index.wxml -->

<wxs src="./../tools.wxs" module="tools" />
<view> {{tools.msg}} </view>
<view> {{tools.bar(tools.FOO)}} </view> 
```

最终输出：

```html
<view> some msg </view>
<view> 'hello world' from tools.wxs </view>
```

###### `require` 函数

要在 `.wxs` 模块中引用其他 `wxs` 模块文件，可以使用 `require` 函数。引用规则和注意事项与 `<wxs>` 的 `src` 引用一样。

```js
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```js
// /pages/logic.wxs

var tools = require("./tools.wxs");

console.log(tools.FOO); 				// "'hello world' from tools.wxs"
console.log(tools.bar("logic.wxs")); 	// "logic.wxs"
console.log(tools.msg); 				// "some msg"
```

```html
<!-- /page/index/index.wxml -->

<wxs src="./../logic.wxs" module="logic" />
```

当然，不使用 `src`，直接在 `<wxs>` 中使用 `require()` 导入也是可以的。

```html
<!-- /page/index/index.wxml -->

<wxs module="logic">
    var tools = require("./tools.wxs");

    console.log(tools.FOO); 				// "'hello world' from tools.wxs"
    console.log(tools.bar("logic.wxs")); 	// "logic.wxs"
    console.log(tools.msg); 				// "some msg"
</wxs>
```

##### 变量

###### 声明

`WXS` 仅支持了使用 `var` 关键字来声明变量（与 `javascript` 一样，会有变量提升）。没有声明的变量直接赋值使用，会被定义为全局变量（虽然没有全局对象）。如果只声明变量而不赋值，则默认值为 `undefined`。

```html
<wxs module="m1">
	var a = b = 1, c;
    
    console.log(a, b, c); // 1 1 undefined
</wxs>

<wxs module="m2">
  	console.log(b); // 1
    console.log(a); // ReferenceError: a is not defined
    console.log(c); // ReferenceError: c is not defined
</wxs>
```

`WXS` 虽然没有全局对象，但仍有全局变量的概念。需要注意的是，使用 `var` 声明的变量是独属于此模块的局部变量，而未使用 `var` 声明的变量才是全局变量，这与 `JavaScript` 不同，如上所示。

###### 变量名

变量命名必须符合下面两个规则：

- 首字符必须是：字母（`a-z, A-Z`）、下划线（`_`），二者之一。
- 剩余字符可是：字母（`a-z, A-Z`）、下划线（`_`）、数字（0 - 9），三者之一。

###### 保留标识符

以下标识符不能作为变量名：

|     保      |     留     |    标     |   识    |     符      |
| :---------: | :--------: | :-------: | :-----: | :---------: |
|  `delete`   |   `void`   | `typeof`  | `null`  | `undefined` |
|    `NaN`    | `Infinity` |   `var`   |  `if`   |   `else`    |
|   `true`    |  `false`   | `require` | `this`  | `function`  |
| `arguments` |   return   |   `for`   | `while` |    `do`     |
|   `break`   | `continue` | `switch`  | `case`  |  `default`  |

##### 注释

与 `JavaScript` 一样，`WXS` 主要有 2 种注释的方法。

- 单行注释：`// 最多能注释一行`
- 多行注释：`/* 可注释多行 */`

##### 运算符

`WXS` 支持的运算符，及其优先级如下表所示。

| 优先级 |  运算符  |    说明    |  结合性  |
| :----: | :------: | :--------: | :------: |
|   20   |   `()`   |    括号    |  `N/A`   |
|   19   |   `.`    |  成员访问  | 从左到右 |
|        |   `[]`   |  成员访问  | 从左到右 |
|        |  `fn()`  |  函数调用  | 从左到右 |
|   17   |   `++`   |  后置递增  |  `N/A`   |
|        |   `--`   |  后置递减  |  `N/A`   |
|   16   |   `!`    |   逻辑非   | 从右到左 |
|        |   `~`    |   按位非   | 从右到左 |
|        |   `+`    |  正值运算  | 从右到左 |
|        |   `-`    |  负值运算  | 从右到左 |
|        |   `++`   |  前置递增  | 从右到左 |
|        |   `--`   |  前置递减  | 从右到左 |
|        | `typeof` |  类型检测  | 从右到左 |
|        |  `void`  |   `void`   | 从右到左 |
|        | `delete` |  删除成员  | 从右到左 |
|   14   |   `*`    |    乘法    | 从左到右 |
|        |   `/`    |    除法    | 从左到右 |
|        |   `%`    |    取模    | 从左到右 |
|   13   |   `+`    |    加法    | 从左到右 |
|        |   `-`    |    减法    | 从左到右 |
|   12   |   `<<`   |  按位左移  | 从左到右 |
|        |   `>>`   |  按位右移  | 从左到右 |
|        |  `>>>`   | 无符号右移 | 从左到右 |
|   11   |   `<`    |    小于    | 从左到右 |
|        |   `<=`   |  小于等于  | 从左到右 |
|        |   `>`    |    大于    | 从左到右 |
|        |   `>=`   |  大于等于  | 从左到右 |
|   10   |   `==`   |    等号    | 从左到右 |
|        |   `!=`   |   非等号   | 从左到右 |
|        |  `===`   |   全等号   | 从左到右 |
|        |  `!==`   |  非全等号  | 从左到右 |
|   9    |   `&`    |   按位与   | 从左到右 |
|   8    |   `^`    |  按位异或  | 从左到右 |
|   7    |   `｜`   |   按位或   | 从左到右 |
|   6    |   `&&`   |   逻辑与   | 从左到右 |
|   5    |  `｜｜`  |   逻辑或   | 从左到右 |
|   4    | `?` `:`  | 条件运算符 | 从右到左 |
|   3    |   `=`    |    赋值    | 从右到左 |
|        |   `+=`   |    赋值    | 从右到左 |
|        |   `-=`   |    赋值    | 从右到左 |
|        |   `*=`   |    赋值    | 从右到左 |
|        |   `/=`   |    赋值    | 从右到左 |
|        |   `%=`   |    赋值    | 从右到左 |
|        |  `<<=`   |    赋值    | 从右到左 |
|        |  `>>=`   |    赋值    | 从右到左 |
|        |  `>>>=`  |    赋值    | 从右到左 |
|        |   `&=`   |    赋值    | 从右到左 |
|        |   `^=`   |    赋值    | 从右到左 |
|        |  `｜=`   |    赋值    | 从右到左 |
|   0    |   `,`    |    逗号    | 从左到右 |

##### 语句

与 `JavaScript` 一样，`WXS` 也支持以下 4 种语句：`if`、`switch`、`for` 和 `while`。

###### `if`

```js
// if
if (expression) statement;

if (expression)
 	statement;

if (expression) {
  	statement;
}

// if-else
if (expression) statement;
else statement2;

if (expression)
  	statement1;
else
  	statement2;

if (expression) {
  	statement1;
} else {
  	statement2;
}

// if-else if-else
if (expression1) {
  	statement1;
} else if (expression2) {
  	statement2;
} else if (expression3) {
  	statement3;
} else {
  	statement4;
}
```

###### `switch`

```js
switch (expression) {
  	case variable:
    	statement1;
  	case number:
    	statement2;
    	break;
  	case boolean:
    	statement3;
    	break;
  	case string:
    	statement4;
  	default:
    	statement5;
}
```

注意：`default` 分支可以省略不写。`case` 关键词后面只能直接使用：变量、数字、布尔值、字符串，不可以使用表达式。

###### `for`

```js
for (语句; 语句; 语句)
  	语句;

for (语句; 语句; 语句) {
  	代码块;
}
```

支持使用 `break`，`continue` 关键词。

###### `while`

```js
while (表达式)
  	语句;

while (表达式){
  	代码块;
}

do {
  	代码块;
} while (表达式)
```

支持使用 `break`，`continue` 关键词。

##### 数据类型

`WXS` 语言目前共有以下 8 种数据类型，这些类型都不可以通过其构造器来创建，只能使用相应的字面量或方法来创建。

|     数     |    据    |    类     |    型    |
| :--------: | :------: | :-------: | :------: |
|  `Number`  | `String` | `Boolean` | `Object` |
| `Function` | `Array`  |  `Date`   | `RegExp` |

###### `Number`

`Number` 仅支持字面量创建，包括两种数值：整数，小数。

|     属性      | 描述                    |
| :-----------: | :---------------------- |
| `constructor` | 返回字符串 `"Number"`。 |

|       方        |        法        |
| :-------------: | :--------------: |
|   `toString`    | `toLocaleString` |
|    `valueOf`    |    `toFixed`     |
| `toExponential` |  `toPrecision`   |

```js
(10).constructor; // "Number"
```

###### `String`

`String` 仅支持字面量创建，有两种写法：单引号，双引号。

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"String"`。 |
|   `length`    | 返回字符串长度。        |

|      方       |         法          |
| :-----------: | :-----------------: |
|  `toString`   |      `valueOf`      |
|   `charAt`    |    `charCodeAt`     |
|   `concat`    |      `indexOf`      |
| `lastIndexOf` |   `localeCompare`   |
|    `match`    |      `replace`      |
|   `search`    |       `slice`       |
|    `split`    |     `substring`     |
| `toLowerCase` | `toLocaleLowerCase` |
| `toUpperCase` | `toLocaleUpperCase` |
|    `trim`     |                     |

```js
"".constructor; // "String"
```

###### `Boolean`

`Boolean` 仅支持字面量创建，只有两个特定的值：`true` 和 `false`。

|     属性      | 描述                     |
| :-----------: | ------------------------ |
| `constructor` | 返回字符串 `"Boolean"`。 |

|     方     |    法     |
| :--------: | :-------: |
| `toString` | `valueOf` |

```js
true.constructor; // "Boolean"
```

###### `Object`

`Object` 仅支持字面量，是一种无序的键值对。

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"Object"`。 |

|    方法    | 描述                             |
| :--------: | -------------------------------- |
| `toString` | 返回字符串 `"[object Object]"`。 |

```js
{}.constructor // "Object"
```

###### `Function`

`Function` 仅支持使用关键字声明的定义方式，尚未支持箭头函数。

|     属性      | 描述                      |
| :-----------: | ------------------------- |
| `constructor` | 返回字符串 `"Function"`。 |
|   `length`    | 返回函数的形参个数。      |

|    方法    | 描述                                 |
| :--------: | ------------------------------------ |
| `toString` | 返回字符串 `"[function Function]"`。 |

`function` 里面可以使用 `arguments` 关键词，该关键词目前只支持以下的属性：

- `length`：实参个数。
- `[index]`：每个实参所依次对应的下标。

```js
(function() {}).constructor; // "Function"
```

###### `Array`

`Array` 仅支持字面量创建。

|     属性      | 描述                   |
| :-----------: | ---------------------- |
| `constructor` | 返回字符串 `"Array"`。 |
|   `length`    | 数组长度               |

|      方       |      法       |
| :-----------: | :-----------: |
|  `toString`   |   `concat`    |
|    `join`     |     `pop`     |
|    `push`     |   `reverse`   |
|    `shift`    |    `slice`    |
|    `sort`     |   `splice`    |
|   `unshift`   |   `indexOf`   |
| `lastIndexOf` |    `every`    |
|    `some`     |   `forEach`   |
|     `map`     |   `filter`    |
|   `reduce`    | `reduceRight` |

```js
[].constructor; // "Array"
```

###### `Date`

生成 `Date` 对象仅支持使用 `getDate`函数，返回一个当前时间的对象。

```text
getDate()
getDate(milliseconds)
getDate(datestring)
getDate(year, month-1, day, hours, minutes, seconds, milliseconds)
```

|      参数      | 描述                                                         |
| :------------: | ------------------------------------------------------------ |
| `milliseconds` | 从 1970 年 1 月 1 日 `00:00:00 UTC` 开始计算的毫秒数         |
|  `datestring`  | 日期字符串，其格式可为：<br /> （1）`"month day, year hours:minutes:seconds"`<br /> （2）`"year-month-day hours:minutes:seconds"` |

```js
getDate(); 							// Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
getDate(1683118557440); 			// Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
getDate('2023-5-3 20:55:57'); 		// Wed May 03 2023 00:00:00 GMT+0800 (中国标准时间)
getDate('5 3, 2023 20:55:57'); 		// Wed May 03 2023 00:00:00 GMT+0800 (中国标准时间)
getDate(2023, 4, 3, 20, 55, 57, 0); // Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
```

|     属性      |         描述          |
| :-----------: | :-------------------: |
| `constructor` | 返回字符串 `"Date"`。 |

|          支          |        持         |          的          |          方          |          法          |
| :------------------: | :---------------: | :------------------: | :------------------: | :------------------: |
|      `toString`      |  `toDateString`   |    `toTimeString`    |   `toLocaleString`   | `toLocaleDateString` |
| `toLocaleTimeString` |     `valueOf`     |      `getTime`       |    `getFullYear`     |   `getUTCFullYear`   |
|      `getMonth`      |   `getUTCMonth`   |      `getDate`       |     `getUTCDate`     |       `getDay`       |
|     `getUTCDay`      |    `getHours`     |    `getUTCHours`     |     `getMinutes`     |   `getUTCMinutes`    |
|     `getSeconds`     |  `getUTCSeconds`  |  `getMilliseconds`   | `getUTCMilliseconds` | `getTimezoneOffset`  |
|      `setTime`       | `setMilliseconds` | `setUTCMilliseconds` |     `setSeconds`     |   `setUTCSeconds`    |
|     `setMinutes`     |  `setUTCMinutes`  |      `setHours`      |    `setUTCHours`     |      `setDate`       |
|     `setUTCDate`     |    `setMonth`     |    `setUTCMonth`     |    `setFullYear`     |   `setUTCFullYear`   |
|    `toUTCString`     |   `toISOString`   |       `toJSON`       |                      |                      |

```js
getDate().constructor; // "Date"
```

###### `RegExp`

生成 `regexp` 对象仅支持使用 `getRegExp` 函数。

```
getRegExp(pattern[, flags])
```

|   参数    | 描述                                                         |
| :-------: | ------------------------------------------------------------ |
| `pattern` | 正则表达式的内容（字符串）。                                 |
|  `flags`  | 修饰符。仅支持：`g` —— `global`， `i` —— `ignoreCase`， `m` —— `multiline`。 |

```js
getRegExp("x", "g"); //=> /x/g
```

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"RegExp"`。 |
|   `source`    | 请参考 `ES5` 标准       |
|   `global`    | 请参考 `ES5` 标准       |
| `ignoreCase`  | 请参考 `ES5` 标准       |
|  `multiline`  | 请参考 `ES5` 标准       |
|  `lastIndex`  | 请参考 `ES5` 标准       |

|     方     |   法   |
| :--------: | :----: |
|   `exec`   | `test` |
| `toString` |        |

```js
getRegExp().constructor; // "RegExp"
```

###### 类型判断

判断 `WXS` 的数据类型，主要有以下两种方式：

- `WXS` 将各个数据类型的 `constructor` 重写为返回对应类型的字符串。因此，可以使用 `constructor` 属性来进行判断。
- 当然，使用 `typeof`（与 `JS` 的行为一样）也可以来区分部分数据类型。

```js
var arr1 = [1, '', true, {}, function(){}, [], getDate(), getRegExp()],
	arr2 = [1, '', true, {}, function(){}, [], getDate(), getRegExp()];

arr1.map(function(item, index, arr) {
    arr[index] = item.constructor;
});

arr2.map(function(item, index, arr) {
    arr[index] = typeof item;
});

console.log(arr1); // ["Number", "String", "Boolean", "Object", "Function", "Array", "Date", "RegExp"]
console.log(arr2); // ["number", "string", "boolean", "object", "function", "object", "object", "object"]
```

##### 基础类库

###### `console`

| 方法  | 描述                                                         |
| :---: | :----------------------------------------------------------- |
| `log` | 用于在 `console` 窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。 |

###### `Math`

|    属     |   性    |
| :-------: | :-----: |
|    `E`    | `LN10`  |
|   `LN2`   | `LOG2E` |
| `LOG10E`  |  `PI`   |
| `SQRT1_2` | `SQRT2` |

|   方    |    法    |
| :-----: | :------: |
|  `abs`  |  `acos`  |
| `asin`  |  `atan`  |
| `atan2` |  `ceil`  |
|  `cos`  |  `exp`   |
| `floor` |  `log`   |
|  `max`  |  `min`   |
|  `pow`  | `random` |
| `round` |  `sin`   |
| `sqrt`  |  `tan`   |

```js
Math.E; // 2.718281828459045
```

###### `JSON`

|        方法         | 描述                                                   |
| :-----------------: | ------------------------------------------------------ |
| `stringify(object)` | 将 `object` 对象转换为 `JSON` 字符串，并返回该字符串。 |
|   `parse(string)`   | 将 `JSON` 字符串转化成对象，并返回该对象。             |

###### `Number`

|         属          |         性          |
| :-----------------: | :-----------------: |
|     `MAX_VALUE`     |     `MIN_VALUE`     |
| `NEGATIVE_INFINITY` | `POSITIVE_INFINITY` |

###### `Date`

|   方    |  法   |
| :-----: | :---: |
| `parse` | `UTC` |
|  `now`  |       |

###### `Global`

|     属      |     性     |
| :---------: | :--------: |
|    `NaN`    | `Infinity` |
| `undefined` |            |

|     方      |          法          |
| :---------: | :------------------: |
| `parseInt`  |     `parseFloat`     |
|   `isNaN`   |      `isFinite`      |
| `decodeURI` | `decodeURIComponent` |
| `encodeURI` | `encodeURIComponent` |

注释：实际上并没有 `Global` 对象，它在这里表示全局。也就是说，上述属性和方法都是全局可用的变量。



#### 事件系统



#### 双向绑定



#### 基础组件



#### 节点信息



#### 显示区域



#### 分栏模式



#### 动画



#### 初始渲染缓存





### 逻辑层



#### 注册程序



#### 注册页面



#### 页面生命周期



#### 页面路由



#### 模块化



#### `API`





### 场景值



### 框架接口





