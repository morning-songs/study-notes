# 单例模式

单例模式（`Singleton Pattern`）是最简单的设计模式之一。属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有唯一一个实例被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。

简单来说，单例模式就是保证一个类只会创建一个实例，且该类全局可访问。

**注意：**

- 单例类只能有一个实例。
- 单例类必须自己创建自己的唯一实例。
- 单例类必须给所有其他对象提供这一实例。



### 介绍

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**应用实例：**

- 一个班级只有一个班主任。
- `Windows` 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：**

- 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

- 要求生产唯一序列号。
- `WEB` 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- 复用性高的全局组件（如弹框、遮罩层等等），都可以用单例来缓存。
- 创建的一个对象需要消耗的资源过多，比如 `I/O` 与数据库的连接等。



### 实现

##### 简单实现

实现单例模式的基本思路如下：

```js
let instance = null;

class SingletonClass {
    constructor() {
        if (instance) return instance;
        instance = this;
    }
}

let singleton1 = new SingletonClass();
let singleton2 = new SingletonClass();

console.log(singleton1 === singleton2); // true
```

##### 闭包封装

简单单例模式，存在的问题在于 `instance` 并不安全，且造成了全局污染。因此，应该将其封装起来，这可以使用闭包来实现。

```js
const SingletonClass = (() => {
    let instance = null;
    return class {
        constructor() {
            if (instance) return instance;
            instance = this;
        }
    }
})();

let singleton1 = new SingletonClass();
let singleton2 = new SingletonClass();

console.log(singleton1 === singleton2); // true
```

使用闭包封装的关键是借助立即执行函数，而这正是它的一个缺点 —— 无论是否需要，都总是会立即执行，造成一些性能浪费。

##### 代理封装

代理封装只是闭包封装的变式，即：将类单独提取到外面，用来代理闭包函数的创建请求（使接口职责单一）。

```js
class SingletonPerson {
    constructor(name) {
        this.name = name;
    }
    sayName() {
        console.log(this.name);
    }
}

const createSingletonPerson = (() => {
    let instance = null;
    return (name) => {
        return instance || (instance = new SingletonPerson(name));
    }
})();
```

##### 惰性封装

更理想的情形是按需执行，而这就是惰性封装。

首先，定义一个单例模式的工厂函数，用于创建实现了生成单例对象的函数（可称为：单例函数）。

```js
const SingletonFunctionFactory = function (fn) {
    let instance = null;
    return function() {
        return instance || (instance = fn());
    }
}
```

然后，定义创建相应对象的工厂函数（这个函数只是一个普通的构造工厂，它不用于创建单例对象）。例如，用于创建登录框。

```js
const LoginDialogFactory = function () {
    const loginDialog = document.createElement("div");
    // 元素增强...
    document.body.appendChild(loginDialog);
    return loginDialog;
}
```

接着，将普通的对象工厂函数传给单例模式工厂函数以创建相应的单例函数（它实现了单例模式，只会创建一个实例）。

```js
const createSingletonLoginDialog = SingletonFunctionFactory(LoginDialogFactory);
```

最后，即可在任何地方任意使用这个单例函数。例如，将其应用到事件处理程序中，以避免每次触发都创建新的对象。

```js
element.onclick = function () {
    let loginDialog = createSingletonLoginDialog();
}
```

##### 静态封装

静态封装纯属个人探索，目前并不提倡使用。

借助 `ES6+` 的新特性，可以将原先暴露在全局的 `instance` 变量直接封装为私有的静态字段。

```js
class SingletonClass {
    static #instance = null;
    constructor() {
        return this.constructor.#instance || (this.constructor.#instance = this);
    }
}

let singleton1 = new SingletonClass();
let singleton2 = new SingletonClass();

console.log(singleton1 === singleton2); // true
```

静态封装也可以实现惰性封装的功能。例如，可以像下面这样改写上面的这个例子（但这样会造成代码臃肿，不易复用）。

```js
const SingletonLoginDialog = class {
    static #instance = null;
    static #fn = LoginDialogFactory; // 可将LoginDialogFactory定义到内部
    constructor() {
        return SingletonLoginDialog.#instance || 
            	(SingletonLoginDialog.#instance = SingletonLoginDialog.#fn());
    }
}

element.onclick = function () {
    let loginDialog = new SingletonLoginDialog();
}
```

优化，使其继承自一个基类，但这样会造成私密性不够好，容易被外部篡改。

```js
class Singleton {
    constructor() {
        return this.constructor.instance || (this.constructor.instance = this.constructor.fn());
    }
}

class SingletonLoginDialog extends Singleton {
    static instance = null;
    static fn = LoginDialogFactory;
    constructor() {
        return super();
    }
}

element.onclick = function () {
    let loginDialog = new SingletonLoginDialog();
}
```

进一步优化，提取抽象。如果想要更改单例传入新的函数即可，如果不想更改则不用传（使用起来不如惰性封装的简便）。

```js
class SingletonInstance {
    constructor(fn) {
        return typeof fn === "function" ? this.constructor.instance = fn() : this.constructor.instance;
    }
}

function createSingletonInstance(SingletonClass, instanceFactory) {
    return () => {
        return SingletonClass.instance || new SingletonClass(instanceFactory);
    }
}

class SingletonLoginDialog extends SingletonInstance {
    static instance = null;
    constructor(fn) {
        return super(fn);
    }
}

let createSingletonLoginDialog = createSingletonInstance(SingletonLoginDialog, LoginDialogFactory);

element.onclick = function () {
    let loginDialog = createSingletonLoginDialog();
}
```

注意，单例类只会创建一个实例。因此，使用同一个单例类同时创建实例（即使工厂函数不同），只会生效第一个。

```js
let createSingletonLoginDialog = createSingletonInstance(SingletonLoginDialog, LoginDialogFactory);
let createSingletonLoginDialog1 = createSingletonInstance(SingletonLoginDialog, LoginDialogFactory1);

element.onclick = function () {
    let loginDialog = createSingletonLoginDialog(); 	// 生效（有创建，创建新的）
    let loginDialog1 = createSingletonLoginDialog1(); 	// 无效（无创建，返回旧的）
}
```

此时，只需要将它们分开，单独使用其中一个即可。

```js
element.onclick = function () {
    let loginDialog1 = createSingletonLoginDialog1();
}

element1.onclick = function () {
    let loginDialog1 = createSingletonLoginDialog1();
}
```

也可以直接覆盖原先的单例创建方法，从而使旧的方法失效。

```js
// 重写单例创建方法，传入新的工厂函数，以更新类的单例。
createSingletonLoginDialog = createSingletonInstance(SingletonLoginDialog, LoginDialogFactory1);
```

##### 静态闭包

可以考虑使用静态的 `getter` 和 `setter` 来实现。

```js
class SingletonFunctionClass {
    static #instance = null;
    static get instance() {
        return this.#instance;
    }
    static set instance(instance) {
        this.#instance = instance;
    }
    static createSingletonFunction(fn) {
        return () => {
            return this.instance || (this.instance = fn());
        }
    }
}

let createSingletonLoginDialog1 = SingletonFunctionClass.createSingletonFunction(() => {
    return { a: 1 }
});
let createSingletonLoginDialog2 = SingletonFunctionClass.createSingletonFunction(() => {
    return { a: 2 }
});

console.log(createSingletonLoginDialog1() === createSingletonLoginDialog1()); // true
console.log(createSingletonLoginDialog2() === createSingletonLoginDialog2()); // true
```

这里完全可以去掉 `getter` 和 `setter`，做进一步优化。于是，成为了惰性封装的一种变式。

```js
class SingletonFunctionClass {
    static #instance = null;
    static createSingletonFunction(fn) {
        return () => {
            return this.#instance || (this.#instance = fn());
        }
    }
}

let createSingletonLoginDialog1 = SingletonFunctionClass.createSingletonFunction(() => {
    return {a: 1};
});
let createSingletonLoginDialog2 = SingletonFunctionClass.createSingletonFunction(() => {
    return {a: 2};
});

console.log(createSingletonLoginDialog1() === createSingletonLoginDialog1()); // true
console.log(createSingletonLoginDialog2() === createSingletonLoginDialog2()); // true
```

为了使封闭性更好，可以像下面这样进行优化。

```js
class SingletonFunctionClass {
    static #instance = null;
    static #createSingletonFunction(fn) {
        return () => {
            return this.#instance || (this.#instance = fn());
        }
    }
    constructor(fn) {
        return this.constructor.#createSingletonFunction(fn);
    }
}

let createSingletonLoginDialog1 = new SingletonFunctionClass(() => {
    return { a: 1 };
});
let createSingletonLoginDialog2 = new SingletonFunctionClass(() => {
    return { a: 2 };
});

console.log(createSingletonLoginDialog1() === createSingletonLoginDialog1()); // true
console.log(createSingletonLoginDialog2() === createSingletonLoginDialog2()); // true
```

无论是静态封装还是静态闭包，都不如直接使用惰性封装更简便高效，这里仅作演示用。

