# 脚本与文档模式

### 脚本

背景：

​		将`JavaScript` 引入网页，首先要解决它与网页的主导语言 `HTML` 的关系问题。在 `JavaScript` 早期，网景公司的工作人员希望在将 `JavaScript` 引入 `HTML` 页面的同时，不会导致页面在其他浏览器中渲染出问题。

原则：仅将 `JavaScript` 作为脚本文件引入到页面中使用，而不能被渲染到页面中。



##### 脚本元素

目前，将 `JavaScript` 插入 `HTML` 的主要方法是使用`<script>`元素。

这个元素是由网景公司创造出来，并最早在 `Netscape Navigator 2` 中实现的。后来，这个元素被正式加入到 `HTML` 规范。

`<script>`元素有下列 8 个属性：

- `src`：外部文件的请求地址。
- `async`：立即开启异步线程下载外部脚本文件，下载完毕立即异步执行，不会阻塞页面的其他动作。
- `defer`：立即异步下载外部脚本文件，但延迟到文档完全被解析并显示后再异步执行。
- `crossorigin`：跨域设置，默认不允许在文件内跨域请求。`anonymous`无凭据标识；`use-credentials`有凭据标识。
- `integrity`：验证签名，比对接收资源的签名与该属性指定的签名是否匹配，以确保内容分发网络不会提供恶意内容。
- `charset`：指定代码使用的字符集，通常为`utf-8`，但大多数浏览器并不会在乎`charset`自定义的值。
- `language`：废弃，表示在代码块中所使用的脚本语言，如：`"JavaScript"`、`"JavaScript 1.2" `或 `"VBScript"`。
- `type`：表示代码块中脚本语言的内容类型（`MIME`），指定类型可能导致代码被忽略。为`module`值表示是`ES6`模块。

注释：只有在`<script type="module">`中，才能完全使用`ES6`的语法，包括`import`和`export`关键字。

使用`script`的方式：直接嵌入代码，或者`src`引入外部文件。

注意：

- 在使用行内代码时，代码中不能出现字符串的`"</script>"`结束标签，要使用必须转义为`"<\/script>"`。
- 浏览器解析行内脚本的方式决定了它在看到字符串`"</script>"`时，会将其当成结束的`</script>`标签。



##### 外部文件

在`<script>`元素上，可通过`src`属性引入外部的文件，通常是以 `".js"` 结尾的  `JavaScript` 文件。

注意：

- 按照惯例，外部 `JavaScript` 文件的扩展名是`.js`。但这不是必需的，因为浏览器不会检查所包含 `JavaScript` 文件的扩展名。
- 这就为在服务器端使用脚本语言动态生成 `JavaScript` 代码，或者在浏览器中将 `JavaScript`扩展语言转译为`JavaScript`提供了可能性。【`JS`的扩展语言：如`TypeScript`，或`React`的 `JSX`】
- 不过要注意，服务器经常会根据文件的扩展名来确定响应的正确 `MIME` 类型。
- 如果不打算使用`.js` 扩展名，一定要确保服务器能返回正确的 `MIME` 类型。
- 另外在设置了`src`的`script`元素之间嵌入代码，会被全部忽略。



##### 跨域请求

`HTML`元素的`href，src`等值为`url`的属性，在请求资源时不受同源限制，如：`<script>，<img>，<a>`元素。

浏览器在解析资源时，会向 `src` 属性指定的路径发送一个 `GET` 请求，以取得相应资源。`<script>`会假定它是一个 `JavaScript` 文件。

这个初始的请求不受浏览器同源策略限制，但返回并被执行的 `JavaScript` 代码则受浏览器限制。

当然，这个请求仍然受父页面 `HTTP/HTTPS` 协议的限制。

分发 `JavaScript`：

- 来自外部域的代码会被当成加载页面的一部分来加载和解释，这个能力让我们可以不同的域分发`JavaScript`。
- 一定要确保该域是一个可信的来源，防止分发恶意代码。`<script>`标签的 `integrity` 属性正是防范这种问题的一个武器。



##### 执行顺序

浏览器会按照`<script>`在页面中出现的顺序依次解释其中的代码，使用 `defer` 和 `async` 属性加载的除外。

注释：

- 下一个`<script>`元素的代码必须在上一个`<script>`元素的代码解释完毕之后才能开始解释和执行。
- 所有的<`script`>元素共享一个全局作用域，使用`let`或`const`重复声明变量会报错。
- 但是，上一个`<script>`报错不会影响到下一个`<script>`的执行。



##### 元素位置

过去，所有`<script>`元素都被放在页面的`<head>`标签内。

然而，页面在浏览器解析到`<body>`的起始标签时开始渲染，加载期间会造成页面长期空白。

现代 `Web` 应用程序将`<script>`紧放在`</body>`结束标签之前使用，使渲染完毕后再加载。



##### 延迟执行

`HTML 4.01` 为`<script>`元素定义了一个 `defer` 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。

`HTML5` 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在 `DOMContentLoaded` 事件之前执行。

不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 `DOMContentLoaded`事件之前执行，因此最好只包含一个这样的脚本。



##### 异步执行

`HTML5` 为`<script>`元素定义了 `async` 属性。

浏览器会立即开始下载，但会在下载后立即异步执行，因此不保证能按照它们书写的次序执行。

注意：

- 异步执行脚本不能按照既定顺序执行，`async`脚本文件之间不能具有依赖性，也不应该修改`DOM`。
- `async`脚本保证会在页面的 `load` 事件前执行，但可能会在 `DOMContentLoaded`之前或之后。
- 在`async`脚本中，禁止使用`document.write`方法，会导致页面出错。
- 不过，好的 `Web` 开发实践根本就不推荐使用`document.write`方法。

 

##### 动态加载脚本

在合适的时机，通过`createElement`方法创建`script`元素并插入到页面中，可以实现动态加载脚本。

默认情况下，以这种方式创建的`<script>`元素是以异步方式加载的，相当于添加了 `async` 属性。

不是所有浏览器都支持 `async` 属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载。

```js
let script = document.createElement('script'); 
script.src = 'gibberish.js'; 
script.async = false; 
document.head.appendChild(script);
```

以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。

根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。

要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：

`<link rel="preload" href="gibberish.js">` 



##### 轻量独立脚本

在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。

在 `SPDY/HTTP2` 中，预请求的消耗已显著降低，以轻量、独立 `JavaScript` 组件形式向客户端送达脚本更具优势。

从浏览器角度看，通过 `SPDY/HTTP2` 获取所有这些独立的资源与获取一个大 `JavaScript` 文件的延迟差不多。

建议：将应用程序切割成轻量可缓存的文件，有利于浏览器缓存外部文件，而避免请求大文件的性能消耗。

```html
<!-- 将大文件拆分为轻量独立的小文件 -->
<script src="component1.js"></script> 
<script src="component2.js"></script> 
<script src="component3.js"></script>
```



##### `<noscript>`元素

`<noscript>`元素，被用于给不支持 `JavaScript` 的浏览器提供替代提示内容。

虽然如今的浏览器已经 100%支持 `JavaScript`，但对于禁用 `JavaScript` 的浏览器来说，这个元素仍然有它的用处。

`<noscript>`元素内可以包含任何可以出现在`<body>`中的 `HTML` 元素，`<script>`除外。

当浏览器不支持脚本或者浏览器对脚本的支持被关闭时，包含在`<noscript>`中的内容就会被渲染。

```html
<body> 
	<noscript> 
 		<p>This page requires a JavaScript-enabled browser.</p> 
 	</noscript> 
</body>
```



小结：

- 要使用外部 `JavaScript` 文件，必须将 `src` 属性设置为文件的 `URL`。文件可以跟网页在同一台服务器上，也可以位于不同的域。

- 所有`<script>`元素会依照它们在网页中出现的次序被解释。
- 在不使用 `defer` 和 `async` 属性的情况下，包含在`<script>`元素中的代码必须严格按次序解释。

- 对不推迟执行的脚本，浏览器必须解释完位于`<script>`元素中的代码，然后才能继续渲染页面的剩余部分。
- 为此，通常应该把`<script>`元素放到页面的末尾，介于主内容之后及`</body>`结束标签之前。

- 可以使用 `defer` 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。

<hr>

### 文档模式

`IE5.5` 发明了文档模式的概念，即可以使用 `doctype` 切换文档模式。

最初的文档模式有两种：混杂模式（`quirks mode`）和标准模式（`standards mode`）。

虽然这两种模式的主要区别，只体现在通过 `CSS` 渲染的内容方面，但对 `JavaScript` 也有一些关联影响，或称为副作用。

随着浏览器的普遍实现，又出现了第三种文档模式：准标准模式（`almost standards mode`）。

准标准模式没有标准规定得那么严格，主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。



##### 混杂模式

混杂模式在所有浏览器中都以省略文档开头的 `doctype` 声明作为开关。

但这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大。



##### 标准模式

标准模式通过下列几种文档类型声明开启：

```js
<!-- HTML 4.01 Strict --> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> 

<!-- HTML5 --> 
<!DOCTYPE html>
```



##### 准标准模式

准标准模式通过过渡性文档类型（`Transitional`）和框架集文档类型（`Frameset`）来触发：【在版本号后使用关键字开启】

```js
<!-- HTML 4.01 Transitional --> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<!-- HTML 4.01 Frameset --> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"> 
```

准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。

而对文档模式的检测也不会区分它们。因此，标准模式，指的就是除混杂模式以外的模式。

