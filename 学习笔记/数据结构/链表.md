# 链表

当在数组中插入和删除元素时，会导致其后的所有元素重新排序。如果不希望引起后续的元素重排序，则可以使用链表。因为链表不是以数字排序的，它没有顺序上的连续性，而是通过一个个结点链接而成的。每个结点都可通过一个关系（即：指针）指向下一个结点。



### 定义

链表（`linked list`）是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749?fromModule=lemma_inlink)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782?fromModule=lemma_inlink)，[数据元素](https://baike.baidu.com/item/数据元素/715313?fromModule=lemma_inlink)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素?fromModule=lemma_inlink)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域。 相比于[线性表](https://baike.baidu.com/item/线性表/3228081?fromModule=lemma_inlink)[顺序结构](https://baike.baidu.com/item/顺序结构/9845234?fromModule=lemma_inlink)，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到 `O(1)` 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 `O(n)` 的时间，而线性表和顺序表相应的时间复杂度分别是 `O(logn)` 和 `O(1)`。

使用链表结构可以克服[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)随机读取的优点，同时链表由于增加了结点的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域，空间开销比较大。链表最明显的好处就是，常规[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)排列关联项目的方式可能不同于这些数据项目在[记忆体](https://baike.baidu.com/item/记忆体/3029693?fromModule=lemma_inlink)或[磁盘](https://baike.baidu.com/item/磁盘/2842227?fromModule=lemma_inlink)上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的[节点](https://baike.baidu.com/item/节点/865052?fromModule=lemma_inlink)，但是不允许[随机存取](https://baike.baidu.com/item/随机存取/4610937?fromModule=lemma_inlink)。链表有很多种不同的类型：[单向链表](https://baike.baidu.com/item/单向链表/8671935?fromModule=lemma_inlink)，[双向链表](https://baike.baidu.com/item/双向链表/2968731?fromModule=lemma_inlink)以及[循环链表](https://baike.baidu.com/item/循环链表/3228465?fromModule=lemma_inlink)。链表可以在多种编程语言中实现。像 `Lisp` 和 `Scheme` 这样的语言的内建[数据类型](https://baike.baidu.com/item/数据类型/10997964?fromModule=lemma_inlink)中就包含了链表的存取和操作。程序语言或[面向对象语言](https://baike.baidu.com/item/面向对象语言?fromModule=lemma_inlink)，如 `C`、`C++` 和 `Java` 依靠易变工具来生成链表。



### 实现

##### 单向链表

```js
const LinkedList = (function() {
    // 创建数据结点
    class DataNode {
        constructor(data) {
            this.data= data; 	// 当前结点的数据
            this.next = null; 	// 下一结点的数据
        }
    }
    // 链头
    const HEAD = Symbol("head");
    // 创建链表结构
    return class LinkedList {
        constructor() {
            this[HEAD] = null;
            this.size = 0;
        }
        // 添加结点
        append(data) {
            this.size++;
            // 根据数据，生成结点。
            const node = new DataNode(data); 
            let target = this[HEAD];
            // 无链头时，设置链头。
            if(!target) {
                return this[HEAD] = node; 
            }
            // 有链头时，寻找链尾。
            while(target.next) {
                target = target.next;
            }
            // 找到链尾，链接链尾。
            return target.next = node;
        }
        // 查找结点
        find(index) {
            let target = this[HEAD];
            while(target && index-- > 0) {
                target = target.next;
            }
            return target;
        }
        // 插入结点：在指定的位置上插入
        insert(index, data) {
            const node = new DataNode(data);
            let prevNode = null,
                nextNode = null;
            if(index < 1) {
                nextNode = this[HEAD];
                this[HEAD] = node;
            } else {
                prevNode = this.find(index - 1);
                if(!prevNode) return console.warn(index + " 已超出界限");
                nextNode = prevNode.next;
                prevNode.next = node;
            }
            node.next = nextNode;
            this.size++;
        }
        // 插入结点：在指定的结点后插入
        insertByData(oldData, newData) {
            const node = new DataNode(newData);
            let target = this[HEAD];
            while(target.data !== oldData) {
                target = target.next;
            }
            if(!target) return console.warn("链表中不存在指定的数据");
            let nextNode = target.next;
            target.next = node;
            node.next = nextNode;
            this.size++;
        }
        // 删除结点：在指定的位置上删除
        remove(index) {
            const prevNode = this.find(index - 1);
            if (!prevNode || !prevNode.next) return console.warn(index + " 已超出边界");
            if (index < 1) {
                this[HEAD] = this[HEAD].next;
            } else {
                prevNode.next = prevNode.next.next;
            }
            this.size--;
        }
        // 删除结点：在指定的结点处删除
        removeByData(data) {
            let target = this[HEAD];
            if(target.data === data) {
                this.size--;
                return this[HEAD] = target.next;
            }
            while(target.next) {
                if(target.next.data === data) {
                    this.size--;
                    return target.next = target.next.next;
                }
                target = target.next;
            }
        }
        // 打印链表
        print() {
            let target = this[HEAD];
            while(target) {
                console.log(target.data);
                target = target.next;
            }
        }
    }
})();
```









