# 策略模式

在策略模式（`Strategy Pattern`）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 `context` 对象。策略对象改变 `context` 对象的执行算法。

策略模式：基于同一个目的，根据不同的情况，采取不同的策略。



### 介绍

**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

**主要解决：**在有多种算法相似的情况下，使用 `if...else` 所带来的复杂和难以维护。

**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。

**如何解决：**将这些算法封装成一个一个的类，任意地替换。

**关键代码：**实现同一个接口。

**应用实例：** 

- 诸葛亮的锦囊妙计，每一个锦囊就是一个策略。
- 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。
- `JAVA AWT` 中的 `LayoutManager`。

**优点：** 

- 算法可以自由切换。
- 避免使用多重条件判断。
- 扩展性良好。

**缺点：** 

- 策略类会增多。
- 所有策略类都需要对外暴露。

**使用场景：** 

- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
- 一个系统需要动态地在几种算法中选择一种。
- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

**注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。



### 实现

#### 绩效考核

绩效考核，通常基于绩效等级和月薪来计算年终奖。

```js
function calBonus(level, salary) {
    if (level === "A") {
        return salary * 4;
    } 
    if(level === "B") {
        return salary * 3;
    }
    if (level === "C") {
        return salary * 2;
    }
    if (level === "D"){
        return salary * 1;
    }
}

console.log(calBonus("A", 30000));
console.log(calBonus("B", 30000));
console.log(calBonus("C", 30000));
console.log(calBonus("D", 30000));
```

##### 封装优化

策略模式，将算法（即策略）封装起来，使与其实现相分离。这样的好处是，算法的使用是不变的，而算法的实现可以有很多样。

实现策略模式的一般步骤为：

- 定义一组策略类（策略即算法）。
- 定义一个环境类（环境类接收用户请求，并将请求委托给某个策略类）。

```js
// 策略类
const Strategies = {
    S: salary => salary * 5,
    A: salary => salary * 3,
    B: salary => salary * 2,
    C: salary => salary * 1
}

// 环境类
const calBonus = function(level, salary) {
    return Strategies[level](salary);
}

// 使用
console.log(calBonus("S", 5000));
console.log(calBonus("A", 3000));
console.log(calBonus("B", 2000));
console.log(calBonus("C", 1000));
```

#### 表单校验

```html
<form id="regForm" method="post">
    <label for="username">用户名：<input type="text" id="username" placeholder="请输入用户名" /></label>
    <label for="password">密码：<input type="text" id="password" placeholder="请输入密码" /></label>
    <label for="telephone">手机号：<input type="text" id="telephone" placeholder="请输入手机号" /></label>
    <input type="submit" value="注册">
</form>
```

根据不同的控件，采取不同的校验策略。

```js
const regForm = document.forms["regForm"];

regForm.onsubmit = function() {
    const {username, password, telephone} = regForm;
    
    if(username.value === "") {
        console.log("用户名不能为空");
        return false;
    }
    if(password.value.length < 6) {
        console.log("密码长度不小于 6 位");
        return false;
    }
    if(!/(^1[3|5|7|8|9][0-9]{9}$)/.test(telephone.value)) {
        console.log("手机号码格式不正确");
        return false;
    }
}
```

##### 封装优化

首先，定义一个策略类。

```js
// 策略类
const Rules ={
    notEmpty: val => val.trim() !== "",
    longerThan3: val => val.length >= 3,
    longerThan6: val => val.length >= 6,
    telephone: val => /(^1[3|5|7|8|9][0-9]{9}$)/.test(val)
};
```

然后，定义一个环境类。如果要返回错误信息，则按照注释的步骤，依次修改代码即可。

```js
// 环境类
class Validator {
    constructor() {
        this.rules = []; // 策略列表
    }
    add(value, rules, errMsg) {
        const ruleList = this.rules;
        if(typeof rules === "function") {
            // 单条规则
            return ruleList.push({
                value,
                validator: rules,
                errMsg
            })
        }
        if(Array.isArray(rules)) {
            // 多条规则
            return rules.forEach((item) => {
                ruleList.push({
                    value,
                    validator: item.validator,
                    errMsg: item.errMsg
                })
            });
        }
    }
    start() {
        let rules = this.rules;
        for(const rule of rules) {
            const {value, validator, errMsg} = rule;
            if(!validator(value)) return console.warn(errMsg); // 1、可以选择返回错误信息
        }
        return "valid"; // 2、这里改为返回false值。
    }
}
```

接着，定义一个使用校验器的方法。

```js
function validate(username, password, telephone) {
    let validator = new Validator();
    
    validator.add(username, [
        {validator: Rules.notEmpty, errMsg: "用户名不能为空"},
        {validator: Rules.longerThan3, errMsg: "用户名不低于 3 位"}
    ]);
    
    validator.add(password, [
        {validator: Rules.notEmpty, errMsg: "密码不能为空"},
        {validator: Rules.longerThan6, errMsg: "密码不低于 6 位"}
    ]);
    
    validator.add(telephone, Rules.telephone, "手机号码格式不对");
    
    return validator.start() === "valid" ? true : false; // 3、这里直接返回调用结果
}
```

最后，提交时进行校验即可。

```js
regForm.onsubmit = function() {
    const {username, password, telephone} = regForm;
    return validate(username.value, password.value, telephone.value); // 4、校验失败，打印错误，阻止提交。
}
```

