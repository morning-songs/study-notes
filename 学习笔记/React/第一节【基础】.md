# `React`

### 基础

##### 基本概念

​		`React` 是一个用于构建用户界面的 `JavaScript` 库（通过 `js` 封装而成）。它主要用于构建 `UI`，因此很多人认为 `React` 是 `MVC` 中的 `V`（视图）。`React` 起源于 `Facebook` 的内部项目，用来架设 `Instagram` 的网站（该公司对市场上所有 `JavaScript MVC` 框架都不满意，于是决定自行开发一套，用于架设 `Instagram` 的网站），并于 2013 年 5 月开源。它拥有较高的性能，代码逻辑非常简单，广受开发者青睐。【`react`：反应】

##### 未来主流

​		由于`React` 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 `Web` 开发的主流工具。现在许多大型企业（如 `BAT`）或大型项目都是使用 `React` 来构建的。

​		这个项目本身也越滚越大，从最早的 `UI` 引擎变成了一整套前后端通吃的 `Web App` 解决方案。衍生的 [`React Native`](https://baike.baidu.com/item/React Native/20307162?fromModule=lemma_inlink) 项目，目标更是宏伟，希望用写 `Web App` 的方式去写 [`Native App`](https://baike.baidu.com/item/Native App/4491953?fromModule=lemma_inlink)。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 `UI` ，就能同时运行在服务器、浏览器和手机。

##### 框架用途

​		`React` 主要用于构建 [`UI`](https://baike.baidu.com/item/UI/393851?fromModule=lemma_inlink)。你可以在 `React` 里传递多种类型的参数，如声明代码，帮助你渲染出 `UI`、也可以是静态的 `HTML DOM` 元素、也可以传递动态变量、甚至是可交互的应用组件。

##### 框架特点

1. 声明式设计：`React` 使创建 **交互式 `UI`** 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 `React` 能高效更新并渲染合适的组件。`React` 采用声明范式，可以轻松描述应用。声明式设计，是指只需在 `React` 中声明和使用函数以及 `React` 提供的众多 `API`，即可完成交互式 `UI` 的设计，不需要接触真实的 `DOM` 和事件系统。
2. 组件化：构建管理自身状态的封装组件，然后对其组合以构成复杂的 `UI`。通过 `React` 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
3. 高效：`React` 通过对真实 `DOM` 的模拟（虚拟 `DOM` 和 `diff` 算法），最大限度地减少与真实 `DOM` 的交互，极大地提升了性能。
4. 灵活：`React` 可以与已知的库或框架很好地配合。无论你现在使用什么技术栈，在无需重写现有代码的前提下，都可以通过引入 `React` 来开发新功能。
5. `JSX`：`JSX` 是 `JavaScript` 语法的扩展。`React` 开发不一定使用 `JSX` ，但我们建议使用它。
6. 单向响应：`React` 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。
7. 严格模式：严格模式是 `React` 的一个特性。它能够捕获很多 `bug`，使得代码库更可预测。

##### 必备知识

​		学习 `React` 需要准备的知识：

- `ES6` 基础知识：字符串，数组 `API`，`class`，`this` 指向。其中，数组是重中之重。
- 包管理器：`npm`、`pnpm` 或 `yarn`，三者任一。更多参考：[`pnpm` 简介](https://blog.csdn.net/snowball_li/article/details/124787870)、[`pnpm` 教程](https://blog.csdn.net/shentian885/article/details/122237746?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-122237746-blog-124787870.pc_relevant_landingrelevant&spm=1001.2101.3001.4242.2&utm_relevant_index=4)。
- 数据交互：`Ajax`、`Axios` 或 `fetch`，三者任一。



### 使用

#### 安装

​		在页面中安装 `React`，只需使用 `script` 标签的 `src` 来引入 `React` 的基础库即可。

##### 远程引入

​		远程引入时需要为 `script` 标签添加 `crossorigin` 属性，通常需要引入如下的三个 `js` 文件：

- `react.development.js`： `React` 核心文件。
- `react-dom.development.js`：`React` 用来操作 `DOM` 的文件。
- `babel.min.js`：在 `React` 中会使用到 `jsx`，但是浏览器不支持 `jsx`，所以要使用 `babel` 将 `jsx` 编译为 `js`。

```html
<!-- 加载 React -->
<!-- 注意: 部署时，将 "development.js" 替换为 "production.min.js"。-->

<!-- CDN方式引入：react核心库 -->
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>

<!-- 引入react-dom库：用于操作DOM -->
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  
<!-- 引入JSX语法处理器 -->
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

​		引入网址：[引入 `React` 基础库](https://react.docschina.org/docs/add-react-to-a-website.html#step-2-add-the-script-tags)、[引入 `JSX` 预处理器](https://react.docschina.org/docs/add-react-to-a-website.html#quickly-try-jsx)。

##### 本地引入

​		远程加载有时会比较缓慢，于是可以将要远程引入的 `React` 相关文件下载到本地项目，然后本地引入（且无需 `crossorigin`）。

```diff
|- React
+	|-core
+		|- react.development.js
+		|- react-dom.development.js
+		|- babel.min.js
```

```html
<!-- 引入react核心库 -->
<script src="./core/react.development.js"></script>

<!-- 引入react-dom库：用于操作DOM -->
<script src="./core/react-dom.development.js"></script>

<!-- 引入JSX语法处理器 -->
<script src="./core/babel.min.js"></script>
```



#### 容器

##### 定义容器

​		与使用 `Vue` 一样，`React` 也需要一个容器元素，通常是 `<div>`。用于存放 `React` 的组件以及其他自定义的 `DOM` 内容。

​		根据需要，你可以在一个页面上放置多个独立的 `DOM` 容器。它们通常是空标签，`React` 会替换 `DOM` 容器内的任何已有内容。

```html
<!-- React 的容器元素：用于放置 React 的一切 DOM 内容 -->
<div id="root"></div>
```

##### 挂载容器

​		定义好 `React` 的根容器后，就可以使用 `ReactDOM`（由 `react-dom` 库提供）的 `createRoot()` 方法来挂载容器元素了。 

```js
// 传入页面上存在的真实DOM节点，通过该方法将react元素挂载到容器所在的位置。
let app = ReactDOM.createRoot(document.getElementById("root"));
```

​		`ReactDOM.createRoot` 方法返回 `ReactDOMRoot` 的一个实例，它是一个对应于入口元素的 `React` 应用。

```js
console.log(app); // ReactDOMRoot {_internalRoot: FiberRootNode}
```

##### 创建元素

​		调用 `React`（由 `react` 库提供）上的 `createElement()` 方法，可以创建 `React` 元素（虚拟 `DOM`）。可传递如下三个参数：

- `type`：字符串，用于指定元素的类型。即：标签名。如：`p`，`div` 等。该参数还可以是 `React` 组件类型。
- `props`：对象，用于指定元素的属性。
- `children`：字符串或数组，用于指定元素的子节点，可指定多个。

​		实际上，每个 `JSX` 元素都是调用 [`React.createElement()`](https://react.docschina.org/docs/react-api.html#createelement) 的语法糖。更多参考：[`React` 顶层 `APIs`](https://react.docschina.org/docs/react-api.html)。

```js
// 创建一个 React 的虚拟 DOM 元素
React.createElement(
    'p', 
    {
    	className: 'paragraph'
    }, 
    '这是一个由React创建的段落！'
);
```

##### 虚拟 `DOM`

​		`React.createElement()` 创建的是虚拟的 `DOM` 元素，虚拟 `DOM` 是真实 `DOM` 的映射。因为，虚拟 `DOM` 是将真实 `DOM` 映射成的**树型结构的 `js` 对象**，而这些 `js` 对象包含了对应的真实 `DOM` 的信息。【`virtual`：虚拟的】

```html
<ul id="list">
    <li class="item">item1</li>
    <li class="item">item2</li>
</ul>
```

​		将上面的真实 `DOM` 映射成虚拟 `DOM` 后，会成为如下所示的样子（为便于观看，调整了部分属性的顺序）。

```js
// 在React中的虚拟DOM
{
    type: "ul",
    props: {
        id: "list",
        children: [
            {
                type: "li",
                props: {className: 'item', children: 'item1'}
            },
            {
                type: "li",
                props: {className: 'item', children: 'item2'}
            }
		]
    }
}

// 在Vue2中的虚拟DOM
VNode {
    tag: "ul",
    data: {attrs: {id: 'list'}},
    children: [
        {
            tag: "li",
            data: {staticClass: 'item'},
        	children: [{text: 'item1'}]
        },
        {
            tag: "li",
            data: {staticClass: 'item'},
        	children: [{text: 'item2'}]
        }
    ]
}
```

​		下面打印一个虚拟 `DOM` 来看看里面具体都有什么内容。更多参考：[虚拟 `DOM` 到底是什么](https://blog.51cto.com/u_15492153/5277868)、[虚拟 `DOM(vnode)`](https://blog.csdn.net/yiyueqinghui/article/details/105468012)。

```react
let vp = React.createElement('p', {className: 'paragraph'}, '这是一个由React创建的段落！');

console.log(vp);
/*
{
	$$typeof: Symbol(react.element),
	key: null,
	props: {className: 'paragraph', children: '这是一个由React创建的段落！'},
	ref: null,
	type: "p",
	_owner: null,
	_store: {validated: false},
	_self: null,
	_source: null,
	[[Prototype]]: Object
}
*/
```

​		虚拟`DOM`本质上是一个普通的 `js` 对象（如上面的打印所示），通过对象来表示真实的 `DOM` 结构。虚拟 `DOM` 非常简洁轻量，它只保留了真实 `DOM` 的关键性信息。例如：其中的 `type` 用来描述标签，`props` 用来描述属性，`children` 用来表示嵌套的层级关系。

​		虚拟 `DOM` 的更新不会立即操作真实 `DOM`，而是会通过 `diff` 算法，找出需要更新的节点，按需更新，并将更新的内容保存为一个 `js` 对象，更新完成后再挂载到真实 `dom` 上，实现真实的 `dom` 更新。通过虚拟 `DOM`，解决了操作真实 `DOM` 的以下三个问题。

- 无差别频繁更新导致`DOM` 频繁更新，造成性能问题。
- 频繁回流与重绘。
- 开发体验。

​		另外，由于虚拟 `DOM` 实际上是普通的 `js` 对象，所以天然地具有**跨平台**的能力，而不是像真实 `DOM` 那样只局限于浏览器。

​		总结起来，虚拟 `DOM` 的优势有以下几点：

- 小修改无需频繁更新 `DOM`，框架的 `diff` 算法会自动比较，分析出需要更新的节点，按需更新。
- 更新数据不会造成频繁的回流与重绘。
- 表达力更强，数据更新更加方便。
- 保存的是 `js` 对象，具备跨平台能力。

​		虚拟 `DOM` 同样也有缺点，首次渲染大量 `DOM` 时，由于多了一层虚拟 `DOM` 的计算，因此会比 `innerHTML` 插入慢。

​		真实 `DOM` 与虚拟 `DOM` 的区别：

- 虚拟 `DOM` 简洁轻量，它只保留真实 `DOM` 的关键性信息。真实 `DOM` 拥有众多丰富的内容，但很多内容往往都用不到。
- 由此可见，使用虚拟 `DOM` 参与运算比使用真实 `DOM` 显然会更快。
- 参与运算时使用的是虚拟 `DOM`，只有最终渲染到页面上时才会转为真实 `DOM`，因为只有真实 `DOM` 才能被渲染到页面上。

​		更多参考：[深入理解虚拟 `DOM` 与 `Diff` 算法](https://baijiahao.baidu.com/s?id=1719635258375915850&wfr=spider&for=pc) 

##### 渲染元素

​		容纳 `React` 元素的容器已准备好，此时可以调用 `ReactDOM.createRoot()` 的返回值 `app` 上的 `render()` 方法来在容器中创建并渲染指定的元素了。

```js
// 将React的虚拟DOM渲染成真实DOM
app.render(React.createElement(
    'p', 
    {
    	className: 'paragraph'
    }, 
    '这是一个由 React 创建的段落！'
));
```

​		渲染后，最终成为下面的样子。

```html
<p class="paragraph">这是一个由 React 创建的段落！</p>
```



#### `JSX`

##### 基本认识

​		`React` 使用一种名为 `JavaScript XML`（即 `JSX`）的特殊语法。 借助 `JSX`，你可将 `XML`（或创建的自定义组件）与 `JS` 集成到一个文件中，甚至可以集成到单个代码行中。 通过使用 `JSX`，你可以借助 `XML` 语法来实现 `UI` 设计，然后依赖 `JavaScript` 语法来实现交互逻辑。另外，`Visual Studio Code` 为 `JSX` 文件提供了 `IntelliSense` 功能，使用 `React` 时此工具会非常有用。

> ​		`JSX` 依赖于可扩展标记语言（`XML`）。 `XML` 的语法类似于 `HTML`。 许多情况下，你可能都不会注意到二者之间的细微差异。 然而，`XML` 对语法有几点重要的限制：
>
> - 所有元素都必须放置在一个父元素内。
> - 必须结束所有元素。

​		`React` 使用 `JSX` 来替代常规的 `JavaScript`。`JSX` 是一个看起来很像 `XML` 的 `JavaScript` 语法扩展。我们不需要一定使用 `JSX`，但它有以下优点：

- `JSX` 执行更快，因为它在编译为 `JavaScript` 代码后进行了优化。
- 它是类型安全的，在编译过程中就能发现错误。
- 使用 `JSX` 编写模板更加简单快速。

​		更多参考：[`React JSX` 简介](https://react.docschina.org/docs/introducing-jsx.html) 

##### 初步体验

​		在页面中引入转换 `JSX` 语法的 `babel` 工具之后，就可以直接在 `script` 标签中使用 `JSX` 语法了。但前提是，必须要引入 `react` 核心包，而且要为 `script` 标签添加 `type` 属性，并设其值为 `"text/babel"`。没有设置该属性和值的 `script` 标签只能使用浏览器默认支持的 `JS` 语法。

```react
<script type="text/babel">
	// 这里可以直接使用 JSX 语法了。
	let vdiv = <div>这是使用 JSX 语法创建的 React 元素！</div>;
</script>
```

​		这种看起来可能有些奇怪的标签语法，既不是字符串也不是 `HTML`。它被称为 `JSX`，是一种 `JavaScript` 的语法扩展。 我们推荐在 `React` 中使用 `JSX` 来描述用户界面。`JSX` 是在 `JavaScript` 内部实现的。

​		我们知道元素是构成 `React` 应用的最小单位，而 `JSX` 就是用来声明 `React` 当中的元素的。与浏览器的 `DOM` 元素不同，`React` 当中的元素事实上是普通的 `js` 对象（即虚拟 `DOM`），`React DOM` 可以确保浏览器 `DOM` 的数据内容与 `React` 元素保持一致。我们通过把 `React` 元素传递给 `ReactDOMRoot ` 实例的 `render()` 方法，来将它们渲染到页面上的指定容器中：

```react
<script type="text/babel">
    // ReactDOM.render在React18中已经不再被支持了！
	app.render(<div>这是使用 JSX 语法创建的 React 元素！</div>);
</script>
```

​		注意：由于 `JSX` 就是 `JavaScript`，一些标识符像 `class` 和 `for` 等 `JS` 关键字和保留字不建议作为 `XML` 的属性名。因此，`React DOM` 使用 `className` 和 `htmlFor` 等来作为替代。但是 `React` 并不识别 `classList` 属性，它只支持 `className` 属性。

```react
<script type="text/babel">
    let vnode = <div className="box box1"></div>;
    app.render(vnode);
</script>

<!-- 渲染到页面后 -->
<div class="box box1"></div>
```

##### 语法规则

​		在 `js` 环境中使用 `JSX` 语法，需要遵守以下几点规则：

1. `XML` 语法：使用 `XML` 语法定义虚拟 `DOM` 元素，但禁止使用任何引号将其包裹为字符串。
2. 多行定义：支持定义多行虚拟 `DOM`，但只能有一个根元素，所有 `React` 元素都必须被包含其中。
3. 代码隔离：始终建议使用一对小括号来将 `JSX` 代码与其他代码进行隔离，以避免没必要的 `Bug`。
4. 元素闭合：定义的所有虚拟 `DOM` 元素都必须闭合。如：`<img />`，`<hr />` 和 `<input />` 等。
5. 嵌入 `JS`：定义虚拟 `DOM` 元素时，可在任意位置使用一对单花括号 `{}` 来嵌入任何 `js` 表达式。
6. 驼峰命名：在 `JS` 中，通常使用对象来定义元素样式。元素的属性和样式名均采用小驼峰写法。
7. 属性替代：与 `JS` 关键字或保留字冲突的元素属性都会被替代。如将 `class` 换成 `className`。
8. 支持 `Emmet`：支持使用 `Emmet` 插件及其提供的语法，来快速生成 `HTML` 代码。更多参考：[`Emmet` 快速生成 `HTML` 代码](https://www.cnblogs.com/beileixinqing/p/16383085.html)。
9. 添加注释：如果在定义虚拟 `DOM` 时需要使用注释，则要使用 `{/* 注释内容 */}` 的格式来注入。
10. 事件名称：`React` 对原生事件进行了封装，封装后的事件可跨浏览器使用，但采用小驼峰写法。
11. 展开数组：`JSX` 允许在定义虚拟 `DOM` 的 `{}` 中插入数组，数组成员会被自动展开并渲染到页面。
12. 省略单位：定义虚拟 `DOM` 元素的样式值时，可以省略单位而直接使用数字。渲染时会自动补全。

```jsx
// 声明页面的初始数据
let title = 'H1标题',
	fontSize = 16; // 默认采用px单位，最后渲染时会自动补上单位。由于数字更便于计算，因此通常都省略单位。

let vnode = (
    <div className="box">
        {/* 注释内容：练习JSX语法 */}
        <h1>{title}</h1>
        <p style={{ color: 'red', fontSize }}>段落元素</p>
        <form>
            输入框：<input type="text" defaultValue="请输入内容……" />
            <button type="button" onClick={() => console.log('触发click事件')}>点击</button>
        </form>
    </div>
);
```

​		注意，此处将 `input` 元素的 `value` 属性替换为 `defaultValue`。因为，当我们给一个没有设置 `onChange` 处理程序的表单字段设置 `value` 属性时，该字段将会成为一个只读字段。然后 `react-dom` 工具会发出警告：如果字段应该是可变的，使用 `'defaultValue'` 属性。否则，应为其设置 `'onChange'` 或 `'readOnly'`。

​		上述 `JSX` 代码定义的 `React` 虚拟 `DOM` 在被渲染到页面后，会变成下面的样子。

```html
<div class="box">
    <h1>H1标题</h1>
    <p style="color: red; font-size: 16px;">段落元素</p>
    <form>
        "输入框："
    	<input type="text" value="请输入内容……">
        <button type="button">点击</button>
    </form>
</div>
```

##### 封装模块

​		可以将 `React JSX` 代码封装到一个 `js` 文件中，然后直接在页面中引入它即可，当然也需要设置 `type` 属性。

```jsx
// 在 helloworld_react.js 文件中
let app = ReactDOM.createRoot(document.getElementById("root"));

let vnode = <h1 className="hw">Hello World!</h1>;

app.render(vnode);
```

```react
<script type="text/babel" scr="helloworld_react.js"></script>
```

##### 遍历数组

​		`JSX` 允许在模板（即：定义虚拟 `DOM` 时所用的 `{}`）中直接使用数组，数组中的所有元素会被自动遍历并且渲染到页面上。

```jsx
let arr = ["剑魔", "锐雯", "青钢影", "纳尔"];

let vnode = (<div>{arr}</div>); // 完全等同于：(<div>{arr.map(item => item)}</div>);
```

​		渲染后

```html
<div>
    "剑魔"
    "锐雯"
    "青钢影"
    "纳尔"
</div>
```

​		由于具备了这个能力，所以数组是 `React` 的重中之重。但 `JSX` 只遍历和渲染数组的元素，并不能修改数组数据。要修改数组元素，则要使用更为高级的数组 `API`，如：`map` 和 `flutter` 等。

​		借助 `JSX` 赋予数组的这个特殊能力，就可以实现 `React` 的列表渲染，但要注意设置 `key` 标识属性。

```jsx
let vnode = (
	<ul>{
		arr.map((item, index) => {
            return <li key={index}>{item}</li>;
        })
	}</ul>
);
```

​		注意：虽然 `JSX` 能够自动展开并渲染数组的元素，但并没有赋予数组响应式的功能。因此，通过原生 `JS` 修改数组，即使数据改变了，也不会触发视图上的更新。

