# 树

**树**是一种[数据结构](https://baike.baidu.com/item/数据结构/1450?fromModule=lemma_inlink)，它是由 *`n (n ≥ 0)`* 个有限节点组成一个具有层次关系的[集合](https://baike.baidu.com/item/集合/2908117?fromModule=lemma_inlink)。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树。

树的种类：

- 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树，也称为自由树；
- [有序树](https://baike.baidu.com/item/有序树?fromModule=lemma_inlink)：树中任意节点的子结点之间有顺序关系，这种树称为有序树；
- [二叉树](https://baike.baidu.com/item/二叉树/1602879?fromModule=lemma_inlink)：每个节点最多含有两个子树的树称为二叉树；
- [满二叉树](https://baike.baidu.com/item/满二叉树?fromModule=lemma_inlink)：叶节点除外的所有节点均含有两个子树的树被称为满二叉树；
- [完全二叉树](https://baike.baidu.com/item/完全二叉树?fromModule=lemma_inlink)：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树；
- [哈夫曼树](https://baike.baidu.com/item/哈夫曼树/2305769?fromModule=lemma_inlink)（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。

结点的种类：

- 内部节点：有子节点的结点，被称为内部结点。
- 外部结点：无子节点的结点，被称为外部结点或叶结点。

树的层次，被称为树的深度。例如，一颗树有 3 层结构，则其深度为 3。

树的遍历表达法有 4 种方法：[先序遍历](https://baike.baidu.com/item/先序遍历/6442839?fromModule=lemma_inlink)、[中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)、[后序遍历](https://baike.baidu.com/item/后序遍历/1214806?fromModule=lemma_inlink)、层次遍历。

​										<img src="images/%E6%A0%91/image-20230524211720843.png" alt="image-20230524211720843" style="zoom:80%;" /> 

- [先序遍历](https://baike.baidu.com/item/先序遍历/6442839?fromModule=lemma_inlink)（又称先根遍历）：为 `ABDECF`（根 ==> 左 ==> 右）

- [中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)（又称中根遍历）：为 `DBEAFC`（左 ==> 根 ==> 右）（仅二叉树有[中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)）
- [后序遍历](https://baike.baidu.com/item/后序遍历/1214806?fromModule=lemma_inlink)（又称后根遍历）：为 `DEBFCA`（左 ==> 右 ==> 根）
- 层次遍历：为 `ABCDEF`（同[广度优先搜索](https://baike.baidu.com/item/广度优先搜索/2148012?fromModule=lemma_inlink)）



### 实现

#### 二叉搜索树

##### 简单实现

二叉搜索树，将比当前结点数据小的数据存在左边的子节点中，将大于或等于当前结点数据的数据存在右边的子节点中。

在往二叉搜索树中插入新的结点时，每次都要先从根节点开始，依次跟其下的每个节点进行比较以确定该新节点的去向。

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
    }
})();
```

使用

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);
```

二叉搜索树，将所有比根节点小的数据放到左边，所有比根节点大的数据放到右边。

##### 遍历方式

###### 中序遍历

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 中序遍历：左根右
    function middleorderTraversalNode(root, arr) {
        if (!root) return;
        // 左
        middleorderTraversalNode(root.left, arr);
        // 根
        arr.push(root.data);
        // 右
        middleorderTraversalNode(root.right, arr);
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        middleorderTraversalNode() {
            const arr = [];
            middleorderTraversalNode(this.root, arr);
            return arr;
        }
    }
})();
```

中序遍历，实现了对数据的升序读取。

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);

bst.middleorderTraversalNode(); // [0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9]
```

###### 先序遍历

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 先序遍历：根左右
    function preorderTraversalNode(root, arr) {
        if (!root) return;
        // 根
        arr.push(root.data);
        // 左
        preorderTraversalNode(root.left, arr);
        // 右
        preorderTraversalNode(root.right, arr);
    }
    
    // 中序遍历：左根右
    function middleorderTraversalNode(root, arr) {
        if (!root) return;
        // 左
        middleorderTraversalNode(root.left, arr);
        // 根
        arr.push(root.data);
        // 右
        middleorderTraversalNode(root.right, arr);
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        preorderTraversalNode() {
            const arr = [];
            preorderTraversalNode(this.root, arr);
            return arr;
        }
        middleorderTraversalNode() {
            const arr = [];
            middleorderTraversalNode(this.root, arr);
            return arr;
        }
    }
})();
```

使用

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);

console.log(bst.preorderTraversalNode()); // [5, 2, 1, 0, 3, 4, 6, 5, 7, 8, 9]
```

###### 后序遍历

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 先序遍历：根左右
    function preorderTraversalNode(root, arr) {
        if (!root) return;
        // 根
        arr.push(root.data);
        // 左
        preorderTraversalNode(root.left, arr);
        // 右
        preorderTraversalNode(root.right, arr);
    }
    
    // 中序遍历：左根右
    function middleorderTraversalNode(root, arr) {
        if (!root) return;
        // 左
        middleorderTraversalNode(root.left, arr);
        // 根
        arr.push(root.data);
        // 右
        middleorderTraversalNode(root.right, arr);
    }
    
    // 后序遍历：左右根
    function postorderTraversalNode(root, arr) {
        if (!root) return;
        // 左
        postorderTraversalNode(root.left, arr);
        // 右
        postorderTraversalNode(root.right, arr);
        // 根
        arr.push(root.data);
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        preorderTraversalNode() {
            const arr = [];
            preorderTraversalNode(this.root, arr);
            return arr;
        }
        middleorderTraversalNode() {
            const arr = [];
            middleorderTraversalNode(this.root, arr);
            return arr;
        }
        postorderTraversalNode() {
            const arr = [];
            postorderTraversalNode(this.root, arr);
            return arr;
        }
    }
})();
```

使用

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);

console.log(bst.postorderTraversalNode()); // [0, 1, 4, 3, 2, 5, 9, 8, 7, 6, 5]
```

##### 查询删除

###### 查询结点

查询结点，就是确定包含指定数据的结点是否存在。

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 包含指定数据的结点是否存在
    function hasData(node, data) {
        if (!node) return false;
        if (node.data === data) return true;
        node = data < node.data ? node.left : node.right;
        return hasData(node, data);
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        has(data) {
            return hasData(this.root, data);
        }
    }
})();
```

使用

```js
const bst = new BST();

!bst.has(6) && bst.insert(6);
bst.has(6); // true
```

###### 删除结点

删除结点，情况比较复杂。通常，要删除的结点有以下几种情况：

- 两边没有子节点：直接删除。
- 一边存在子节点：提升子树，替换要删除的节点。
- 两边存在子节点：这里有很多处理方案，下面提供三种。

第一种：

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 查询结点
    function hasNode(node, data) {
        if (!node) return false;
        if (node.data === data) return true;
        node = data < node.data ? node.left : node.right;
        return hasData(node, data);
    }
    
    // 调节节点位置
    function adjustNodePos(left, right) {
        if (!left.right) {
            left.right = right;
            return left;
        } else if (!right.left) {
            right.left = left;
            return right;
        } else {
            const temp = left.right;
            left.right = right;
            right.left = adjustNodePos(temp, right.left);
            return left;
        }
    }
    
    // 删除节点
    function removeNode(node, data) {
        if (!node) return null;
        if (node.data === data) {
            if (!node.left && !node.right) {
                return null;
            } else if (!node.right) {
                return node.left;
            } else if (!node.left) {
                return node.right;
            } else {
                return adjustNodePos(node.left, node.right);
            }
        } else if (data < node.data && node.left) {
            node.left = removeNode(node.left, data);
        } else if (data > node.data && node.right) {
            node.right = removeNode(node.right, data);
        }
        return node;
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        has(data) {
            return hasNode(this.root, data);
        }
        remove(data) {
            this.root = removeNode(this.root, data);
        }
    }
})();
```

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);

bst.remove(5);

console.log(bst);
```

第二种方案：

- 删除左子树节点：使用左子树中的最大值来替换要删除的节点。
- 删除右子树节点：使用右子树中的最小值来替换要删除的节点。

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 查询结点
    function hasNode(node, data) {
        if (!node) return false;
        if (node.data === data) return true;
        node = data < node.data ? node.left : node.right;
        return hasData(node, data);
    }
    
    // 子树中的最大值
    function getMaxData(node) {
        if (node.right) return getMaxData(node.right);
        return node.data;
    }
    // 子树中的最小值
	function getMinData(node) {
        if (node.left) return getMaxData(node.left);
        return node.data;
    }
    
    // 调节节点位置
    function adjustNodePos(left, right) {
        if (!left.right) {
            left.right = right;
            return left;
        } else if (!right.left) {
            right.left = left;
            return right;
        } else {
            const temp = left.right;
            left.right = right;
            right.left = adjustNodePos(temp, right.left);
            return left;
        }
    }
    
    // 删除节点
    function removeNode(node, data) {
        if (!node) return null;
        if (node.data === data) {
            if (!node.left && !node.right) {
                return null;
            } else if (!node.right) {
                return node.left;
            } else if (!node.left) {
                return node.right;
            } else {
                // 以左子树最大值，替换要删除节点的位置。
                const leftMaxData = getMaxData(node.left);
                node.left = removeNode(node.left, leftMaxData);
                node.data = leftMaxData;
                
                // 以右子树最小值，替换要删除节点的位置。
                // const rightMinData = getMaxData(node.right);
                // node.right = removeNode(node.right, rightMinData);
                // node.data = rightMinData;
            }
        } else if (data < node.data && node.left) {
            node.left = removeNode(node.left, data);
        } else if (data > node.data && node.right) {
            node.right = removeNode(node.right, data);
        }
        return node;
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        has(data) {
            return hasNode(this.root, data);
        }
        remove(data) {
            this.root = removeNode(this.root, data);
        }
    }
})();
```

#### 二叉平衡树

使用二叉搜索树时，可能存在某一条枝干很深但另一条很浅的情况，从而出现树枝不对称、不平衡的现象。要平衡这种现象，则可使用二叉平衡树。

左右失衡的左子树 + 右右失衡的处理 ==> 整棵树的左左失衡；右左失衡的右子树 + 左左失衡的处理 ==> 整棵树的右右失衡。

注解：

- 左右失衡：将失衡的左子树按右右失衡的规则处理（得到整颗树左左失衡的形态），再将整棵树按左左失衡的方式处理即可。
- 右左失衡：将失衡的右子树按左左失衡的规则处理（得到整颗树右右失衡的形态），再将整棵树按右右失衡的方式处理即可。

##### 简单实现

```js
const AVL = (function() {
    class DataNode {
        constructor(data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }
    
    // 求树深度
    function nodeDeep(node) {
        if (!node) return 0;
        return Math.max(nodeDeep(node.left), nodeDeep(node.right)) + 1;
    }
    
    // 左左失衡
    function LLImbalance(node) {
        const temp = node.left;
        node.left = temp.right;
        temp.right = node;
        return temp;
    }
    // 右右失衡
    function RRImbalance(node) {
       	const temp = node.right;
        node.right = temp.left;
        temp.left = node;
        return temp;
    }
    // 左右失衡
   	function LRImbalance(node) {
        node.left = RRImbalance(node.left);
        return LLImbalance(node);
    }
    
    // 右左失衡
    function RLImbalance(node) {
        node.right = LLImbalance(node.right);
        return RRImbalance(node);
    }
    
    // 插入节点
    function insertData(root, node) {
        if (!root) return node;
        // 在左侧添加还是右侧添加
        if (node.data < root.data) {
            root.left = insertData(root.left, node);
            // 检测深度，是否失衡
            if (nodeDeep(root.left) - nodeDeep(root.right) > 1) {
                // 左侧失衡
                if (node.data < root.left.data) {
                    // 左左失衡
                    root = LLImbalance(root);
                } else {
                    // 左右失衡
                    root = LRImbalance(root);
                }
            }
        } else {
            root.right = insertData(root.right, node);
           	// 检测深度，是否失衡
            if (nodeDeep(root.right) - nodeDeep(root.left) > 1) {
                // 右侧失衡
                if (node.data < root.right.data) {
                    // 右左失衡
                    root = RLImbalance(root);
                } else {
                    // 右右失衡
                    root = RRImbalance(root);
                }
            }
        }
        return root;
    }
    
    return class AVL {
        constructor() {
            this.root = null;
        }
        insert(data) {
            // 每次插入新的节点，都要调整（即：平衡）整颗树的结构。
            this.root = insertData(this.root, new DataNode(data));
        }
    }
})();
```

```js
const avl = new AVL();

// 右左失衡
avl.insert(100);
avl.insert(110);
avl.insert(90);
avl.insert(120);
avl.insert(105);
avl.insert(103);

console.log(avl);
```

