# 工作者线程

前端开发者常说：“`JavaScript` 是单线程的”。这种说法虽然有些简单，但描述了 `JavaScript` 在浏览器中的一般行为。因此，作为帮助 `Web` 开发人员理解 `JavaScript` 的教学工具，它非常有用。

单线程就意味着不能像多线程语言那样把**工作委托**给独立的线程或进程去做，无法充分发挥现代计算机多核 `CPU` 的优势。`JS` 的单线程可以保证它与不同的浏览器 `API` 兼容。假如 `JavaScript` 可以多线程执行并发更改，那么像 `DOM` 这样的 `API` 就会使渲染不可控。因此，`POSIX` 线程或 `Java` 的 `Thread` 类等传统并发结构都不适合 `JavaScript`。【渲染必须是单线程的，否则就会造成页面混乱】

而这也正是工作者线程的**价值所在**：允许把主线程的**工作转嫁**给独立的实体，而不会改变现有的单线程模型。虽然本章要介绍的各种工作者线程有着不同的形式和功能，但它们的**共同特点**是都独立于 `JavaScript` 的主执行环境。



### 工作者线程简介

`JavaScript` 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、`DOM`，等等。每个页面就相当于一个沙盒，不会干扰其他页面。对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。

使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级**子环境**。这个子环境不可以与依赖单线程交互的 `API`（如 `DOM`）互操作，但**可以与父环境并行执行代码**。

`Web Worker` 的作用，就是为 `JavaScript` 创造多线程环境，允许主线程创建 `Worker` 线程，将一些任务分配给后者运行。在主线程运行的同时，`Worker` 线程在后台运行，两者互不干扰。等到 `Worker` 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 `Worker` 线程负担了，主线程（通常负责 `UI` 交互）就会很流畅，不会被阻塞或拖慢。

 `Worker` 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 `Worker` 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

`web worker` 的一些特点：

- **同源限制**：分配给 `Worker` 线程运行的脚本文件，必须与主线程的脚本文件同源。也就是说只能加载来自网络的脚本文件，无法读取本地文件。
- **`DOM` 限制**：`Worker` 线程所在的全局对象，与主线程不一样。无法读取主线程所在网页的 `DOM` 对象，也无法使用 `document`、`window`、`parent` 这些对象，自然也不能 `alert()`。但是，`Worker` 线程可以使用 `navigator` 对象和 `location` 对象。
- **实际线程：**工作者线程是以实际线程实现的。但不一定在同一个进程里（一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于）。
- **并行执行：**虽然页面和工作者线程都是单线程 `JavaScript` 环境，但多个工作者线程可以并行执行。
- **通信联系：**`Worker` 线程和主线程不在同一个上下文环境中，因此它们不能直接通信，必须通过消息完成。



#### 与执行线程

作为介绍，通常需要将工作者线程与执行线程进行比较。在许多方面，这是一个恰当的比较，因为工作者线程和线程之间确实存在很多共同之处。

- **工作者线程是以实际线程实现的**。例如，`Blink` 浏览器引擎实现工作者线程的 `WorkerThread` 就对应着底层的线程。
- **工作者线程并行执行**。虽然页面和工作者线程都是单线程 `JavaScript` 环境，但每个工作者环境中的指令都可以并行执行。
- **工作者线程可共享部分内存**。工作者线程能够使用 `SharedArrayBuffer` 在多个环境间共享内容。虽然线程会使用锁实现并发控制，但 `JavaScript` 使用 `Atomics` 接口实现并发控制。

工作者线程与线程有很多类似之处，但也有重要的区别。

- **工作者线程不共享全部内存**。在传统线程模型中，多线程有能力读写共享内存空间。除了 `SharedArrayBuffer` 外，从工作者线程进出的数据需要复制或转移。
- **工作者线程不一定在同一个进程里**。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如，`Chrome` 的 `Blink` 引擎对共享工作者线程和服务工作者线程使用独立的进程。
- **创建工作者线程的开销更大**。工作者线程有自己独立的事件循环、全局对象、事件处理程序和其他 `JavaScript` 环境所必需的特性。因此，创建这些结构的代价不容忽视。

无论形式还是功能，工作者线程都不是用于替代线程的。`HTML Web` 工作者线程规范是这样说的：

> 工作者线程相对比较重，不建议大量使用。例如，对一张 400 万像素的图片，为每个像素都启动一个工作者线程是不合适的。通常，工作者线程应该是长期运行的，其启动成本比较高，每个实例占用的内存也比较大。



#### 线程的类型

`Web` 工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。现代浏览器都支持这些工作者线程。注意，`Web` 工作者线程规范参见 `HTML Standard` 网站。

##### 专用工作者线程

专用工作者线程，通常简称为工作者线程（`Web Worker` 或 `Worker`），是一种实用的工具，它允许脚本单独创建一个 `JavaScript` 线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它的页面所使用。

##### 共享工作者线程

共享工作者线程与专用工作者线程非常相似。主要区别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面，主要用于共享内容。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。

##### 服务工作者线程

服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者角色。

注意：还有其他一些工作者线程规范，比如 `ChromeWorker` 或 `Web Audio API`，但它们并未得到广泛支持，或者定位于小众应用程序，因此本章没有包含与之相关的内容。



#### 线程作用域

在网页上，`window` 对象可以向运行在其中的脚本暴露各种全局变量。但在工作者线程内部，没有 `window` 的概念。这里的全局对象是 `WorkerGlobalScope` 的实例，通过 `self` 关键字暴露出来。

```js
// 在正常环境中
console.log('self',self); // -> 打印结果是Window实例
```

```js
// 在worker环境中
const worker_code = () => {
    
    // 向主线程发送一条消息
    self.postMessage('worker loaded successfully...');

    // 监听主线程发来的信息
    self.onmessage = (e) => {
        console.log('接收到的event:',e);
        let result = `从主线程接收到的数据 ${e.data}`;
        self.postMessage(result)
    }

    console.log('self',self); // -> 打印结果是WorkerGlobalScope实例
}
```

##### 属性和方法

`self` 上可用的属性是 `window` 对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。

- `navigator`：返回与工作者线程关联的 `WorkerNavigator`。
- `self`：返回 `WorkerGlobalScope` 的实例。
- `location`：返回与工作者线程关联的 `WorkerLocation`。
- `performance`：返回（只包含特定属性和方法的）`Performance` 对象。
- `console`：返回与工作者线程关联的 `Console` 对象；对 `API` 没有限制。
- `caches`：返回与工作者线程关联的 `CacheStorage` 对象；对 `API` 没有限制。
- `indexedDB`：返回 `IDBFactory` 对象。
- `isSecureContext`：返回布尔值，表示工作者线程上下文是否安全。
- `origin`：返回 `WorkerGlobalScope` 的源。

类似地，`self` 对象上暴露的一些方法也是 `window` 上方法的子集。这些 `self` 上的方法也与 `window` 上对应的方法操作一样。

- `atob()`
- `btoa()`
- `clearInterval()`
- `clearTimeout()`
- `createImageBitmap()`
- `fetch()`
- `setInterval()`
- `setTimeout()`

`WorkerGlobalScope` 还增加了新的全局方法 `importScripts()`，只在工作者线程内可用。本章稍后会介绍该方法。

##### 子类

实际上，并不是所有地方都实现了 `WorkerGlobalScope`。每种类型的工作者线程都使用了自己特定的全局对象，但是它们都继承自 `WorkerGlobalScope`。

- 专用工作者线程使用 `DedicatedWorkerGlobalScope`。【`dedicated`：专用的】
- 共享工作者线程使用 `SharedWorkerGlobalScope`。
- 服务工作者线程使用 `ServiceWorkerGlobalScope`。

本章稍后会在这些全局对象对应的小节中讨论其差异。



### 专用工作者线程

专用工作者线程是最简单的 `Web` 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）。

注意：在使用工作者线程时，脚本在哪里执行、以及在哪里加载都是非常重要的概念。除非另有说明，否则本章假定 `main.js` 是从 `https://example.com` 域的根路径加载并执行的顶级脚本。



#### 基本概念

可以把专用工作者线程称为后台脚本（`background script`）。`JavaScript` 线程的各个方面，包括生命周期管理、代码路径和输入输出，都由初始化线程时提供的脚本来控制。该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。

##### 创建线程

创建专用工作者线程最常见的方式是加载 `JavaScript` 文件。把文件路径提供给 `Worker` 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。传给构造函数的文件路径可以是多种形式。

下面的代码演示了如何创建空的专用工作者线程。由于同源策略，创建线程必须在网络文件中运行。

```js
console.log(location.origin); // "http://127.0.0.1:59481" 

const worker = new Worker((new URL(location.origin)).toString() + 'emptyWorker.js');

console.log(worker); 		  // Worker {onmessage: null, onerror: null}
/*
Worker {
	onerror: null,
	onmessage: null, 
	[[Prototype]]: Worker {
		onerror: null,
		onmessage: null,
		postMessage: ƒ postMessage(),
		terminate: ƒ terminate(),
		constructor: ƒ Worker(),
		Symbol(Symbol.toStringTag): "Worker",
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		get onmessage: ƒ onmessage(),
		set onmessage: ƒ onmessage(),
		[[Prototype]]: EventTarget
	}
}
*/
```

这个例子非常简单，但涉及以下几个基本概念。

- `emptyWorker.js` 文件是从绝对路径加载的。根据应用程序的结构，使用绝对 `URL` 经常是多余的。
- 这个文件是在后台加载的，工作者线程的初始化完全独立于 `main.js`。
- 工作者线程本身存在于一个独立的 `JavaScript` 环境中，因此 `main.js` 必须以 `Worker` 对象为代理实现与工作者线程的通信。在上面的例子中，该对象被赋值给了 `worker` 变量。
- 虽然相应的工作者线程可能还不存在，但该 `Worker` 对象已在原始环境中可用了。

前面的例子可修改为使用相对路径而不必手动指定源。不过，这要求 `main.js` 必须与 `emptyWorker.js` 在同一个路径下：

```js
const worker = new Worker('./emptyWorker.js'); // 默认从当前源中加载
```

##### 安全限制

工作者线程的脚本文件只能从与父页面相同的源中加载。从其他源加载工作者线程的脚本文件会导致错误，如下所示：

```js
// 尝试基于 https://example.com/worker.js 创建工作者线程
const sameOriginWorker = new Worker('./worker.js'); 

// 尝试基于 https://untrusted.com/worker.js 创建工作者线程
const remoteOriginWorker = new Worker('https://untrusted.com/worker.js'); 
// Uncaught DOMException: Failed to construct 'Worker': Script at 'https://untrusted.com/worker.js' cannot be accessed from origin 'https://example.com'.
```

注意：虽然使用非同源的脚本无法创建工作者线程，但并不影响已创建的工作者线程加载和执行其他源的脚本。在工作者线程内部，使用 `importScripts()` 可以加载其他源的脚本。本章稍后会介绍。

基于加载脚本创建的工作者线程不受文档的内容安全策略（`CSP`，`Content Security Policy`）限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。

注意：在后续的《行内创建》小节中会介绍基于二进制大文件创建工作者线程。

##### 使用线程

`Worker()` 构造函数返回的 `Worker` 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文之间传输信息，以及捕获专用工作者线程发出的事件。

注意：必须管理好使用 `Worker()` 创建的每个 `Worker` 对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过编程方式恢复对之前 `Worker` 对象的引用。

`Worker` 对象支持下列事件处理程序属性。

- `onerror`：在工作者线程中发生 `ErrorEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程抛出错误时发生。该属性是伴生属性。
  - 该事件也可以通过 `worker.addEventListener('error', handler)` 的形式处理。

- `onmessage`：在工作者线程中发生 `MessageEvent` 类型的消息事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程向父上下文发送消息时发生。该属性是伴生属性。
  - 该事件也可以通过使用 `worker.addEventListener('message', handler)` 处理。

- `onmessageerror`：在工作者线程中发生 `MessageEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程收到无法反序列化的消息时发生。注意，此属性非伴生属性。
  - 该事件也可以通过使用 `worker.addEventListener('messageerror', handler)` 处理。


`Worker` 对象还支持下列方法。

- `postMessage()`：用于通过异步消息事件向此工作者线程发送信息。
- `terminate()`：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。

##### 全局作用域

在专用工作者线程内部，全局作用域是 `DedicatedWorkerGlobalScope` 的实例。因为继承自 `WorkerGlobalScope`，所以包含它的所有属性和方法。工作者线程可以通过 `self` 关键字访问该全局作用域。

```js
// globalScopeWorker.js
console.log('inside worker:', self); 

// main.js
const worker = new Worker('./globalScopeWorker.js'); 

console.log('created worker:', worker); 
/*
> created worker: Worker {...} 
> inside worker: DedicatedWorkerGlobalScope {...}
*/
```

如此例所示，顶级脚本和工作者线程中的 `console` 对象都将写入浏览器控制台，这对于调试非常有用。因为工作者线程具有不可忽略的启动延迟，所以即使 `Worker` 对象存在，工作者线程的日志也会在主线程的日志之后打印出来。

注意：这里两个独立的 `JavaScript` 线程都在向一个 `console` 对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的 `JavaScript` 线程收到消息，并按照自己认为合适的顺序输出这些消息。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。

`DedicatedWorkerGlobalScope` 在 `WorkerGlobalScope` 基础上增加了以下属性和方法。

- `name`：可以提供给 `Worker` 构造函数的一个可选的字符串标识符。
- `postMessage()`：与 `worker.postMessage()` 对应的方法，用于从工作者线程内部向父上下文发送消息。
- `close()`：与 `worker.terminate()` 对应的方法，用于立即终止工作者线程（实际上不会立即终止线程，只是取消事件循环中的所有任务并阻止添加新任务）。没有为工作者线程提供清理的机会，脚本会突然停止？
- `importScripts()`：用于向工作者线程中导入任意数量的脚本。



#### 隐式通信

专用工作者线程的 `Worker` 和 `DedicatedWorkerGlobalScope` 都与 `MessagePorts`（消息端口）有一些相同的接口处理程序和方法：`onmessage`、`onmessageerror`、`close()` 和 `postMessage()`。这不是偶然的，因为专用工作者线程隐式使用了 `MessagePorts` 在（脚本与其线程）这两个上下文之间通信。

父上下文中的 `Worker` 和线程上下文中 `DedicatedWorkerGlobalScope` 实际上都融合了 `MessagePort`，并在自己的接口中分别暴露了相应的处理程序和方法。换句话说，消息还是通过 `MessagePort` 发送的，只是没有直接使用 `MessagePort` 而已。

也有不一致的地方，如对 `start()` 和 `close()` 的约定。专用工作者线程会自动发送排队的消息，因此 `start()` 也就没有必要了。另外，`close()` 在专用工作者线程的上下文中没有意义，因为这样关闭 `MessagePort` 会使工作者线程陷入孤立。因此，在工作者线程内部调用 `close()`（或在外部调用 `terminate()`）不仅会关闭 `MessagePort`，也会终止线程。



#### 生命周期

调用 `Worker()` 构造函数是一个专用工作者线程生命的起点。调用之后，它会初始化对工作者线程脚本的请求，并把 `Worker` 对象返回给父上下文。虽然父上下文中可以立即使用这个 `Worker` 对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网络延迟和初始化延迟。

专用工作者线程一般可以非正式地划分为下列三种状态：初始化（`initializing`）、活动（`active`） 和终止（`terminated`）。这几个状态对其他上下文是不可见的。虽然 `Worker` 对象可能会存在于父上下文中，但也无法通过它确定工作者线程当前是处于哪个状态。换句话说，与活动的专用工作者线程关联的 `Worker` 对象和与终止的专用工作者线程关联的 `Worker` 对象无法分别。

##### 初始化线程

初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作者线程的状态变为活动，然后再把消息添加到它的消息队列。下面的代码演示了这个过程。

```js
// 在 initializingWorker.js 中
self.addEventListener('message', ({data}) => console.log(data)); 

// 在 main.js 中
const worker = new Worker('./initializingWorker.js'); 

// Worker可能仍处于初始化状态，但可以先使用postMessage()发送数据。
worker.postMessage('foo'); 
worker.postMessage('bar'); 
worker.postMessage('baz');
```

当工作者线程的状态从初始化变为活动后，这些消息就会被添加到此工作者线程的消息队列中。最终，它会依次输出如下结果：

```
foo 
bar 
baz
```

##### 终止线程

创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非通过 `self.close()` 自我终止或通过 `worker.terminate()` 外部终止。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，与之关联的 `Worker` 对象就不会被当成垃圾收集掉。

自我终止和外部终止最终都会执行相同的工作者线程终止例程。如下例，工作者线程在发送两条消息的代码中间执行了自我终止：

```js
// 在 closeWorker.js 中
self.postMessage('foo');

self.close();

for(let i = 0; i < 5; i ++) {
    console.log(i);
}

self.postMessage('bar');

setTimeout(() => self.postMessage('baz'), 0); 

for (let i = 0; i < 5; i++) {
    console.log(i);
}

// 在 main.js 中
const worker = new Worker('./closeWorker.js'); 
worker.onmessage = ({data}) => console.log(data); 
```

虽然调用了 `close()`，但显然工作者线程的执行并没有立即终止。`close()` 在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务，这也是为什么 `"baz"` 没有打印出来的原因。然而工作者线程不需要执行同步停止，因此工作者脚本中的其余所有同步代码仍会被正常执行。结果如下，父上下文中消息的打印时机取决于自身何时接收到它：

```
0
1
2
'foo'
3
4
0
1
'bar'
2
3
4
```

下面来看一个外部终止的例子。

```js
// 在 terminateWorker.js 中
self.onmessage = ({data}) => console.log(data); 

// 在 main.js 中
const worker = new Worker('./terminateWorker.js'); 

// 给 1000 毫秒让工作者线程进行初始化
setTimeout(() => { 
 	worker.postMessage('foo'); // 此时，已完成初始化，这条消息将被立即接收。如果未完成，那么它将在消息队列中被清理。
 	worker.terminate(); 
 	worker.postMessage('bar'); 
 	setTimeout(() => worker.postMessage('baz'), 0); 
}, 1000); 
```

这里，外部先给工作者线程发送了带 `"foo"` 的 `postMessage`，这条消息可以在线程被终止之前收到。一旦调用了 `terminate()`，工作者线程的消息队列就会被清理并锁住，这也是结果只打印了 `"foo"` 的原因。由于工作者线程不会立即完成初始化，所以这里等待了它 1 秒。如果不等待它完成，那么此工作者线程在完成初始化之前就会被终止，最终导致它一条消息也收不到。

```
foo
```

注意：`close()` 和 `terminate()` 是幂等操作，多次调用没有问题。这两个方法仅仅是将 `Worker` 标记为 `teardown` 而已，因此多次调用不会产生不好的影响。【`teardown`：拆卸】

在整个生命周期中，一个专用工作者线程只会关联一个网页（工作者线程规范称其为一个文档）。除非明确终止它，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（导航到其他页面、关闭标签页或窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。



#### 配置选项

`Worker()` 构造函数允许将可选的配置对象作为第二个参数，用以配置加载脚本（即首参）的相关信息。该配置对象支持下列属性。

- `name`：表示加载脚本的字符串标识符。可以在工作者线程中通过 `self.name` 读取到。
- `type`：表示加载脚本的类型，可以是 `"classic"` 或 `"module"`。不同类型的脚本有着不同的运行方式，`"classic"` 将脚本作为常规脚本来执行，`"module"` 将脚本作为模块来执行。
- `credentials`：表示加载脚本的凭据。在 `type` 为 `"module"` 时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是 `"omit"`、 `"same-orign"` 或 `"include"`。这些选项与 `fetch()` 的凭证选项相同。在 `type` 为 `"classic"` 时，默认为 `"omit"`。【`omit`：省略；`same-origin`：同源；`include`：包含】

注意：有的现代浏览器还不完全支持模块工作者线程或可能需要修改标志才能支持。

```js
const worker = new Worker('./b.js', {
    name: 'b',
    type: "classic",
    credentials: "omit"
});
```



#### 行内创建

工作者线程需要基于脚本文件来创建，但这并不意味着该脚本必须是远程资源。专用工作者线程也可以通过 `Blob` 对象 `URL` 在行内脚本创建。这样可以更快速地初始化工作者线程，因为没有网络延迟。

下面展示了一个在行内创建工作者线程的例子。

```js
// 创建脚本内容
const workerScript = `self.onmessage = ({data}) => console.log(data);`;

// 基于脚本内容生成 Blob 对象
const workerScriptBlob = new Blob([workerScript]); 

// 基于 Blob 实例创建对象 URL 
const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob); 

// 基于对象 URL 创建专用工作者线程
const worker = new Worker(workerScriptBlobUrl); 

worker.postMessage('blob worker script'); 

// 打印结果：blob worker script
```

在这个例子中，通过脚本字符串创建了 `Blob`，然后又通过 `Blob` 创建了对象 `URL`，最后把对象 `URL` 传给了 `Worker()` 构造函数。该构造函数同样创建了专用工作者线程。

如果把所有代码写在一块，则可以浓缩成这样：

```js
const worker = new Worker(URL.createObjectURL(new Blob([
    `self.onmessage = ({data}) => console.log(data);`
]))); 

worker.postMessage('blob worker script'); 
```

工作者线程也可以利用序列化的函数来初始化行内脚本。这是因为函数的 `toString()` 方法返回函数代码的字符串，且函数可以在父上下文中定义但在子上下文中执行。来看下面这个简单的例子：

```js
// 定义斐波那契函数
function fibonacci(n) { 
 	return n < 1 ? 0 : n <= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2); 
} 

const workerScript = `self.postMessage((${fibonacci.toString()})(9));`; 

const worker = new Worker(URL.createObjectURL(new Blob([workerScript]))); 

worker.onmessage = ({data}) => console.log(data); // 34
```

这里有意使用了斐波那契数列的实现，将其序列化之后传给了工作者线程。该函数作为 `IIFE` 调用并传递参数，结果则被发送回主线程。虽然计算斐波那契数列比较耗时，但所有计算都会委托到工作者线程，因此并不会影响父上下文的性能。

注意：像这样序列化函数有个前提，就是函数体内不能使用父上下文中的任何变量，包括全局变量，比如 `window`。由于两个上下文相互独立且不同，这些引用在工作者线程中执行时会导致引用错误。简单来说，就是用于序列化的函数必须是与外界完全独立的纯函数。



#### 动态执行

工作者线程中的脚本并非铁板一块，而是可以使用 `importScripts()` 方法通过编程方式加载和执行任意脚本。该方法可用于全局的 `Worker` 对象，它会加载脚本并按照加载顺序同步执行它们。比如，下面的例子加载并执行了两个脚本：

```js
// 在 scriptA.js 中
console.log('scriptA executes');

// 在 scriptB.js 中
console.log('scriptB executes'); 

// 在 worker.js 中
console.log('importing scripts'); 
importScripts('./scriptA.js'); 
importScripts('./scriptB.js'); 
console.log('scripts imported');

// 在 main.js 中
const worker = new Worker('./worker.js'); 

/*
> 'importing scripts'
> 'scriptA executes'
> 'scriptB executes' 
> 'scripts imported' 
*/
```

`importScripts()` 方法可以一次性接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。因此，下面的代码与前面的效果一样：

```js
console.log('importing scripts'); 

importScripts('./scriptA.js', './scriptB.js'); // 严格按照此参数列表的顺序执行脚本

console.log('scripts imported');
```

脚本加载受到常规 `CORS` 的限制，但在工作者线程内部可以请求来自任何源的脚本。这种脚本导入策略类似于使用生成的 `<script>` 标签动态加载脚本。在这种情况下，所有被导入的脚本也会共享此工作者线程的全局作用域。下面的代码演示了这个事实：

```js
// scriptA.js
console.log(`scriptA executes in ${self.name} with ${globalToken}`); 

// scriptB.js
console.log(`scriptB executes in ${self.name} with ${globalToken}`); 

// worker.js
const globalToken = 'bar'; 
console.log(`importing scripts in ${self.name} with ${globalToken}`); 
importScripts('./scriptA.js', './scriptB.js'); // 这两个脚本共享这个工作者线程的全局作用域
console.log('scripts imported');

// main.js
const worker = new Worker('./worker.js', {name: 'foo'}); 
```

此时，`scriptA.js` 和 `scriptB.js` 脚本会共享 `work.js` 的全局作用域，结果如下：

```
importing scripts in foo with bar 
scriptA executes in foo with bar 
scriptB executes in foo with bar 
scripts imported 
```

注意，调用这个方法并不会对同一个脚本只加载一次。也就是说，每次调用它加载同一个脚本，都会加载和执行它。

```js
importScripts('./scriptA.js', './scriptA.js'); // 加载和执行两次scriptA.js文件
```



#### 委托任务

有时候可能需要在工作者线程中再**创建子工作者线程**。在有多个 `CPU` 核心的时候，使用多个子工作者线程可以实现并行计算。使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。

除了路径解析不同，创建子工作者线程与创建普通工作者线程是一样的。子工作者线程的脚本路径根据父工作者线程而不是相对于网页来解析。来看下面的例子（注意额外的 `js` 目录）：

```js
// js/subworker.js
console.log('subworker');

// js/worker.js
console.log('worker'); 
const worker = new Worker('./subworker.js'); 

// main.js
const worker = new Worker('./js/worker.js'); 

/*
> worker 
> subworker 
*/
```

注意：顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源中加载。



#### 线程错误

如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。这是理所当然的，因为两个工作者线程和父线程本就是相互独立的。如下例所示，其中的 `try/catch` 块不会捕获到子线程抛出的错误：

```js
// worker.js
throw Error('foo');

// main.js
try { 
 	const worker = new Worker('./worker.js'); // 子线程抛出的错误，不会在此被捕获到。
    console.log('no error'); 
} catch(e) { 
 	console.log('caught error'); 
} 
```

不过，相应的错误事件仍然会冒泡到工作者线程的全局上下文，因此可以通过在 `Worker` 对象上设置错误事件侦听器来监听它。

```js
// worker.js
throw Error('foo');

// main.js
const worker = new Worker('./worker.js'); 
worker.onerror = console.log; // ErrorEvent {message: "Uncaught Error: foo", ...} 
```

但如果在工作者线程中捕获了此错误，那么它就不会再冒泡到工作者线程的全局上下文了。



#### 线程通信

主线程与工作者线程的通信都是通过异步消息完成的，而这些消息也可以有多种形式。

##### `postMessage()`

最简单也最常用的形式是使用 `postMessage()` 传递消息（可以是任何消息）。下面来看一个计算阶乘的例子：

```js
// factorialWorker.js
function factorial(n) { 
 	let result = 1; 
 	while(n) { result *= n--; } 
 	return result; 
} 

self.onmessage = ({data}) => { 
 	self.postMessage(`${data}! = ${factorial(data)}`); 
}; 

// main.js
const factorialWorker = new Worker('./factorialWorker.js'); 

factorialWorker.onmessage = ({data}) => console.log(data); 

factorialWorker.postMessage(5); 	// 5! = 120 
factorialWorker.postMessage(7); 	// 7! = 5040 
factorialWorker.postMessage(10); 	// 10! = 3628800
```

对于简单的消息，可以使用 `postMessage()` 来在主线程和工作者线程之间传递。这与在两个窗口间传递消息非常像，主要区别是没有 `targetOrigin` 的限制。该限制是针对 `Window.prototype.postMessage` 的，对 `WorkerGlobalScope.prototype.postMessage` 或 `Worker.prototype.postMessage` 则没有影响。这样约定的原因也很简单：因为工作者线程脚本的源已被限制为主页的源，所以没有必要再去过滤了。

##### `MessageChannel`

无论主线程还是工作者线程，通过 `postMessage()` 进行通信都涉及调用全局对象上的方法，并定义一个临时的传输协议。不过，这个过程可以被 `Channel Messaging API` 取代，基于该 `API` 可以在两个上下文间明确建立通信渠道。【`channel`：通道、信道】

`MessageChannel` 实例有两个端口，分别代表两个通信端点。要让父页面和工作线程通过 `MessageChannel` 来通信，就需要把其中一个端口传到工作者线程中使用，如下所示：

```js
// worker.js
let messagePort = null; // 定义全局可用的消息端口

function factorial(n) { 
 	let result = 1; 
 	while(n) { result *= n--; } 
 	return result; 
} 

// 监听外部发送给线程的消息
self.onmessage = ({ports}) => { 
 	// 消息端口不存在时，初始化端口
 	if (!messagePort) { 
 		// 初始化消息端口，给变量赋值并重置监听器
   		messagePort = ports[0]; // 赋值给全局变量
 		self.onmessage = null; 	// 重置监听器
 		// 消息端口初始化之后，用它来监听线程消息。
 		messagePort.onmessage = ({data}) => { 
 			// 收到消息后发送数据
 			messagePort.postMessage(`${data}! = ${factorial(data)}`); 
 		}; 
 	} 
}; 

// main.js
const channel = new MessageChannel(); 
const factorialWorker = new Worker('./worker.js'); 

// 把其中一个消息端口发送到工作者线程，然后由工作者线程负责处理初始化信道。
factorialWorker.postMessage(null, [channel.port1]); 

// 使用另一个消息端口，通过信道发送数据
channel.port2.postMessage(5); 

// 监听工作者线程对该信道的响应
channel.port2.onmessage = ({data}) => console.log(data); 

// 打印结果：5! = 120
```

在这个例子中，父页面通过 `postMessage` 与工作者线程共享 `MessagePort`。使用数组语法是为了在两个上下文间传递可转移的对象。本章稍后会介绍可转移对象（`Transferable`）。工作者线程维护着对该端口的引用，并使用它代替通过全局对象传递消息。当然，消息的格式也需要临时约定：工作者线程收到的第一条消息包含端口，后续的消息才是数据。

使用 `MessageChannel` 与父页面通信在很大程度上是多余的。因为全局 `postMessage()` 方法本质上与 `channel.postMessage()` 执行的是同样的操作（不考虑 `MessageChannel` 接口的其他特性的话）。`MessageChannel` 真正有用的地方是能够让任意两个工作者线程直接通信，这可以通过把端口传给另一个工作者线程来轻松实现。下面的例子把一个数组从主线程传给了一个工作者线程，这个线程又把它传另一个工作者线程，然后再传回主页：

```js
// main.js
const channel = new MessageChannel(); // 创建消息信道

// 使用同一个脚本创建两个专用工作者线程
const workerA = new Worker('./worker.js'); 
const workerB = new Worker('./worker.js'); 

// 使用线程来收发消息，将两个端口分别发送给两个工作者线程
workerA.postMessage('workerA', [channel.port1]); // 将端口1发给workerA线程
workerB.postMessage('workerB', [channel.port2]); // 将端口2发给workerA线程
workerA.onmessage = ({data}) => console.log(data); 
workerB.onmessage = ({data}) => console.log(data); 
workerA.postMessage(['page']); // ['page', 'workerA', 'workerB'] 
workerB.postMessage(['page']); // ['page', 'workerB', 'workerA']

// worker.js
let messagePort = null; 
let contextIdentifier = null; 

function addContextAndSend(data, destination) { 
 	// 添加标识符以标识当前工作者线程
 	data.push(contextIdentifier); 
 	// 使用端口或线程发送数据（使用端口则发送给另一个端口，使用线程则发送给父线程）
 	destination.postMessage(data); 
} 

self.onmessage = ({data, ports}) => { 
 	// 如果消息中包含消息端口，则初始化工作者线程
 	if (ports.length) { 
 		contextIdentifier = data; 	// 记录标识符
 		messagePort = ports[0]; 	// 获取 MessagePort 
 		// 添加处理程序，把端口接收的数据发回到父页面
 		messagePort.onmessage = ({data}) => { 
			addContextAndSend(data, self); 
 		} 
 	} else { 
 		addContextAndSend(data, messagePort); // 如果不包含端口，则将数据发送给目标端口。
 	} 
};
```

在这个例子中，数组的每一段旅程都会添加一个字符串，标识自己到过哪里。数组从主线程发送到工作者线程，工作者线程会加上自己的上下文标识符。然后，数组又从这个工作者线程发送到另一个工作者线程。第二个线程又加上自己的上下文标识符，随即将数组发回主页，主页把数组打印出来。这个例子中的两个工作者线程使用了同一个脚本，因此要注意该脚本会被独立且并行地加载和执行两次。

##### `BroadcastChannel`

同源脚本之间可以通过 `BroadcastChannel` 互相发送和接收消息。这种通道类型的设置比较简单，不需要像 `MessageChannel` 那样转移端口。这可以通过以下方式实现：【`Broadcast`：广播】

```js
// worker.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道

channel.onmessage = ({data}) => { 
 	console.log(`heard ${data} in worker`); 
 	channel.postMessage('bar'); 
}

// main.js
const channel = new BroadcastChannel('worker_channel'); 
const worker = new Worker('./worker.js'); 

channel.onmessage = ({data}) => { 
 	console.log(`heard ${data} on page`); 
} 

setTimeout(() => channel.postMessage('foo'), 1000); 
/*
> heard foo in worker 
> heard bar on page 
*/
```

这里，页面在通过 `BroadcastChannel` 发送消息之前会先等 1 秒钟。因为这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。在这种情况下，如果没有 `setTimeout()`，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。

使用时需要给 `BroadcastChannel()` 构造函数传入一个信道标识符，所有使用该标识符创建的信道都会进入该广播频道，都能从中广播一条消息或收听广播的消息。与其他类型的信道类似，广播信道也通过 `onmessage` 监听广播，通过 `postMessage` 广播消息。不过要特别注意的是，当具有多条广播信道时，要对信道施加适当的判断以避免惨烈的广播死循环。如下便是一个典型的死循环。

```js
// a.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in a`);
    channel.postMessage('a');
}

// b.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in b`);
    channel.postMessage('b');
}

// c.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in c`);
    channel.postMessage('c');
}

// main.js
const channel = new BroadcastChannel('worker_channel');
const workerA = new Worker('./a.js');
const workerB = new Worker('./b.js');
const workerC = new Worker('./c.js');

channel.onmessage = ({ data }) => {
    console.log(`heard ${data} on page`);
}

setTimeout(() => channel.postMessage('page'), 1000); 
```



#### 数据传输

使用工作者线程时，经常需要为它们提供某种形式的数据负载。但工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 `volatile` 变量。在 `JavaScript` 中，有三种在上下文间转移信息的方式：结构化克隆算法（`structured clone algorithm`）、可转移对象（`transferable objects`）和共享数组缓冲区（`shared array buffers`）。

##### 结构化克隆算法

结构化克隆算法可用于在两个独立的上下文之间共享数据，`postMessage()` 使用它。该算法由浏览器在后台实现，不可直接使用。

```js
worker.postMessage({
    name: 'workerA',
    data: {}
});
```

在通过 `postMessage()` 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。下面是该克隆算法支持的类型。

|           支           |    持     |     的     |      类       |        型         |
| :--------------------: | :-------: | :--------: | :-----------: | :---------------: |
| 非 `Symbol` 的原始类型 | `Boolean` |  `String`  |    `BDate`    |     `RegExp`      |
|         `Blob`         |  `File`   | `FileList` | `ArrayBuffer` | `ArrayBufferView` |
|      `ImageData`       |  `Array`  |  `Object`  |     `Map`     |       `Set`       |

关于结构化克隆算法，有以下几点需要注意。

- 复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象。
- 结构化克隆算法可以识别对象中包含的循环引用，不会无穷无尽地遍历对象。
- 克隆 `Error` 对象、`Function` 对象、类或 `DOM` 节点时会抛出错误。
- 结构化克隆算法并不总是创建完全一致的副本（可能会舍弃一些东西）。
- 对象属性描述符、获取方法和设置方法不会克隆，必要时会使用默认值。
- 原型链不会被克隆。
- `RegExp.prototype.lastIndex` 属性不会被克隆。

注意：结构化克隆算法在对象比较复杂时会存在计算性消耗。因此，实践中要尽可能避免过大、过多的复制。

##### 可转移对象

使用可转移对象（`transferable objects`）可以把对象的所有权从一个上下文转移到另一个上下文。当不太可能在上下文间复制大量数据的时候，这个功能特别有用。只有如下几种对象是可转移对象：

- `ArrayBuffer`
- `MessagePort`
- `ImageBitmap`
- `OffscreenCanvas`

`postMessage()` 方法的第二个可选参数是一个数组，它指定应该将哪些对象转移到目标上下文。在遍历消息负载对象时，浏览器根据转移对象数组检查对象引用，并对转移对象进行转移而不克隆它们。这意味着被转移的对象可以通过消息负载发送，但消息负载本身会被复制，比如对象或数组。

下面的例子演示了工作者线程对 `ArrayBuffer` 的常规结构化克隆。这里没有对象转移：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage(arrayBuffer); // 对象没有被转移
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
```

如果把 `ArrayBuffer` 指定为可转移对象，那么对缓冲区内存的引用就会从父上下文中抹去，然后分配给工作者线程。下面的例子演示了这个操作，结果分配给 `ArrayBuffer` 的内存从父上下文转移到了工作者线程：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage(arrayBuffer, [arrayBuffer]); // 对象被转移了，此对象的缓冲区将被重置。
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 0
```

在其他类型的对象中**嵌套可转移对象**也完全没有问题。包装对象会被复制，而嵌套的对象会被转移：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.foo.bar.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage({foo: {bar: arrayBuffer}}, [arrayBuffer]); // 转移嵌套的对象
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 0
```

##### `SharedArrayBuffer`

注意：由于 `Spectre` 和 `Meltdown` 的漏洞，所有主流浏览器在 2018 年 1 月就禁用了 `SharedArrayBuffer`。从 2019 年开始，有些浏览器开始逐步重新启用这一特性。既不克隆，也不转移，`SharedArrayBuffer` 作为 `ArrayBuffer` 且能够在不同浏览器上下文间共享。在把 `SharedArrayBuffer` 传给 `postMessage()` 时，浏览器直接传递原始缓冲区的引用。结果是，两个不同的 `JavaScript` 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规 `ArrayBuffer` 一样。来看下面的例子：

```js
// worker.js
self.onmessage = ({data}) => { 
 	const view = new Uint8Array(data);
   	console.log(`buffer value before worker modification: ${view[0]}`); 
 	view[0] += 1; // 工作者线程为共享缓冲区赋值
 	self.postMessage(null); // 发送空消息，通知赋值完成
};

// main.js
const worker = new Worker('./worker.js'); 
const sharedArrayBuffer = new SharedArrayBuffer(1); // 创建 1 字节缓冲区
const view = new Uint8Array(sharedArrayBuffer); // 创建 1 字节缓冲区的视图
view[0] = 1; // 父上下文赋值 1 

worker.onmessage = () => { 
 	console.log(`buffer value after worker modification: ${view[0]}`); 
}; 

worker.postMessage(sharedArrayBuffer); // 发送对 sharedArrayBuffer 的引用

/* 
> buffer value before worker modification: 1 
> buffer value after worker modification: 2 
*/
```

当然，在两个并行线程中共享内存块有资源争用的风险。换句话说，`SharedArrayBuffer` 实例实际上会被当成易变（`volatile`）内存。下面的例子演示了这一点：

```js
// worker.js 
self.onmessage = ({data}) => { 
 	const view = new Uint32Array(data); 
 	// 执行 100 万次加操作
 	for (let i = 0; i < 1E6; ++i) { 
 		view[0] += 1; 
 	} 
 	self.postMessage(null); 
};

// main.js
// 创建包含 4 个线程的线程池
const workers = []; 
for (let i = 0; i < 4; ++i) { 
 	workers.push(new Worker('./worker.js')); 
} 

// 在最后一个工作者线程完成后打印最终值
let responseCount = 0; 
for (const worker of workers) { 
 	worker.onmessage = () => { 
 		if (++responseCount == workers.length) { 
 			console.log(`Final buffer value: ${view[0]}`); 
 		} 
 	}; 
} 

// 初始化 SharedArrayBuffer 
const sharedArrayBuffer = new SharedArrayBuffer(4); 
const view = new Uint32Array(sharedArrayBuffer); 
view[0] = 1; 

// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) { 
 	worker.postMessage(sharedArrayBuffer); 
} 

// 期待结果为 4000001。实际输出类似于：Final buffer value: 2145106 
```

这里，每个工作者线程都顺序执行了 100 万次加操作，每次都读取共享数组的索引、执行一次加操作，然后再把值写回数组索引。然而，在所有工作者线程读/写操作交织的过程中会发生资源争用。例如：

(1) 线程 A 读取到值 1；

(2) 线程 B 读取到值 1；

(3) 线程 A 加 1 并将 2 写回数组；

(4) 线程 B 在自己获取的数组值 1 上加 1，然后同样把 2 写回数组。

为解决该问题，可以使用 `Atomics` 对象让一个工作者线程获得 `SharedArrayBuffer` 实例的锁，在执行完所有读/写操作后，再允许另一个工作者线程执行操作。把 `Atomics.add()` 放到这个例子中就可以得到正确的最终值：

```js
// worker.js 
self.onmessage = ({data}) => { 
 	const view = new Uint32Array(data); 
 	// 执行 100 万次加操作
 	for (let i = 0; i < 1E6; ++i) { 
 		Atomics.add(view, 0, 1); // 在一个线程完成操作后，再允许下一个线程操作。
	} 
 	self.postMessage(null); 
};

// main.js 
// 创建包含 4 个线程的线程池
const workers = []; 
for (let i = 0; i < 4; ++i) { 
 	workers.push(new Worker('./worker.js')); 
} 

// 在最后一个工作者线程完成后打印最终值
let responseCount = 0; 
for (const worker of workers) { 
 	worker.onmessage = () => { 
 		if (++responseCount == workers.length) { 
 			console.log(`Final buffer value: ${view[0]}`); 
 		} 
 	}; 
} 

// 初始化 SharedArrayBuffer 
const sharedArrayBuffer = new SharedArrayBuffer(4); 
const view = new Uint32Array(sharedArrayBuffer); 
view[0] = 1; 

// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) { 
 	worker.postMessage(sharedArrayBuffer); 
} 

//（期待结果为 4000001），Final buffer value: 4000001 
```

注意：前面在《`JavaScript API`》一章中已经详细介绍了 `SharedArrayBuffer` 和 `Atomics API`。



#### 线程池

因为启用工作者线程代价很大，所以某些情况下可以考虑始终使固定数量的线程保持活动状态，需要时就把任务分派给它们。工作者线程在执行计算时，会被标记为忙碌状态。直到它通知线程池自己空闲了，才会准备好接收新任务。维护这些活动线程的容器就称为 “线程池” 或 “工作者线程池”。

线程池中线程的数量多少才算合适并没有权威的答案，不过可以参考 `navigator.hardwareConcurrency` 属性返回的系统可用的核心数量。因为浏览器不太可能知道每个核心的多线程能力，所以最好把这个数字作为线程池大小的上限。

一种使用线程池的策略是每个线程都执行同样的任务，但具体执行什么任务由几个参数来控制。要使用特定于任务的线程池，则可分配固定数量的工作者线程，并根据需要为他们提供参数。工作者线程会接收这些参数，执行耗时的计算，并把结果返回给线程池。结束后线程池可以再将其他工作分派给空闲的线程去执行。接下来的例子将构建一个相对简单的线程池，但可以涵盖上述思想的所有基本要求。

首先是定义一个 `TaskWorker` 类，用于创建任务工作者线程实例，它扩展自 `Worker` 类。`TaskWorker` 类负责两件事：跟踪线程是否正忙于工作，并管理进出线程的信息与事件。另外，传给这些任务工作者线程的任务会被封装到一个期约中，以便得知任务的状态。

```js
// 任务工作者线程类（特定于某个任务）
class TaskWorker extends Worker {
    constructor(notifyAvailable, workerArgs) {
        super(...workerArgs); // 调用Worker创建线程（this）
        // 给每个线程添加属性，并初始化为不可用状态
        this.available = false;
        this.resolve = null;
        this.reject = null;
        // 线程池会传递回调，以便工作者线程发出它需要新任务的信号
        this.notifyAvailable = notifyAvailable; // 用于通知线程池该线程空闲的回调
        // 线程脚本在完全初始化之后，会发送一条"ready"消息，收到后则将此线程设为空闲。
        this.onmessage = () => this.setAvailable(); // 将线程设为可用的空闲状态
    }

    // 由线程池调用，用以向空闲的线程分派任务
    dispatch({ resolve, reject, postMessageArgs }) {
        // 收到任务后，转为忙碌状态；完成任务或线程出错后，转为空闲状态。
        this.available = false; 
        this.onmessage = ({ data }) => {
            resolve(data); // 将任务解决为线程的响应。
            this.setAvailable();
        };
        this.onerror = (e) => {
            reject(e);     // 将任务拒绝为线程的错因。
            this.setAvailable();
        };
        this.postMessage(...postMessageArgs); // 向线程发送数据，以开始执行任务。
    }

    // 设置线程为空闲
    setAvailable() {
        this.available = true;
        this.resolve = null;
        this.reject = null;
        this.notifyAvailable();
    }
}
```

然后是定义 `WorkerPool` 类，用于创建线程池来管理和使用 `TaskWorker` 线程。它还必须维护尚未分派给工作者线程的任务队列。

```js
// 线程池类
class WorkerPool {
    constructor(poolSize, ...workerArgs) {
        this.taskQueue = []; // 任务队列
        this.workers = [];   // 线程池
        // 初始化线程池（创建固定数量的任务线程）
        for (let i = 0; i < poolSize; ++i) {
            // 当线程空闲时，向其派发新任务
            this.workers.push(new TaskWorker(() => this.dispatchIfAvailable(), workerArgs));
        }
    }

    // 把交给线程池的任务封装为期约并推入其任务队列
    enqueue(...postMessageArgs) {
        return new Promise((resolve, reject) => {
            this.taskQueue.push({ resolve, reject, postMessageArgs }); // 推入队列
            this.dispatchIfAvailable(); // 将队列中的任务交给空闲的线程
        });
    }

    // 把任务派发给一个空闲的线程（如果有的话）
    dispatchIfAvailable() {
        if (!this.taskQueue.length) {
            return; // 队列中没有任务时停止派发
        }
        for (const worker of this.workers) {
            // 找出空闲的线程，并将任务交给它
            if (worker.available) {
                let task = this.taskQueue.shift(); // 从队列中弹出一个任务
                worker.dispatch(task); // 将弹出的任务交给这个空闲的线程
                break; // 停止遍历
            }
        }
    }

    // 终止所有任务工作者线程
    close() {
        for (const worker of this.workers) {
            worker.terminate();
        }
    }
}
```

定义这两个类之后，现在可以把任务分派到线程池，并在任务线程可用时执行它们。任务线程脚本在完成加载后，首先需要发送一个消息给线程以触发线程的进一步初始化（将状态设为空闲）。任务线程脚本还需要监听线程发来的消息，在收到消息后立即执行任务。

```js
// 收到消息之后，就立即开始执行任务。
self.onmessage = ({data}) => { 
	// ...
}

// 发送消息给 TaskWorker，通知工作者线程准备好接收任务了
self.postMessage('ready');
```

假设要计算 1000 个随机浮点值之和，则任务线程的脚本大致如下。

```js
self.onmessage = ({data}) => { 
 	let sum = 0; 
 	let view = new Float32Array(data.arrayBuffer); 
    
 	for (let i = data.startIdx; i < data.endIdx; ++i) { 
 		// 不需要原子操作，因为只需要读
 		sum += view[i]; // 求和
 	} 
    
 	self.postMessage(sum); // 把结果发送给工作者线程
}; 

self.postMessage('ready');
```

有了以上代码，利用线程池分派任务的代码可以这样写：

```js
const totalTasks = 0; 	// 任务总量 
const numTasks = 0; 	// 任务数量（将总任务划分为多少个小的任务） 
const totalPerTask = totalTasks / numTasks; // 任务单量（划分到每个任务的总量）
const numWorkers = 4; 	// 线程数量（可根据系统CPU的数量来决定）
    
// 创建线程池（这里，使用同一个脚本，为了完成特定任务）
const pool = new WorkerPool(numWorkers, './worker.js');

// 任务期约池，保存每个任务的期约。
let taskPromises = []; 
// 将任务依次推送到线程池中进行处理
for (let i = 0; i < numTasks; i++) { 
    // 保存每个任务的期约
 	taskPromises.push( 
        // 向线程池分派任务
 		pool.enqueue({ 
 			// 传递执行任务的关键信息（这些信息用于控制各个线程具体执行哪部分任务）
 		}) 
 	); 
} 

// 等待任务期约池中的所有期约完成，然后进行总和
Promise.all(taskPromises) 
 	.then((partial) => partial.reduce((x, y) => x + y)) 
 	.then(console.log); 
```

完成上面这个计算任务的代码如下。如果要转移内存，为节省转移成本，这里可使用 `SharedArrayBuffer`：

```js
const totalFloats = 1E3;
const numTasks = 20;
const floatsPerTask = totalFloats / numTasks;
const numWorkers = 4;
const pool = new WorkerPool(numWorkers, './worker.js');

// 填充随机浮点值数组
let arrayBuffer = new ArrayBuffer(4 * totalFloats); // 使用 4 个字节表示一个浮点值
let view = new Float32Array(arrayBuffer);
for (let i = 0; i < totalFloats; ++i) {
    view[i] = Math.random();
}

let partialSumPromises = []; 
for (let i = 0; i < totalFloats; i += floatsPerTask) {
    partialSumPromises.push(
        pool.enqueue({
            startIdx: i,
            endIdx: i + floatsPerTask,
            arrayBuffer: arrayBuffer
        })
    );
}

Promise.all(partialSumPromises)
    .then((partialSums) => partialSums.reduce((x, y) => x + y))
    .then(console.log);

//（在这个例子中，和应该约等于 1E3/2），500.10405499720946
```

注意：草率地采用并行计算不一定是最好的办法。线程池的调优策略会因计算任务和系统硬件的不同而不同。



### 共享工作者线程

共享工作者线程（或称共享线程）与专用工作者线程类似，但它可以被多个可信任的执行上下文访问。例如，同源的两个标签页可以访问同一个共享工作者线程。`SharedWorker` 与 `Worker` 的消息接口稍有不同，包括外部和内部。

共享线程适合开发者希望通过在多个上下文间共享线程以减少计算性消耗的情形。比如，可以使用一个共享线程来管理多个同源页面 `WebSocket` 消息的发送与接收。共享线程也可以用在同源上下文希望通过一个线程通信的情形。



#### 线程简介

从行为上讲，共享工作者线程可以看作是专用工作者线程的一个扩展。二者在线程创建、线程选项、安全限制和 `importScripts()` 的行为上都是相同的。与专用工作者线程一样，共享工作者线程也在独立执行上下文中运行，也只能与其他上下文异步通信。

##### 创建线程

与专用工作者线程一样，创建共享工作者线程非常常用的方式是通过加载 `JavaScript` 文件创建。此时，需要给 `SharedWorker` 构造函数传入文件路径，该构造函数在后台异步加载脚本并实例化共享工作者线程。

下面的例子演示了如何基于绝对路径创建空共享工作者线程：

```js
// main.js 
console.log(location.origin); // "http://127.0.0.1:59481" 

const sharedWorker = new SharedWorker((new URL(location.origin)).toString() + 'emptyWorker.js');

console.log(sharedWorker); 	 // SharedWorker {port: MessagePort, onerror: null}

/*
SharedWorker {
	onerror: null,
	port: MessagePort {onmessage: null, onmessageerror: null},
	[[Prototype]]: SharedWorker {
		onerror: null,
		port: MessagePort,
		constructor: ƒ SharedWorker(),
		Symbol(Symbol.toStringTag): "SharedWorker",
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		get port: ƒ port(),
		[[Prototype]]: EventTarget
	}
}
*/
```

前面的例子可以修改为使用相对路径，不过这需要 `main.js` 和 `emptySharedWorker.js` 在同一个目录下：

```js
const sharedWorker = new SharedWorker('./emptyWorker.js'); 

console.log(sharedWorker); // SharedWorker {port: MessagePort, onerror: null}
```

也可以在行内脚本中创建共享工作者线程，但这样做没什么意义。因为每个基于行内脚本字符串创建的 `Blob` 都会被赋予自己唯一的浏览器内部 `URL`，所以行内脚本中创建的共享工作者线程始终是唯一的。这里的原因将在下一节介绍。

##### 线程标识

共享工作者线程与专用工作者线程的一个重要区别在于，`Worker()` 构造函数始终会创建新实例，而 `SharedWorker()` 则只会在相同的标识不存在的情况下才创建新实例。如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。

```js
// 每次都加载和执行脚本
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）

// 只加载和执行一次脚本
new SharedWorker('./test.js'); // 创建共享线程（加载并且执行脚本）
new SharedWorker('./test.js'); // 连接共享线程（不加载和执行脚本）
new SharedWorker('./test.js'); // 连接共享线程（不加载和执行脚本）
```

共享工作者线程标识源自解析后的脚本 `URL`、工作者线程名称和文档源，三者中任何一个不同都会产生新的共享线程标识。例如，下面的脚本将实例化一个共享工作者线程并在它上面添加两个连接：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js'); // 创建共享线程
new SharedWorker('./sharedWorker.js'); // 连接共享线程
new SharedWorker('./sharedWorker.js'); // 连接共享线程
```

类似地，因为下面三个脚本字符串都解析到相同的 `URL`，所以也只会创建一个共享工作者线程：

```js
new SharedWorker('./sharedWorker.js'); 							// 创建共享线程
new SharedWorker('sharedWorker.js'); 							// 连接共享线程
new SharedWorker('https://www.example.com/sharedWorker.js'); 	// 连接共享线程
```

因为可选的工作者线程名称也是共享工作者线程标识的一部分，所以不同的线程名称会强制浏览器创建多个共享工作者线程。对下面的例子而言，一个名为 `'foo'`，另一个名为 `'bar'`，尽管它们同源且脚本 `URL` 都相同：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 一个线程名称为'foo'，一个线程名称为'bar' 
*/
new SharedWorker('./sharedWorker.js', {name: 'foo'}); // 创建'foo'共享线程（加载并且执行脚本）
new SharedWorker('./sharedWorker.js', {name: 'foo'}); // 连接'foo'共享线程（不加载和执行脚本）
new SharedWorker('./sharedWorker.js', {name: 'bar'}); // 创建'bar'共享线程（加载并且执行脚本）
```

共享线程，顾名思义，可以在不同标签页、不同窗口、不同内嵌框架或同源的其他工作者线程之间共享。因此，下面的脚本如果在多个标签页运行，则只会在第一次执行时创建一个共享工作者线程，后续执行将会连接到该线程：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js');
```

初始化共享线程的脚本只会限制 `URL`，因此下面的代码会创建两个共享工作者线程，尽管加载了相同的脚本：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- '?'导致了两个不同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js'); 	// 创建共享线程（加载并且执行脚本）
new SharedWorker('./sharedWorker.js?');	// 创建共享线程（加载并且执行脚本）
```

如果该脚本在两个不同的标签页中运行，同样也只会创建两个共享工作者线程。每个构造函数都会检查匹配的共享工作者线程，然后连接到已存在的那个。

##### 使用线程

`SharedWorker()` 构造函数返回的 `SharedWorker` 对象被用作与新创建的共享线程通信的连接点。它可以用来通过 `MessagePort` 在共享工作者线程和父上下文间传递信息，也可以用来捕获共享线程中发出的错误事件。

`SharedWorker` 对象支持以下属性。

- `onerror`：在共享线程中发生 `ErrorEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 此事件会在共享线程抛出错误时发生。
  - 此事件也可以通过使用 `sharedWorker.addEventListener('error', handler)` 处理。
- `port`：专门用来跟共享线程通信的 `MessagePort`。

##### 全局作用域

在共享线程内部，全局作用域是 `SharedWorkerGlobalScope` 的实例。因为继承自 `WorkerGlobalScope`，所以包括它所有的属性和方法。与专用工作者线程一样，共享工作者线程也可以通过 `self` 关键字访问该全局上下文。

`SharedWorkerGlobalScope` 通过以下属性和方法扩展了 `WorkerGlobalScope`。

- `name`：可选的字符串标识符，可以传给 `SharedWorker` 构造函数。
- `importScripts()`：用于向共享线程中导入任意数量的脚本。
- `close()`：与 `worker.terminate()` 对应，用于立即终止工作者线程（实际上可能并不会立即终止）。
- `onconnect`：与共享线程建立新连接时触发的事件。`connect` 事件对象包含 `MessagePort` 实例的 `ports` 数组，可用于从共享线程内部把消息发送回父上下文。
  - 在通过 `worker.port.onmessage` 或 `worker.port.start()` 与共享线程建立连接时都会触发 `connect` 事件。
  - `connect` 事件也可以通过使用 `sharedWorker.addEventListener('connect', handler)` 处理。

注意：根据浏览器实现，在 `SharedWorker` 中把日志打印到控制台不一定能在默认的控制台中看到结果（如 `Chrome` 和 `Edge`）。



#### 生命周期

共享工作者线程的生命周期具有与专用工作者线程相同的阶段的特性。不同之处在于，专用工作者线程只跟一个页面绑定，页面关闭后，其专用线程也会立即终止；而共享工作者线程可跟多个页面绑定，且只要还有一个上下文连接就会持续存在。

比如下面的代码，每次调用它都会创建一个专用工作者线程：

```js
new Worker('./worker.js');
```

下表详细列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么。

|       事件        |      结果       | 事件发生后的线程数 |
| :---------------: | :-------------: | :----------------: |
| 标签页 1 执行代码 | 创建专用线程 1  |         1          |
| 标签页 2 执行代码 | 创建专用线程 2  |         2          |
| 标签页 3 执行代码 | 创建专用线程 3  |         3          |
|   标签页 1 关闭   | 专用线程 1 终止 |         2          |
|   标签页 2 关闭   | 专用线程 2 终止 |         1          |
|   标签页 3 关闭   | 专用线程 3 终止 |         0          |

如上表所示，`new Worker('./worker.js');` 的执行次数、打开标签页数和运行的线程数是对等关系。下面再来看看这个简单的代码，每次执行它都会创建或者连接到共享线程：

```js
new SharedWorker('./sharedWorker.js');
```

下表列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么。

|       事件        |                          结果                           | 事件发生后的线程数 |
| :---------------: | :-----------------------------------------------------: | :----------------: |
| 标签页 1 执行代码 |                     创建共享线程 1                      |         1          |
| 标签页 2 执行代码 |                     连接共享线程 1                      |         1          |
| 标签页 3 执行代码 |                     连接共享线程 1                      |         1          |
|   标签页 1 关闭   |                 断开与共享线程 1 的连接                 |         1          |
|   标签页 2 关闭   |                 断开与共享线程 1 的连接                 |         1          |
|   标签页 3 关闭   | 断开与共享线程 1 的连接。没有连接了，因此终止共享线程 1 |         0          |

如上表所示，标签页 2 和标签页 3 再次调用 `new SharedWorker('./sharedWorker.js');` 会连接到已有线程。随着连接的增加和移除，浏览器会记录连接总数。在连接数为 0 时，线程被终止。

关键在于，没有办法以编程方式终止共享线程。前面已经交代过，`SharedWorker` 对象上没有 `terminate()` 方法。然而，在共享线程端口（稍后讨论）上调用 `close()` 时，只要还有一个端口连接此共享线程就不会真的终止它。

`SharedWorker` 的“连接”与关联的 `MessagePort` 或 `MessageChannel` 的状态无关。只要建立了连接，浏览器就会负责管理该连接。建立的连接会在页面的生命周期内持续存在，只有当页面销毁且没有连接时，浏览器才会终止共享线程。



#### 连接共享

每次调用 `SharedWorker()` 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 `connect` 事件。如下所示：

```js
// main.js 
for (let i = 0; i < 5; ++i) { 
 	new SharedWorker('./sharedWorker.js'); 
} 

// sharedWorker.js 
let i = 0; // 该代码只会被执行一次
self.onconnect = () => console.log(`connected ${++i} times`); // 每次连接线程时，都会触发该事件。

/* 
> connected 1 times 
> connected 2 times 
> connected 3 times 
> connected 4 times 
> connected 5 times
*/
```

发生 `connect` 事件时，`SharedWorker()` 构造函数会隐式创建 `MessageChannel` 实例，并把 `MessagePort` 实例的所有权唯一地转移给该 `SharedWorker` 的实例。这个 `MessagePort` 实例会保存在 `connect` 事件对象的 `ports` 数组中。每次连接共享线程时都会触发该事件，因此 `ports` 数组的长度总是等于 1。

下面的代码演示了访问事件对象的 `ports` 数组。这里使用了 `Set` 来保证只跟踪唯一的对象实例：

```js
// sharedWorker.js 
const connectedPorts = new Set(); 
self.onconnect = ({ports}) => { 
 	connectedPorts.add(ports[0]); 
 	console.log(`${connectedPorts.size} unique connected ports`); 
}; 

// main.js 
for (let i = 0; i < 5; ++i) { 
 	new SharedWorker('./sharedWorker.js'); 
} 

/*
> 1 unique connected ports 
> 2 unique connected ports 
> 3 unique connected ports 
> 4 unique connected ports 
> 5 unique connected ports
*/
```

关键在于，共享线程与父上下文的启动和关闭不是对称的。每个新的 `SharedWorker` 连接都会触发一个事件，但没有事件对应断开 `SharedWorker` 实例的连接（如页面关闭）。

在前面的例子中，随着与相同共享线程连接和断开连接的页面越来越多，`connectedPorts` 集合中会受到死端口的污染，且没有办法识别它们。一个解决方案是在 `beforeunload` 事件即将销毁页面时，明确发送卸载消息，让共享线程有机会清除死端口。



#### 线程通信

共享线程上自带一个 `port` 属性（保存着一个 `MessagePort` 实例），专门用来在共享线程间通信。

```js
// ports.js
self.onconnect = ({ ports }) => {
    ports[0].postMessage('port'); 	// 利用端口发送消息
    self.postMessage('thread'); 	// 利用线程发送消息
}; 

// main.js
const sharedWorker = new SharedWorker('./port.js');
// 使用线程监听消息
sharedWorker.onmessage = ({data}) => {
    console.log('thread', data);
}
// 使用端口监听消息
sharedWorker.port.onmessage = ({data}) => {
    console.log('port', data);
}
```

注意，共享线程上没有 `postMessage()` 方法，所以它们只能通过端口互相通信，不能与其他线程直接通信。



### 服务工作者线程

服务线程（`service worker`）是一种类似在浏览器中代理服务器的线程，它可以拦截外出请求和缓存响应。这可以让网页在没有网络连接的情况下正常使用，因为部分或全部页面可以从服务工作者线程的缓存中获得服务。服务工作者线程也可以使用 `Notifications API`、`Push API`、`Background Sync API` 和 `Channel Messaging API`。

与共享工作者线程类似，来自一个域的多个页面可以共享一个服务工作者线程。不过，为了使用 `Push API` 等特性，服务工作者线程也可以在相关的标签页或浏览器关闭后继续等待到来的推送事件。

无论如何，对于大多数开发者而言，服务工作者线程在两个主要任务上最有用：充当网络请求的缓存层和启用推送通知。在这个意义上，服务工作者线程就是用于把网页变成像原生应用程序一样的工具。

注意：服务工作者线程涉及的内容极其广泛，几乎可以单独写一本书。为了更好地理解它，推荐有条件的读者学一下 `Udacity` 的课程 `“Offline Web Applications”`。除此之外，也可以参考 `Mozilla` 维护的 `Service Worker Cookbook` 网站，其中包含了常见的服务工作者线程模式。

注意：服务工作者线程的生命周期取决于打开的同源标签页（称为“客户端”）数量、页面是否发生导航，以及服务脚本是否改变（以及其他一些因素）。如果对服务工作者线程的生命周期认识不够，本节的一些例子可能会让人觉得出乎意料。本节的《生命周期》详细解释了服务工作者线程的生命周期。另外，在调试服务工作者线程时，要谨慎使用浏览器的强制刷新功能（`Ctrl+Shift+R`）。强制刷新会强制浏览器忽略所有网络缓存，而服务工作者线程对大多数主流浏览器而言就是网络缓存。



#### 线程基础

作为一种工作者线程，服务工作者线程与专用工作者线程和共享工作者线程拥有很多共性。比如，在独立上下文中运行，只能通过异步消息通信。不过，服务工作者线程与专用工作者线程和共享工作者线程还是有很多本质区别的。

##### 线程集装箱

服务工作者线程与专用工作者线程或共享工作者线程的一个区别是没有全局构造函数，服务工作者线程被保存到一个集装箱中，通过 `ServiceWorkerContainer` 来管理，它的实例被保存在 `navigator.serviceWorker` 属性中。该对象是个顶级接口，通过它可以让浏览器创建、更新、销毁或者与服务工作者线程交互。

```js
console.log(navigator.serviceWorker); // ServiceWorkerContainer {controller: null, ready: Promise, ...}
```

##### 线程注册证

与共享线程类似，服务线程同样是在不存在时创建新实例，在存在时连接到已有实例。`ServiceWorkerContainer` 没有提供全局构造函数创建，而是暴露了 `register()` 方法，该方法以与 `Worker()` 或 `SharedWorker()` 构造函数相同的方式传递脚本 `URL`：

```js
// main.js
// 注册服务线程
navigator.serviceWorker.register('./emptyServiceWorker.js'); // 首次注册时，加载和执行脚本
```

`register()` 方法返回一个期约，该期约解决为 `ServiceWorkerRegistration` 对象（服务线程注册证），或在注册失败时拒绝。线程注册证上的 `active` 属性就是被激活的服务线程实例，默认为 `null`。

```js
// main.js 
// 注册成功，成功回调（解决）
navigator.serviceWorker.register('./emptyServiceWorker.js').then(console.log, console.error); 
// ServiceWorkerRegistration { ... } 

// 使用不存在的文件注册，失败回调（拒绝）
navigator.serviceWorker.register('./doesNotExist.js').then(console.log, console.error);
// TypeError: Failed to register a ServiceWorker for scope ('http://127.0.0.1:60446/') with script ('http://127.0.0.1:60446/doesNotExist.js'): A bad HTTP response code (404) was received when fetching the script.
```

服务线程对于何时注册是比较灵活的。在第一次调用 `register()` 激活服务线程后，后续在同一页面使用相同 `URL` 对 `register()` 的调用实际上不会再加载和执行脚本，而是直接连接到这个活跃的服务线程。此外，即使浏览器未全局支持服务工作者线程，服务工作者线程本身对页面也应该是不可见的。这是因为它的行为类似代理，就算有需要它处理的操作，也仅仅是发送常规的网络请求而已。

考虑到上述情况，注册服务工作者线程的一种非常常见的模式是基于特性检测，并在页面的 `load` 事件中进行。比如：

```js
if ('serviceWorker' in navigator) { 
    // 当页面加载完毕后，注册服务线程
 	window.addEventListener('load', () => { 
 		navigator.serviceWorker.register('./serviceWorker.js'); 
 	}); 
}
```

如果没有 `load` 事件这个门槛，服务工作者线程的注册就会与页面资源的加载重叠，进而拖慢初始页面渲染的过程。除非该服务工作者线程负责管理缓存（这样的话就需要尽早注册，比如使用本章稍后会讨论的 `clients.claim()`），否则等待 `load` 事件是个明智的选择，这样同样可以发挥服务工作者线程的价值。

##### 使用集装箱

`ServiceWorkerContainer` 接口是浏览器对服务线程生态的顶部封装。它为管理服务工作者线程的状态和生命周期提供了便利，始终可以在客户端上下文中访问，其 `controller` 就是与页面关联的被激活的服务线程：

```js
console.log(navigator.serviceWorker); 
/*
ServiceWorkerContainer {
	controller: null,
	oncontrollerchange: null,
	onmessage: null,
	onmessageerror: null,
	ready: Promise {<pending>},
	[[Prototype]]: ServiceWorkerContainer {
		controller: null,
		getRegistration: ƒ getRegistration(),
		getRegistrations: ƒ getRegistrations(),
		oncontrollerchange: null,
		onmessage: null,
		onmessageerror: null,
		ready: null,
		register: ƒ register(),
		startMessages: ƒ startMessages(),
		constructor: ƒ ServiceWorkerContainer(),
		Symbol(Symbol.toStringTag): "ServiceWorkerContainer",
		get controller: ƒ controller(),
		get oncontrollerchange: ƒ oncontrollerchange(),
		set oncontrollerchange: ƒ oncontrollerchange(),
		get onmessage: ƒ onmessage(),
		set onmessage: ƒ onmessage(),
		get onmessageerror: ƒ onmessageerror(),
		set onmessageerror: ƒ onmessageerror(),
		get ready: ƒ ready(),
		[[Prototype]]: EventTarget
	}
}
*/
```

`ServiceWorkerContainer` 支持以下事件处理程序。

- `oncontrollerchange`：在 `ServiceWorkerContainer` 触发 `controllerchange` 事件时会调用指定的事件处理程序。
  - 此事件在获得新激活的 `ServiceWorkerRegistration` 时触发。
  - 此事件也可以使用 `navigator.serviceWorker.addEventListener('controllerchange', handler)` 处理。
- `onerror`：在关联的服务工作者线程触发 `ErrorEvent` 错误事件时会调用指定的事件处理程序。
  - 此事件在关联的服务工作者线程内部抛出错误时触发。
  - 此事件也可以使用 `navigator.serviceWorker.addEventListener('error', handler)` 处理。

- `onmessage`：在服务工作者线程触发 `MessageEvent` 事件时会调用指定的事件处理程序。
  - 此事件在服务脚本向父上下文发送消息时触发。
  - 此事件也可以使用 `navigator.serviceWorker.addEventListener('message', handler)` 处理。


`ServiceWorkerContainer` 支持下列属性。

- `ready`：返回期约，解决为激活的 `ServiceWorkerRegistration` 对象。该期约不会拒绝。
- `controller`：返回与当前页面关联的激活的 `ServiceWorker` 对象，如果没有激活的服务工作者线程则返回 `null`。

`ServiceWorkerContainer` 支持下列方法。

- `register()`：使用接收的 `url` 和 `options` 对象创建或更新 `ServiceWorkerRegistration` 对象。
- `getRegistration()`：返回期约，解决为与提供的作用域匹配的 `ServiceWorkerRegistration` 对象；如果没有匹配的服务工作者线程则返回 `undefined`。
- `getRegistrations()`：返回一个期约，解决为与 `ServiceWorkerContainer` 关联的 `ServiceWorkerRegistration` 对象的数组；如果没有关联的服务工作者线程则返回空数组。
- `startMessage()`：开始传送通过 `Client.postMessage()` 派发的消息。

##### 使用注册证

`ServiceWorkerRegistration` 对象表示注册成功的服务工作者线程。通过它的一些属性可以确定关联的服务线程的生命周期状态。

如前所述，调用 `navigator.serviceWorker.register()` 返回的期约会在注册成功时解决为 `ServiceWorkerRegistration` 对象（注册对象）。然而，在同一页面使用同一 `URL` 多次调用该方法会返回相同的注册对象，它们会接入该服务线程。

```js
(async () => {
    const c1 = await navigator.serviceWorker.register('./test.js'); // 激活服务线程
    const c2 = await navigator.serviceWorker.register('./test.js'); // 连接服务线程

    console.log(c1 === c2); // true
})(); 
```

线程注册证不会轻易更换。因此，默认情况下，使用其他 `URL` 来注册新的服务线程时也不会更换注册对象，而是接入它的线程。

```js
(async () => {
    const c1 = await navigator.serviceWorker.register('./test1.js'); // 激活服务线程
    const c2 = await navigator.serviceWorker.register('./test2.js'); // 连接服务线程

    console.log(c1 === c2); // true
})(); 
```

一个常见的 `ServiceWorkerRegistration` 对象，如下所示。其中，`active` 属性就是被激活的服务线程实例。

```
ServiceWorkerRegistration {
	active: ServiceWorker {scriptURL: 'http://127.0.0.1:60446/test.js', state: 'activated', ...},
	backgroundFetch: BackgroundFetchManager {},
	cookies: CookieStoreManager {},
	installing: null,
	navigationPreload: NavigationPreloadManager {},
	onupdatefound: null,
	paymentManager: PaymentManager {userHint: ''},
	periodicSync: PeriodicSyncManager {},
	pushManager: PushManager {},
	scope: "http://127.0.0.1:60446/",
	sync: SyncManager {},
	updateViaCache: "imports",
	waiting: null,
	[[Prototype]]: ServiceWorkerRegistration {
		active: ServiceWorker,
		backgroundFetch: BackgroundFetchManager,
		cookies: CookieStoreManager,
		getNotifications: ƒ getNotifications(),
		installing: null,
		navigationPreload: NavigationPreloadManager,
		onupdatefound: null,
		paymentManager: PaymentManager,
		periodicSync: PeriodicSyncManager,
		pushManager: PushManager,
		scope: "http://127.0.0.1:60446/",
		showNotification: ƒ showNotification(),
		sync: SyncManager,
		unregister: ƒ unregister(),
		update: ƒ update(),
		updateViaCache: "imports",
		waiting: null,
		constructor: ƒ ServiceWorkerRegistration(),
		Symbol(Symbol.toStringTag): "ServiceWorkerRegistration",
		get active: ƒ active(),
		get backgroundFetch: ƒ backgroundFetch(),
		get cookies: ƒ cookies(),
		get installing: ƒ installing(),
		get navigationPreload: ƒ navigationPreload(),
		get onupdatefound: ƒ onupdatefound(),
		set onupdatefound: ƒ onupdatefound(),
		get paymentManager: ƒ paymentManager(),
		get periodicSync: ƒ periodicSync(),
		get pushManager: ƒ pushManager(),
		get scope: ƒ scope(),
		get sync: ƒ sync(),
		get updateViaCache: ƒ updateViaCache(),
		get waiting: ƒ waiting(),
		[[Prototype]]: EventTarget
	}
}
```

`ServiceWorkerRegistration` 支持以下事件处理程序。

- `onupdatefound`：在服务工作者线程触发 `updatefound` 事件时会调用指定的事件处理程序。
  - 此事件会在服务工作者线程开始安装新版本时触发，表现为 `ServiceWorkerRegistration.installing` 收到一个新的服务工作者线程。
  - 此事件也可以使用 `serviceWorkerRegistration.addEventListener('updatefound', handler)` 处理。

`ServiceWorkerRegistration` 支持以下通用属性。

- `scope`：返回服务工作者线程作用域的完整 `URL` 路径，它是服务线程注册证的唯一标识。该值来源于接收服务脚本的路径和在 `register()` 中提供的作用域。
- `navigationPreload`：返回与注册对象关联的 `NavigationPreloadManager` 实例。
- `pushManager`：返回与注册对象关联的 `PushManager` 实例。

`ServiceWorkerRegistration` 还支持以下属性，可用于判断服务工作者线程处于生命周期的什么阶段。

- `installing`：如果有则返回状态为 `installing`（安装中）的服务工作者线程，否则为 `null`。
- `waiting`：如果有则返回状态为 `waiting`（等待中）的服务工作者线程，否则为 `null`。
- `active`：如果有则返回状态 `activating` 或 `active`（活动中）的服务工作者线程，否则为 `null`。

注意，这些属性都是服务工作者线程状态的一次性快照。这在大多数情况下是没有问题的，因为活动状态的服务工作者线程在页面的生命周期内不会改变状态，除非强制这样做（比如调用 `ServiceWorkerGlobalScope.skipWaiting()`）。

`ServiceWorkerRegistration` 支持下列方法。

- `getNotifications()`：返回期约，解决为 `Notification` 对象的数组。
- `showNotifications()`：显示通知，可以配置 `title` 和 `options` 参数。
- `update()`：直接从服务器重新请求服务脚本，如果新脚本不同，则重新初始化。
- `unregister()`：取消服务工作者线程的注册。该方法会在服务工作者线程执行完毕后再取消注册。

##### 使用线程

`ServiceWorker` 对象可以通过两种方式获得：通过服务线程集装箱的 `controller` 属性和通过服务线程注册证的 `active` 属性。该对象继承自 `Worker` 原型，因此包括其所有属性和方法，但没有 `terminate()` 方法。

```js
console.log(navigator.serviceWorker.controller); 
/* 
ServiceWorker {
	onerror: null,
	onstatechange: null,
	scriptURL: "http://127.0.0.1:61290/test.js",
	state: "activated",
	[[Prototype]]: ServiceWorker {
		onerror: null,
		onstatechange: null,
		postMessage: ƒ postMessage(),
		scriptURL: "http://127.0.0.1:61290/test.js",,
		state: "activated",
		constructor: ƒ ServiceWorker(),
		Symbol(Symbol.toStringTag): "ServiceWorker",
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		get onstatechange: ƒ onstatechange(),
		set onstatechange: ƒ onstatechange(),
		get scriptURL: ƒ scriptURL(),
		get state: ƒ state(),
		[[Prototype]]: EventTarget
	}
}
*/
```

`ServiceWorker` 支持以下事件处理程序。

- `onstatechange`：`ServiceWorker` 发生 `statechange` 事件时会调用指定的事件处理程序。
  - 此事件会在 `ServiceWorker.state` 变化时发生。
  - 此事件也可以使用 `serviceWorker.addEventListener('statechange', handler)` 处理。


`ServiceWorker` 支持以下属性。

- `scriptURL`：解析后的注册服务线程的 `URL`。例如，如果服务工作者线程是通过相对路径 `'./serviceWorker.js'` 创建，且注册在 `https://www.example.com` 上的，则 `scriptURL` 属性将返回 `"https://www.example.com/serviceWorker.js"`。
- `state`：表示服务工作者线程状态的字符串，可能的值为：`"installing"`、`"installed"`、`"activating"`、`"activated"` 和 `"redundant"`。

##### 安全限制

与其他工作者线程一样，服务工作者线程也受加载脚本对应源的常规限制（参见前面《专用线程基本概念》一节）。此外，由于服务工作者线程几乎可以任意修改和重定向网络请求以及加载静态资源，所以服务工作者线程 `API` 只能在安全上下文（`HTTPS`）中使用。在非安全上下文（`HTTP`）中，`navigator.serviceWorker` 是 `undefined`。为方便开发，浏览器豁免了通过 `localhost` 或 `127.0.0.1` 在本地服务器中加载的页面。

注意：可以通过 `window.isSecureContext` 来确定当前上下文是否安全。由上可知，本地服务页面会被认为是安全的。

##### 全局作用域

在服务工作者线程内部，全局上下文是 `ServiceWorkerGlobalScope` 的实例。因为继承自 `WorkerGlobalScope`，所以拥有它的所有属性和方法。服务工作者线程脚本可以通过 `self` 关键字访问该全局上下文。

`ServiceWorkerGlobalScope` 通过以下属性和方法扩展了 `WorkerGlobalScope`。

- `caches`：返回服务工作者线程的 `CacheStorage` 对象（缓存仓库）。
- `clients`：返回服务工作者线程的 `Clients` 接口，用于访问底层 `Client` 对象（“客户端”）。
- `registration`：返回服务工作者线程的 `ServiceWorkerRegistration` 对象（注册证）。
- `skipWaiting()`：强制服务工作者线程跳过等待而进入活动状态；需要跟 `Clients.claim()` 一起使用。
- `fetch()`：在服务线程内发送常规网络请求；用于在服务线程确定有必要发送实际网络请求（而不是返回缓存值）时发送请求。

虽然专用工作者线程和共享工作者线程只有一个 `message` 事件作为输入，但服务工作者线程可以接收很多事件，包括页面操作和通知操作触发的事件或推送事件。

注意：根据浏览器实现，在 `SeviceWorker` 中把日志打印到控制台不一定能在浏览器默认控制台中看到。

服务工作者线程的全局作用域可以监听以下事件，这里进行了分类。

<img src="images/%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/image-20230419202225579.png" alt="image-20230419202225579" style="zoom:80%;" />  

注意：有些浏览器也支持 `async` 事件，该事件是在 `Background Sync API` 中定义的。但是 `Background Sync API` 还没有被标准化，目前只有 `Chrome` 和 `Opera` 支持，因此本章没介绍。

##### 作用域限制

服务工作者线程只能拦截其作用域内的客户端发送的请求。作用域是相对于获取服务脚本的路径定义的。如果没有在 `register()` 中指定，则作用域就是服务脚本的路径。更多参考：[`ServiceWorkerContainer: register() method`](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register) 

本节中涉及注册服务工作者线程的例子都使用脚本绝对 `URL`，以避免混淆。

下面第一个例子演示通过根目录获取服务脚本对应的默认根作用域：

```js
// 在 main.js 中
navigator.serviceWorker.register('/serviceWorker.js').then((serviceWorkerRegistration) => { 
 	console.log(serviceWorkerRegistration.scope); // https://example.com/ 
}); 

// 以下请求都会被拦截：
// fetch('/foo.js'); 
// fetch('/foo/fooScript.js'); 
// fetch('/baz/bazScript.js');
```

下面的例子演示了通过根目录获取服务脚本但指定了同一目录作用域：

```js
navigator.serviceWorker.register('/serviceWorker.js', {scope: './'}).then((serviceWorkerRegistration) => { 
 	console.log(serviceWorkerRegistration.scope); // https://example.com/ 
}); 

// 以下请求都会被拦截：
// fetch('/foo.js'); 
// fetch('/foo/fooScript.js'); 
// fetch('/baz/bazScript.js');
```

下面的例子演示了通过根目录获取服务脚本但限定了目录作用域：

```js
navigator.serviceWorker.register('/serviceWorker.js', {scope: './foo'}).then((serviceWorkerRegistration)=> { 
 	console.log(serviceWorkerRegistration.scope); // https://example.com/foo 
}); 

// 以下请求都会被拦截：
// fetch('/foo/fooScript.js'); 

// 以下请求都不会被拦截：
// fetch('/foo.js'); 
// fetch('/baz/bazScript.js');
```

下面的例子演示了通过嵌套的二级目录获取服务脚本对应的同一目录作用域：

```js
navigator.serviceWorker.register('/foo/serviceWorker.js').then((serviceWorkerRegistration) => { 
 	console.log(serviceWorkerRegistration.scope); // https://example.com/foo/ 
}); 

// 以下请求都会被拦截：
// fetch('/foo/fooScript.js'); 

// 以下请求都不会被拦截：
// fetch('/foo.js'); 
// fetch('/baz/bazScript.js');
```

服务线程的作用域实际上遵循了目录权限模型，即：只能相对于服务脚本所在路径（由第一个参数决定）缩小作用域。

```js
navigator.serviceWorker.register('/foo/test.js', {scope: '/foo/bar'}).then((serviceWorkerRegistration) => {
    console.log(serviceWorkerRegistration.scope); // http://127.0.0.1:53277/foo/bar
}); 
```

像下面这样扩展作用域会抛出错误：

```js
navigator.serviceWorker.register('/foo/serviceWorker.js', {scope: '/'}); 
// The path of the provided scope ('/') is not under the max scope allowed ('/foo/'). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.
```

通常，服务工作者线程作用域会使用末尾带斜杠的绝对路径来定义，比如：

```js
navigator.serviceWorker.register('/serviceWorker.js', {scope: '/foo/'})
```

这样定义作用域有两个目的：将脚本文件的相对路径与作用域的相对路径区分开，同时将该路径本身排除在作用域之外。例如，对于前面的代码片段而言，可能不需要在服务工作者线程的作用域中包含路径 `/foo`，在末尾加上一个斜杠就可以明确排除 `/foo`。当然，这要求绝对作用域路径不能扩展到服务工作者线程路径外。

如果想扩展服务工作者线程的作用域，主要有两种方式。

- 通过包含想要的作用域的路径提供（获取）服务脚本。
- 给服务脚本的响应添加 `Service-Worker-Allowed` 头部，把它的值设置为想要的作用域。该作用域值应该与 `register()` 中的作用域值一致。



#### 线程缓存

在服务工作者线程之前，网页缺少 **缓存网络请求** 的稳健机制。浏览器一直使用 `HTTP` 缓存，但 `HTTP` 缓存并没有对 `JavaScript` 暴露编程接口，且其行为是受 `JavaScript` 运行时外部控制的。可以开发临时缓存机制，缓存响应字符串或 `blob`，但这种策略比较麻烦且效率低。

`JavaScript` 缓存的实现之前也有过尝试。`MDN` 文档也介绍了：

> 之前的尝试，即 `AppCache`，看起来是个不错的想法，因为它可以非常容易地指定要缓存的资源。可是，它对你想要做的事情做了很多假设，当应用程序没有完全遵循这些假设时，它就崩溃了。

服务工作者线程的一个主要能力是可以通过编程方式实现真正的网络请求缓存机制。与 `HTTP` 缓存或 `CPU` 缓存不同，服务工作者线程缓存非常简单。

- 服务工作者线程缓存不会自动缓存任何请求。所有缓存都必须明确指定。
- 服务工作者线程缓存没有到期失效的概念。除非明确删除，否则缓存内容一直有效。
- 服务工作者线程缓存必须手动更新和删除。
- 缓存版本必须手动管理。每次服务工作者线程更新，新服务工作者线程负责提供新的缓存键以保存新缓存。
- 唯一的浏览器强制逐出策略也基于服务工作者线程缓存所占用的空间。服务工作者线程负责管理自己缓存占用的空间。缓存超过浏览器限制时，浏览器会基于最近最少使用（`LRU`，`Least Recently Used`）原则清理旧缓存，从而为新缓存腾出空间。

本质上，服务工作者线程缓存机制是一个 **双层字典**，其中顶级字典的条目映射到二级嵌套字典。顶级字典是 `CacheStorage` 对象，可以通过服务工作者线程全局作用域的 `caches` 属性访问。顶级字典中的每个值都是一个 `Cache` 对象，该对象也是个字典，是 `Request` 对象到 `Response` 对象的映射。【映射即 `Map`】

与 `LocalStorage` 一样，`Cache` 对象在 `CacheStorage` 字典中无限期地存在，会超出浏览器会话的界限。此外，`Cache` 条目只能以源为基础存取。

注意：虽然 `CacheStorage` 和 `Cache` 对象是在 `Service Worker` 规范中定义的，但它们也可在主线程或其他工作者线程中使用。

##### `CacheStorage`

`CacheStorage` 对象是映射到 `Cache` 对象的字符串键/值存储。`CacheStorage` 提供的 `API` 类似于异步 `Map`。`CacheStorage` 的接口通过全局对象的 `caches` 属性暴露出来。与 `LocalStorage` 一样，在浏览器的存储面板中也可以查看 `CacheStorage` 的内容。

```js
console.log(caches); // CacheStorage {}
/*
CacheStorage {
	[[Prototype]]: CacheStorage {
		delete: ƒ delete(),
		has: ƒ has(),
		keys: ƒ keys(),
		match: ƒ match(),
		open: ƒ open(),
		constructor: ƒ CacheStorage(),
		Symbol(Symbol.toStringTag): "CacheStorage",
		[[Prototype]]: Object
}
*/
```

`CacheStorage` 中的每个缓存可以通过给 `caches.open()` 传入相应字符串键取得。非字符串键会转换为字符串。如果缓存不存在，就会创建它（即：`Cache` 对象）。

`Cache` 对象是通过期约返回的：

```js
caches.open('v1').then(console.log); // Cache {}
/*
Cache {
	[[Prototype]]: Cache {
		add: ƒ add()
		addAll: ƒ addAll()
		delete: ƒ delete()
		keys: ƒ keys()
		match: ƒ match()
		matchAll: ƒ matchAll()
		put: ƒ put()
		constructor: ƒ Cache()
		Symbol(Symbol.toStringTag): "Cache"
		[[Prototype]]: Object
	}
}
*/
```

与 `Map` 类似，`CacheStorage` 也有 `has()`、`delete()` 和 `keys()` 方法。这些方法与 `Map` 上对应方法类似，但都基于期约。

```js
/*
	打开新缓存 v1 
	检查缓存 v1 是否存在
	检查缓存 v2 是否存在
*/
caches.open('v1') 
	.then(() => caches.has('v1')) 
	.then(console.log) // true
	.then(() => caches.has('v2')) 
	.then(console.log); // false

/* 
	打开新缓存 v1 
	检查缓存 v1 是否存在
	删除缓存 v1
	再次检查缓存 v1 是否存在
*/
caches.open('v1') 
	.then(() => caches.has('v1')) 
	.then(console.log) // true
	.then(() => caches.delete('v1')) 
	.then(() => caches.has('v1')) 
	.then(console.log); // false

/*
	打开缓存 v1、v3 和 v2
	检查当前缓存的键
	注意：缓存键按创建顺序输出
*/
caches.open('v1') 
	.then(() => caches.open('v3')) 
	.then(() => caches.open('v2')) 
	.then(() => caches.keys()) 
	.then(console.log); // ["v1", "v3", "v2"]
```

`CacheStorage` 接口还有一个 `match()` 方法，它可以根据 `Request` 对象搜索 `CacheStorage` 中的所有 `Cache` 对象。搜索顺序是 `CacheStorage.keys()` 的顺序，返回匹配到的第一个 `Response` 响应对象：

```js
// 创建一个请求键和两个响应值
const request = new Request(''); 
const response1 = new Response('v1'); 
const response2 = new Response('v2'); 

// 用同一个键创建两个缓存对象，最终会先找到 v1，因为它在 caches.keys() 的输出中排在前面
caches.open('v1') 
	.then((v1cache) => v1cache.put(request, response1)) 
	.then(() => caches.open('v2')) 
	.then((v2cache) => v2cache.put(request, response2)) 
	.then(() => caches.match(request)) 
	.then((response) => response.text()) 
	.then(console.log); // "v1"
```

`CacheStorage.match()` 可以接收一个 `options` 配置对象。下节将介绍该对象。

##### `Cache`

`CacheStorage` 通过字符串映射到 `Cache` 对象。`Cache` 对象跟 `CacheStorage` 一样，类似于异步的 `Map`。`Cache` 键可以是 `URL` 字符串，也可以是 `Request` 对象。这些键会映射到 `Response` 对象。

服务工作者线程缓存只会考虑缓存 `HTTP` 的 `GET` 请求。这是合理的，因为 `GET` 请求的响应通常不会随时间而改变。另一方面，默认情况下，`Cache` 不允许使用 `POST`、`PUT` 和 `DELETE` 等请求方法。这些方法意味着要与服务器动态交换信息，因此不适合客户端缓存。

为填充 `Cache`，可能会使用以下三个方法。

- `put(request, response)`：在键（`Request` 对象或 `URL` 字符串）和值（`Response` 对象）同时存在时用于添加缓存项。该方法返回期约，在添加成功后会解决。
- `add(request)`：在只有 `Request` 对象或 `URL` 时使用此方法发送 `fetch()` 请求，并缓存其响应。该方法返回期约，期约在添加成功后会解决。
- `addAll(requests)`：在希望填充全部缓存时使用，比如在服务线程初始化时也初始化缓存。该方法接收 `URL` 或 `Request` 对象的数组。`addAll()` 会对请求数组中的每一项分别调用 `add()`。该方法返回期约，在所有缓存内容添加成功后会解决。

与 `Map` 类似，`Cache` 也有 `delete()` 和 `keys()` 方法。这些方法与 `Map` 上对应方法类似，但都基于期约。

```js
const request1 = new Request('https://www.foo.com'); 
const response1 = new Response('fooResponse'); 

caches.open('v1').then((cache) => { 
    cache.put(request1, response1) 
        .then(() => cache.keys()) 
        .then(console.log) // [Request]
        .then(() => cache.delete(request1)) 
        .then(() => cache.keys()) 
        .then(console.log); // [] 
});
```

要检索 `Cache`，可以使用下面的两个方法。

- `matchAll(request, options)`：返回期约，期约解决为匹配缓存中 `Response` 对象的数组。
  - 此方法可对结构类似的缓存执行批量操作，如删除所有缓存在 `/images` 目录下的值。
  - 可以通过 `options` 对象配置请求匹配方式，本节稍后会介绍。
- `match(request, options)`：返回期约，期约解决为匹配缓存中的 `Response` 对象；如果没命中缓存则返回 `undefined`。
  - 本质上相当于 `matchAll(request, options)[0]`，只返回第一项。
  - 可以通过 `options` 对象配置请求匹配方式，本节稍后会介绍。

缓存是否命中取决于 `URL` 字符串或 `Request` 对象 `URL` 与缓存项的键是否匹配。`URL` 字符串和 `Request` 对象是可以互相替换的，因为匹配时也会提取 `Request` 对象的 `URL`。下面的例子演示了这种互换性：

```js
const request1 = 'https://www.foo.com'; 
const request2 = new Request('https://www.bar.com');
const response1 = new Response('fooResponse'); 
const response2 = new Response('barResponse'); 

caches.open('v1').then((cache) => { 
 	cache.put(request1, response1) 
 		.then(() => cache.put(request2, response2)) 
 		.then(() => cache.match(new Request('https://www.foo.com'))) 
 		.then((response) => response.text()) 
 		.then(console.log) // "fooResponse"
 		.then(() => cache.match('https://www.bar.com')) 
 		.then((response) => response.text()) 
 		.then(console.log); // "barResponse"
});
```

`Cache` 对象会使用 `Request` 和 `Response` 对象的 `clone()` 来方法创建它们的副本，并把这些副本存储为键/值对。下面的例子演示了这一点，从缓存中取得的键/值对并不等于原始的键/值实例：

```js
const request1 = new Request('https://www.foo.com'); 
const response1 = new Response('fooResponse'); 

caches.open('v1').then((cache) => { 
	cache.put(request1, response1) 
 		.then(() => cache.keys()) 
 		.then((keys) => console.log(keys[0] === request1)) // false 
 		.then(() => cache.match(request1)) 
 		.then((response) => console.log(response === response1)); // false 
});
```

`Cache.match()`、`Cache.matchAll()` 和 `CacheStorage.match()` 都支持可选的 `options` 对象，它允许通过设置以下属性来配置匹配 `URL` 时的行为。

- `cacheName`：只有 `CacheStorage.match()` 支持，用于在指定的 `Cache` 对象中匹配 `Url`。

```js
caches.match('https://www.foo.com', { cacheName: 'v1' }).then((response) => {
    console.log(response);
});
```

- `ignoreSearch`：设置为 `true` 后，在匹配 `URL` 时忽略其中的查询字符串片段，包括 `Request` 和 `URL` 字符串。例如，如果使用 `https://example.com/url?foo=bar` 则最终会匹配到 `https://example.com/url`。

```js
const request1 = new Request('https://www.foo.com/url');
const response1 = new Response('fooResponse');
const postRequest1 = new Request('https://www.foo.com/url?foo=bar');

caches.open('v1').then((cache) => {
    cache.put(request1, response1)
        .then(() => cache.match(postRequest1))
        .then(console.log) // undefined
        .then(() => cache.match(postRequest1, { ignoreSearch: true }))
        .then(console.log); // Response {}
});
```

- `ignoreMethod`：设置为 `true` 后，在匹配 `URL` 时忽略 `Request` 的请求方法。下面的例子展示了 `POST` 请求匹配 `GET` 请求：

```js
const request1 = new Request('https://www.foo.com'); 
const response1 = new Response('fooResponse'); 
const postRequest1 = new Request('https://www.foo.com', { method: 'POST' }); 

caches.open('v1').then((cache) => { 
 	cache.put(request1, response1) 
 		.then(() => cache.match(postRequest1)) 
 		.then(console.log) // undefined
 		.then(() => cache.match(postRequest1, { ignoreMethod: true })) 
 		.then(console.log); // Response {}
});
```

- `ignoreVary`：匹配时默认会考虑 `HTTP` 的 `Vary` 头部，它用于指定哪个请求头部将会导致服务器响应不同的值。`ignoreVary` 设置为 `true` 后，在匹配 `URL` 时就会忽略 `Vary` 头部。

```js
const request1 = new Request('https://www.foo.com'); 
const response1 = new Response('fooResponse', { headers: {'Vary': 'Accept' }}); 
const acceptRequest1 = new Request('https://www.foo.com', { headers: { 'Accept': 'text/json' }}); 

caches.open('v1').then((cache) => { 
 	cache.put(request1, response1) 
 		.then(() => cache.match(acceptRequest1)) 
 		.then(console.log) // undefined
 		.then(() => cache.match(acceptRequest1, { ignoreVary: true })) 
 		.then(console.log); // Response {}
});
```

##### 最大存储空间

浏览器需要限制缓存占用的磁盘空间，否则无限制地存储势必会造成滥用。对于该存储空间的限制没有任何规范定义，完全由浏览器供应商的个人喜好决定。

使用 `StorageEstimate API` 可以近似地获悉还有多少空间可用（以字节为单位），以及当前使用了多少空间。此方法只在安全上下文中可用：

```js
navigator.storage.estimate().then(console.log); 

/* 不同浏览器的输出可能不同：
> Chrome：{quota: 142328141414, usage: 1024, usageDetails: {caches: 1024}}
> Firefox：{ quota: 10737418240, usage: 850565 }
> Edge：{quota: 142328141414, usage: 512, usageDetails: {caches: 512}}
*/
```

根据 `Service Worker` 规范：这些并不是确切的数值，考虑到压缩、去重和混淆等安全原因，该数字并不精确。



#### 线程客户端

服务工作者线程会使用 `Client` 对象跟踪关联的窗口、工作线程或服务工作者线程，服务线程的客户端，包括：`Window`、`Worker` 和 `SharedWorker`，分别表示浏览器标签页、专用线程和共享线程。服务工作者线程可以通过 `Clients` 接口访问这些 `Client` 对象。该接口暴露在全局上下文的 `self.clients` 属性上。

```
Clients {
	[[Prototype]]: Clients {
		claim: ƒ claim(),
		get: ƒ (),
		matchAll: ƒ matchAll(),
		openWindow: ƒ openWindow(),
		constructor: ƒ Clients(),
		Symbol(Symbol.toStringTag): "Clients",
		[[Prototype]]: Object
	}
}
```

`Clients` 接口支持通过 `get()` 或 `matchAll()` 访问 `Client` 对象，这两个方法都通过期约返回结果。

- `get()`：用于获取一个与给定 `id` 匹配的 `service worker` 客户端，并在 `Promise` 中返回它。
- `matchAll()`：返回一个 `service worker Client` 对象列表的 `Promise`。提供 `options` 参数时返回所有与关联的 `service worker` 的起源相同的 `service worker` 客户端。如果不提供 `options`，则该方法只返回由 `service worker` 控制的 `service worker` 客户端。

```js
// 给 get() 传入客户端的 id 标识值
self.clients.get(id).then((client) => {
  	self.clients.openWindow(client.url);
});
```

`matchAll()` 方法接收一个可选的 `options` 对象，该对象支持使用以下配置属性。

- `includeUncontrolled`：在设置为 `true` 时，返回结果将包含不受当前服务工作者线程控制的客户端。默认为 `false`。
- `type`：设置要匹配的客户端类型。取值为 `"window"`、`"worker"`、`"sharedworker"` 和 `"all"`。默认为 `"window"`。

```js
clients.matchAll().then((clientList) => {
	console.log(clientList);
});

clients.matchAll(options).then((clientList) => {
  	for (const client of clientList) {
    	if (client.url === "index.html") {
      		clients.openWindow(client);
            // or do something else involving the matching client
    	}
  	}
});
```

`Clients` 接口也支持以下方法。

- `openWindow(url)`：创建一个新的顶级浏览上下文（即：`window` 窗口）并加载给定的 `URL`。如果调用脚本没有显示弹出窗口的权限，`openWindow()` 将抛出 `InvalidAccessError`。该方法在新窗口中打开指定的 `URL`，实际上会给当前服务工作者线程添加一个新的 `Client`。这个新 `Client` 对象以解决的期约形式返回。该方法可用于回应点击通知的操作，此时服务工作者线程可以检测单击事件并作为响应打开一个窗口。
- `claim()`：该方法允许活动的服务工作者线程将自己设置为其作用域中所有客户端的控制器，这会在 `navigator` 对象上触发一个 `controllerchange` 事件，然后被控制的任何客户端中的服务线程都将被该服务线程所控制。当一个 `service worker` 被初始注册时，页面在被重新加载之前都不会使用它。`claim()` 方法使这些页面立即被控制。请注意，这会导致你的服务线程所控制的页面在网络中被定期地加载，或者可能通过不同的服务线程加载。强制性设置当前服务工作者线程以控制其作用域中的所有客户端。`claim()` 可用于让服务线程立即开始管理页面，而不需要等待页面重新加载。【`claim`：索取、认领】

下面是使用 `openWindow()` 方法的一个例子，来源于 `MDN`。

```js
// Send notification to OS if applicable
if (self.Notification.permission === "granted") {
  	const notificationObject = {
    	body: "Click here to view your messages.",
    	data: { url: `${self.location.origin}/some/path` }, // data: { url: 'http://example.com' }
  	};
  	self.registration.showNotification("You've got messages!", notificationObject);
}

// Notification click event listener
self.addEventListener("notificationclick", (e) => {
  	// Close the notification popout
  	e.notification.close();
  	// Get all the Window clients
  	e.waitUntil(
    	clients.matchAll({ type: "window" }).then((clientsArr) => {
      		// If a Window tab matching the targeted URL already exists, focus that;
      		const hadWindowToFocus = clientsArr.some((windowClient) =>
        		windowClient.url === e.notification.data.url ? (windowClient.focus(), true) : false
      		);
      		// Otherwise, open a new tab to the applicable URL and focus it.
      		if (!hadWindowToFocus)
        		clients.openWindow(e.notification.data.url).then((windowClient) => (
                    windowClient ? windowClient.focus() : null
                ));
    	})
  	);
});
```

下面的例子在服务线程的 `"activate"` 事件监听器中使用了 `claim()`，这样在同一个作用域中加载的客户端在通过这个服务线程获取之前就不需要重新加载了。

```js
self.addEventListener("activate", (event) => {
  	event.waitUntil(clients.claim()); // 当此服务线程进入活动状态后，立即控制其作用域中的所有页面（即：“客户端”）
});
```

`Client` 对象支持以下属性和方法。

- `id`：返回客户端的全局唯一标识符。可用于通过 `Clients.get()` 获取指定客户端的引用。
- `type`：返回表示客户端类型的字符串。`type` 可能的值是 `"window"`、`"worker"` 或 `"sharedworker"`。
- `url`：返回客户端的 `URL`。
- `frameType`：指示客户端浏览上下文的类型。可取值有 `"auxiliary"`、`"top-level"`、`"nested"` 或 `"none"`。
- `postMessage()`：允许服务线程向客户端发送消息。该消息在 `navigator.serviceWorker` 的 `"message"` 事件中接收。

```js
// 从服务线程向客户端发送消息
addEventListener("fetch", (event) => {
  	event.waitUntil((async () => {
    	// Exit early if we don't have access to the client. Eg, if it's cross-origin.
      	if (!event.clientId) return;

		// Get the client.
      	const client = await clients.get(event.clientId);
      	// Exit early if we don't get the client. Eg, if it closed.
      	if (!client) return;

      	// Send a message to the client.
      	client.postMessage({
        	msg: "Hey I just got a fetch from you!",
        	url: event.request.url,
      	});
    })());
});

navigator.serviceWorker.addEventListener("message", (event) => {
  	console.log(event.data.msg, event.data.url);
});
```

注释，这里直接使用 `addEventListener` 完全等同于调用 `self.addEventListener`，因为它们都是在给顶级上下文添加事件。



#### 线程一致性

理解服务工作者线程的最终用途是十分重要的，即：让网页能够模拟原生应用程序。要做到像原生应用程序一样，服务工作者线程就必须支持版本控制（`versioning`）。

从全局角度说，服务工作者线程的版本控制可以确保任何时候两个网页的操作都有一致性。该一致性可以表现为如下两种形式。

- 代码一致性。网页不是像原生应用程序那样基于一个二进制文件创建，而是由很多 `HTML`、`CSS`、`JavaScript`、图片、`JSON`，以及页面可能加载的任何类型的文件创建。网页经常会递增更新，即版本升级，以增加或修改行为。如果网页总共加载了 100 个文件，而加载的资源同时来自第 1 版和第 2 版，那么就会导致完全无法预测，而且很可能出错。服务工作者线程为此提供了一种强制机制，确保来自同源的所有并存页面始终会使用来自相同版本的资源。
- 数据一致性。网页并非与外界隔绝的应用程序。它们会通过各种浏览器 `API` 如 `LocalStorage` 或 `IndexedDB` 在本地读取和写入数据；也会向远程 `API` 发送请求并获取数据。这些获取和写入数据的格式在不同版本中可能也会变化。如果一个页面以第 1 版中的格式写入了数据，第二个页面以第 2 版中的格式读取该数据就会导致无法预测的结果甚至出错。服务工作者线程的资源一致性机制可以保证网页输入/输出行为对同源的所有并存网页都相同。

为确保一致性，服务工作者线程的生命周期不遗余力地避免出现有损一致性的现象。比如下面这些可能。

- 服务工作者线程提早失败。在安装服务工作者线程时，任何预料之外的问题都可能导致服务线程安装失败。包括：服务脚本加载失败、服务脚本中存在语法或运行时错误、无法通过 `importScripts()` 加载工作者线程依赖，甚至加载某个缓存资源失败。
- 服务工作者线程激进更新。当浏览器再次加载服务脚本时（无论通过 `register()` 手动加载还是基于页面重载），如果服务脚本或通过 `importScripts()` 加载的依赖发生了变化（哪怕有一个字节的差异），都会启动安装新版本的服务工作者线程。
- 未激活的服务工作者线程消极活动。当页面上第一次调用 `register()` 时，服务工作者线程会被安装，但不会被激活，并且在导航事件发生前不会控制页面。这应该是合理的：可以认为当前页面已经加载了资源，因此服务工作者线程不应该被激活，否则就会加载不一致的资源。
- 活动的服务工作者线程粘连。只要有一个客户端关联着这个活动的服务工作者线程，浏览器就会在该源的所有页面中使用它。浏览器可以安装新的服务线程来替代这个活动线程，但浏览器在活动线程所关联的客户端为 0（或强制更新服务工作者线程）之前都不会切换到新的服务线程。这个服务工作者线程逐出策略能够防止两个客户端同时运行两个不同版本的服务工作者线程。



#### 生命周期

`Service Worker` 规范定义了服务工作者线程可能存在的 6 种状态，包括：已解析（`parsed`）、安装中（`installing`）、已安装（`installed`）、激活中（`activating`）、已激活（`activated`）和已失效（`redundant`）。注意，服务线程注册证上不包含处于已解析和已失效状态的服务线程实例，只包含处于安装和激活状态的服务线程实例（分别对应着 `installing`、`waiting` 和 `active` 这 3 个属性）。完整的服务工作者线程生命周期会以该顺序进入相应状态，尽管有可能不会进入每个状态。安装或激活服务工作者线程时遇到错误会跳到已失效状态。更多参考：[`service worker` 实现离线缓存](https://www.infoq.cn/article/geVZkkhue8bki9PFvPxe) 

上述状态的每次变化都会在 `ServiceWorker` 对象上触发 `statechange` 事件，可以像下面这样为它添加一个事件处理程序：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => {
    // 在处于安装中状态的服务线程上添加此事件的监听器
 	registration.installing.onstatechange = ({ target: { state } }) => { 
 		console.log('state changed to', state); 
 	};
});
```

##### 已解析状态

调用 `navigator.serviceWorker.register()` 会启动创建服务工作者线程实例的过程。刚创建的服务工作者线程实例会立即进入已解析状态，所以该状态没有事件，也没有与之相关的 `ServiceWorker.state` 值。

注意：虽然已解析（`parsed`）是 `Service Worker` 规范正式定义的一个状态，但 `ServiceWorker.prototype.state` 永远不会返回 `"parsed"`。通过该属性能够返回的最早阶段是 `"installing"`。

浏览器获取脚本文件，然后执行一些初始化任务，服务工作者线程的生命周期就开始了。

​	（1）确保服务脚本来自相同的源。

​	（2）确保在安全上下文中注册服务工作者线程。

​	（3）确保服务脚本可以被浏览器 `JavaScript` 解释器成功解析而不会抛出任何错误。

​	（4）捕获服务脚本的快照。浏览器再次下载服务脚本时会与这个快照进行差异对比，并据此决定是否应该更新这个服务线程。

所有这些任务全部成功，`register()` 返回的期约就会解决为一个 `ServiceWorkerRegistration` 对象。然后这个新创建的服务工作者线程实例会进入到安装中状态。

##### 安装中状态

安装中（`installing`）状态是执行所有服务线程设置任务的状态。这些任务包括在服务线程控制页面之前必须完成的操作。

在客户端，这个阶段可以通过检查 `ServiceWorkerRegistration.installing` 是否被设置为 `ServiceWorker` 实例来确定：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	if (registration.installing) { 
        // 服务线程正处于安装中状态
 		console.log('Service worker is in the installing state'); 
 	} 
});
```

与之关联的 `ServiceWorkerRegistration` 对象也会在服务工作者线程到达此状态时触发 `updatefound` 事件：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => {
    registration.onupdatefound = () => {
        // 服务线程正处于安装中状态
        console.log('Service worker is in the installing state');
    }; 
});
```

在服务工作者线程中，这个阶段则可以通过给 `install` 事件添加处理程序来确定：

```js
self.oninstall = (installEvent) => { 
    // 服务线程正处于安装中状态
 	console.log('Service worker is in the installing state'); 
};
```

安装中状态频繁用于填充服务工作者线程的缓存。服务工作者线程在成功缓存指定资源之前可以一直处于该状态。如果有任何资源缓存失败，服务工作者线程都会安装失败并跳至已失效状态。

服务工作者线程可以通过 `ExtendableEvent` 停留在安装中状态（或者说进入等待中状态以等待安装完成）。`ExtendableEvent` 暴露了一个 `waitUntil()` 方法，允许将状态过渡延迟到指定的期约解决。由于 `InstallEvent` 继承自 `ExtendableEvent`，因此可以调用 `ExtendableEvent.waitUntil()` 方法，该方法接收一个期约参数，会将状态过渡延迟到这个期约解决。例如，下面的例子可以在延迟 5 秒后再将状态过渡到已安装状态：

```js
self.oninstall = (installEvent) => {
    // 状态等待直到期约解决
 	installEvent.waitUntil( 
 		new Promise((resolve, reject) => setTimeout(resolve, 5000)) 
 	); 
};
```

实际中更常用的例子是通过 `Cache.addAll()` 在缓存一组资源之后再过渡状态：

```js
const CACHE_KEY = 'v1'; 

self.oninstall = (installEvent) => { 
 	installEvent.waitUntil( 
 		caches.open(CACHE_KEY).then((cache) => cache.addAll([ 
 			'foo.js', 
 			'bar.html', 
 			'baz.css', 
 		])) 
 	); 
};
```

如果所有资源被成功缓存，没有错误发生或者被拒绝，服务工作者线程就会前进到已安装状态。

##### 已安装状态

等待中（`waiting`）状态，用于等待服务线程安装完毕，此时服务工作者线程没有别的事件要做，只是等待在服务线程安装完成后将其推入已安装（`installed`）状态。如果浏览器中已没有活动的服务工作者线程，则 **新安装的服务工作者线程会跳到这个状态，并直接进入激活中状态**，因为（安装已经完成）没有必要再等了。

在客户端，这个阶段可以通过检查 `ServiceWorkerRegistration.waiting` 是否被设置为一个 `ServiceWorker` 实例来确定：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => {
    if (registration.installing) {
        registration.installing.onstatechange = ({ target: { state } }) => { 
            console.log('state changed to', state); 
            if (registration.waiting) { 
                // 服务线程正处于已安装状态
                console.log('Service worker is in the installing/waiting state'); 
            }
        };
    }
});
```

如果新建了一个活动的服务工作者线程，则已安装状态是触发逻辑的好时机，这样会把这个新服务工作者线程推进到激活中状态。使浏览器推进服务线程的状态可以通过 `self.skipWaiting()` 强制推进，也可以通过提示用户重新加载应用程序。

##### 激活中状态

激活中（`activating`）状态表示服务工作者线程已经被浏览器选中即将变成可以控制页面的服务工作者线程。如果浏览器中没有活动的服务工作者线程，则这个新服务工作者线程会自动到达激活中状态。如果有一个活动服务工作者线程，则这个作为替代的服务工作者线程可以通过如下方式进入激活中状态。

- 原有服务工作者线程控制的客户端数量变为 0。这通常意味着所有受控的浏览器标签页都被关闭。在下一个导航事件触发时，新服务工作者线程立即会到达激活中状态。
- 在已安装的服务工作者线程中直接调用 `self.skipWaiting()`。这样可以立即进入激活中状态，而不必等待一次导航事件。

在客户端，这个阶段大致可以通过检查 `ServiceWorkerRegistration.active` 是否被设置为一个 `ServiceWorker` 实例来确定：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	if (registration.active) { 
 		console.log('Service worker is in the activating/activated state'); 
 	} 
});
```

注意，`ServiceWorkerRegistration.active` 属性表示服务工作者线程可能在激活中状态，也可能在已激活状态。但在激活中状态下，不能像在已激活状态中那样执行发送请求或推送事件的操作。

在这个服务工作者线程内部，可以通过给 `activate` 事件添加处理程序来获悉：

```js
self.onactivate = (activateEvent) => { 
 	console.log('Service worker is in the activating state'); 
};
```

`activate` 事件表示此时可以将老的服务工作者线程清理掉了，该事件经常用于清除旧缓存数据和迁移数据库。例如，下面的代码清除了所有版本比较老的缓存：

```js
const CACHE_KEY = 'v3'; 

self.onactivate = (activateEvent) => { 
 	caches.keys()
        .then((keys) => keys.filter((key) => key !== CACHE_KEY)) 
 		.then((oldKeys) => oldKeys.forEach((oldKey) => caches.delete(oldKey)); 
};
```

`ActivateEvent` 也继承自 `ExtendableEvent`，因此也支持 `waitUntil()` 方法，可以延迟过渡到已激活状态，或者基于期约拒绝过渡到已失效状态。

注意：服务工作者线程中的 `activate` 事件并不代表服务工作者线程正在控制客户端，因为它也可能处于激活中状态。

##### 已激活状态

已激活（`activated`）状态表示服务工作者线程此时正在控制一个或多个客户端。在这个状态下，服务工作者线程会捕获其作用域中的 `fetch()` 事件、通知和推送事件。

在客户端，这个阶段大致可以通过检查 `ServiceWorkerRegistration.active` 是否被设置为一个 `ServiceWorker` 实例来确定：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	if (registration.active) { 
 		console.log('Service worker is in the activating/activated state'); 
 	}
});
```

如前所述，`ServiceWorkerRegistration.active` 属性表示服务工作者线程此时可能在激活中状态，也可能在已激活状态。

更可靠的确定服务工作者线程处于已激活状态一种方式是检查 `ServiceWorkerRegistration` 的 `controller` 属性。该属性会返回已激活的 `ServiceWorker` 实例，即：当前正在控制页面的服务线程实例。

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	if (registration.controller) { 
 		console.log('Service worker is in the activated state'); 
 	} 
});
```

在使用新服务工作者线程控制客户端时，该客户端中的 `ServiceWorkerContainer` 会触发 `controllerchange` 事件：

```js
navigator.serviceWorker.oncontrollerchange = () => { 
 	console.log('A new service worker is controlling this client'); 
};
```

另外，也可以使用 `ServiceWorkerContainer.ready` 期约来检测活动服务工作者线程。该期约会在当前页面拥有活动工作者线程时立即解决：

```js
navigator.serviceWorker.ready.then(() => { 
 	console.log('A new service worker is controlling this client'); 
});
```

##### 已失效状态

已失效状态表示服务工作者线程已被宣布死亡。不会再有事件发送给它，浏览器随时可能销毁它并回收它的资源。

##### 更新服务线程

因为版本控制的概念根植于服务工作者线程的整个生命周期，所以服务工作者线程会随着版本变化。为此，服务工作者线程提供了稳健同时也复杂的流程，以安装替换过时的服务工作者线程。

这个更新流程的初始阶段是更新检查，也就是浏览器重新请求服务脚本。以下事件可以触发更新检查。

- 使用与创建当前活动服务工作者线程时不一样的 `URL` 调用 `register()` 注册新的服务线程。
- 浏览器导航到服务工作者线程作用域中的一个页面。
- 发生了 `fetch()` 或 `push()` 等功能性事件，且至少 24 小时内没有发生更新检查。

新获取的服务脚本会与当前服务工作者线程的脚本比较差异。如果不相同，浏览器就会用新脚本初始化一个新的服务工作者线程。更新的服务工作者线程进入自己的生命周期，直至抵达已安装状态。到达已安装状态后，更新服务工作者线程会等待浏览器决定让它安全地获得页面的控制权（或用户强制它获得页面控制权）。

关键在于，刷新页面不会让更新服务工作者线程进入激活状态并取代已有的服务工作者线程。比如，有个打开的页面，其中有一个服务工作者线程正在控制它，而一个更新服务工作者线程正在已安装状态中等待。客户端在页面刷新期间会发生重叠，即：旧页面还没有卸载，新页面已经加载了。然而，现有的服务工作者线程永远不会让出控制权，毕竟至少还有一个客户端在它的控制之下。为此，**取代现有服务工作者线程的唯一方式就是关闭所有受控页面**。



#### 控制反转与线程持久化

虽然专用线程和共享线程都是有状态的，但服务线程是无状态的。更具体地说，服务工作者线程遵循控制反转（`IoC`，`Inversion of Control`）模式并且是事件驱动的。

这样就意味着服务工作者线程不应该依赖工作者线程的全局状态。服务工作者线程中的绝大多数代码应该在事件处理程序中定义。当然，服务工作者线程的版本作为全局常量是个显而易见的例外。服务脚本执行的次数变化很大，高度依赖浏览器状态，因此服务脚本的行为应该是幂等的。

理解服务工作者线程的生命周期与它所控制的客户端的生命周期无关是非常重要的。大多数浏览器将服务工作者线程实现为独立的进程，而该进程由浏览器单独控制。如果浏览器检测到某个服务工作者线程空闲了，就可以终止它并在需要时再重新启动。这意味着可以依赖服务工作者线程在激活后处理事件，但不能依赖它们的持久化全局状态。



#### 管理服务文件缓存

正常情况下，浏览器加载的所有 `JavaScript` 资源会按照它们的 `Cache-Control` 头部纳入 `HTTP` 缓存管理。因为服务脚本没有优先权，所以浏览器不会在缓存文件失效前接收更新的服务脚本。

为了尽可能传播更新后的服务脚本，常见的解决方案是在响应服务脚本时设置 `Cache-Control: max-age=0` 头部。这样浏览器就能始终取得最新的脚本文件。

这个即时失效的方案能够满足需求，但仅仅依靠 `HTTP` 头部来决定是否更新意味着只能由服务器控制客户端。为了让客户端能控制自己的更新行为，可以通过在 `register()` 的第二个参数中指定 `updateViaCache` 属性来设置客户端对待服务脚本的方式。可取的值是如下三个字符串值。

- `imports`：该值是默认值。顶级服务脚本永远不会被缓存，但通过 `importScripts()` 在服务工作者线程内部导入的文件会按照 `Cache-Control` 头部设置纳入 `HTTP` 缓存管理。
- `all`：服务脚本没有任何特殊待遇。所有文件都会按照 `Cache-Control` 头部设置纳入 `HTTP` 缓存管理。
- `none`：顶级服务脚本和通过 `importScripts()` 在服务工作者线程内部导入的文件永远都不会被缓存。

可以像下面这样使用 `updateViaCache` 属性：

```js
navigator.serviceWorker.register('/serviceWorker.js', { 
 	updateViaCache: 'none' 
});
```

浏览器仍在渐进地支持这个选项，因此强烈推荐读者同时使用 `updateViaCache` 和 `CacheControl` 头部指定客户端的缓存行为。



#### 强制操作

某些情况下，有必要尽可能快地让服务工作者线程进入已激活状态，即使可能会造成资源版本控制不一致。该操作通常适合在安装事件中缓存资源，此时要强制服务工作者线程进入活动状态，然后再强制活动服务工作者线程去控制关联的客户端。

实现上述操作的基本代码如下。

```js
const CACHE_KEY = 'v1'; 

self.oninstall = (installEvent) => { 
 	// 填充缓存，然后强制服务工作者线程进入已激活状态，这样会触发 activate 事件
 	installEvent.waitUntil(
        caches.open(CACHE_KEY).then(
            (cache) => cache.addAll([ 
                'foo.css', 
                'bar.js', 
            ])
        ).then(() => self.skipWaiting()) 
 	); 
}; 

// 强制服务工作者线程接管客户端，这会在每个客户端触发 controllerchange 事件
self.onactivate = (activateEvent) => clients.claim();
```

浏览器会在每次导航事件中检查新服务脚本，但有时候仅仅这样也太不够了。`ServiceWorkerRegistration` 对象为此提供了一个 `update()` 方法，可以用来告诉浏览器去重新获取服务脚本，与现有的比较，然后必要时安装更新的服务工作者线程。可以这样来实现：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	// 每 15 分钟左右检查一个更新版本
 	setInterval(() => registration.update(), 9 * 1E5); 
});
```



#### 线程消息

与专用工作者线程和共享工作者线程一样，服务工作者线程也能与客户端通过 `postMessage()` 交换消息。实现通信的最简单方式是向活动工作者线程发送一条消息，然后使用事件对象发送回应。发送给服务工作者线程的消息可以在全局作用域处理，而发送回客户端的消息则可以在 `ServiceWorker` 对象上处理：

```js
// serviceWorker.js 
self.onmessage = ({data, source}) => { 
 	console.log('service worker heard:', data); 
 	source.postMessage('bar'); // 向服务线程的客户端发送消息
}; 

// main.js 
navigator.serviceWorker.onmessage = ({data}) => { 
 	console.log('client heard:', data); 
}; 
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	if (registration.active) { 
 		registration.active.postMessage('foo'); // 向服务线程发送消息
 	} 
}); 

/*
> service worker heard: foo 
> client heard: bar
*/
```

也可以简单地使用 `serviceWorker.controller` 属性：

```js
// serviceWorker.js（只在初始执行，后续刷新不再执行）
self.onmessage = ({data, source}) => { 
 	console.log('service worker heard:', data); 
 	source.postMessage('bar'); 
}; 

// main.js（每次刷新都会执行）
navigator.serviceWorker.onmessage = ({data}) => { 
 	console.log('client heard:', data); 
}; 
navigator.serviceWorker.register('./serviceWorker.js').then(() => { 
 	if (navigator.serviceWorker.controller) { 
 		navigator.serviceWorker.controller.postMessage('foo');
 	} 
}); 
```

这个例子在每次页面重新加载时都会运行。这是因为服务工作者线程会回应每次刷新后客户端脚本发送的消息。在通过新标签页打开这个页面时也一样。

如果服务工作者线程需要率先发送消息，可以像下面这样获得客户端的引用：

```js
// serviceWorker.js 
self.onmessage = ({data}) => { 
 	console.log('service worker heard:', data); 
}; 
// 获得客户端的引用（activate只会响应一次）
self.onactivate = () => { 
 	self.clients.matchAll({includeUncontrolled: true})
        .then((clientMatches) => clientMatches[0].postMessage('foo')); 
}; 

// main.js 
navigator.serviceWorker.onmessage = ({data, source}) => { 
 	console.log('client heard:', data); 
 	source.postMessage('bar'); 
}; 
navigator.serviceWorker.register('./serviceWorker.js'); 
```

这个例子只会运行一次，因为活动事件在每个服务工作者线程上只会触发一次。

因为客户端和服务工作者线程可以相互之间发送消息，所以通过 `MessageChannel` 或 `BroadcastChannel` 实现通信也是可能的。



#### 拦截请求

服务工作者线程最重要的一个特性就是拦截网络请求。服务工作者线程作用域中的网络请求会注册为 `fetch` 事件。这种拦截能力不限于 `fetch()` 方法发送的请求，也能拦截对 `JavaScript`、`CSS`、图片和 `HTML`（包括对主 `HTML` 文档本身）等资源发送的请求。这些请求可以来自 `JavaScript`，也可以通过 `<script>`、`<link>` 或 `<img>` 标签创建。直观地说，这样是合理的：如果想让服务工作者线程模拟离线应用程序，它就必须能够把控页面在正常运行中所需的所有请求资源。

`FetchEvent` 继承自 `ExtendableEvent`。让服务工作者线程能够决定如何处理 `fetch` 事件的方法是 `event.respondWith()`。该方法接收期约，该期约会解决为一个 `Response` 对象。当然，该 `Response` 对象实际上来自哪里完全由服务工作者线程决定。可以来自网络，来自缓存，或者动态创建。下面几节将介绍几种网络/缓存策略，可以在服务工作者线程中使用。

##### 从网络返回

该策略就是简单地转发 `fetch` 事件。那些确实需要发送到服务器的请求（如 `POST`）就很适合该策略。可以像这样实现这一策略：

```js
self.onfetch = (fetchEvent) => { 
    // 当缓存中没有相应的资源时，可以使用这个策略
 	fetchEvent.respondWith(fetch(fetchEvent.request)); // 将请求转发到服务器，然后从服务器中获取所需的资源
};
```

这个例子只演示了如何使用 `event.respondWith()`。如果没有触发 `self.onfetch` 或者 `event.respondWith()` 没有被调用，浏览器也会一如既往地通过网络发送请求，就像根本就不存在服务线程一样。

##### 从缓存返回

这个策略其实就是缓存检查。对于任何肯定有缓存的资源（如在安装阶段缓存的资源），可以采用该策略：

```js
self.onfetch = (fetchEvent) => { 
    // 当缓存中拥有相应的资源时，可以使用这个策略
 	fetchEvent.respondWith(caches.match(fetchEvent.request)); // 直接在缓存中查找所需的资源
};
```

#####  从网络返回，缓存作后备

这个策略把从网络获取最新的数据作为首选，但如果缓存中有值也会返回缓存的值。如果应用程序需要尽可能展示最新数据，但在离线的情况下仍要展示一些信息时，就可以采用该策略：

```js
self.onfetch = (fetchEvent) => { 
    // 优先从网络中获取最新的资源，若获取失败，则使用缓存中的已有资源
 	fetchEvent.respondWith(fetch(fetchEvent.request).catch(() => caches.match(fetchEvent.request))); 
};
```

##### 从缓存返回，网络作后备

这个策略优先考虑响应速度，但仍会在没有缓存的情况下发送网络请求。这是大多数渐进式 `Web` 应用程序（`PWA`，`Progressive Web Application`）采取的首选策略：

```js
self.onfetch = (fetchEvent) => { 
    // 优先从缓存中获取相应的资源，若没有，则从网络中获取资源
 	fetchEvent.respondWith(
        caches.match(fetchEvent.request).then((response) => response || fetch(fetchEvent.request)) 
 	); 
};
```

##### 通用后备

应用程序需要考虑缓存和网络都不可用的情况。服务工作者线程可以在安装时缓存后备资源，然后在缓存和网络都失败时返回它们：

```js
self.onfetch = (fetchEvent) => { 
    // 优先从缓存中获取相应的资源，若没有，则从网络中获取资源，若获取失败，则使用在安装时缓存的后备资源。
 	fetchEvent.respondWith( 
 		caches.match(fetchEvent.request)
        	.then((response) => response || fetch(fetchEvent.request)) 
        	.catch(() => caches.match('/fallback.html')) 
 	); 
};
```

这里的 `catch()` 子句可以扩展为支持不同类型的后备，例如点位图、哑数据，等等。

注意：`Jake Archibald` 在 `Google Developers` 网站有一篇关于网络/缓存策略的好文章《离线指南》。



#### 推送通知

对于模拟原生应用程序的 `Web` 应用程序而言，必须支持推送消息。这意味着网页必须能够接收服务器的推送事件，然后在设备上显示通知（即使应用程序没有运行）。当然，这在常规网页中肯定是不可能的。不过，有了服务工作者线程之后就可以实现该行为。

为了在 `PWA` 应用程序中支持推送通知，必须支持以下 4 种行为。

- 服务工作者线程必须能够显示通知。
- 服务工作者线程必须能够处理与这些通知的交互。
- 服务工作者线程必须能够订阅服务器发送的推送通知。
- 服务工作者线程必须能够处理推送消息，即使应用程序没在前台运行或者根本没打开。

更多参考：[服务器主动推送消息数据给客户端](https://blog.csdn.net/weixin_38582851/article/details/121516452) 

##### 显示通知

服务工作者线程可以通过它们的注册对象来使用 `Notification API`。这样做有很好的理由：与服务工作者线程关联的通知也会触发服务工作者线程内部的交互事件。

显示通知要求向用户明确地请求授权。授权完成后，可以通过 `ServiceWorkerRegistration.showNotification()` 显示通知。下面是一个示例实现：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
    // 获取通知权限
 	Notification.requestPermission().then((status) => { 
 		if (status === 'granted') { 
			registration.showNotification('foo'); 
 		} 
 	}); 
});
```

类似地，在服务工作者线程内部可以使用全局 `registration` 属性触发（显示）通知：

```js
self.onactivate = () => self.registration.showNotification('bar');
```

在上面的例子中，获得显示通知的授权后，会把 `foo` 通知显示在浏览器中。该通知与使用 `new Notification()` 创建的通知看不出有任何差别。此外，显示该通知不需要服务工作者线程额外做任何事情。服务工作者线程只在需要处理通知事件时才会发挥作用。

##### 处理通知事件

通过 `ServiceWorkerRegistration` 对象创建的通知，会向服务工作者线程发送 `notificationclick` 和 `notificationclose` 事件。假设前面例子中的服务脚本定义了如下事件处理程序：

```js
self.onnotificationclick = ({notification}) => { 
 	console.log('notification click', notification); 
}; 

self.onnotificationclose = ({notification}) => {
     console.log('notification close', notification); 
};
```

在这个例子中，与通知相关的两种交互操作（点击和关闭）都在服务工作者线程中注册了处理程序。这里的 `notification` 事件对象暴露了 `notification` 属性，其中包含着生成该事件 `Notification` 对象。这些处理程序可以决定交互操作之后的响应方式。

一般来说，单击通知意味着用户希望转到某个具体的页面。在服务工作者线程处理程序中，可以通过 `clients.openWindow()` 打开相应的 `URL`，例如：

```js
self.onnotificationclick = ({notification}) => { 
 	clients.openWindow('https://foo.com'); // 在新窗口中打开此 URL
};
```

##### 订阅推送事件

对于发送给服务工作者线程的推送消息，必须通过服务工作者线程的 `PushManager` 来订阅。这样服务工作者线程就可以在 `push` 事件处理程序中处理推送消息。

下面展示了使用 `ServiceWorkerRegistration.pushManager` 订阅推送消息的例子：

```js
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	registration.pushManager.subscribe({ 
 		applicationServerKey: key, // 来自服务器的公钥
 		userVisibleOnly: true 
 	}); 
});
```

另外，服务工作者线程也可以使用全局的 `registration` 属性自己订阅：

```js
self.onactivate = () => { 
 	self.registration.pushManager.subscribe({ 
 		applicationServerKey: key, // 来自服务器的公钥
 		userVisibleOnly: true 
 	}); 
};
```

##### 处理推送事件

订阅之后，服务工作者线程会在每次服务器推送消息时收到 `push` 事件。这时候它可以这样来处理：

```js
self.onpush = (pushEvent) => { 
 	console.log('Service worker was pushed data:', pushEvent.data.text()); 
};
```

为实现真正的推送通知，这个处理程序只需要通过注册对象创建一个通知即可。不过，完善的推送通知还需要创建它的服务工作者线程保持足够长时间的活动，以便处理后续的交互事件。

要实现这一点，`push` 事件继承了 `ExtendableEvent`。可以把 `showNotification()` 返回的期约传给 `waitUntil()`，这样就会让服务工作者线程一直活动到通知的期约解决。

下面展示了实现上述逻辑的简单框架：

```js
// main.js 
navigator.serviceWorker.register('./serviceWorker.js').then((registration) => { 
 	// 请求显示通知的授权
 	Notification.requestPermission().then((status) => {
     	if (status === 'granted') { 
			// 如果获得授权，只订阅推送消息
			registration.pushManager.subscribe({ 
				applicationServerKey: key, // 来自服务器的公钥
				userVisibleOnly: true 
			}); 
 		} 
 	}); 
}); 

// ServiceWorker.js 
// 收到推送事件后，在通知中以文本形式显示数据
self.onpush = (pushEvent) => { 
 	// 保持服务工作者线程活动到通知期约解决
 	pushEvent.waitUntil(self.registration.showNotification(pushEvent.data.text())); 
}; 
// 如果用户单击通知，则打开相应的应用程序页面
self.onnotificationclick = ({notification}) => { 
 	clients.openWindow('https://example.com/clicked-notification'); 
};
```



### 小结

工作者线程可以运行异步 `JavaScript` 而不阻塞用户界面。这非常适合复杂计算和数据处理，特别是因为需要花费较长时间而会影响用户界面处理任务的速度。工作者线程有自己独立的环境，只能通过异步消息与外界通信。

工作者线程可以是专用线程和共享线程。专用线程只能由一个页面使用，而共享线程则可以由同源的任意个页面共享。

服务工作者线程用于让网页模拟原生应用程序。服务工作者线程也是一种工作者线程，但它们更像是网络代理，而非独立的浏览器线程。可以把它们看成是高度定制化的网络缓存，它们也可以在 `PWA` 中支持推送通知。

