# 队列

队列，就像排队中的一条长列一样，它只在队尾插入数据，且只在队首删除数据。于是，呈现出：先进先出，后进后出的规律。



### 实现

##### 简单实现

```js
class Queue {
    constructor() {
        this.queue = [];
    }
    // 入队
    enqueue(...items) {
        this.queue.push(...items);
    }
    // 静态出队
    getFirst() {
        if(!this.size()) return console.warn("队已空");
        return this.queue[0];
    }
    // 动态出队
    dequeue() {
        if(!this.size()) return console.warn("队已空");
        return this.queue.shift();
    }
    // 清空队列
    clear() {
        this.queue = [];
    }
    // 队长
    size() {
        return this.queue.length;
    }
}
```

使用

```js
let queue = new Queue();

// 单条存储
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);

// 批量存储
queue.enqueue(1, 2, 3);

// 静态读取
queue.getFirst(); // 1

// 动态读取
console.log(queue.dequeue()); // 1
console.log(queue.dequeue()); // 2
console.log(queue.dequeue()); // 3
console.log(queue.dequeue()); // "队已空", undefined

// 清空队
queue.clear();

// 队长度
queue.size(); // 0
```

##### 隐藏封装

```js
const Queue = (function() {
    let sym = Symbol();
    return class Queue {
        constructor() {
            this[sym] = [];
        }
        // 入队
        enqueue(...items) {
            this[sym].push(...items);
        }
        // 静态出队
        getFirst() {
            if(!this.size()) return console.warn("队已空");
            return this[sym][0];
        }
        // 动态出队
        dequeue() {
            if(!this.size()) return console.warn("队已空");
            return this[sym].shift();
        }
        // 清空队列
        clear() {
            this[sym] = [];
        }
        // 队长
        size() {
            return this[sym].length;
        }
    }
})();
```



### 应用

##### 动画队列







