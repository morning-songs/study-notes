# 处理非 `JS` 文件

`webpack` 默认只处理 `js` 文件（通常将其合并为一个文件），其他的文件则不会处理。

要使 `webpack` 能够处理非 `js` 的文件，就必须使用相应的 `loader` 来对它们继续处理。

`webpack` 对于无法处理的文件或资源，不做任何处理，而是使它们在项目中保持原样。



### 基础概念

##### 输出目录

`webpack` 默认将 `js` 文件打包到 `dist` 目录中。因此，项目中所用到的所有文件（无论是 `js` 还是非 `js`）以及资源（图片、音视频等）最终都应该被打包到该目录中。当文件和资源都被打包到 `dist` 目录中之后，打包后的项目便可以以 `dist` 目录为根目录引用其资源了。

##### 资源替换

`webpack` 会采用特定的算法对打包资源的路径进行重新分配，然后使用这些新的资源路径覆盖原先的旧资源路径，从而完成资源替换。

##### 构建依赖

`webpack` 默认以 `js` 文件之间的依赖关系，来构建项目的依赖关系图。因此，要想文件或资源被构建到这张依赖图中，就必须将它们导入到 `js` 文件去使用。

##### 模块配置

在模块中构建好资源的依赖关系后，就需要对模块进行配置了。在 `webpack.config.js` 配置文件中，通过定义 `module` 项配置模块。

```js
module.exports = {
    module: {
        // 配置模块
    }
}
```

更多参考：[`module` 配置](https://webpack.docschina.org/configuration/module/) 



### 处理 `CSS`

更多参考：[样式 `loader`](https://webpack.docschina.org/loaders/#styling) 

#### 引入 `css`

##### 原生方式

原先，我们使用 `link` 标签的 `rel` 和 `href` 属性来链接外部的 `css` 文件。

`webpack` 不能处理 `css` 文件。因此，它不会将 `css` 文件打包到项目中去。

当项目打包上线后，就会导致项目的 `css` 文件丢失。最好的办法就是，使 `css` 文件能够被打包并且以正确的方式被引入到项目中。

当然，如果是直接写在 `html` 里面的页面级样式，`webpack` 也不会处理，而是使其保持原样。因此，页面级样式在打包后不会丢失。

```html
<!-- 打包前后：-->
<style>
    body {
        background-color: #ccc;
    }
</style>
```

##### 构建依赖

为了将 `css` 文件打包到项目中使用，首先就需要将它导入到一个 `js` 文件中使用，让该 `js` 文件对它形成依赖。

```js
import "./css/index.css"
```

#### 载入程序

`webpack` 不能处理 `css`。因此，在导入 `css` 文件后，必须使用相应的 `css` 载入程序（`loader`）来解析 `css` 文件，否则会报错。

载入 `css` 的基本思路是：

1. 解析 `import` 的 `css` 文件，返回其中的 `css` 代码。然后，在模块中导出 `css` 代码。
2. 将模块中导出的 `css` 代码添加到 `DOM` 中使用。

##### 解析 `css`

解析导入的 `css` 文件，使用 `css-loader`。它会解析 `css` 文件并返回其中的 `css` 代码，最终在模块中导出 `css` 代码。

安装 `css-loader`：

```shell
npm i css-loader --save-dev
```

更多参考：[`css-loader`](https://webpack.docschina.org/loaders/css-loader) 

##### 插入 `css`

使用 `style-loader`，可将模块导出的 `css` 代码添加到 `DOM` 中去使用。它会将 `css` 代码插入到 `<style>` 元素中作为页面样式使用。

```shell
npm i style-loader --save-dev
```

更多参考：[`style-loader`](https://webpack.docschina.org/loaders/style-loader) 

#### 模块配置

使用 `css-loader` 和 `style-loader` 载入程序时，需要对模块进行配置。

##### 定义规则

通过 `rules` 定义处理规则。`rules` 是一个规则数组，其元素是一个个规则对象。

在规则对象中定义规则：

- `test`：指定处理哪些文件，允许使用正则表达式。
- `use`：指定使用哪些 `loader` 来处理 `test` 匹配到的文件。

```js
module.exports = {
    module: {
        // 定义处理规则
        rules: [
            // 定义解析css的loader规则
            {
                test: /\.css$/i, // 匹配css文件
                use: ["style-loader", "css-loader"] // 指定使用css-loader和style-loader来处理匹配到的文件
            }
        ]
    }
}
```

注意：`use` 是一个 `loader` 数组，具有严格的顺序。`use` 数组的使用顺序为 —— 从右到左，即：先使用 `css-loader` 解析并导出 `css` 代码，再使用 `style-loader` 接收 `css` 代码并将其插入到页面的 `<style>` 元素中。

#### 高级语法

当在项目中使用 `less` 和 `sass` 等高级 `css` 语法时，也需要使用相应的 `loader` 将这些高级语法的代码编译为 `css` 代码。

##### `less`

```js
import "./less/index.less" // 构建依赖关系
```

使用 `less-loader`，可以将 `less` 代码编译成 `css` 代码。安装 `less`（`less-loader` 的核心）和 `less-loader`：

```shell
npm i less less-loader --save-dev
```

定义使用 `less-loader` 的规则：

```js
module.exports = {
    module: {
        rules: [
            // 定义编译less的loader规则
            {
                test: /\.less$/i, // 匹配less文件
                use: ["style-loader", "css-loader", "less-loader"] // 将less编译成css，然后将css插入style元素
            }
        ]
    }
}
```



### 处理资源

`webpack` 对于资源同样无法处理的。因此，它不会自动将资源打包到项目中。这在项目上线后，就会造成资源的丢失。

`webpack 5` 内置了处理资源的模块，其中有 4 种模块类型。

- `asset/resource`：发送一个单独的文件并导出 `URL`。之前通过使用 `file-loader` 实现。
- `asset/inline`：导出一个资源的 `data URI`。之前通过使用 `url-loader` 实现。
- `asset/source`：导出资源的源代码。之前通过使用 `raw-loader` 实现。
- `asset`：在导出一个 `data URI` 和发送一个单独的文件之间自动选择。之前通过使用 `url-loader`，并且配置资源体积限制实现。

有了这些资源模块之后，就不需要再安装其他的 `loader` 了。直接对各种资源进行模块配置，便可以使用资源模块处理相应的资源了。

以上 4 中模块类型的主要作用如下：

- `asset/resource`：将 `import` 导入的文件打包到项目中之后，返回其新文件的 `Url` 地址。
- `asset/inline`：将 `import` 导入的文件采用特定的算法编码成一个 `data URI` 字符串。
- `asset/source`：将 `import` 导入的文件采用相应的算法转换成源代码文本。
- `asset`：根据 `import` 导入文件的体积大小，自动在 `resource` 和 `inline` 之间做选择。

更多参考：[资源模块](https://webpack.docschina.org/guides/asset-modules/#root) 

#### 图片资源

一个项目中的图片资源，主要有两种：1、`css` 引入的背景图片，2、`img` 标签引入的页面图片。

`webpack 5` 对 `css` 中引入的背景图片做了优化处理，不需要再进行额外的配置，它们会随着 `css` 代码一起被打包处理到项目中。

```css
/* 打包前 */
.bg {
    width: 200px;
    height: 150px;
    background: url("./images/bg.png");
}
```

```html
<!-- 打包后 -->
<style>
.bg {
    width: 200px;
    height: 150px;
    background: url(file:///E:/WebPack/demo/dist/1af5d23d5272359f0279.png);
}
</style>
```

但是 `webpack` 无法处理 `img` 标签引入的图片，不会对它们做任何处理。

```html
<!-- 打包前后 -->
<img src="./images/01.png" width="200" height="150" />
```

##### 模块配置

`webpack 5` 不能直接处理 `img` 标签引入的图片，需要对其进行模块配置。

```js
module.exports = {
    module: {
        rules: [
            // 定义处理图片资源的规则
            {
                test: /\.(png|jpg|jpeg|gif|webp)$/i, // 指定处理文件
                type: "asset/resource" // 指定处理test匹配文件的资源模块类型
            }
        ]
    }
}
```

##### 构建依赖

```js
import img01Url from "./images/01.png"

console.log(img01Url); // http://localhost:8080/images/1af5d23d5272359f0279.png
```

`import` 导入的图片资源，在经过 `asset/resource` 模块的打包处理后，会得到该资源在打包项目中的新 `Url` 路径。

##### 设置路径

得到图片资源的路径之后，就需要将其设置到页面的 `img` 元素中。

```js
let oImgs = document.images;

oImgs[0].src = imge01Url;
```

##### 图标资源

对于图标、`logo` 和精灵图等小体积（小于 `10Kb`）的图片文件，可以考虑使用 `asset/inline` 资源模块类型将它们导出为 `data URI`。

`asset/inline` 资源模块类型默认将图片以 `base64` 算法转换成 `Url` 文本。这样一来，不仅减少了资源的请求次数（浏览器可以直接识别和解析 `base64` 的编码文本），而且加载速度也会得到明显提升（加载文本远快于加载图片）。

```js
module.exports = {
    module: {
        rules: [
            // 定义处理图片资源的规则
            {
                test: /\.(png|jpg|jpeg|gif|webp)$/i, // 指定处理文件
                type: "asset/inline" // 指定处理test匹配文件的资源模块类型
            }
        ]
    }
}
```

更多参考：[`Base64` 编码知识详解](https://baijiahao.baidu.com/s?id=1735577033729027737&wfr=spider&for=pc) 

##### 自动选择

`asset` 资源模块类型，会根据打包资源的体积来自动选择模块类型。对于大体积的文件采用 `asset/resource` 模块类型，打包处理为与原文件格式一样的文件资源；对于小体积的文件采用 `asset/inline` 模块类型，打包处理为 `data URI` 编码格式的字符串文本。

```js
module.exports = {
    module: {
        rules: [
            // 定义处理图片资源的规则
            {
                test: /\.(png|jpg|jpeg|gif|webp)$/i, // 指定处理文件
                type: "asset" // 指定处理test匹配文件的资源模块类型
            }
        ]
    }
}
```

##### 资源输出

在规则对象中，可以通过定义 `generator` 选项来指定将打包资源输出到哪个位置以及采用什么文件名称。

其中，使用一个 `filename` 字段来定义输出路径和文件名称。在 `filename` 的值中允许使用中括号语法引用源文件的相关信息。

- `name`：源文件的名称
- `ext`：源文件的扩展名（包含 `.`）
- `hash`：根据源文件内容计算出一个 `hash` 值。

注意：不建议指定输出名称为原名称。如果项目在两个模块中引入了相同的文件，而配置指定输出原文件名，可能导致构建冲突和报错。

```js
module.exports = {
    module: {
        rules: [
            // 定义处理图片资源的规则
            {
                test: /\.(png|jpg|jpeg|gif|webp)$/i, // 指定处理文件
                type: "asset", // 指定处理test匹配文件的资源模块类型
                generator: {
                    filename: "images/[name][hash][ext]" // 如果指定的输出目录不存在，则会先创建它。
                }
            }
        ]
    }
}
```

另外，由于输出的 `hash` 字符串很长，导致文件名过长。当想要限制 `hash` 的长度时，可以使用在 `hash` 之后使用冒号紧跟一个数字。

```js
{
    filename: "images/[hash:4][ext]" // 限定只输出hash字符串的前4位
}
```

注意：在冒号和数字之间不能出现空格，二者必须紧密相连，否则将造成输出异常而使资源受到损坏。

更多参考：[`Rule.generator`](https://webpack.docschina.org/configuration/module/#rulegenerator) 

#### 音频视频

处理音视频与处理图片资源一样，只需要进行相应的配置即可。

```js
{
    test: /\.(mp3 | mp4 | ogg | wav | webm)$/i,
    type: "asset/resource",
    generator: {
        filename: "media/[name][hash:4][ext]"
    }
}
```

#### 字体文件

字体文件通常被引入到 `css` 中使用。因此，`webpack` 会将它们与 `css` 代码一同打包处理，不需要进行额外的配置。

```css
@font-face {
    font-family: "my-font"; /* 指定字体名称 */
    src: url("./font/custom.ttf"); /* 链接字体文件 */
}

p {
    font-family: "my-font"; /* 使用字体 */
}
```

当然，为了方便集中管理打包输出后的字体文件，也可以对它们的输出位置进行配置。

```js
{
    test: /\.(woff | eot | ttf | otf)$/i,
    type: "asset/resource",
    generator: {
        filename: "font/[name][hash:4][ext]"
    }
}
```



### 实时打包

#### 服务器

为方便实时更新打包项目，在开发中提供热更新的功能。`webpack` 提供了实时打包项目的工具 —— `webpack-dev-server`。

```shell
npm i webpack-dev-server -D
```

该工具会启动一个 `HTTP` 服务器，能够实时打包项目并且将它运行在该服务器上，以提供热更新的服务。

##### 启动服务

输入 `npx webpack server` 指令，来启动实时打包项目的功能以及热更新服务。该指令，由 `webpack-dev-server` 工具提供。

```shell
npx webpack server
```

可以重新指定启动命令。在 `package.json` 配置文件中，指定 `scripts` 对象中的 `server` 属性值为 `"webpack sever"`。

```json
"scripts": {
    "server": "webpack server"
}
```

使用修改后的启动指令

```shell
npm run server /* 等同于：npx webpack server */
```

##### 服务地址

启动服务器之后，会提供两个服务地址。在浏览器中浏览其中任何一个地址，都可以看到被打包的项目。

该服务会在被打开的目录中自动寻找 `index.html` 文件，并将其作为入口页面（即：首页文件）打开。

##### 项目变化

为了更好地保护实时打包的项目，`webpack-dev-server` 不会将它显式地存到本地磁盘上，所以在本地无法查看实时打包的项目实体。实际上，它将实时打包的项目资源直接运行在启动的服务器上，并将它们隐式地存于根路由下。因此，在服务器上可以查看和引用它们。

而这时，也需要在入口页面中重新引入入口 `js` 文件。 

```html
<!-- 在index.html入口页面中 -->
<script src="/main.js"></script> <!-- 引用被实时编译打包的入口js文件 -->
```

##### 配置服务器

在 `webpack.config.js` 配置文件中，可以通过 `devServer` 配置启动的服务器。

```js
module.exports = {
    devServer: {
        open: true, // 在默认的浏览器中，自动启动服务器
        port: 4040, // 指定提供服务的端口号
    }
}
```

更多参考：[`devServer` 配置](https://webpack.docschina.org/configuration/dev-server/#root) 

#### 页面文件

##### 实时页面

由于 `webpack` 无法处理 `html` 文件，所以它不会对入口页面做任何处理。因此，入口页面仍然是显式存在且没有被打包的。

如果想要在服务器中看到打包后项目的实时页面，就必须将入口页面也一并打包到项目中，需要使用 `html-webpack-plugin`。

```shell
npm i html-webpack-plugin -D
```

配置插件

```js
// 获取插件方法
const HtmlWebpackPlugin = require('html-webpack-plugin'); 

// 创建插件实例
const htmlWPlugin = new HtmlWebpackPlugin({
    template: "./src/index.html", 	// 源入口页面的路径
    filename: "./index.html" 		// 新入口页面的路径
});

module.exports = {
    plugins: [htmlWPlugin] // 挂载插件实例
}
```

`html-webpack-plugin` 工具，会将 `template` 指向的入口页面文件打包输出到 `filename` 指向的位置（通常引入到项目根目录下），并且该工具还会自动在入口页面中引用实时打包的入口 `js` 文件。这样一来，就不需要在入口页面中引入入口 `js` 文件了。

正因为入口页面被打包到项目根目录中。因此，在提供热更新的服务器上，便可以在根路由下直接找到并打开被实时打包的入口页面。

##### 页面文件

如前所述，`webpack` 默认不会处理和打包 `html` 文件。使用 `html-webpack-plugin` 插件可以将 `html` 文件打包到项目中，但 `webpack` 仍然不会对 `html` 文件中的代码做任何处理，只是原样复制 `html` 代码而已。如下：

```html
<!-- 打包前后：-->
<img src="./image/01.png" width="200" height="100"/>
```

在 `html` 文件中引入的资源不会被打包处理，当项目打包后，它们也会意外丢失。打包后的项目因为引用不到资源，页面就会出现空缺。

##### 动态模板

如果想要在 `html` 文件中引入的资源能够被打包处理，则应使用动态的模板语法（如：`ejs`），在页面上以动态的方式引入相关资源。

```html
<!-- 打包前：-->
<img src="<%= require('./images/01.png') %>" width="200" height="100" />

<!-- 打包后：-->
<img src="520121ed09812agdd251.png" width="200" height="100" />
```

在 `html` 文件中使用 `ejs` 的动态模板语法，能够被 `html-webpack-plugin` 识别，并在打包该 `html` 文件时一并打包动态引用的资源。

因为在开发中基本上不会直接操作 `html` 文件，所以很少需要使用动态模板的语法，但有时会在 `vue` 项目中使用。

```html
<!DOCTYPE html>
<html lang="">
    <head>
        <link rel="icon" href="<%= BASE_URL %>favicon.ico">
        <title><%= htmlWebpackPlugin.options.title %></title>
    </head>
    <body>
		<noscript>
        	<strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
        </noscript>
        <div id="app"></div>
	</body>
</html>
```

```js
// 获取插件方法
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    plugins: [
        // 挂载插件实例
        new HtmlWebpackPlugin({
    		template: "./src/index.html", 	// 指定模板文件
    		title: "页面标题" 				 // 指定页面标题
		})
    ] 
}
```

更多参考：[`html-webpack-plugin` 使用文档](https://github.com/jantimon/html-webpack-plugin#options) 

##### 自动打开

如果想要在启动服务时，自动在默认的浏览器中打开项目。可以在 `package.json` 配置文件中，在启动指令后面追加 `--open`。

```json
"scripts": {
    "open": "webpack server --open"
}
```

```shell
npm run open
```

更多参考：[使用 `webpack-dev-server`](https://webpack.docschina.org/guides/development#using-webpack-dev-server)、[`HtmlWebpackPlugin`](https://webpack.docschina.org/plugins/html-webpack-plugin/#root) 

