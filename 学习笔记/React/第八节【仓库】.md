# 仓库

​		`Redux` 由 [`Flux`](http://facebook.github.io/flux/) 演变而来，但受 [`Elm`](http://elm-lang.org/guide/architecture) 的启发，避开了 `Flux` 的复杂性。是由 `react` 配置的一个全局仓库管理工具。



### 基础

​		`Redux` 是 `JavaScript` 状态容器，提供可预测化的状态管理。



#### 动机

​		随着 `JavaScript` 单页应用开发日趋复杂，**`JavaScript` 需要管理比任何时候都要多的 `state`（状态）**。 这些 `state` 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 `UI` 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。

​		管理不断变化的 `state` 非常困难。如果一个 `model` 的变化会引起另一个 `model` 变化，那么当 `view` 变化时，就可能引起对应 `model` 以及另一个 `model` 的变化，依次地，可能会引起另一个 `view` 的变化。直至你搞不清楚到底发生了什么。**`state` 在什么时候，由于什么原因，如何变化已然不受控制。** 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。

​		如果这还不够糟糕，考虑一些**来自前端开发领域的新需求**，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，[难道就这么放弃了吗？](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html)当然不是。

​		这里的复杂性很大程度上来自于：**我们总是将两个难以理清的概念混淆在一起：变化和异步**。 我称它们为 [曼妥思和可乐](https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption)。如果把二者分开，能做的很好；但混到一起，就变得一团糟。一些库如 [`React`](http://facebook.github.io/react) 试图在视图层禁止异步和直接操作 `DOM` 来解决这个问题。美中不足的是，`React` 依旧把处理 `state` 中数据的问题留给了你。`Redux` 就是为了帮你解决这个问题。

​		跟随 [`Flux`](http://facebook.github.io/flux)、[`CQRS`](http://martinfowler.com/bliki/CQRS.html) 和 [`Event Sourcing`](http://martinfowler.com/eaaDev/EventSourcing.html) 的脚步，通过限制更新发生的时间和方式，**`Redux` 试图让 `state` 的变化变得可预测**。这些限制条件反映在 `Redux` 的 [三大原则](https://www.redux.org.cn/docs/introduction/ThreePrinciples.html) 中。



#### 核心

​		`Redux` 本身很简单。

​		当使用普通对象来描述应用的 `state` 时。例如，`todo` 应用的 `state` 可能长这样：

```js
{
  	todos: [{
    	text: 'Eat food',
    	completed: true
  	}, {
    	text: 'Exercise',
    	completed: false
  	}],
  	visibilityFilter: 'SHOW_COMPLETED'
}
```

​		这个对象就像 `“Model”`，区别是它并没有 `setter`（修改器方法）。因此其它的代码不能随意修改它，造成难以复现的 `bug`。

​		要想更新 `state` 中的数据，你需要发起一个 `action`。`Action` 就是一个普通 `JavaScript` 对象（这里没有任何魔法！）用来描述发生了什么。下面是一些 `action` 的示例：

```js
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
```

​		强制使用 `action` 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道它们为什么会变化。`action` 就像是描述发生了什么的指示器。最终，为了把 `action` 和 `state` 串起来，还需开发一些函数，这就是 `reducer`。再次地，没有使用任何魔法，`reducer` 只是一个接收 `state` 和 `action`，并返回新 `state` 的函数。 对于大的应用来说，不大可能仅仅只写一个这样的函数，所以我们编写很多小函数来分别管理 `state` 的一部分：

```js
function visibilityFilter(state = 'SHOW_ALL', action) {
  	if (action.type === 'SET_VISIBILITY_FILTER') {
    	return action.filter;
  	} else {
    	return state;
  	}
}

function todos(state = [], action) {
  	switch (action.type) {
  		case 'ADD_TODO':
    		return state.concat([{ text: action.text, completed: false }]);
  		case 'TOGGLE_TODO':
    		return state.map((todo, index) =>
      			action.index === index ? { text: todo.text, completed: !todo.completed } : todo)
  		default:
    		return state;
  	}
}
```

​		再开发一个 `reducer` 调用这两个 `reducer`，进而来管理整个应用的 `state`：

```js
function todoApp(state = {}, action) {
  	return {
    	todos: todos(state.todos, action),
    	visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  	};
}
```

​		这差不多就是 `Redux` 思想的全部。注意到没我们还没有使用任何 `Redux` 的 `API`。`Redux` 里有一些工具来简化这种模式，但是主要的想法是如何根据这些 `action` 对象来更新 `state`，而且 `90%` 的代码都是纯 `JavaScript`，没使用 `Redux`、`Redux API` 和其它魔法。



#### 原则

​		`Redux` 可以用这三个基本原则来描述：

- 单一数据源（只存在一个仓库，它以一颗对象树的形式存储整个应用的 `state`）
- `state` 是只读的（只能通过触发 `action` 来通知修改 `state`）
- 使用纯函数来执行修改（使用 `reducer` 纯函数接收 `state` 和 `action`，处理后返回新 `state`）

##### 单一数据源

​		**整个应用的 [`state`](https://www.redux.org.cn/docs/Glossary.html#state) 被储存在一棵 `object tree` 中，并且这个 `object tree` 只存在于唯一一个 [`store`](https://www.redux.org.cn/docs/Glossary.html#store) 中。**

​		这让同构应用开发变得非常容易。来自服务端的 `state` 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 `state tree` ，调试也变得非常容易。在开发中，你可以把应用的 `state` 保存在本地，从而加快开发速度。此外，受益于单一的 `state tree`，以前难以实现的如 “撤销/重做” 这类功能也变得轻而易举。

```js
console.log(store.getState())

/* 输出
{
  	visibilityFilter: 'SHOW_ALL',
  	todos: [
    	{
      		text: 'Consider using Redux',
      		completed: true,
    	},
    	{
      		text: 'Keep all state in a single tree',
      		completed: false
    	}
  	]
}
*／
```

##### `state` 只读

​		**唯一改变 `state` 的方法就是触发 [`action`](https://www.redux.org.cn/docs/Glossary.html#action)，`action` 是一个用于描述已发生事件的普通对象。**

​		这样确保了视图和网络请求都不能直接修改 `state`，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 `race condition` 的出现。 `Action` 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。

```js
store.dispatch({
  	type: 'COMPLETE_TODO',
  	index: 1
})

store.dispatch({
  	type: 'SET_VISIBILITY_FILTER',
  	filter: 'SHOW_COMPLETED'
})
```

##### 纯函数修改

​		**为了描述 `action` 如何改变 `state tree` ，你需要编写 [`reducers`](https://www.redux.org.cn/docs/Glossary.html#reducer)。**

​		`Reducer` 只是一些纯函数，它接收先前的 `state` 和 `action`，并返回新的 `state`。刚开始你可以只有一个 `reducer`，随着应用变大，你可以把它拆成多个小的 `reducers`，分别独立地操作 `state tree` 的不同部分，因为 `reducer` 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 `reducer` 来处理一些通用任务，如分页器。

```js
function visibilityFilter(state = 'SHOW_ALL', action) {
  	switch (action.type) {
    	case 'SET_VISIBILITY_FILTER':
      		return action.filter;
    	default:
      		return state;
  	}
}

function todos(state = [], action) {
  	switch (action.type) {
    	case 'ADD_TODO':
      		return [...state, {text: action.text, completed: false}];
    	case 'COMPLETE_TODO':
      		return state.map((todo, index) => {
        		if (index === action.index) {
          			return Object.assign({}, todo, {
            			completed: true
          			});
        		}
        		return todo;
      		});
    	default:
      		return state;
  	}
}

import { combineReducers, createStore } from 'redux';
let reducer = combineReducers({ visibilityFilter, todos }); // combineReducers用于将多个reducer合并为一个。
let store = createStore(reducer);
```

​		就是这样，现在你应该明白 `Redux` 是怎么回事了。



#### 数据流

##### 单向数据流

​		早些时候，我们谈到了 **“单向数据流”**，它描述了更新应用程序的以下步骤序列：

- `State` 描述了应用程序在特定时间点的状况；
- 基于 `state` 来渲染 `UI`；
- 当发生某些事情时（例如用户单击按钮），`state` 会根据发生的事情进行更新；
- 基于新的 `state` 重新渲染 `UI`；

##### 数据流更新

​		具体来说，对于 `Redux`，我们可以将这些步骤分解为更详细的内容：

- 初始启动：
  - 给 `Redux` 提供的 `createStore` 函数传入最顶层的 `root reducer` 函数来创建 `Redux store`；
  - `store` 调用一次 `root reducer`，并将返回值保存为它的初始 `state`；
  - 当 `UI` 首次渲染时，`UI` 组件访问 `Redux store` 的当前 `state`，并使用该数据来决定要呈现的内容。同时监听 `store` 的更新，以便他们可以知道 `state` 是否已更改。
- 更新环节：
  - 应用程序中发生了某些事情，例如，用户单击按钮；
  - `dispatch` 一个 `action` 到 `Redux store`，例如 `dispatch({type: 'counter/increment'})`；
  - `store` 用之前的 `state` 和当前的 `action` 再次运行 `root reducer` 函数，并将返回值保存为新的 `state`；
  - `store` 通知所有订阅过的 `UI`，通知它们 `store` 发生更新；
  - 每个订阅过 `store` 数据的 `UI` 组件都会检查它们需要的 `state` 部分是否被更新；
  - 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页。

​		以动画的方式来表达数据流更新：

​                                         <img src="images/%E7%AC%AC%E5%85%AB%E8%8A%82%E3%80%90%E4%BB%93%E5%BA%93%E3%80%91/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="img" style="zoom: 33%;" />  

​		注释：仓库中只有一个 `reducer`，它用于更新仓库（无论是初始化，还是后续更新）。当通过事件触发一个 `dispatch` 时，它会发送一个 `action` 给这个 `reducer` 回调。与此同时，仓库也会传递当前存储的 `state` 给 `reducer`。然后，`reducer` 将根据 `action` 的指示以及现有 `state` 的状态，返回一个新的 `state` 以更新仓库的 `state`。



#### 安装

​		使用 `npm i redux` 指令，安装 `redux` 工具。

```shell
npm i redux
```



### 使用

​		安装好 `redux` 工具之后，就可以开始创建和使用仓库了。



#### 仓库目录

​		在 `src` 下新建一个 `store` 目录，并创建一个 `index.js` 文件，用来创建和初始化仓库。

```diff
|-src 
+	|- store
+		|- index.js
```



#### 新建仓库

##### 创建新仓库

​		在 `src/store/index.js` 文件中，通过 `redux` 提供的 `createStore` 方法创建仓库，并将其导出。

```js
// 在src/store/index.js文件中
import {createStore} from "redux";

// 创建并导出仓库
export default createStore();
```

​		`createStore` 返回一个 `redux` 仓库。

```js
/* 打印仓库对象：
{
	@@observable: ƒ observable(),
	dispatch: ƒ dispatch(action),
	getState: ƒ getState(),
	replaceReducer: ƒ replaceReducer(nextReducer),
	subscribe: ƒ subscribe(listener),
	[[Prototype]]: Object
}
*/
```

##### 初始化仓库

​		使用 `createStore` 方法创建仓库时，必须传入一个 `reducer` 回调，该回调的返回值用于更新仓库的 `state`。

```js
// 在src/store/index.js文件中
import {createStore} from "redux";

// 定义初始化数据
const init = {};

// 定义root reducer，其返回值用于更新仓库的state
const reducer = (state = init, action) => {
    // 初时仓库state尚未定义，因此可以设置默认传值。
    return {...state};
};

// 传递root reducer创建并初始化仓库，然后导出
export default createStore(reducer);
```

​		传给 `createStore` 的 `reducer` 用于更新仓库的 `state`。新建仓库的 `state` 初始为 `undefined`，因此，`reducer` 初次接收到的 `state` 参数为 `undefined`，但可以选择给它设置一个默认传值。最终，该 `reducer` 的返回值将用于更新仓库 `state`。

​		注意：每个仓库只有一个 `reducer`。也就是说，传给 `createStore` 的 `reducer` 不仅要初始化仓库，还要在后续继续更新仓库。

##### 创建初始化

​		当然，也可以直接调用 `createStore` 创建并初始化一个 `redux` 仓库，然后将其导出。

```js
// 在src/store/index.js文件中
import {createStore} from "redux";

export default createStore((state, action) => {
    // 定义并初始化仓库的state
    return {};
});
```



#### 使用仓库

​		创建并初始化好仓库之后将其导出，然后，就可以在需要使用仓库的组件中导入并使用仓库了。

##### 导入仓库

​		在需要使用仓库的组件中导入仓库。

```jsx
// 导入仓库
import store from "@/store/index.js";
```

##### 获取数据

​		导入仓库对象后，通过对象上的 `getState` 方法获取仓库的所有 `state`。

```jsx
import store from "@/store/index.js";

export default function Home() {
    console.log(store.getState());
    
    return (<h1>Home</h1>);
}
```

##### 通知更新

​		在 `UI` 组件中，通过触发事件调用仓库提供的 `dispatch` 方法通知仓库更新数据，并发送一个 `action` 对象。其中应含以下属性：

- `type`：指示更新行为的类型（告诉 `reducer` 应如何更新仓库的 `state`）。
- `data`：携带的新数据（向 `reducer` 提供更新仓库时用于参考的新数据）。

```jsx
import store from "@/store/index.js";

const {getState, dispatch} = store;

export default function Home() {
    let {count} = getState();
    
    let update = () => {
        dispatch({type: "add", step: 1});
    };
    
    return (
    	<div>
        	<h1>Home</h1>
            <div>{count}</div>
            <button onClick={update}>点击增加</button>
        </div>
    );
}
```

##### 更新仓库

​		`dispatch` 发送的 `action` 对象，将被回抛给创建仓库时传给 `createStore` 的 `reducer` 回调，通过该 `reducer` 再次更新仓库。

```js
// 在src/store/index.js文件中
import {createStore} from "redux";

// 定义初始化数据
const init = {count: 0};

// 定义root reducer，其返回值用于更新仓库的state
const reducer = (state = init, action) => {
    let newState = {...state};
    switch(action.type) {
		case "add":
            newState.count += action.step;
            break;
		case "sub":
            newState.count -= action.step;
            break;
    }
    return newState;
};

export default createStore(reducer);
```

##### 订阅仓库

​		仓库对象提供了一个订阅仓库的 `subscribe` 方法，它接收一个回调。每次仓库更新时都会执行该方法（**只在仓库更新时执行**）。

```jsx
import store from "@/store/index.js";

const {subscribe} = store;

export default function Home() {
    // 只在仓库更新时执行，组件更新并不会执行它。
    subscribe(() => {
        console.log("仓库已更新");
    });
}
```

​		过去，可以在项目启动文件中，通过仓库提供的 `subscribe` 方法来使所有组件都订阅该仓库。

```js
// 在src/index.js文件中
import store from "@/store/index.js";

store.subscribe(() => {
    root.render();
});
```

​		所有订阅过仓库的组件都会监听仓库的更新。每次 `store` 更新后，这些订阅组件都会检查它们所需的 `state` 部分是否被更新。发现数据被更新的每个组件都强制使用新数据重新渲染组件，紧接着更新网页。

```jsx
import React from "react";
import store from "@/store/index.js";

const {useState} = React;
const { getState, dispatch, subscribe } = store;

export default function Home() {
    let [state, setState] = useState(getState());

    let { count } = state;

    let update = () => {
        dispatch({ type: "add", step: 1 });
    };

    subscribe(() => {
        setState(getState());
    });

    return (
        <div>
            <h1>Home</h1>
            <div>{count}</div>
            <button onClick={update}>点击增加</button>
        </div>
    );
}
```

​		过去，还会将它包裹在 `useEffect` 中，以清除因订阅外部数据而产生的副作用。

```jsx
useEffect(() => {
    subscribe(() => {
        setState(getState());
    });
}, []);
```



### 进阶

​		`Redux` 是一个小型的独立 `JS` 库。 但是，它通常与其他几个包一起使用：

- [`React-Redux`](https://www.reduxjs.cn/tutorials/essentials/part-1-overview-concepts#react-redux)：`Redux` 可以集成到任何 `UI` 框架中，其中最常见的就是 `React`。[**`React-Redux`**](https://react-redux.js.org/) 是我们的官方包，它可以让 `React` 组件访问 `state` 片段以及 `dispatch` ` actions` 更新 `store`，从而同 `Redux` 集成起来。【`dispatch`：派遣、发送】
- [`Redux Toolkit`](https://www.reduxjs.cn/tutorials/essentials/part-1-overview-concepts#redux-toolkit)：[**`Redux Toolkit`**](https://redux-toolkit.js.org/) 是我们推荐的编写 `Redux` 逻辑的方法。 它包含我们认为对于构建 `Redux` 应用程序必不可少的包和函数。`Redux Toolkit` 构建是我们建议的最佳实践，它简化了大多数 `Redux` 任务，预防了常见错误，并使编写 `Redux` 应用程序变得更加容易。
- [`Redux DevTools` 扩展](https://www.reduxjs.cn/tutorials/essentials/part-1-overview-concepts#redux-devtools-扩展)：[**`Redux DevTools` 扩展**](https://github.com/zalmoxisus/redux-devtools-extension) 用于查看 `redux` 仓库，它可以显示 `Redux` 存储中状态随时间变化的历史记录。这允许你有效地调试应用程序，包括使用强大的技术，如 “时间旅行调试”。

​		其中，`Redux DevTools` 是一个扩展插件，而 `React-Redux` 和 `Redux ToolKit` 是需要安装到项目的两个工具包。

​		更多参考：[`Redux Toolkit` 快速开始](https://www.reduxjs.cn/tutorials/quick-start) 



#### 安装

​		使用 `npm i react-redux @reduxjs/toolkit` 指令，安装 `react-redux` 和 `@reduxjs/toolkit` 工具。

```shell
npm install react-redux @reduxjs/toolkit
```

​		这两个工具的作用简单来说，就是在配置仓库时使用 `@reduxjs/toolkit` 工具，在使用仓库时使用 `react-redux` 工具。



#### 建立

​		使用 `react-redux` 和 `@reduxjs/toolkit` 工具来创建和管理仓库时，需要更改原来的一些语法。

##### 新建仓库

​		通过 `@reduxjs/toolkit` 工具提供的 `configureStore` 方法来创建和配置 `redux` 仓库。

```js
// 在src/store/index.js文件中
import {configureStore} from "@reduxjs/toolkit";

// 创建、配置并导出仓库
export default configureStore();
```

##### 配置仓库

​		`configureStore` 方法，必须接收一个对象参数。其中，必须包含一个 `reducer` 属性（用于更新仓库的 `state`）。

```js
export default configureStore({
    reducer: (state, action) => newState
});
```

​		这个 `reducer` 属性也可以是一个对象，用于为仓库中不同的 `state` 挂载不同的 `reducer` 函数。也就是说，这个 `reducer` 对象允许我们为每个 `state` 设置单独的 `reducer` 方法。这样做的好处是，将原先统一执行的 `reducer` 拆分成单独执行的小 `reducer` —— 更新某个 `state` 只需要触发对应的 `reducer` 即可。

```js
import {configureStore} from "@reduxjs/toolkit";

export default configureStore({
    // 键是仓库中的state，值是只更新该state的reducer。
    reducer: {
        state1: (state, action) => newState,
        state2: (state, action) => newState,
        ...
    }
});
```

​		这个 `reducer` 对象中的键将作为 `redux` 仓库的 `state`，值将作为修改该 `state` 的 `reducer`。

##### 细化仓库

​		当然，也可以将 `redux` 仓库中的 `state` 作为一个个相互独立的小储藏间（`storage`）使用。

```js
export default configureStore({
    // 将仓库中的state定义为储藏间
    reducer: {
        storage1: reducer1,
        storage2: reducer2,
        ...
    }
});
```

​		为了方便使用，`@reduxjs/toolkit` 工具提供了定义静态仓库的方法，它们也都拥有自己的 `reducer` 方法。只需将这些静态仓库的 `reducer` 挂载到 `configureStore` 方法配置对象的 `reducer` 对象中即可。

##### 静态仓库

​		建议将 `redux` 仓库上的静态仓库（即：小储物间）单独提取到一个文件中，使它们能够像 `redux` 仓库一样被配置和管理。

```diff
|- src
+	|- store
+		|- storage1.js
+		|- storage2.js
```

​		然后在这些静态仓库文件（如 `storage1.js`）中，使用 `@reduxjs/toolkit` 工具提供的 `createSlice` 方法创建静态仓库。

```js
// 在storage1.js文件中
import { createSlice } from "@reduxjs/toolkit";

// 创建并导出静态仓库
export createSlice();
```

```js
/* 静态仓库：
{
	actions: {},
	caseReducers: {},
	getInitialState: ƒ (),
	name: "",
	reducer: ƒ (state, action),
	[[Prototype]]: Object
}
*/
```

​		`createSlice` 接收一个配置对象，用于配置该静态仓库。其中，包含以下基本属性：

- `name`：仓库名称。
- `initialState`：初始数据。
- `reducers`：一个对象，用于为该仓库定义多个 `reducer`。其键可与 `name` 结合组成 `action` 的 `type`，值是对应的 `reducer`。

```js
export createSlice({
    name: "",
    initialState: {},
    reducers: {
        // 静态仓库的 state 是一个 proxy 对象
        add: (state, action) => newState,
        sub: (state, action) => newState,
    }
});
```

​		静态仓库配置中的 `reducers` 对象最后将合并成一个 `reducer` 方法存储在静态仓库对象上，将该 `reducer` 作为默认值导出即可。

```js
export const storage1Slice = createSlice({
    name: "storage1",
    initialState: {count: 0},
    reducers: {
        // 修改state的两种方式：返回对象或直接修改。
        add: (state, action) => ({ count: state.count + 1 }), // 如果返回，就必须返回state对象。
        sub: (state, action) => { state.count -= 1 } 		  // 若不返回，则必须直接修改state。
    }
});

// 将静态仓库的reducer方法作为默认值导出
export default storage1Slice.reducer // 注意：此处是reducer，没有s。
```

​		定义并导出静态仓库的 `reducer` 方法之后，需要将其挂载到 `redux` 仓库的 `reducer` 配置中。

```js
import storage1 = "./storage1.js"

export default configureStore({
    reducer: {
        storage1
    }
});
```



#### 使用

##### 使用仓库

​		建立并配置好 `redux` 仓库之后，就可以直接将其导入到组件中使用了，与之前的用法一样。

```jsx
import store from "@/store/index.js";

export default function Home() {
    console.log(store);
    return (
        <div>
            <h1>Home</h1>
        </div>
	);
}
```

##### 应用仓库

​		也可以将仓库导入到项目启动文件中，将其应用给所有的组件。

```jsx
// 在src/index.js文件中
import { Provider } from "react-redux";
import store from "@/store/index.js";

root.render(
	<Provider store={store}>
    	<App />
    </Provider>
);
```

​		使用 `react-redux` 提供的 `<Provider>` 内置组件包裹根组件。然后在 `<Provider>` 组件上通过 `store` 属性向下传递仓库对象。现在，任何调用 `useSelector` 或 `useDispatch` 的 `React` 组件都可以直接访问 `<Provider>` 中的 `store` 了。当仓库更新后，它会自动重新渲染使用 `useSelector` 提取了更新数据的所有组件。

##### 获取仓库

​		在组件中，可以通过 `react-redux` 提供的 `useStore` 方法来获得 `redux` 仓库。

```jsx
import {useStore} from "react-redux";

export default function Home() {
    const store = useStore();
    
    console.log(store);
}
```

```js
/*
{
	@@observable: ƒ observable(),
	dispatch: ƒ (action),
	getState: ƒ getState(),
	replaceReducer: ƒ replaceReducer(nextReducer),
	subscribe: ƒ subscribe(listener),
	[[Prototype]]: Object
}
*/
```

##### 获取数据

​		在组件中导入或获取到 `redux` 仓库之后，仍然可以使用仓库上的 `getState`、`dispatch` 和 `subscribe` 等原生方法来使用仓库。

```jsx
import React from "react";
import store from "@/store/index.js";

const { useState } = React;
const { getState } = store;

export default function Home() {

    let [state, setState] = useState(getState());

    console.log(state);

    return (<h1>Home</h1>);
}
```

##### 提取数据

​		在组件中使用 `react-redux` 提供的 `useSelector` 方法，即可获取仓库的 `state`，并从中挑选出所需的数据。

​		`useSelector` 用于从仓库的 `state` 中提取所需的数据，接收一个回调函数。回调函数的首参就是仓库的 `state`。

```jsx
import { useSelector } from "react-redux";

export default function Home() {
    // 挑选storage1静态仓库中的count数据
    let count = useSelector((state) => state.storage1.count);
    // 当静态仓库中的count更新后，组件中的count也会同步更新，并且触发组件的重新渲染。
} 
```

​		使用 `react-redux` 提供的方法，不需要再手动导入仓库，前提是 `react-redux` 已经在项目启动文件中将仓库应用给所有的组件。

​		另外，`useSelector` 直接从仓库中提取数据，并且会监听提取数据的更新。这意味着，每次当 `useSelector` 提取的数据在仓库中被更新后，组件都会触发 `useSelector` 来重新提取数据，然后触发组件的重新渲染。

##### 更新数据

​		在组件中，可使用仓库的 `dispatch` 原生方法或 `react-redux` 提供的 `useDispatch` 方法返回一个 `dispatch`，通知仓库更新。

```jsx
import { useDispatch } from "react-redux";

export default function Home() {
    // 使用store.dispatch或useDispatch返回的dispatch，通知仓库更新。
    const dispatch = useDispatch();
}
```

​		在事件中 `dispatch` 一个 `action`，`action` 必须包含一个 `type` 属性。这个 `type` 属性由 `静态仓库名/reducers的键` 组成。

```jsx
import { useDispatch } from "react-redux";

export default function Home() {
    const dispatch = useDispatch();
    
    const add = () => {
        // 触发storage1静态仓库的add reducer方法
        dispatch({type: "storage1/add", value: 10});
    };
    
    return (
    	<div>
        	<h1>Home</h1>
            <button onClick={add}>点击</button>
        </div>
    );
}
```

​		由于 `react-redux` 在项目启动文件中的配置以及 `useSelector` 的特性，当仓库更新后，会自动重新渲染提取了更新数据的组件。

##### 静态更新

​		还有一种更新仓库的方式，只能用于更新静态仓库。

​		在创建静态仓库时，可以将静态仓库 `actions` 属性中的 `reducer` 方法一并导出。

```js
// 导出静态仓库
export const storage1Slice = createSlice({
    name: "storage1",
    initialState: {count: 0},
    reducers: {
        add: (state, action) => ({ count: state.count + 1 }), 
        sub: (state, action) => { state.count -= 1 } 
    }
});

// 直接导出各种reducer方法
export const {add, sub} = storage1Slice.actions;

// 导出合并后的reducer方法（默认导出值）
export default storage1Slice.reducer;
```

​		然后，在组件中导入静态仓库的各种 `reducer` 方法。再将这些 `reducer` 方法传给 `dispatch` 调用，调用时直接传递数据即可。

```jsx
import { useSelector, useDispatch } from "react-redux";

// 直接从静态仓库文件中导入各种reducer方法
import { add, sub } from "@/store/storage1.js";

export default function Home() {
    const count = useSelector((state) => state.storage1.count);
    const dispatch = useDispatch();
    
    const clickAdd = () => {
        dispatch(add(10));
    };
    const clickSub = () => {
        dispatch(sub(5));
    };
    
    return (
    	<div>
        	<h1>Home</h1>
            <div>{count}</div>
            <button onClick={clickAdd}>加10</button>
            <button onClick={clickSub}>减5</button>
        </div>
    );
}
```

​		`dispatch(reducer(data))` 直接执行仓库导出的 `reducer` 并传递数据 `data`。传递的数据会被 `action` 的 `payload` 属性接收。

```js
import { createSlice } from "@reduxjs/toolkit";

export const storage1Slice = createSlice({
    name: "storage1",
    initialState: { count: 0 },
    reducers: {
        // 传递的数据存在action的payload属性中
        add: ({count}, action) => {
            count += (action.payload || 1);
            return { count };
        },
        sub: (state, action) => { state.count -= action.payload || 1 }
    }
});

export const { add, sub } = storage1Slice.actions;
export default storage1Slice.reducer;
```

##### 异步更新

​		`JavaScript` 语言有很多编写异步代码的方法，我们的静态仓库通常具有异步逻辑，比如从 `API` 请求数据之类的事情。我们需要一个地方在我们的 `Redux` 静态仓库中放置异步逻辑，这个地方就是 `thunk` 函数。

​		**`thunk`** 是一种特定类型的 `Redux` 函数，可以包含异步逻辑。`Thunk` 是使用两个函数嵌套配合编写出来的：

- 内部函数就是 `thunk` 函数，它依次接收 `dispatch` 和 `getState` 这两个参数。
- 外部函数是创建者函数，它创建并返回 `thunk` 函数，还可接收外部传递的数据。

```js
export const storage1Slice = createSlice({
    name: "storage1",
    initialState: { count: 0 },
    reducers: {
        // 传递的数据存在action的payload属性中
        add: (state, action) => { state.count += action.payload || 1 },
        sub: (state, action) => { state.count -= action.payload || 1 }
    }
});

export const { add, sub } = storage1Slice.actions;

// 定义并导出add reducer的异步版本
export const addAsync = (data) => {
    // 返回一个 thunk 函数
    return (dispatch, getState) => {
        // 在此编写异步更新仓库的逻辑
        setTimeout(() => {
            dispatch(add(data));
        }, 1000);
    };
}

// 定义并导出sub reducer的异步版本
export const subAsync = data => (dispatch, getState) => {
    setTimeout(() => {
        dispatch(sub(data));
    }, 1000);
}

export default storage1Slice.reducer;
```

​		异步 `reducer` 编写好并导出之后，就可以像使用同步 `reducer` 一样使用它们了（用法完全相同）。

```jsx
import { useSelector, useDispatch } from "react-redux";

// 从静态仓库文件中导入各种异步的reducer方法
import { addAsync, subAsync } from "@/store/storage1.js";

export default function Home() {
    const count = useSelector((state) => state.storage1.count);
    const dispatch = useDispatch();
    
    const clickAdd = () => {
        dispatch(addAsync(10));
    };
    const clickSub = () => {
        dispatch(subAsync(5));
    };
    
    return (
    	<div>
        	<h1>Home</h1>
            <div>{count}</div>
            <button onClick={clickAdd}>加10</button>
            <button onClick={clickSub}>减5</button>
        </div>
    );
}
```

​		由于静态仓库的 `state` 是一个 `proxy` 对象，因此异步逻辑不能直接写到同步的 `reducer` 中，否则会报错。

​		更多参考：[用 `Thunk` 编写异步逻辑](https://www.reduxjs.cn/tutorials/essentials/part-2-app-structure#%E7%94%A8-thunk-%E7%BC%96%E5%86%99%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91) 

