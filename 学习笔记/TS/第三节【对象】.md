# 对象

### 对象类型

限制对象类型，其实就是在指定对象的属性及其值的类型。一方面规定了对象允许的属性，另一方面规定了各属性值的类型。

语法：在变量后紧跟一个 `:` 以及一个 `{}`，在 `{}` 中以 `;` 分隔每条属性及其值类型，每条属性与值类型之间以 `:` 连接。

##### 对象属性

```tsx
// 规定了对象允许的属性及其值的类型
let person: {name: string; age: number} = {
    name: 'wanzi',
    age: 14
};
```

注释：

- 在对象的类型注解中，低版本使用分号 `;` 来分隔各属性，高版本中可使用逗号 `,`。为了兼容建议继续使用分号。
- 给变量进行对象的类型注解后，必须给它赋值一个合规的对象。属性不能多，也不能少，且值必须是规定的类型。

##### 对象方法

```tsx
let person: {fn1(): void; fn2(a:string, b: number): void} = {
    fn1() {},
    fn2(a, b) {}
};
```

规定：

- 添加对象方法的类型注解时，必须指定返回值的类型。
- 当指定返回值的类型为：`{}`、`void` 或 `any` 时，相当于没有限定类型，`TS` 会对其进行类型推论，但不会将其固定为某一种类型。

```tsx
// 当返回值的注解类型为：{}、void或any时，允许方法返回任何类型的值，且值的类型不固定。
let person: { fn1(): void; fn2(a: string, b: number): void } = {
    fn1() { 
        return 1;
    },
    fn2(a, b) {
        return a ? a : b;
     }
};

console.log(person.fn1()); 			// 1
console.log(person.fn2('a', 2)); 	// 'a'
console.log(person.fn2('', 2)); 	// 2
```

为了加强对对象方法返回值的类型限定，可以在右边（即：直接在方法上）限定其返回值的类型。

```tsx
// 此时，会对fn2的返回值应用右边的类型限定
let person: { fn1(): void; fn2(a: string, b: number): void } = {
    fn1() {
        return 1;
    },
    fn2(a, b): number | string {
        return a ? a : b;
    }
};
```

因为箭头函数其实是一种表达式。因此，当需要定义箭头函数时，要采用定义属性的方式，将其设置为对象的属性。

```tsx
let person: {af: () => void} = {
     // 箭头函数
    af() {
        // 因为被设置为对象属性，所以内部的this指向该对象。
    }
};
```

##### 注解格式

当注解对象时，可以在每一个分号后换行以美化格式。当每一行只定义和注解一条属性时，分号也可以省略。

```tsx
let person: { 
    fn1(): void; 
    fn2(a: string, b: number): void // 省略分号
    fn3: () => void
} = {
    fn1() {},
    fn2(a, b) {},
    fn3() {}
};
```

##### 类型别名

对象是在编程中需要大量使用的数据结构。因此，单一地使用对象注解不仅相当繁琐，而且代码将会非常臃肿。此时，可以使用类型别名来预定义对象的类型，以提高复用性。

```tsx
// 定义对象的类型别名
type CustomPerson = {
    name: string;
    age: number;
    sayName(): void
};

let person: CustomPerson = {
    name: 'wanzi',
    age: 14,
    sayName() { 
        console.log(this.name);
    }
};

person.sayName(); // 'wanzi'
```

##### 可选属性

与函数的可选参数一样，注解对象的属性时，可以在属性名之后，冒号之前使用一个问号来将该属性设定为可选。但是对象的属性不同于函数的参数，它没有严格的顺序规定。因此，对象的可选属性可以出现在对象中的任何位置，它主要靠属性名来匹配和辨认。

```tsx
let person: {
    name: string;
    age?: number; // 可选属性
    sayName(): void
} = {
    name: 'wanzi',
    sayName() {
        console.log(this.name);
    }
};

console.log(person); // { name: 'wanzi', sayName: [Function: sayName] }
```

##### 只读属性

在注解对象的属性时，可以在属性名前应用一个 `readonly` 关键字，来将该属性设定为只读属性。

```tsx
let person: {
    readonly name: string; // 只读属性
    age?: number; // 可选属性
    sayName(): void
} = {
    name: 'wanzi',
    sayName() {
        console.log(this.name);
    }
};

person.name = 'cherry'; // Cannot assign to 'name' because it is a read-only property.
```

注意：只读属性与使用 `const` 声明的常量一样，只是不允许修改它的栈值（如：通过等号重新赋值）。但如果是通过替换其父对象引用的方式，则可以指定一次只读属性的值，因为这相当于是在给它进行初始化。不过，通常也不会替换掉整个父对象的引用。

```tsx
type CustomPerson = {
    readonly name: string;
    age: number;
    sayName(): void
};

let person: CustomPerson;

person = {
    name: 'wanzi', // 初始化只读属性
    age: 16,
    sayName() {}
}

console.log(person); // { name: 'wanzi', age: 16, sayName: [Function: sayName] }

person = {
    name: 'cherry', // 初始化只读属性
    age: 19,
    sayName() {}
}

console.log(person); // { name: 'cherry', age: 19, sayName: [Function: sayName] }
```

另外，通过 `TS` 的类型兼容机制，可以绕过对只读属性的限制而修改它们的值。

```tsx
// 类型兼容：一个对象的属性及其类型，被另一个对象的属性及其类型完全兼容的情况。
interface IPerson1 {
    name: string;
    age: number
}

// IPerson2的属性类型完全兼容IPerson1
interface IPerson2 {
    readonly name: string;
    readonly age: number | string
}

let person1: IPerson1 = {
    name: 'wanzi',
    age: 14
};

// 当类型完全兼容时，可以直接将被兼容的类型（或子类型）赋值给兼容的类型（或父类型）。
let person2: IPerson2 = person1; // 两者引用同一个堆，但它们对属性的要求不同。

// person2的两个属性都是只读的，但可以通过修改person1，来间接地修改person2中的属性值。因为两者维护的是同一个内存空间。
person1.name = 'cherry' // 直接修改堆中的内容
person1.age = 20; 		// 直接修改堆中的内容

console.log(person1); // { name: 'cherry', age: 20 }
console.log(person2); // { name: 'cherry', age: 20 }
```

##### 只读数组

定义数组时，若使用 `ReadonlyArray` 泛型注解，则可以将该数组定义成一个只读数组。即：其根元素的栈值不可被修改。

注释：所有会影响数组自身的 `API` 都被只读数组剔除了。如果要修改只读数组，就只能整个替换它的引用。

```tsx
let arr: ReadonlyArray<number> = [1, 2, 3];

arr[0] = 10; // Index signature in type 'readonly number[]' only permits reading.
```

只读数组也可以在对象中使用。

```tsx
type CustomPerson = {
    readonly name: string;
    age: number;
    arr: ReadonlyArray<number>
};
```

##### 动态属性

为了增加对象的灵活性，`TS` 允许通过索引签名的方式，使用中括号语法，为对象设置动态属性。

设置了动态属性后，就允许动态地向对象中额外添加任意多个属性了，这些属性及其值只要符合类型要求即可。

```tsx
type CustomPerson = {
    readonly name: string;
    age: number;
    [propName: string]: any // 对象属性默认为string型，其值此处被指定为any型。
};

// 该对象除了要指定必须的属性外，还可以额外地添加任意数量的属性。
let person: CustomPerson = {
	name: 'wanzi',
    age: 16,
    // 上面是对象的必选属性，下面是动态添加的对象属性。
    sex: '女',
    id: 1
};

console.log(person); // { name: 'wanzi', age: 16, sex: '女', id: 1 }
```

注意：

- 中括号中的属性名是随意的，但必须指定其类型，可以是：`string`、`number` 或 `symbol`。
- 动态属性的值类型也必须指定，并且此后动态添加的属性都必须符合这个值类型要求。
- 一旦明确了动态属性的值类型，则其他的属性值都必须符合该动态属性的值类型要求。
- 索引签名可以指定多个，且可以写在对象中的任意位置，但索引签名的类型不能重复。

```tsx
// 每种类型的索引签名只能定义一个，不能重复定义。
type CustomPerson = {
    name: string;
    [a: string]: any; // string型的索引签名，值类型为any
    age: number;
    [b: number]: any; // number型的索引签名，值类型为any
    [c: symbol]: any; // symbol型的索引签名，值类型为any
};
```

注释：中括号中的属性名十分随意，可以完全相同，也可以是已知的属性名。它只是一种临时占位符，没有任何额外的实际意义。

```tsx
// 一旦明确了某个索引签名的值类型，则其余的值类型都必须符合它的要求
type CustomPerson = {
    name: string;
    [a: string]: string; // string型的索引签名，值类型为string
    age: any;
    [b: number]: string; // number型的索引签名，值类型为string
    [c: symbol]: string; // symbol型的索引签名，值类型为string
};
```

上述代码，因为将索引签名的值类型指定为了 `string` 型，所以其他的值类型也都必须是 `string` 型或者 `any` 型（兼容任意类型）。

因此，在设置动态属性时，为了获得更大的兼容性，动态属性的值类型要能够兼容其他属性的值类型，通常会设其为 `any` 型。这样，其他属性的值才能够指定合理的类型。

```tsx
type CustomPerson = {
    name: string;
    [a: string]: string | number; // 兼容其他字符串属性的值类型（如果有undefined、null或void值类型，需要在此指定）
    age: number;
    [b: number]: number; // 在动态属性中：数字属性的值类型不能超过字符串属性的值类型
    [c: symbol]: boolean; // 兼容其他符号属性的值类型（如果有undefined、null或void值类型，需要在此指定）
};
```

字符串属性和符号属性是两种属性，因此动态字符串属性的值类型，只能限制字符串属性的值类型，并不会限制符号属性的值类型。

利用数字型动态属性（即：数字索引签名），也可以实现定义数组的类型，因为数组就是典型的以数字为属性的对象。

```tsx
// 定义一维数组的类型
type MyArr = {
    [i: number]: any // 元素为任意类型
}

let arr: MyArr = [1, '2', true, undefined, null, []];

// 定义多维数组的类型
type MyArr = {
    [i: number]: Array<number | string> | boolean
}

let arr: MyArr = [[1, 2], ['3', 4, 5], true];
```



### 接口类型

当对象的数据类型比较复杂或者想要对对象进行更复杂的扩展时，则可以使用接口来定义对象类型。

接口主要针对函数、对象和类，使用一个 `interface` 关键字来定义，目的主要是为了提高复用性。

##### 定义对象

```tsx
// 接口名通常使用一个大写的字母“I”开头，然后紧跟一个花括号即可。
// 接口定义对象类型
interface IPerson {
    name: string;
    age: number;
    sayName(): void
}

// 使用接口时，也只能且必须定义已知的属性和方法。
let person: IPerson = {
    name: 'wanzi',
    age: 14,
    sayName() { 
        console.log(this.name);
    }
};

person.sayName(); // 'wanzi'
```

所有适用于对象类型的语法，也都基本适用于接口类型。

##### 定义函数

使用接口定义函数，同样是限制其输入和输出。其语法类似定义对象类型与函数类型的结合。

```tsx
// 接口定义函数类型
interface IFn {
    (x: number, y: number): number
}

let fn1: IFn = (x, y) => x + y;
```

如果使用类型别名来定义函数类型，则要像下面这样改写。

```tsx
type Fn = (x: number, y: number) => number; // 没有花括号，且使用箭头指定返回值的类型
```

##### 同名接口

可以定义多个同名的接口，当使用的接口是用于定义对象类型时，这些同名的接口最终会合并为一个接口。

```tsx
// 使用多个同名的接口定义函数类型
// 多个同名的接口最终会合并为一个，重复的部分必须类型相同。
interface IPoint {
    x: number
}
interface IPoint {
    x: number; // 重复的部分类型必须一致，不能多也不能少，否则合并会失败
    y: number
}
interface IPoint {
    z: number
}

/* 最后合并为一个对象类型：
interface IPoint {
    x: number;
    y: number;
    z: number
}*/

let point: IPoint = {
    x: 1,
    y: 2,
    z: 3
};
```

当使用的接口是用于定义函数类型时，这些同名的接口最终会合并为该函数类型的重载签名。

注意：

- 合并后的重载签名，必须完全被实现签名所兼容。
- 实现合并的重载签名时，可简单地将输入的类型进行联合，但不可以简单地将输出的类型也进行联合（建议给它一个 `any` 类型）。

```tsx
// 使用多个同名的接口定义函数类型
interface IFn {
    (x: number, y: number): number | void
}
interface IFn {
    (x: string, y: string): string | void // 后定义的重载签名优先级更高
}

/* 最后合并为该函数类型的重载签名，且“后来者居上”
interface IFn {
	(x: string, y: string): string | void
	(x: number, y: number): number | void
}
*/

// 实现签名（简单地联合输出的类型可能会导致该函数的类型不符合接口的类型要求）
let fn: IFn = (x: number | string, y: number | string): any => {
    // 在TS中，不能将运算符应用于类型不明确的操作数
    if (typeof x === 'number' && typeof y === 'number') {
        return x + y;
    } else if (typeof x === 'string' && typeof y === 'string'){
        return x + y;
    }
}

// 使用函数
console.log(fn(1, 2)); 		// 3
console.log(fn('1', '2')); 	// '12'
```

如果有可选的参数，那么要在重载签名和实现签名中都将该参数设为可选。

```tsx
// 使用同名接口定义重载签名
interface IFn {
    (x: number, y: number): number | void
}
interface IFn {
    (x: string, y: string): string | void
}
interface IFn {
    (x: string, y: string, z?: string): string | void // 高版本中，这里不用设置可选。但低版本中需要。
}

// 实现签名
let fn: IFn = (x: string | number, y: string | number, z?: string): any => {}

fn(1, 2);
fn('1', '2');
fn('1', '2', '3');
```

##### 接口继承

接口可以像类一样，通过 `extends` 关键字来实现单次继承，目的是为了在已有接口的基础上进行扩展【接口类型一次只可扩展一个】。

```tsx
interface IBase {
    a: number
}

// 扩展已有的接口类型：花括号中为扩展的部分，扩展后的接口类型赋值给Sub。
interface ISub extends IBase {
    // 扩展的部分
    b: number
}

let obj: ISub = {
    a: 1,
    b: 2
};
```

扩展类型别名：在定义新的类型别名时，在右边可以使用一个 `&` 链接已有类型别名和扩展的部分【类型别名可以一次性扩展多个】。

```tsx
type BaseObject = {
    a: number
};

// 扩展已有的类型别名
type SubObject = BaseObject & {
    // 扩展部分1
    b: number
} & {
    // 扩展部分2
    c: number
}

let obj: SubObject = {
    a: 1,
    b: 2,
    c: 3
};
```

其实，接口类型与类型别名是可以相互扩展的。

```tsx
type BaseObject = {
    a: number
};

// 接口类型扩展类型别名
interface ISub extends BaseObject {
    b: number
}

// 类型别名扩展接口类型
type SubObject = ISub & {
    c: number
}
```

接口类型与类型别名的主要区别：

1. 首先，使用接口只能定义对象和函数（包括类）的类型；而类型别名几乎可以定义所有的类型。
2. 其次，使用接口定义对象和函数类型的语法跟使用类型别名定义它们的语法很明显是不一样的。
3. 再者，接口允许定义多个同名的接口（同名接口最终会合并为一个）；而类型别名不允许重名。
4. 最后，接口类型使用 `extends` 关键字且只能实现单次扩展；而类型别名使用 `&` 且可多次扩展。

当然，只定义简单的类型约束时，使用类型别名就足够了。但如果要定义复杂的类型约束，可考虑使用接口类型。



### 元组类型

`TS` 在限制数组类型时，只限制了其中元素的类型，但这样是不够严谨的。因为数组的长度和数组槽位的类型都还没有得到限制。因此，要将对数组的类型进行彻底地限制，就可以使用元组类型。

元组本身也是一种数组，只不过它更加严格，它额外规定了数组槽位的数量以及各个槽位的类型。

```tsx
// 数组将类型约束到外面（即：整体），元组将类型约束到内部（即：局部）。
// 定义一个长度为3，各槽位的类型依次如下的元组。
let tuple: [number, string, boolean] = [1, '2', true]; // 元组的长度和槽位类型必须都符合要求
```

##### 伸缩元组

元组的长度已经得到了限制，因此不可以使用越界的索引去扩展元组。

```tsx
tuple[3] = 3; // Tuple type '[number, string, boolean]' of length '3' has no element at index '3'.
```

但是因为元组具有 `push()` 等方法，因此，元组可以通过 `push` 等 `API` 进行伸缩。但扩展的槽位类型只能是已知槽位的类型之一。

```tsx
// 1、扩展元组
// 可以通过push或unshift，向元组中推入number、string或boolean类型的元素。
tuple.push(3);
tuple.push('4');
tuple.push(false);
tuple.unshift(); // 空插：什么也不插入

// 推入其他类型的元素，则会导致报错。
tuple.push(undefined); 
// Argument of type 'undefined' is not assignable to parameter of type 'string | number | boolean'.
------------------------------------------------------------------------------------------------------------

// 2、压缩元组
tuple.pop();
tuple.shift();
```

##### 可选元素

元组允许设置可选的元素。注解时，在槽位的类型后面紧跟一个 `?`，表示将该槽位设为可选。

```tsx
let tup: [number, number?, number?];

tup = [1];
tup = [1, 2];
tup = [1, 2, 3];
```

注意：元组元素与函数的参数列表（类数组）一样，具有严格的顺序要求。因此，可选元素必须在必选元素之后。

##### 剩余元素

同样，函数的参数列表可以通过扩展运算符设定剩余参数，那么元组也可以使用扩展运算符来设定剩余元素。但可放在元组中任意位置。

```tsx
// 剩余元素可以设置在元组的任何位置，但只能设置一个。另外，元组的剩余元素必须是数组类型，且可以指定它的类型。

// 设置在元组首部
let tup: [...string[], number, number] = ['1', '2', 3, 4];

// 设置在元组中间
let tup: [number, ...string[], number] = [1, '2', '3', 4];

// 设置在元组尾部
let tup: [number, number, ...string[]] = [1, 2, '3', '4'];
```

注释：因为 `rest` 元素不能跟在另一个 `rest` 元素之后，因此，在元组中也只能设置一个剩余元素。

##### 只读元组

使用 `readonly` 关键字，可以将一个元组设为只读。与只读数组一样，所有会影响元组自身的 `API` 都被只读元组剔除了。如果要修改只读元组，就只能整个替换它的引用。

```tsx
let tup: readonly[number, number, ...string[]]; // 只读元组没有push、pop等可以改变元组自身的方法。

tup = [1, 2, '3', '4'];
```



### 解构赋值

`TS` 允许对数组、元组和对象进行解构赋值。解构时不允许再设置类型约束，且只能解构已知的属性，不允许溢出解构。

```tsx
// 解构元组
let tup: [number, string] = [1, '2'];

// 完全解构
let [num, str] = tup;
console.log(num); // 1
console.log(str); // '2'

// 部分解构
let [, str] = tup;
console.log(str); // '2'

// 溢出解构
let [, , more] = tup; // Tuple type '[number, string]' of length '2' has no element at index '2'.
```

```tsx
// 解构对象
interface IObj {
    name: string,
    age: number
}

let obj: IObj = {
    name: 'wanzi',
    age: 16
};

// 解构并重命名
let {name: a, age: b} = obj;

console.log(a); // 'wanzi'
console.log(b); // 16
```

