# 装饰器模式

装饰器模式（`Decorator Pattern`）允许向一个现有的对象添加新的功能，同时又不改变其原有的功能和结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。



### 介绍

**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**如何解决：**将具体功能职责划分，同时继承装饰者模式。

**关键代码：** 

- `Component` 类充当抽象角色，不应该具体实现。 
- 修饰类引用和继承 `Component` 类，具体扩展类重写父类方法。

**应用实例：** 

- 孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。
- 不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。

**使用场景：** 

- 扩展一个类的功能。
- 动态增加功能，动态撤销。

**注意事项：**可代替继承。



### 实现

##### 简单实现

最简单直接地使用装饰器模式，就是直接在实例上增加方法或属性。

```js
function Person(name, sex) {
    this.name = name;
    this.sex = sex;
}
Person.prototype.say = function() {
    console.log(`${this.name}: ${this.sex}`);
}

let wz = new Person("wz", "女");
let cy = new Person("cy", "女");

// 增加功能，装饰对象
wz.age = 16;
cy.age = 19;
```

通常，应该实现一个装饰器函数，使用统一的接口来装饰对象。

```js
function Decorator(origin, decoration) {
	origin.age = decoration.age;
    // ...
}

Decorator(wz, { age: 16, eat: () => {} });
Decorator(cy, { age: 19, eat: () => {} });
```

抽象封装

```js
function Decorator(origin, decoration) {
    for(const key of Object.keys(decoration)) {
        origin[key] = decoration[key];
    }
}

// 直接使用 Object.assign(origin, decoration) 也是一样的
```

对于一些引用值，通常应该添加到原型上共用，尤其是方法。如果要添加属性或方法到原型上，则可以为此定义一个静态方法。

```js
Decorator.setProto = function(origin, proto) {
    const prototype = Object.getPrototypeOf(origin);
    for (const key of Object.keys(proto)) {
        prototype[key] = proto[key];
    }
};
```

##### 封装优化

上述封装，直接触及源对象的原型，有时可能会带来麻烦。如果想再加一层隔离层，则可以像下面这样定义。

```js
function Decorator(origin, decoration) {
    return Object.assign(Object.create(origin), decoration);
}

wz = new Decorator(wz, {age: 16});
cy = new Decorator(cy, {age: 19});
```

##### 闭包封装

上述封装，虽然隔离了源对象的原型，但隔离层的原型是共享的。如果想要使隔离层的原型相互独立，则可以使用闭包封装。

```js
let Decorator = (function() {
    const assign = Object.assign;
    
    function Origin(data) {
        // 新增实例属性
		assign(this, data);
    }
    
    return function(origin, {instance, proto}) {
        // 不断继承前人添加的原型方法
        Origin.prototype = assign(origin, proto);
        return new Origin(instance); // 注意：返回的是此时此刻的快照。
    }
}());

wz = new Decorator(wz, {
    instance: {
    	age: 16
	},
    proto: {
        eat() {}
    }
});

cy = new Decorator(cy, {
    instance: {
    	age: 19
	},
    proto: {
        eat() {}, // 重写wz添加的eat原型方法
        slp() {}  // 增加原型方法slp（该方法不会共享到前人的原型上）
    }
});
```

```js
console.log(wz); // Origin {age: 16}
/*
Origin {
	age: 16,
	[[Prototype]]: Person {
		eat: ƒ eat()
		name: "wz"
		sex: "女"
		[[Prototype]]: Object {
			say: ƒ ()
			constructor: ƒ Person(name, sex)
			[[Prototype]]: Object
		}
	}
}
*/

console.log(cy); // Origin {age: 19}
/*
Origin {
	age: 19,
	[[Prototype]]: Person {
		eat: ƒ eat()
		name: "cy"
		sex: "女",
		slp: f slp(),
		[[Prototype]]: Object {
			say: ƒ ()
			constructor: ƒ Person(name, sex)
			[[Prototype]]: Object
		}
	}
}
*/
```

注意：后人添加的原型方法，前人是没有的。因为，前人在 `new Origin()` 时，`Origin.prototype` 上还没有这些方法。每次执行 `new Origin()` 返回的都是一个快照，因此它们的原型是不共享的。后人的原型只可能越来越大，不可能越来越小。

