# 工作者线程

前端开发者常说：“`JavaScript` 是单线程的”。这种说法虽然有些简单，但描述了 `JavaScript` 在浏览器中的一般行为。因此，作为帮助 `Web` 开发人员理解 `JavaScript` 的教学工具，它非常有用。

单线程就意味着不能像多线程语言那样把**工作委托**给独立的线程或进程去做，无法充分发挥现代计算机多核 `CPU` 的优势。`JS` 的单线程可以保证它与不同的浏览器 `API` 兼容。假如 `JavaScript` 可以多线程执行并发更改，那么像 `DOM` 这样的 `API` 就会使渲染不可控。因此，`POSIX` 线程或 `Java` 的 `Thread` 类等传统并发结构都不适合 `JavaScript`。【渲染必须是单线程的，否则就会造成页面混乱】

而这也正是工作者线程的**价值所在**：允许把主线程的**工作转嫁**给独立的实体，而不会改变现有的单线程模型。虽然本章要介绍的各种工作者线程有着不同的形式和功能，但它们的**共同特点**是都独立于 `JavaScript` 的主执行环境。



### 工作者线程简介

`JavaScript` 环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。这样，每个页面都有自己的内存、事件循环、`DOM`，等等。每个页面就相当于一个沙盒，不会干扰其他页面。对于浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。

使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级**子环境**。这个子环境不可以与依赖单线程交互的 `API`（如 `DOM`）互操作，但**可以与父环境并行执行代码**。

`Web Worker` 的作用，就是为 `JavaScript` 创造多线程环境，允许主线程创建 `Worker` 线程，将一些任务分配给后者运行。在主线程运行的同时，`Worker` 线程在后台运行，两者互不干扰。等到 `Worker` 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 `Worker` 线程负担了，主线程（通常负责 `UI` 交互）就会很流畅，不会被阻塞或拖慢。

 `Worker` 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 `Worker` 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

`web worker` 的一些特点：

- **同源限制**：分配给 `Worker` 线程运行的脚本文件，必须与主线程的脚本文件同源。也就是说只能加载来自网络的脚本文件，无法读取本地文件。
- **`DOM` 限制**：`Worker` 线程所在的全局对象，与主线程不一样。无法读取主线程所在网页的 `DOM` 对象，也无法使用 `document`、`window`、`parent` 这些对象，自然也不能 `alert()`。但是，`Worker` 线程可以使用 `navigator` 对象和 `location` 对象。
- **实际线程：**工作者线程是以实际线程实现的。但不一定在同一个进程里（一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于）。
- **并行执行：**虽然页面和工作者线程都是单线程 `JavaScript` 环境，但多个工作者线程可以并行执行。
- **通信联系：**`Worker` 线程和主线程不在同一个上下文环境中，因此它们不能直接通信，必须通过消息完成。



#### 与执行线程

作为介绍，通常需要将工作者线程与执行线程进行比较。在许多方面，这是一个恰当的比较，因为工作者线程和线程之间确实存在很多共同之处。

- **工作者线程是以实际线程实现的**。例如，`Blink` 浏览器引擎实现工作者线程的 `WorkerThread` 就对应着底层的线程。
- **工作者线程并行执行**。虽然页面和工作者线程都是单线程 `JavaScript` 环境，但每个工作者环境中的指令都可以并行执行。
- **工作者线程可共享部分内存**。工作者线程能够使用 `SharedArrayBuffer` 在多个环境间共享内容。虽然线程会使用锁实现并发控制，但 `JavaScript` 使用 `Atomics` 接口实现并发控制。

工作者线程与线程有很多类似之处，但也有重要的区别。

- **工作者线程不共享全部内存**。在传统线程模型中，多线程有能力读写共享内存空间。除了 `SharedArrayBuffer` 外，从工作者线程进出的数据需要复制或转移。
- **工作者线程不一定在同一个进程里**。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者线程可能与页面属于同一进程，也可能不属于。例如，`Chrome` 的 `Blink` 引擎对共享工作者线程和服务工作者线程使用独立的进程。
- **创建工作者线程的开销更大**。工作者线程有自己独立的事件循环、全局对象、事件处理程序和其他 `JavaScript` 环境所必需的特性。因此，创建这些结构的代价不容忽视。

无论形式还是功能，工作者线程都不是用于替代线程的。`HTML Web` 工作者线程规范是这样说的：

> 工作者线程相对比较重，不建议大量使用。例如，对一张 400 万像素的图片，为每个像素都启动一个工作者线程是不合适的。通常，工作者线程应该是长期运行的，其启动成本比较高，每个实例占用的内存也比较大。



#### 线程的类型

`Web` 工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。现代浏览器都支持这些工作者线程。注意，`Web` 工作者线程规范参见 `HTML Standard` 网站。

##### 专用工作者线程

专用工作者线程，通常简称为工作者线程（`Web Worker` 或 `Worker`），是一种实用的工具，它允许脚本单独创建一个 `JavaScript` 线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它的页面所使用。

##### 共享工作者线程

共享工作者线程与专用工作者线程非常相似。主要区别是共享工作者线程可以被多个不同的上下文使用，包括不同的页面，主要用于共享内容。任何与创建共享工作者线程的脚本同源的脚本，都可以向共享工作者线程发送消息或从中接收消息。

##### 服务工作者线程

服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的请求，充当网络请求的仲裁者角色。

注意：还有其他一些工作者线程规范，比如 `ChromeWorker` 或 `Web Audio API`，但它们并未得到广泛支持，或者定位于小众应用程序，因此本章没有包含与之相关的内容。



#### 线程作用域

在网页上，`window` 对象可以向运行在其中的脚本暴露各种全局变量。但在工作者线程内部，没有 `window` 的概念。这里的全局对象是 `WorkerGlobalScope` 的实例，通过 `self` 关键字暴露出来。

```js
// 在正常环境中
console.log('self',self); // -> 打印结果是Window实例
```

```js
// 在worker环境中
const worker_code = () => {
    
    // 向主线程发送一条消息
    self.postMessage('worker loaded successfully...');

    // 监听主线程发来的信息
    self.onmessage = (e) => {
        console.log('接收到的event:',e);
        let result = `从主线程接收到的数据 ${e.data}`;
        self.postMessage(result)
    }

    console.log('self',self); // -> 打印结果是WorkerGlobalScope实例
}
```

##### 属性和方法

`self` 上可用的属性是 `window` 对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。

- `navigator`：返回与工作者线程关联的 `WorkerNavigator`。
- `self`：返回 `WorkerGlobalScope` 的实例。
- `location`：返回与工作者线程关联的 `WorkerLocation`。
- `performance`：返回（只包含特定属性和方法的）`Performance` 对象。
- `console`：返回与工作者线程关联的 `Console` 对象；对 `API` 没有限制。
- `caches`：返回与工作者线程关联的 `CacheStorage` 对象；对 `API` 没有限制。
- `indexedDB`：返回 `IDBFactory` 对象。
- `isSecureContext`：返回布尔值，表示工作者线程上下文是否安全。
- `origin`：返回 `WorkerGlobalScope` 的源。

类似地，`self` 对象上暴露的一些方法也是 `window` 上方法的子集。这些 `self` 上的方法也与 `window` 上对应的方法操作一样。

- `atob()`
- `btoa()`
- `clearInterval()`
- `clearTimeout()`
- `createImageBitmap()`
- `fetch()`
- `setInterval()`
- `setTimeout()`

`WorkerGlobalScope` 还增加了新的全局方法 `importScripts()`，只在工作者线程内可用。本章稍后会介绍该方法。

##### 子类

实际上，并不是所有地方都实现了 `WorkerGlobalScope`。每种类型的工作者线程都使用了自己特定的全局对象，但是它们都继承自 `WorkerGlobalScope`。

- 专用工作者线程使用 `DedicatedWorkerGlobalScope`。【`dedicated`：专用的】
- 共享工作者线程使用 `SharedWorkerGlobalScope`。
- 服务工作者线程使用 `ServiceWorkerGlobalScope`。

本章稍后会在这些全局对象对应的小节中讨论其差异。



### 专用工作者线程

专用工作者线程是最简单的 `Web` 工作者线程，网页中的脚本可以创建专用工作者线程来执行在页面线程之外的其他任务。这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）。

注意：在使用工作者线程时，脚本在哪里执行、以及在哪里加载都是非常重要的概念。除非另有说明，否则本章假定 `main.js` 是从 `https://example.com` 域的根路径加载并执行的顶级脚本。



#### 基本概念

可以把专用工作者线程称为后台脚本（`background script`）。`JavaScript` 线程的各个方面，包括生命周期管理、代码路径和输入输出，都由初始化线程时提供的脚本来控制。该脚本也可以再请求其他脚本，但一个线程总是从一个脚本源开始。

##### 创建线程

创建专用工作者线程最常见的方式是加载 `JavaScript` 文件。把文件路径提供给 `Worker` 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程。传给构造函数的文件路径可以是多种形式。

下面的代码演示了如何创建空的专用工作者线程。由于同源策略，创建线程必须在网络文件中运行。

```js
console.log(location.origin); // "http://127.0.0.1:59481" 

const worker = new Worker((new URL(location.origin)).toString() + 'emptyWorker.js');

console.log(worker); 		  // Worker {onmessage: null, onerror: null}
/*
Worker {
	onerror: null,
	onmessage: null, 
	[[Prototype]]: Worker {
		onerror: null,
		onmessage: null,
		postMessage: ƒ postMessage(),
		terminate: ƒ terminate(),
		constructor: ƒ Worker(),
		Symbol(Symbol.toStringTag): "Worker",
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		get onmessage: ƒ onmessage(),
		set onmessage: ƒ onmessage(),
		[[Prototype]]: EventTarget
	}
}
*/
```

这个例子非常简单，但涉及以下几个基本概念。

- `emptyWorker.js` 文件是从绝对路径加载的。根据应用程序的结构，使用绝对 `URL` 经常是多余的。
- 这个文件是在后台加载的，工作者线程的初始化完全独立于 `main.js`。
- 工作者线程本身存在于一个独立的 `JavaScript` 环境中，因此 `main.js` 必须以 `Worker` 对象为代理实现与工作者线程的通信。在上面的例子中，该对象被赋值给了 `worker` 变量。
- 虽然相应的工作者线程可能还不存在，但该 `Worker` 对象已在原始环境中可用了。

前面的例子可修改为使用相对路径而不必手动指定源。不过，这要求 `main.js` 必须与 `emptyWorker.js` 在同一个路径下：

```js
const worker = new Worker('./emptyWorker.js'); // 默认从当前源中加载
```

##### 安全限制

工作者线程的脚本文件只能从与父页面相同的源中加载。从其他源加载工作者线程的脚本文件会导致错误，如下所示：

```js
// 尝试基于 https://example.com/worker.js 创建工作者线程
const sameOriginWorker = new Worker('./worker.js'); 

// 尝试基于 https://untrusted.com/worker.js 创建工作者线程
const remoteOriginWorker = new Worker('https://untrusted.com/worker.js'); 
// Uncaught DOMException: Failed to construct 'Worker': Script at 'https://untrusted.com/worker.js' cannot be accessed from origin 'https://example.com'.
```

注意：虽然使用非同源的脚本无法创建工作者线程，但并不影响已创建的工作者线程加载和执行其他源的脚本。在工作者线程内部，使用 `importScripts()` 可以加载其他源的脚本。本章稍后会介绍。

基于加载脚本创建的工作者线程不受文档的内容安全策略（`CSP`，`Content Security Policy`）限制，因为工作者线程在与父文档不同的上下文中运行。不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容安全策略的限制。

注意：在后续的《行内创建》小节中会介绍基于二进制大文件创建工作者线程。

##### 使用线程

`Worker()` 构造函数返回的 `Worker` 对象是与刚创建的专用工作者线程通信的连接点。它可用于在工作者线程和父上下文之间传输信息，以及捕获专用工作者线程发出的事件。

注意：必须管理好使用 `Worker()` 创建的每个 `Worker` 对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过编程方式恢复对之前 `Worker` 对象的引用。

`Worker` 对象支持下列事件处理程序属性。

- `onerror`：在工作者线程中发生 `ErrorEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程抛出错误时发生。该属性是伴生属性。
  - 该事件也可以通过 `worker.addEventListener('error', handler)` 的形式处理。

- `onmessage`：在工作者线程中发生 `MessageEvent` 类型的消息事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程向父上下文发送消息时发生。该属性是伴生属性。
  - 该事件也可以通过使用 `worker.addEventListener('message', handler)` 处理。

- `onmessageerror`：在工作者线程中发生 `MessageEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 该事件会在工作者线程收到无法反序列化的消息时发生。注意，此属性非伴生属性。
  - 该事件也可以通过使用 `worker.addEventListener('messageerror', handler)` 处理。


`Worker` 对象还支持下列方法。

- `postMessage()`：用于通过异步消息事件向此工作者线程发送信息。
- `terminate()`：用于立即终止工作者线程。没有为工作者线程提供清理的机会，脚本会突然停止。

##### 全局作用域

在专用工作者线程内部，全局作用域是 `DedicatedWorkerGlobalScope` 的实例。因为继承自 `WorkerGlobalScope`，所以包含它的所有属性和方法。工作者线程可以通过 `self` 关键字访问该全局作用域。

```js
// globalScopeWorker.js
console.log('inside worker:', self); 

// main.js
const worker = new Worker('./globalScopeWorker.js'); 

console.log('created worker:', worker); 
/*
> created worker: Worker {...} 
> inside worker: DedicatedWorkerGlobalScope {...}
*/
```

如此例所示，顶级脚本和工作者线程中的 `console` 对象都将写入浏览器控制台，这对于调试非常有用。因为工作者线程具有不可忽略的启动延迟，所以即使 `Worker` 对象存在，工作者线程的日志也会在主线程的日志之后打印出来。

注意：这里两个独立的 `JavaScript` 线程都在向一个 `console` 对象发消息，该对象随后将消息序列化并在浏览器控制台打印出来。浏览器从两个不同的 `JavaScript` 线程收到消息，并按照自己认为合适的顺序输出这些消息。为此，在多线程应用程序中使用日志确定操作顺序时必须要当心。

`DedicatedWorkerGlobalScope` 在 `WorkerGlobalScope` 基础上增加了以下属性和方法。

- `name`：可以提供给 `Worker` 构造函数的一个可选的字符串标识符。
- `postMessage()`：与 `worker.postMessage()` 对应的方法，用于从工作者线程内部向父上下文发送消息。
- `close()`：与 `worker.terminate()` 对应的方法，用于立即终止工作者线程（实际上不会立即终止线程，只是取消事件循环中的所有任务并阻止添加新任务）。没有为工作者线程提供清理的机会，脚本会突然停止？
- `importScripts()`：用于向工作者线程中导入任意数量的脚本。



#### 隐式通信

专用工作者线程的 `Worker` 和 `DedicatedWorkerGlobalScope` 都与 `MessagePorts`（消息端口）有一些相同的接口处理程序和方法：`onmessage`、`onmessageerror`、`close()` 和 `postMessage()`。这不是偶然的，因为专用工作者线程隐式使用了 `MessagePorts` 在（脚本与其线程）这两个上下文之间通信。

父上下文中的 `Worker` 和线程上下文中 `DedicatedWorkerGlobalScope` 实际上都融合了 `MessagePort`，并在自己的接口中分别暴露了相应的处理程序和方法。换句话说，消息还是通过 `MessagePort` 发送的，只是没有直接使用 `MessagePort` 而已。

也有不一致的地方，如对 `start()` 和 `close()` 的约定。专用工作者线程会自动发送排队的消息，因此 `start()` 也就没有必要了。另外，`close()` 在专用工作者线程的上下文中没有意义，因为这样关闭 `MessagePort` 会使工作者线程陷入孤立。因此，在工作者线程内部调用 `close()`（或在外部调用 `terminate()`）不仅会关闭 `MessagePort`，也会终止线程。



#### 生命周期

调用 `Worker()` 构造函数是一个专用工作者线程生命的起点。调用之后，它会初始化对工作者线程脚本的请求，并把 `Worker` 对象返回给父上下文。虽然父上下文中可以立即使用这个 `Worker` 对象，但与之关联的工作者线程可能还没有创建，因为存在请求脚本的网络延迟和初始化延迟。

专用工作者线程一般可以非正式地划分为下列三种状态：初始化（`initializing`）、活动（`active`） 和终止（`terminated`）。这几个状态对其他上下文是不可见的。虽然 `Worker` 对象可能会存在于父上下文中，但也无法通过它确定工作者线程当前是处于哪个状态。换句话说，与活动的专用工作者线程关联的 `Worker` 对象和与终止的专用工作者线程关联的 `Worker` 对象无法分别。

##### 初始化线程

初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作者线程的状态变为活动，然后再把消息添加到它的消息队列。下面的代码演示了这个过程。

```js
// 在 initializingWorker.js 中
self.addEventListener('message', ({data}) => console.log(data)); 

// 在 main.js 中
const worker = new Worker('./initializingWorker.js'); 

// Worker可能仍处于初始化状态，但可以先使用postMessage()发送数据。
worker.postMessage('foo'); 
worker.postMessage('bar'); 
worker.postMessage('baz');
```

当工作者线程的状态从初始化变为活动后，这些消息就会被添加到此工作者线程的消息队列中。最终，它会依次输出如下结果：

```
foo 
bar 
baz
```

##### 终止线程

创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非通过 `self.close()` 自我终止或通过 `worker.terminate()` 外部终止。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，与之关联的 `Worker` 对象就不会被当成垃圾收集掉。

自我终止和外部终止最终都会执行相同的工作者线程终止例程。如下例，工作者线程在发送两条消息的代码中间执行了自我终止：

```js
// 在 closeWorker.js 中
self.postMessage('foo');

self.close();

for(let i = 0; i < 5; i ++) {
    console.log(i);
}

self.postMessage('bar');

setTimeout(() => self.postMessage('baz'), 0); 

for (let i = 0; i < 5; i++) {
    console.log(i);
}

// 在 main.js 中
const worker = new Worker('./closeWorker.js'); 
worker.onmessage = ({data}) => console.log(data); 
```

虽然调用了 `close()`，但显然工作者线程的执行并没有立即终止。`close()` 在这里会通知工作者线程取消事件循环中的所有任务，并阻止继续添加新任务，这也是为什么 `"baz"` 没有打印出来的原因。然而工作者线程不需要执行同步停止，因此工作者脚本中的其余所有同步代码仍会被正常执行。结果如下，父上下文中消息的打印时机取决于自身何时接收到它：

```
0
1
2
'foo'
3
4
0
1
'bar'
2
3
4
```

下面来看一个外部终止的例子。

```js
// 在 terminateWorker.js 中
self.onmessage = ({data}) => console.log(data); 

// 在 main.js 中
const worker = new Worker('./terminateWorker.js'); 

// 给 1000 毫秒让工作者线程进行初始化
setTimeout(() => { 
 	worker.postMessage('foo'); // 此时，已完成初始化，这条消息将被立即接收。如果未完成，那么它将在消息队列中被清理。
 	worker.terminate(); 
 	worker.postMessage('bar'); 
 	setTimeout(() => worker.postMessage('baz'), 0); 
}, 1000); 
```

这里，外部先给工作者线程发送了带 `"foo"` 的 `postMessage`，这条消息可以在线程被终止之前收到。一旦调用了 `terminate()`，工作者线程的消息队列就会被清理并锁住，这也是结果只打印了 `"foo"` 的原因。由于工作者线程不会立即完成初始化，所以这里等待了它 1 秒。如果不等待它完成，那么此工作者线程在完成初始化之前就会被终止，最终导致它一条消息也收不到。

```
foo
```

注意：`close()` 和 `terminate()` 是幂等操作，多次调用没有问题。这两个方法仅仅是将 `Worker` 标记为 `teardown` 而已，因此多次调用不会产生不好的影响。【`teardown`：拆卸】

在整个生命周期中，一个专用工作者线程只会关联一个网页（工作者线程规范称其为一个文档）。除非明确终止它，否则只要关联文档存在，专用工作者线程就会存在。如果浏览器离开网页（导航到其他页面、关闭标签页或窗口），它会将与其关联的工作者线程标记为终止，它们的执行也会立即停止。



#### 配置选项

`Worker()` 构造函数允许将可选的配置对象作为第二个参数，用以配置加载脚本（即首参）的相关信息。该配置对象支持下列属性。

- `name`：表示加载脚本的字符串标识符。可以在工作者线程中通过 `self.name` 读取到。
- `type`：表示加载脚本的类型，可以是 `"classic"` 或 `"module"`。不同类型的脚本有着不同的运行方式，`"classic"` 将脚本作为常规脚本来执行，`"module"` 将脚本作为模块来执行。
- `credentials`：表示加载脚本的凭据。在 `type` 为 `"module"` 时，指定如何获取与传输凭证数据相关的工作者线程模块脚本。值可以是 `"omit"`、 `"same-orign"` 或 `"include"`。这些选项与 `fetch()` 的凭证选项相同。在 `type` 为 `"classic"` 时，默认为 `"omit"`。【`omit`：省略；`same-origin`：同源；`include`：包含】

注意：有的现代浏览器还不完全支持模块工作者线程或可能需要修改标志才能支持。

```js
const worker = new Worker('./b.js', {
    name: 'b',
    type: "classic",
    credentials: "omit"
});
```



#### 行内创建

工作者线程需要基于脚本文件来创建，但这并不意味着该脚本必须是远程资源。专用工作者线程也可以通过 `Blob` 对象 `URL` 在行内脚本创建。这样可以更快速地初始化工作者线程，因为没有网络延迟。

下面展示了一个在行内创建工作者线程的例子。

```js
// 创建脚本内容
const workerScript = `self.onmessage = ({data}) => console.log(data);`;

// 基于脚本内容生成 Blob 对象
const workerScriptBlob = new Blob([workerScript]); 

// 基于 Blob 实例创建对象 URL 
const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob); 

// 基于对象 URL 创建专用工作者线程
const worker = new Worker(workerScriptBlobUrl); 

worker.postMessage('blob worker script'); 

// 打印结果：blob worker script
```

在这个例子中，通过脚本字符串创建了 `Blob`，然后又通过 `Blob` 创建了对象 `URL`，最后把对象 `URL` 传给了 `Worker()` 构造函数。该构造函数同样创建了专用工作者线程。

如果把所有代码写在一块，则可以浓缩成这样：

```js
const worker = new Worker(URL.createObjectURL(new Blob([
    `self.onmessage = ({data}) => console.log(data);`
]))); 

worker.postMessage('blob worker script'); 
```

工作者线程也可以利用序列化的函数来初始化行内脚本。这是因为函数的 `toString()` 方法返回函数代码的字符串，且函数可以在父上下文中定义但在子上下文中执行。来看下面这个简单的例子：

```js
// 定义斐波那契函数
function fibonacci(n) { 
 	return n < 1 ? 0 : n <= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2); 
} 

const workerScript = `self.postMessage((${fibonacci.toString()})(9));`; 

const worker = new Worker(URL.createObjectURL(new Blob([workerScript]))); 

worker.onmessage = ({data}) => console.log(data); // 34
```

这里有意使用了斐波那契数列的实现，将其序列化之后传给了工作者线程。该函数作为 `IIFE` 调用并传递参数，结果则被发送回主线程。虽然计算斐波那契数列比较耗时，但所有计算都会委托到工作者线程，因此并不会影响父上下文的性能。

注意：像这样序列化函数有个前提，就是函数体内不能使用父上下文中的任何变量，包括全局变量，比如 `window`。由于两个上下文相互独立且不同，这些引用在工作者线程中执行时会导致引用错误。简单来说，就是用于序列化的函数必须是与外界完全独立的纯函数。



#### 动态执行

工作者线程中的脚本并非铁板一块，而是可以使用 `importScripts()` 方法通过编程方式加载和执行任意脚本。该方法可用于全局的 `Worker` 对象，它会加载脚本并按照加载顺序同步执行它们。比如，下面的例子加载并执行了两个脚本：

```js
// 在 scriptA.js 中
console.log('scriptA executes');

// 在 scriptB.js 中
console.log('scriptB executes'); 

// 在 worker.js 中
console.log('importing scripts'); 
importScripts('./scriptA.js'); 
importScripts('./scriptB.js'); 
console.log('scripts imported');

// 在 main.js 中
const worker = new Worker('./worker.js'); 

/*
> 'importing scripts'
> 'scriptA executes'
> 'scriptB executes' 
> 'scripts imported' 
*/
```

`importScripts()` 方法可以一次性接收任意数量的脚本作为参数。浏览器下载它们的顺序没有限制，但执行则会严格按照它们在参数列表的顺序进行。因此，下面的代码与前面的效果一样：

```js
console.log('importing scripts'); 

importScripts('./scriptA.js', './scriptB.js'); // 严格按照此参数列表的顺序执行脚本

console.log('scripts imported');
```

脚本加载受到常规 `CORS` 的限制，但在工作者线程内部可以请求来自任何源的脚本。这种脚本导入策略类似于使用生成的 `<script>` 标签动态加载脚本。在这种情况下，所有被导入的脚本也会共享此工作者线程的全局作用域。下面的代码演示了这个事实：

```js
// scriptA.js
console.log(`scriptA executes in ${self.name} with ${globalToken}`); 

// scriptB.js
console.log(`scriptB executes in ${self.name} with ${globalToken}`); 

// worker.js
const globalToken = 'bar'; 
console.log(`importing scripts in ${self.name} with ${globalToken}`); 
importScripts('./scriptA.js', './scriptB.js'); // 这两个脚本共享这个工作者线程的全局作用域
console.log('scripts imported');

// main.js
const worker = new Worker('./worker.js', {name: 'foo'}); 
```

此时，`scriptA.js` 和 `scriptB.js` 脚本会共享 `work.js` 的全局作用域，结果如下：

```
importing scripts in foo with bar 
scriptA executes in foo with bar 
scriptB executes in foo with bar 
scripts imported 
```

注意，调用这个方法并不会对同一个脚本只加载一次。也就是说，每次调用它加载同一个脚本，都会加载和执行它。

```js
importScripts('./scriptA.js', './scriptA.js'); // 加载和执行两次scriptA.js文件
```



#### 委托任务

有时候可能需要在工作者线程中再**创建子工作者线程**。在有多个 `CPU` 核心的时候，使用多个子工作者线程可以实现并行计算。使用多个子工作者线程前要考虑周全，确保并行计算的投入确实能够得到收益，毕竟同时运行多个子线程会有很大计算成本。

除了路径解析不同，创建子工作者线程与创建普通工作者线程是一样的。子工作者线程的脚本路径根据父工作者线程而不是相对于网页来解析。来看下面的例子（注意额外的 `js` 目录）：

```js
// js/subworker.js
console.log('subworker');

// js/worker.js
console.log('worker'); 
const worker = new Worker('./subworker.js'); 

// main.js
const worker = new Worker('./js/worker.js'); 

/*
> worker 
> subworker 
*/
```

注意：顶级工作者线程的脚本和子工作者线程的脚本都必须从与主页相同的源中加载。



#### 线程错误

如果工作者线程脚本抛出了错误，该工作者线程沙盒可以阻止它打断父线程的执行。这是理所当然的，因为两个工作者线程和父线程本就是相互独立的。如下例所示，其中的 `try/catch` 块不会捕获到子线程抛出的错误：

```js
// worker.js
throw Error('foo');

// main.js
try { 
 	const worker = new Worker('./worker.js'); // 子线程抛出的错误，不会在此被捕获到。
    console.log('no error'); 
} catch(e) { 
 	console.log('caught error'); 
} 
```

不过，相应的错误事件仍然会冒泡到工作者线程的全局上下文，因此可以通过在 `Worker` 对象上设置错误事件侦听器来监听它。

```js
// worker.js
throw Error('foo');

// main.js
const worker = new Worker('./worker.js'); 
worker.onerror = console.log; // ErrorEvent {message: "Uncaught Error: foo", ...} 
```

但如果在工作者线程中捕获了此错误，那么它就不会再冒泡到工作者线程的全局上下文了。



#### 线程通信

主线程与工作者线程的通信都是通过异步消息完成的，而这些消息也可以有多种形式。

##### `postMessage()`

最简单也最常用的形式是使用 `postMessage()` 传递消息（可以是任何消息）。下面来看一个计算阶乘的例子：

```js
// factorialWorker.js
function factorial(n) { 
 	let result = 1; 
 	while(n) { result *= n--; } 
 	return result; 
} 

self.onmessage = ({data}) => { 
 	self.postMessage(`${data}! = ${factorial(data)}`); 
}; 

// main.js
const factorialWorker = new Worker('./factorialWorker.js'); 

factorialWorker.onmessage = ({data}) => console.log(data); 

factorialWorker.postMessage(5); 	// 5! = 120 
factorialWorker.postMessage(7); 	// 7! = 5040 
factorialWorker.postMessage(10); 	// 10! = 3628800
```

对于简单的消息，可以使用 `postMessage()` 来在主线程和工作者线程之间传递。这与在两个窗口间传递消息非常像，主要区别是没有 `targetOrigin` 的限制。该限制是针对 `Window.prototype.postMessage` 的，对 `WorkerGlobalScope.prototype.postMessage` 或 `Worker.prototype.postMessage` 则没有影响。这样约定的原因也很简单：因为工作者线程脚本的源已被限制为主页的源，所以没有必要再去过滤了。

##### `MessageChannel`

无论主线程还是工作者线程，通过 `postMessage()` 进行通信都涉及调用全局对象上的方法，并定义一个临时的传输协议。不过，这个过程可以被 `Channel Messaging API` 取代，基于该 `API` 可以在两个上下文间明确建立通信渠道。【`channel`：通道、信道】

`MessageChannel` 实例有两个端口，分别代表两个通信端点。要让父页面和工作线程通过 `MessageChannel` 来通信，就需要把其中一个端口传到工作者线程中使用，如下所示：

```js
// worker.js
let messagePort = null; // 定义全局可用的消息端口

function factorial(n) { 
 	let result = 1; 
 	while(n) { result *= n--; } 
 	return result; 
} 

// 监听外部发送给线程的消息
self.onmessage = ({ports}) => { 
 	// 消息端口不存在时，初始化端口
 	if (!messagePort) { 
 		// 初始化消息端口，给变量赋值并重置监听器
   		messagePort = ports[0]; // 赋值给全局变量
 		self.onmessage = null; 	// 重置监听器
 		// 消息端口初始化之后，用它来监听线程消息。
 		messagePort.onmessage = ({data}) => { 
 			// 收到消息后发送数据
 			messagePort.postMessage(`${data}! = ${factorial(data)}`); 
 		}; 
 	} 
}; 

// main.js
const channel = new MessageChannel(); 
const factorialWorker = new Worker('./worker.js'); 

// 把其中一个消息端口发送到工作者线程，然后由工作者线程负责处理初始化信道。
factorialWorker.postMessage(null, [channel.port1]); 

// 使用另一个消息端口，通过信道发送数据
channel.port2.postMessage(5); 

// 监听工作者线程对该信道的响应
channel.port2.onmessage = ({data}) => console.log(data); 

// 打印结果：5! = 120
```

在这个例子中，父页面通过 `postMessage` 与工作者线程共享 `MessagePort`。使用数组语法是为了在两个上下文间传递可转移的对象。本章稍后会介绍可转移对象（`Transferable`）。工作者线程维护着对该端口的引用，并使用它代替通过全局对象传递消息。当然，消息的格式也需要临时约定：工作者线程收到的第一条消息包含端口，后续的消息才是数据。

使用 `MessageChannel` 与父页面通信在很大程度上是多余的。因为全局 `postMessage()` 方法本质上与 `channel.postMessage()` 执行的是同样的操作（不考虑 `MessageChannel` 接口的其他特性的话）。`MessageChannel` 真正有用的地方是能够让任意两个工作者线程直接通信，这可以通过把端口传给另一个工作者线程来轻松实现。下面的例子把一个数组从主线程传给了一个工作者线程，这个线程又把它传另一个工作者线程，然后再传回主页：

```js
// main.js
const channel = new MessageChannel(); // 创建消息信道

// 使用同一个脚本创建两个专用工作者线程
const workerA = new Worker('./worker.js'); 
const workerB = new Worker('./worker.js'); 

// 使用线程来收发消息，将两个端口分别发送给两个工作者线程
workerA.postMessage('workerA', [channel.port1]); // 将端口1发给workerA线程
workerB.postMessage('workerB', [channel.port2]); // 将端口2发给workerA线程
workerA.onmessage = ({data}) => console.log(data); 
workerB.onmessage = ({data}) => console.log(data); 
workerA.postMessage(['page']); // ['page', 'workerA', 'workerB'] 
workerB.postMessage(['page']); // ['page', 'workerB', 'workerA']

// worker.js
let messagePort = null; 
let contextIdentifier = null; 

function addContextAndSend(data, destination) { 
 	// 添加标识符以标识当前工作者线程
 	data.push(contextIdentifier); 
 	// 使用端口或线程发送数据（使用端口则发送给另一个端口，使用线程则发送给父线程）
 	destination.postMessage(data); 
} 

self.onmessage = ({data, ports}) => { 
 	// 如果消息中包含消息端口，则初始化工作者线程
 	if (ports.length) { 
 		contextIdentifier = data; 	// 记录标识符
 		messagePort = ports[0]; 	// 获取 MessagePort 
 		// 添加处理程序，把端口接收的数据发回到父页面
 		messagePort.onmessage = ({data}) => { 
			addContextAndSend(data, self); 
 		} 
 	} else { 
 		addContextAndSend(data, messagePort); // 如果不包含端口，则将数据发送给目标端口。
 	} 
};
```

在这个例子中，数组的每一段旅程都会添加一个字符串，标识自己到过哪里。数组从主线程发送到工作者线程，工作者线程会加上自己的上下文标识符。然后，数组又从这个工作者线程发送到另一个工作者线程。第二个线程又加上自己的上下文标识符，随即将数组发回主页，主页把数组打印出来。这个例子中的两个工作者线程使用了同一个脚本，因此要注意该脚本会被独立且并行地加载和执行两次。

##### `BroadcastChannel`

同源脚本之间可以通过 `BroadcastChannel` 互相发送和接收消息。这种通道类型的设置比较简单，不需要像 `MessageChannel` 那样转移端口。这可以通过以下方式实现：【`Broadcast`：广播】

```js
// worker.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道

channel.onmessage = ({data}) => { 
 	console.log(`heard ${data} in worker`); 
 	channel.postMessage('bar'); 
}

// main.js
const channel = new BroadcastChannel('worker_channel'); 
const worker = new Worker('./worker.js'); 

channel.onmessage = ({data}) => { 
 	console.log(`heard ${data} on page`); 
} 

setTimeout(() => channel.postMessage('foo'), 1000); 
/*
> heard foo in worker 
> heard bar on page 
*/
```

这里，页面在通过 `BroadcastChannel` 发送消息之前会先等 1 秒钟。因为这种信道没有端口所有权的概念，所以如果没有实体监听这个信道，广播的消息就不会有人处理。在这种情况下，如果没有 `setTimeout()`，则由于初始化工作者线程的延迟，就会导致消息已经发送了，但工作者线程上的消息处理程序还没有就位。

使用时需要给 `BroadcastChannel()` 构造函数传入一个信道标识符，所有使用该标识符创建的信道都会进入该广播频道，都能从中广播一条消息或收听广播的消息。与其他类型的信道类似，广播信道也通过 `onmessage` 监听广播，通过 `postMessage` 广播消息。不过要特别注意的是，当具有多条广播信道时，要对信道施加适当的判断以避免惨烈的广播死循环。如下便是一个典型的死循环。

```js
// a.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in a`);
    channel.postMessage('a');
}

// b.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in b`);
    channel.postMessage('b');
}

// c.js
const channel = new BroadcastChannel('worker_channel'); // 创建广播信道
channel.onmessage = ({ data }) => {
    console.log(`heard ${data} in c`);
    channel.postMessage('c');
}

// main.js
const channel = new BroadcastChannel('worker_channel');
const workerA = new Worker('./a.js');
const workerB = new Worker('./b.js');
const workerC = new Worker('./c.js');

channel.onmessage = ({ data }) => {
    console.log(`heard ${data} on page`);
}

setTimeout(() => channel.postMessage('page'), 1000); 
```



#### 数据传输

使用工作者线程时，经常需要为它们提供某种形式的数据负载。但工作者线程是独立的上下文，因此在上下文之间传输数据就会产生消耗。在支持传统多线程模型的语言中，可以使用锁、互斥量，以及 `volatile` 变量。在 `JavaScript` 中，有三种在上下文间转移信息的方式：结构化克隆算法（`structured clone algorithm`）、可转移对象（`transferable objects`）和共享数组缓冲区（`shared array buffers`）。

##### 结构化克隆算法

结构化克隆算法可用于在两个独立的上下文之间共享数据，`postMessage()` 使用它。该算法由浏览器在后台实现，不可直接使用。

```js
worker.postMessage({
    name: 'workerA',
    data: {}
});
```

在通过 `postMessage()` 传递对象时，浏览器会遍历该对象，并在目标上下文中生成它的一个副本。下面是该克隆算法支持的类型。

|           支           |    持     |     的     |      类       |        型         |
| :--------------------: | :-------: | :--------: | :-----------: | :---------------: |
| 非 `Symbol` 的原始类型 | `Boolean` |  `String`  |    `BDate`    |     `RegExp`      |
|         `Blob`         |  `File`   | `FileList` | `ArrayBuffer` | `ArrayBufferView` |
|      `ImageData`       |  `Array`  |  `Object`  |     `Map`     |       `Set`       |

关于结构化克隆算法，有以下几点需要注意。

- 复制之后，源上下文中对该对象的修改，不会传播到目标上下文中的对象。
- 结构化克隆算法可以识别对象中包含的循环引用，不会无穷无尽地遍历对象。
- 克隆 `Error` 对象、`Function` 对象、类或 `DOM` 节点时会抛出错误。
- 结构化克隆算法并不总是创建完全一致的副本（可能会舍弃一些东西）。
- 对象属性描述符、获取方法和设置方法不会克隆，必要时会使用默认值。
- 原型链不会被克隆。
- `RegExp.prototype.lastIndex` 属性不会被克隆。

注意：结构化克隆算法在对象比较复杂时会存在计算性消耗。因此，实践中要尽可能避免过大、过多的复制。

##### 可转移对象

使用可转移对象（`transferable objects`）可以把对象的所有权从一个上下文转移到另一个上下文。当不太可能在上下文间复制大量数据的时候，这个功能特别有用。只有如下几种对象是可转移对象：

- `ArrayBuffer`
- `MessagePort`
- `ImageBitmap`
- `OffscreenCanvas`

`postMessage()` 方法的第二个可选参数是一个数组，它指定应该将哪些对象转移到目标上下文。在遍历消息负载对象时，浏览器根据转移对象数组检查对象引用，并对转移对象进行转移而不克隆它们。这意味着被转移的对象可以通过消息负载发送，但消息负载本身会被复制，比如对象或数组。

下面的例子演示了工作者线程对 `ArrayBuffer` 的常规结构化克隆。这里没有对象转移：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage(arrayBuffer); // 对象没有被转移
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
```

如果把 `ArrayBuffer` 指定为可转移对象，那么对缓冲区内存的引用就会从父上下文中抹去，然后分配给工作者线程。下面的例子演示了这个操作，结果分配给 `ArrayBuffer` 的内存从父上下文转移到了工作者线程：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage(arrayBuffer, [arrayBuffer]); // 对象被转移了，此对象的缓冲区将被重置。
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 0
```

在其他类型的对象中**嵌套可转移对象**也完全没有问题。包装对象会被复制，而嵌套的对象会被转移：

```js
// worker.js
self.onmessage = ({data}) => { 
 	console.log(`worker's buffer size: ${data.foo.bar.byteLength}`); // 32
};

// main.js
const worker = new Worker('./worker.js'); 
// 创建 32 位缓冲区
const arrayBuffer = new ArrayBuffer(32); 
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 32
worker.postMessage({foo: {bar: arrayBuffer}}, [arrayBuffer]); // 转移嵌套的对象
console.log(`page's buffer size: ${arrayBuffer.byteLength}`); // 0
```

##### `SharedArrayBuffer`

注意：由于 `Spectre` 和 `Meltdown` 的漏洞，所有主流浏览器在 2018 年 1 月就禁用了 `SharedArrayBuffer`。从 2019 年开始，有些浏览器开始逐步重新启用这一特性。既不克隆，也不转移，`SharedArrayBuffer` 作为 `ArrayBuffer` 且能够在不同浏览器上下文间共享。在把 `SharedArrayBuffer` 传给 `postMessage()` 时，浏览器直接传递原始缓冲区的引用。结果是，两个不同的 `JavaScript` 上下文会分别维护对同一个内存块的引用。每个上下文都可以随意修改这个缓冲区，就跟修改常规 `ArrayBuffer` 一样。来看下面的例子：

```js
// worker.js
self.onmessage = ({data}) => { 
 	const view = new Uint8Array(data);
   	console.log(`buffer value before worker modification: ${view[0]}`); 
 	view[0] += 1; // 工作者线程为共享缓冲区赋值
 	self.postMessage(null); // 发送空消息，通知赋值完成
};

// main.js
const worker = new Worker('./worker.js'); 
const sharedArrayBuffer = new SharedArrayBuffer(1); // 创建 1 字节缓冲区
const view = new Uint8Array(sharedArrayBuffer); // 创建 1 字节缓冲区的视图
view[0] = 1; // 父上下文赋值 1 

worker.onmessage = () => { 
 	console.log(`buffer value after worker modification: ${view[0]}`); 
}; 

worker.postMessage(sharedArrayBuffer); // 发送对 sharedArrayBuffer 的引用

/* 
> buffer value before worker modification: 1 
> buffer value after worker modification: 2 
*/
```

当然，在两个并行线程中共享内存块有资源争用的风险。换句话说，`SharedArrayBuffer` 实例实际上会被当成易变（`volatile`）内存。下面的例子演示了这一点：

```js
// worker.js 
self.onmessage = ({data}) => { 
 	const view = new Uint32Array(data); 
 	// 执行 100 万次加操作
 	for (let i = 0; i < 1E6; ++i) { 
 		view[0] += 1; 
 	} 
 	self.postMessage(null); 
};

// main.js
// 创建包含 4 个线程的线程池
const workers = []; 
for (let i = 0; i < 4; ++i) { 
 	workers.push(new Worker('./worker.js')); 
} 

// 在最后一个工作者线程完成后打印最终值
let responseCount = 0; 
for (const worker of workers) { 
 	worker.onmessage = () => { 
 		if (++responseCount == workers.length) { 
 			console.log(`Final buffer value: ${view[0]}`); 
 		} 
 	}; 
} 

// 初始化 SharedArrayBuffer 
const sharedArrayBuffer = new SharedArrayBuffer(4); 
const view = new Uint32Array(sharedArrayBuffer); 
view[0] = 1; 

// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) { 
 	worker.postMessage(sharedArrayBuffer); 
} 

// 期待结果为 4000001。实际输出类似于：Final buffer value: 2145106 
```

这里，每个工作者线程都顺序执行了 100 万次加操作，每次都读取共享数组的索引、执行一次加操作，然后再把值写回数组索引。然而，在所有工作者线程读/写操作交织的过程中会发生资源争用。例如：

(1) 线程 A 读取到值 1；

(2) 线程 B 读取到值 1；

(3) 线程 A 加 1 并将 2 写回数组；

(4) 线程 B 在自己获取的数组值 1 上加 1，然后同样把 2 写回数组。

为解决该问题，可以使用 `Atomics` 对象让一个工作者线程获得 `SharedArrayBuffer` 实例的锁，在执行完所有读/写操作后，再允许另一个工作者线程执行操作。把 `Atomics.add()` 放到这个例子中就可以得到正确的最终值：

```js
// worker.js 
self.onmessage = ({data}) => { 
 	const view = new Uint32Array(data); 
 	// 执行 100 万次加操作
 	for (let i = 0; i < 1E6; ++i) { 
 		Atomics.add(view, 0, 1); // 在一个线程完成操作后，再允许下一个线程操作。
	} 
 	self.postMessage(null); 
};

// main.js 
// 创建包含 4 个线程的线程池
const workers = []; 
for (let i = 0; i < 4; ++i) { 
 	workers.push(new Worker('./worker.js')); 
} 

// 在最后一个工作者线程完成后打印最终值
let responseCount = 0; 
for (const worker of workers) { 
 	worker.onmessage = () => { 
 		if (++responseCount == workers.length) { 
 			console.log(`Final buffer value: ${view[0]}`); 
 		} 
 	}; 
} 

// 初始化 SharedArrayBuffer 
const sharedArrayBuffer = new SharedArrayBuffer(4); 
const view = new Uint32Array(sharedArrayBuffer); 
view[0] = 1; 

// 把 SharedArrayBuffer 发给每个线程
for (const worker of workers) { 
 	worker.postMessage(sharedArrayBuffer); 
} 

//（期待结果为 4000001），Final buffer value: 4000001 
```

注意：前面在《`JavaScript API`》一章中已经详细介绍了 `SharedArrayBuffer` 和 `Atomics API`。



#### 线程池

因为启用工作者线程代价很大，所以某些情况下可以考虑始终使固定数量的线程保持活动状态，需要时就把任务分派给它们。工作者线程在执行计算时，会被标记为忙碌状态。直到它通知线程池自己空闲了，才会准备好接收新任务。维护这些活动线程的容器就称为 “线程池” 或 “工作者线程池”。

线程池中线程的数量多少才算合适并没有权威的答案，不过可以参考 `navigator.hardwareConcurrency` 属性返回的系统可用的核心数量。因为浏览器不太可能知道每个核心的多线程能力，所以最好把这个数字作为线程池大小的上限。

一种使用线程池的策略是每个线程都执行同样的任务，但具体执行什么任务由几个参数来控制。要使用特定于任务的线程池，则可分配固定数量的工作者线程，并根据需要为他们提供参数。工作者线程会接收这些参数，执行耗时的计算，并把结果返回给线程池。结束后线程池可以再将其他工作分派给空闲的线程去执行。接下来的例子将构建一个相对简单的线程池，但可以涵盖上述思想的所有基本要求。

首先是定义一个 `TaskWorker` 类，用于创建任务工作者线程实例，它扩展自 `Worker` 类。`TaskWorker` 类负责两件事：跟踪线程是否正忙于工作，并管理进出线程的信息与事件。另外，传给这些任务工作者线程的任务会被封装到一个期约中，以便得知任务的状态。

```js
// 任务工作者线程类（特定于某个任务）
class TaskWorker extends Worker {
    constructor(notifyAvailable, workerArgs) {
        super(...workerArgs); // 调用Worker创建线程（this）
        // 给每个线程添加属性，并初始化为不可用状态
        this.available = false;
        this.resolve = null;
        this.reject = null;
        // 线程池会传递回调，以便工作者线程发出它需要新任务的信号
        this.notifyAvailable = notifyAvailable; // 用于通知线程池该线程空闲的回调
        // 线程脚本在完全初始化之后，会发送一条"ready"消息，收到后则将此线程设为空闲。
        this.onmessage = () => this.setAvailable(); // 将线程设为可用的空闲状态
    }

    // 由线程池调用，用以向空闲的线程分派任务
    dispatch({ resolve, reject, postMessageArgs }) {
        // 收到任务后，转为忙碌状态；完成任务或线程出错后，转为空闲状态。
        this.available = false; 
        this.onmessage = ({ data }) => {
            resolve(data); // 将任务解决为线程的响应。
            this.setAvailable();
        };
        this.onerror = (e) => {
            reject(e);     // 将任务拒绝为线程的错因。
            this.setAvailable();
        };
        this.postMessage(...postMessageArgs); // 向线程发送数据，以开始执行任务。
    }

    // 设置线程为空闲
    setAvailable() {
        this.available = true;
        this.resolve = null;
        this.reject = null;
        this.notifyAvailable();
    }
}
```

然后是定义 `WorkerPool` 类，用于创建线程池来管理和使用 `TaskWorker` 线程。它还必须维护尚未分派给工作者线程的任务队列。

```js
// 线程池类
class WorkerPool {
    constructor(poolSize, ...workerArgs) {
        this.taskQueue = []; // 任务队列
        this.workers = [];   // 线程池
        // 初始化线程池（创建固定数量的任务线程）
        for (let i = 0; i < poolSize; ++i) {
            // 当线程空闲时，向其派发新任务
            this.workers.push(new TaskWorker(() => this.dispatchIfAvailable(), workerArgs));
        }
    }

    // 把交给线程池的任务封装为期约并推入其任务队列
    enqueue(...postMessageArgs) {
        return new Promise((resolve, reject) => {
            this.taskQueue.push({ resolve, reject, postMessageArgs }); // 推入队列
            this.dispatchIfAvailable(); // 将队列中的任务交给空闲的线程
        });
    }

    // 把任务派发给一个空闲的线程（如果有的话）
    dispatchIfAvailable() {
        if (!this.taskQueue.length) {
            return; // 队列中没有任务时停止派发
        }
        for (const worker of this.workers) {
            // 找出空闲的线程，并将任务交给它
            if (worker.available) {
                let task = this.taskQueue.shift(); // 从队列中弹出一个任务
                worker.dispatch(task); // 将弹出的任务交给这个空闲的线程
                break; // 停止遍历
            }
        }
    }

    // 终止所有任务工作者线程
    close() {
        for (const worker of this.workers) {
            worker.terminate();
        }
    }
}
```

定义这两个类之后，现在可以把任务分派到线程池，并在任务线程可用时执行它们。任务线程脚本在完成加载后，首先需要发送一个消息给线程以触发线程的进一步初始化（将状态设为空闲）。任务线程脚本还需要监听线程发来的消息，在收到消息后立即执行任务。

```js
// 收到消息之后，就立即开始执行任务。
self.onmessage = ({data}) => { 
	// ...
}

// 发送消息给 TaskWorker，通知工作者线程准备好接收任务了
self.postMessage('ready');
```

假设要计算 1000 个随机浮点值之和，则任务线程的脚本大致如下。

```js
self.onmessage = ({data}) => { 
 	let sum = 0; 
 	let view = new Float32Array(data.arrayBuffer); 
    
 	for (let i = data.startIdx; i < data.endIdx; ++i) { 
 		// 不需要原子操作，因为只需要读
 		sum += view[i]; // 求和
 	} 
    
 	self.postMessage(sum); // 把结果发送给工作者线程
}; 

self.postMessage('ready');
```

有了以上代码，利用线程池分派任务的代码可以这样写：

```js
const totalTasks = 0; 	// 任务总量 
const numTasks = 0; 	// 任务数量（将总任务划分为多少个小的任务） 
const totalPerTask = totalTasks / numTasks; // 任务单量（划分到每个任务的总量）
const numWorkers = 4; 	// 线程数量（可根据系统CPU的数量来决定）
    
// 创建线程池（这里，使用同一个脚本，为了完成特定任务）
const pool = new WorkerPool(numWorkers, './worker.js');

// 任务期约池，保存每个任务的期约。
let taskPromises = []; 
// 将任务依次推送到线程池中进行处理
for (let i = 0; i < numTasks; i++) { 
    // 保存每个任务的期约
 	taskPromises.push( 
        // 向线程池分派任务
 		pool.enqueue({ 
 			// 传递执行任务的关键信息（这些信息用于控制各个线程具体执行哪部分任务）
 		}) 
 	); 
} 

// 等待任务期约池中的所有期约完成，然后进行总和
Promise.all(taskPromises) 
 	.then((partial) => partial.reduce((x, y) => x + y)) 
 	.then(console.log); 
```

完成上面这个计算任务的代码如下。如果要转移内存，为节省转移成本，这里可使用 `SharedArrayBuffer`：

```js
const totalFloats = 1E3;
const numTasks = 20;
const floatsPerTask = totalFloats / numTasks;
const numWorkers = 4;
const pool = new WorkerPool(numWorkers, './worker.js');

// 填充随机浮点值数组
let arrayBuffer = new ArrayBuffer(4 * totalFloats); // 使用 4 个字节表示一个浮点值
let view = new Float32Array(arrayBuffer);
for (let i = 0; i < totalFloats; ++i) {
    view[i] = Math.random();
}

let partialSumPromises = []; 
for (let i = 0; i < totalFloats; i += floatsPerTask) {
    partialSumPromises.push(
        pool.enqueue({
            startIdx: i,
            endIdx: i + floatsPerTask,
            arrayBuffer: arrayBuffer
        })
    );
}

Promise.all(partialSumPromises)
    .then((partialSums) => partialSums.reduce((x, y) => x + y))
    .then(console.log);

//（在这个例子中，和应该约等于 1E3/2），500.10405499720946
```

注意：草率地采用并行计算不一定是最好的办法。线程池的调优策略会因计算任务和系统硬件的不同而不同。



### 共享工作者线程

共享工作者线程（或称共享线程）与专用工作者线程类似，但它可以被多个可信任的执行上下文访问。例如，同源的两个标签页可以访问同一个共享工作者线程。`SharedWorker` 与 `Worker` 的消息接口稍有不同，包括外部和内部。

共享线程适合开发者希望通过在多个上下文间共享线程以减少计算性消耗的情形。比如，可以使用一个共享线程来管理多个同源页面 `WebSocket` 消息的发送与接收。共享线程也可以用在同源上下文希望通过一个线程通信的情形。



#### 线程简介

从行为上讲，共享工作者线程可以看作是专用工作者线程的一个扩展。二者在线程创建、线程选项、安全限制和 `importScripts()` 的行为上都是相同的。与专用工作者线程一样，共享工作者线程也在独立执行上下文中运行，也只能与其他上下文异步通信。

##### 创建线程

与专用工作者线程一样，创建共享工作者线程非常常用的方式是通过加载 `JavaScript` 文件创建。此时，需要给 `SharedWorker` 构造函数传入文件路径，该构造函数在后台异步加载脚本并实例化共享工作者线程。

下面的例子演示了如何基于绝对路径创建空共享工作者线程：

```js
// main.js 
console.log(location.origin); // "http://127.0.0.1:59481" 

const sharedWorker = new SharedWorker((new URL(location.origin)).toString() + 'emptyWorker.js');

console.log(sharedWorker); 	 // SharedWorker {port: MessagePort, onerror: null}

/*
SharedWorker {
	onerror: null,
	port: MessagePort {onmessage: null, onmessageerror: null},
	[[Prototype]]: SharedWorker {
		onerror: null,
		port: MessagePort,
		constructor: ƒ SharedWorker(),
		Symbol(Symbol.toStringTag): "SharedWorker",
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		get port: ƒ port(),
		[[Prototype]]: EventTarget
	}
}
*/
```

前面的例子可以修改为使用相对路径，不过这需要 `main.js` 和 `emptySharedWorker.js` 在同一个目录下：

```js
const sharedWorker = new SharedWorker('./emptyWorker.js'); 

console.log(sharedWorker); // SharedWorker {port: MessagePort, onerror: null}
```

也可以在行内脚本中创建共享工作者线程，但这样做没什么意义。因为每个基于行内脚本字符串创建的 `Blob` 都会被赋予自己唯一的浏览器内部 `URL`，所以行内脚本中创建的共享工作者线程始终是唯一的。这里的原因将在下一节介绍。

##### 线程标识

共享工作者线程与专用工作者线程的一个重要区别在于，`Worker()` 构造函数始终会创建新实例，而 `SharedWorker()` 则只会在相同的标识不存在的情况下才创建新实例。如果的确存在与标识匹配的共享工作者线程，则只会与已有共享者线程建立新的连接。

```js
// 每次都加载和执行脚本
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）
new Worker('./a.js'); // 创建专用线程（加载并执行脚本）

// 只加载和执行一次脚本
new SharedWorker('./test.js'); // 创建共享线程（加载并且执行脚本）
new SharedWorker('./test.js'); // 连接共享线程（不加载和执行脚本）
new SharedWorker('./test.js'); // 连接共享线程（不加载和执行脚本）
```

共享工作者线程标识源自解析后的脚本 `URL`、工作者线程名称和文档源，三者中任何一个不同都会产生新的共享线程标识。例如，下面的脚本将实例化一个共享工作者线程并在它上面添加两个连接：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js'); // 创建共享线程
new SharedWorker('./sharedWorker.js'); // 连接共享线程
new SharedWorker('./sharedWorker.js'); // 连接共享线程
```

类似地，因为下面三个脚本字符串都解析到相同的 `URL`，所以也只会创建一个共享工作者线程：

```js
new SharedWorker('./sharedWorker.js'); 							// 创建共享线程
new SharedWorker('sharedWorker.js'); 							// 连接共享线程
new SharedWorker('https://www.example.com/sharedWorker.js'); 	// 连接共享线程
```

因为可选的工作者线程名称也是共享工作者线程标识的一部分，所以不同的线程名称会强制浏览器创建多个共享工作者线程。对下面的例子而言，一个名为 `'foo'`，另一个名为 `'bar'`，尽管它们同源且脚本 `URL` 都相同：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 一个线程名称为'foo'，一个线程名称为'bar' 
*/
new SharedWorker('./sharedWorker.js', {name: 'foo'}); // 创建'foo'共享线程（加载并且执行脚本）
new SharedWorker('./sharedWorker.js', {name: 'foo'}); // 连接'foo'共享线程（不加载和执行脚本）
new SharedWorker('./sharedWorker.js', {name: 'bar'}); // 创建'bar'共享线程（加载并且执行脚本）
```

共享线程，顾名思义，可以在不同标签页、不同窗口、不同内嵌框架或同源的其他工作者线程之间共享。因此，下面的脚本如果在多个标签页运行，则只会在第一次执行时创建一个共享工作者线程，后续执行将会连接到该线程：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- 所有脚本解析为相同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js');
```

初始化共享线程的脚本只会限制 `URL`，因此下面的代码会创建两个共享工作者线程，尽管加载了相同的脚本：

```js
/* 
实例化一个共享工作者线程
	- 全部基于同源调用构造函数
	- '?'导致了两个不同的 URL 
	- 所有线程都有相同的名称
*/
new SharedWorker('./sharedWorker.js'); 	// 创建共享线程（加载并且执行脚本）
new SharedWorker('./sharedWorker.js?');	// 创建共享线程（加载并且执行脚本）
```

如果该脚本在两个不同的标签页中运行，同样也只会创建两个共享工作者线程。每个构造函数都会检查匹配的共享工作者线程，然后连接到已存在的那个。

##### 使用线程

`SharedWorker()` 构造函数返回的 `SharedWorker` 对象被用作与新创建的共享线程通信的连接点。它可以用来通过 `MessagePort` 在共享工作者线程和父上下文间传递信息，也可以用来捕获共享线程中发出的错误事件。

`SharedWorker` 对象支持以下属性。

- `onerror`：在共享线程中发生 `ErrorEvent` 类型的错误事件时会调用指定给该属性的处理程序。
  - 此事件会在共享线程抛出错误时发生。
  - 此事件也可以通过使用 `sharedWorker.addEventListener('error', handler)` 处理。
- `port`：专门用来跟共享线程通信的 `MessagePort`。

##### 全局作用域

在共享线程内部，全局作用域是 `SharedWorkerGlobalScope` 的实例。因为继承自 `WorkerGlobalScope`，因此包括它所有的属性和方法。与专用工作者线程一样，共享工作者线程也可以通过 `self` 关键字访问该全局上下文。

`SharedWorkerGlobalScope` 通过以下属性和方法扩展了 `WorkerGlobalScope`。

- `name`：可选的字符串标识符，可以传给 `SharedWorker` 构造函数。
- `importScripts()`：用于向共享线程中导入任意数量的脚本。
- `close()`：与 `worker.terminate()` 对应，用于立即终止工作者线程（实际上可能并不会立即终止）。
- `onconnect`：与共享线程建立新连接时触发的事件。`connect` 事件对象包含 `MessagePort` 实例的 `ports` 数组，可用于从共享线程内部把消息发送回父上下文。
  - 在通过 `worker.port.onmessage` 或 `worker.port.start()` 与共享线程建立连接时都会触发 `connect` 事件。
  - `connect` 事件也可以通过使用 `sharedWorker.addEventListener('connect', handler)` 处理。

注意：根据浏览器实现，在 `SharedWorker` 中把日志打印到控制台不一定能在默认的控制台中看到结果（如 `Chrome` 和 `Edge`）。



#### 生命周期

共享工作者线程的生命周期具有与专用工作者线程相同的阶段的特性。不同之处在于，专用工作者线程只跟一个页面绑定，页面关闭后，其专用线程也会立即终止；而共享工作者线程可跟多个页面绑定，且只要还有一个上下文连接就会持续存在。

比如下面的代码，每次调用它都会创建一个专用工作者线程：

```js
new Worker('./worker.js');
```

下表详细列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么。

|       事件        |      结果       | 事件发生后的线程数 |
| :---------------: | :-------------: | :----------------: |
| 标签页 1 执行代码 | 创建专用线程 1  |         1          |
| 标签页 2 执行代码 | 创建专用线程 2  |         2          |
| 标签页 3 执行代码 | 创建专用线程 3  |         3          |
|   标签页 1 关闭   | 专用线程 1 终止 |         2          |
|   标签页 2 关闭   | 专用线程 2 终止 |         1          |
|   标签页 3 关闭   | 专用线程 3 终止 |         0          |

如上表所示，`new Worker('./worker.js');` 的执行次数、打开标签页数和运行的线程数是对等关系。下面再来看看这个简单的代码，每次执行它都会创建或者连接到共享线程：

```js
new SharedWorker('./sharedWorker.js');
```

下表列出了当三个包含此脚本的标签页按顺序打开和关闭时会发生什么。

|       事件        |                          结果                           | 事件发生后的线程数 |
| :---------------: | :-----------------------------------------------------: | :----------------: |
| 标签页 1 执行代码 |                     创建共享线程 1                      |         1          |
| 标签页 2 执行代码 |                     连接共享线程 1                      |         1          |
| 标签页 3 执行代码 |                     连接共享线程 1                      |         1          |
|   标签页 1 关闭   |                 断开与共享线程 1 的连接                 |         1          |
|   标签页 2 关闭   |                 断开与共享线程 1 的连接                 |         1          |
|   标签页 3 关闭   | 断开与共享线程 1 的连接。没有连接了，因此终止共享线程 1 |         0          |

如上表所示，标签页 2 和标签页 3 再次调用 `new SharedWorker('./sharedWorker.js');` 会连接到已有线程。随着连接的增加和移除，浏览器会记录连接总数。在连接数为 0 时，线程被终止。

关键在于，没有办法以编程方式终止共享线程。前面已经交代过，`SharedWorker` 对象上没有 `terminate()` 方法。然而，在共享线程端口（稍后讨论）上调用 `close()` 时，只要还有一个端口连接此共享线程就不会真的终止它。

`SharedWorker` 的“连接”与关联的 `MessagePort` 或 `MessageChannel` 的状态无关。只要建立了连接，浏览器就会负责管理该连接。建立的连接会在页面的生命周期内持续存在，只有当页面销毁且没有连接时，浏览器才会终止共享线程。



#### 连接共享

每次调用 `SharedWorker()` 构造函数，无论是否创建了工作者线程，都会在共享线程内部触发 `connect` 事件。如下所示：

```js
// main.js 
for (let i = 0; i < 5; ++i) { 
 	new SharedWorker('./sharedWorker.js'); 
} 

// sharedWorker.js 
let i = 0; // 该代码只会被执行一次
self.onconnect = () => console.log(`connected ${++i} times`); // 每次连接线程时，都会触发该事件。

/* 
> connected 1 times 
> connected 2 times 
> connected 3 times 
> connected 4 times 
> connected 5 times
*/
```

发生 `connect` 事件时，`SharedWorker()` 构造函数会隐式创建 `MessageChannel` 实例，并把 `MessagePort` 实例的所有权唯一地转移给该 `SharedWorker` 的实例。这个 `MessagePort` 实例会保存在 `connect` 事件对象的 `ports` 数组中。每次连接共享线程时都会触发该事件，因此 `ports` 数组的长度总是等于 1。

下面的代码演示了访问事件对象的 `ports` 数组。这里使用了 `Set` 来保证只跟踪唯一的对象实例：

```js
// sharedWorker.js 
const connectedPorts = new Set(); 
self.onconnect = ({ports}) => { 
 	connectedPorts.add(ports[0]); 
 	console.log(`${connectedPorts.size} unique connected ports`); 
}; 

// main.js 
for (let i = 0; i < 5; ++i) { 
 	new SharedWorker('./sharedWorker.js'); 
} 

/*
> 1 unique connected ports 
> 2 unique connected ports 
> 3 unique connected ports 
> 4 unique connected ports 
> 5 unique connected ports
*/
```

关键在于，共享线程与父上下文的启动和关闭不是对称的。每个新的 `SharedWorker` 连接都会触发一个事件，但没有事件对应断开 `SharedWorker` 实例的连接（如页面关闭）。

在前面的例子中，随着与相同共享线程连接和断开连接的页面越来越多，`connectedPorts` 集合中会受到死端口的污染，且没有办法识别它们。一个解决方案是在 `beforeunload` 事件即将销毁页面时，明确发送卸载消息，让共享线程有机会清除死端口。



#### 线程通信

共享线程上自带一个 `port` 属性（保存着一个 `MessagePort` 实例），专门用来在共享线程间通信。

```js
// ports.js
self.onconnect = ({ ports }) => {
    ports[0].postMessage('test'); // 利用端口发送消息
}; 

// main.js
sharedWorker.port.onmessage = ({data}) => {
    // 使用端口监听消息
    console.log(data);
}
```



### 服务工作者线程



#### 线程基础



#### 线程缓存



#### 线程客户端



#### 线程一致性



#### 生命周期



#### 控制反转与线程持久化



#### 管理服务文件缓存



#### 强制操作



#### 线程消息



#### 拦截请求



#### 推送通知



### 小结



