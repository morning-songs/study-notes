# 泛型

### 字面量类型

在 `JS` 中，字面量只作为数据使用，提供一种直接书写各类型数据的简便方式。而在 `TS` 中，字面量不仅可以作为数据使用，还可以作为数据类型来使用。字面量类型用于指定一个变量的值必须是指定的字面量。

```tsx
let str: "abc" = "abc";

// 如果仅仅是这样，那么使用const应该更加明智。
const str = 'abc';
```

字面量类型最大的用途是，当明确结果的范围或期待获得某些结果时，用来限制值域。比如：结合联合类型限定函数的输入域或输出域。

```tsx
type ArgsString = 'JM' | 'JJ' | 'JS'; 		// 限定输入域
type resString = '剑魔' | '剑姬' | '剑圣';	// 限定输出域

function fn(code: ArgsString): resString {
    return code === 'JM' ? '剑魔' : code === 'JJ' ? '剑姬' : '剑圣';
}

console.log(fn('JM')); // '剑魔'
console.log(fn('JJ')); // '剑姬'
console.log(fn('JS')); // '剑圣'

// 输入的值超出输入域
console.log(fn('TS')); // Argument of type '"TS"' is not assignable to parameter of type 'ArgsString'.
```



### 条件类型

更多参考：[中文参考](https://www.tslang.cn/docs/release-notes/typescript-2.8.html)、[官网原文](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html) 



### 泛型

之前使用的函数重载、类型别名、接口类型等都是在预先定义函数的输入或输出类型。而泛型则是在调用时指定值的类型。

语法：声明函数时，在函数名后面使用一对尖括号包裹一个泛型变量。该变量用来接收调用函数时以同样方式指定的类型。

```tsx
// 声明函数时，声明一个泛型变量
function fn<T> (arg: string) {}

// 调用函数时，指定输入参数类型
fn<string>('wanzi');
```

此时，变量 `T` 中保存的就是 `string` 类型。因为 `T` 是一个变量，所以在后续的声明中或函数内部当然可以使用它，尤其是输入和输出。

```tsx
// 指定输入和输出的类型均为泛型变量T，而T的实际类型只有在调用时才能确定。
function fn<T> (arg: T): T {
    // 函数内部也可以使用泛型变量
    let res: T = arg; 
    return res;
}

fn<string>('wanzi');
fn<number>(123.456);
```

这样一来，参数的类型就不必在声明时具体指定，而是可以通过在调用时按照实际需求指定了，大大增加了参数类型的灵活性。

##### 泛型变量

泛型变量，首先是一种变量，毫无疑问它可以接收任何类型，包括单一类型、联合类型、类型别名或接口类型等。

```tsx
// 类型别名
type MyType_NSB = number | string | boolean;
// 接口类型
interface IMyType_NSB {
    (a: MyType_NSB): MyType_NSB
}

function fn<T>(arg: T): T {
    return arg;
}

fn<number | string | boolean>(false);
fn<MyType_NSB>(123);
fn<IMyType_NSB>((a: MyType_NSB): MyType_NSB => a);
```

##### 类型参数

泛型变量，其实是一种类型参数。因此，泛型变量也可以像函数参数一样指定多个，且传入与接收的位置始终一一对应。

```tsx
function fn<T, U> (a: T, b: U): T {
    return a;
}

fn<string, number>('丸子', 14);
fn<string, number>('樱桃', 15);
```

##### 类型推论

由于类型推论机制的存在，调用时其实可以不指定类型。类型推论机制会自动推论各参数的类型，并将其传给相应位置上的类型参数。

```tsx
function fn<T, U> (a: T, b: U): T {
    return a;
}

// 应用类型推论
fn('丸子', 14);
fn('樱桃', 15);
```

##### 泛型约束

泛型变量的类型只有在调用时才能确定，并且永远不会被固定为某一种确切的类型，它相当于是一种动态的类型。它的类型在声明时有无限的可能性，是无法确定的。因此，在声明函数，尤其是在实现函数的逻辑时，必须要考虑到所有类型的情况。

比如，下面的函数实现就没有考虑到泛型变量的类型拥有无限可能的特点，导致报错。因为当它为其他类型时，未必会拥有 `name` 属性。

```tsx
function fn<T>(a: T): T {
    return a.name; // Property 'name' does not exist on type 'T'.
}

fn({name: 'wanzi'});
```

如果要保持泛型始终能够代表所有的数据类型，那么泛型自身便不会拥有特定于任一类型的属性和方法（包括原生的和自定义的）。

解决上例的问题，只需帮助类型检查机制将泛型数据（即：`a`  的值）确定为特定的类型即可。可以在操作特定类型时，使用类型断言。

```tsx
interface ITest {
    name: string
}

function fn<T>(a: T) {
    return (a as ITest).name; // 使用类型断言，但如果传入参数不合规范，那么执行后将会得到undefined。
}

console.log(fn({ name: 'wanzi' })); // 'wanzi'
console.log(fn(1)); // undefined
```

然而，如果要使得泛型能够拥有某特定类型的属性或方法的话，则可以使用泛型约束。泛型约束，就是让泛型继承特定的类型，如下。

```tsx
interface ITest {
    name: string
}

// 使泛型变量T继承ITest接口，从而拥有其特性
function fn<T extends ITest>(a: T) {
    return a.name;
}

// 调用时，传入参数必须兼容接口的类型标准
console.log(fn({ name: 'wanzi' })); // 'wanzi'
```

一旦对泛型变量进行了类型约束，那么该泛型变量便被固定成了确切的类型，不能再代表其他类型了。然后在调用函数时，只能传入兼容特定类型标准的数据，即：可以多，但不能少。

```tsx
// 刚好兼容接口类型
fn({name: 'wanzi'}); // 允许

// 溢出兼容接口类型
fn({name: 'wanzi', age: 14}); // 允许

// 没有兼容接口类型
fn({a: 1, b: 2}); // 报错
fn([1, 2, 3, 4]); // 报错
fn(1234); 		  // 报错
```

泛型约束如同直接将函数参数固定成了指定的类型。但它要比后者更加灵活，因为后者，要求实参必须完全符合类型要求，而不是兼容。

```tsx
interface ITest {
    name: string
}

// 直接对参数进行类型注解
function fn(a: ITest) {
    return a.name;
}

// 实参必须完全符合接口类型的要求
fn({name: 'wanzi'});

// 不能对实参进行任何扩展，只能且必须添加接口中已知的属性
fn({name: 'wanzi', age: 14}); 
// Object literal may only specify known properties, and 'age' does not exist in type 'ITest'.
```

##### 相互制约

前面提到过，泛型变量其实是一种类型参数。那么，泛型变量便可以向在 `JS` 中使用参数那样，借用其他参数的值。只不过，泛型变量借用的是类型，而且前面的泛型变量可以借用后面泛型变量的类型。

由此，便可以使用泛型变量去约束（即：继承）其他的泛型变量了。而继承者必须兼容被继承者，如前所述。

```tsx
// 使T继承U，那么传参时T必须兼容U
function fn<T extends U, U>(a: T, b: U) {}

// T刚好兼容U
fn({name: 'wanzi'}, {name: ''}); // 允许
// T溢出兼容U
fn({name: 'wanzi', age: 14}, {name: ''}); // 允许

// T没有兼容U
fn({age: 14}, {name: ''}); // 报错
```

然而，相互制约制约的是类型，而不是值。那么，只要被制约者的类型满足制约者类型要求即可。于是，便出现了如下的奇特场景。

```tsx
// 允许的行为
fn(1, 2);
fn('abc', 'xyz');
fn(true, false);

// 错误的行为
fn(undefined, null);
```



### 工具类型

`TS` 提供了很多实用的工具类型（`Utility Types`，实用程序类型），这些工具类型通常会使用到 `typeof` 和 `keyof` 这两个操作符。

更多工具类型参考：[`Utility Types`](https://www.typescriptlang.org/docs/handbook/utility-types.html) 

##### `typeof`

在 `JS` 中，`typeof` 操作符用于获取某个值的类型，并以字符串的形式给出检测到的类型。由于 `TS` 的类型系统限制的是变量的类型，所以 `TS` 的 `typeof` 用于获取某个变量的类型，并且以数据类型的形式给出检测到的类型，这意味着其检测结果还可以继续作为类型使用。

```tsx
let an: any = 1;

type T = typeof an; // 由于检测的是变量的类型，所以T为any类型

let t: T = '';
```

当然，也可以利用类型推论机制，首先推论变量的类型。然后，再使用 `typeof` 去获取推论的类型，尤其是用在对象或函数的类型中。

```tsx
let userInfo = {
    name: '丸子',
    age: 14,
    sex: '女',
    like: ['电影', '唱歌', '游戏']
};

type Info = typeof userInfo;

// 最终，Info会接收到一个如下的类型：
/*
type Info = {
    name: string;
    age: number;
    sex: string;
    like: string[];
}
*/
```

```tsx
function fn(x: number, y: number): number[] {
    return [x, y];
}

type Fn = typeof fn; // 语法提示结果：type Fn = (x: number, y: number) => number[]
```

##### `keyof`

`keyof` 用于获取指定类型中的属性，并将其字面量类型联合成一个类型。尤其用在对象类型和数组类型中，联合其属性的字面量类型。

```tsx
interface IPerson {
    name: string;
    age: number;
    1: number;
}

type Test = keyof IPerson; // 相当于：type Test = 'name' | 'age' | 1;

let test: Test;
// 只接受类型中的已知属性名
test = 'name';
test = 'age';
test = 1;
```

`typeof` 只能用来检测变量的类型，不能用来检测类型本身（包括字面量类型和其他类型）。而 `keyof` 虽然不可以检测变量的类型（那是 `typeof` 应该做的事），但它可以用于检测指定类型（包括字面量类型和其他类型）的属性字面量类型。

```tsx
// 用于检测字面量类型
type T = keyof ''; 
// type T = number | typeof Symbol.iterator | "toString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | ... 28 more ... | "sup"

type T = keyof 0; 
// type T = "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"

type T = keyof true; // type T = "valueOf"

type T = keyof [];
// type T = number | 'concat' | 'copyWithin' | 'entries' | 'every' | ... | 'values'

type T = keyof [1, 2];
// type T = number | '0' | '1' | 'concat' | 'copyWithin' | 'entries' | 'every' | ... | 'values'

type T = keyof {}; // type T = never

type T = keyof {name: 'wanzi', age: 14};// type T = "name" | "age"

type T = keyof undefined; // type T = never

type T = keyof null; // type T = never
```

```tsx
// 用于检测其它的类型
type T = keyof string;
// type T = number | typeof Symbol.iterator | "toString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | ... 28 more ... | "sup"

type T = keyof number;
// type T = "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"

type T = keyof boolean; // type T = "valueOf"

type T = keyof Array<any>; 
// type T = number | 'concat' | 'copyWithin' | 'entries' | 'every' | ... | 'values'

type T = keyof Function;
// type T = 'apply' | 'arguments' | 'bind' | 'call' | 'caller' | 'length' | 'name' | 'prototype' | 'toString'

type T = keyof object; // type T = never

type T = keyof void; // type T = never

type T = keyof any; // type T = string | number | symbol

type T = keyof never; // type T = string | number | symbol
```

但在动态属性（即：索引签名）中，`keyof` 会检测到动态属性的类型，而不是该类型中某个具体的字面量类型。

```tsx
interface IT {
    name: string;
    [a: number]: number;
    [b: symbol]: symbol;
}

type T = keyof IT; // type T = 'name' | number | symbol
```

如果索引签名是 `string` 类型，则 `keyof` 的检测结果中还会额外包含 `number` 类型。因为访问对象的数字属性，要使用中括号语法，而中括号中允许存在 `number` 型和 `string` 型。并且在中括号中访问数字属性时，既可以使用数字本身，也可以使用字符串型数字。

```tsx
interface IT {
    name: string;
    [prop: string]: string;
}

type T = keyof IT; // type T = string | number
```

如前所述，`keyof` 返回的是联合类型。因此，在声明变量时，也可以直接使用其检测到的联合类型，以限定变量的类型范围。

```tsx
let a: keyof number; 
// let a: "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"

a = "toString";
a = "valueOf";
```

##### 映射类型

`TS` 中的映射，类似于数学中映射的概念。映射类型，就是将一个类型映射成另一个结构基本相同的类型，常用在复杂的类型中。但是它可以对映射出来的类型进行一些个性化的设计，比如将其中的某些部分设为可选或只读等。

使用内置工具类型 `Partial` 可以将指定类型中的所有属性设为可选。在 `Partial` 后紧跟一个被尖括号包裹的类型以获得其映射类型。

```tsx
type Person = {
    name: string;
    age: number;
    sex: string
};

// 在Person类型上映射出一个新的类型，并在新类型中将原先所有的必选属性转为可选属性。
type T = Partial<Person>;
/*
type T = {
    name?: string | undefined;
    age?: number | undefined;
    sex?: string | undefined;
}
*/
```

下面来看看最简单的映射类型和它的组成部分：

```tsx
type Keys = 'option1' | 'option2';

// {[属性名 in 属性名集合]}: 属性值的类型
type Flags = {
    [K in Keys]: boolean 
};
```

它的语法与索引签名的语法类似，内部使用了 `for-in`（`TS` 的 `for-in` 可以遍历联合类型）。 具有以下三个部分：

1. 类型变量 `K`，它会依次绑定到每个属性。
2. 字符串字面量联合的 `Keys`，它包含了要迭代的属性名的集合。
3. 属性值的类型。

在这个简单的例子里， `Keys` 是硬编码的的属性名列表并且属性值的类型永远是 `boolean`，因此这个映射类型等同于：

```tsx
type Flags = {
    option1: boolean;
    option2: boolean;
}
```

在真正的应用里，可能不同于上面情况的 `Readonly` 或 `Partial` 工具类型会基于一些已存在的类型，且按照一定的方式转换字段。 这就是 `keyof` 和索引访问类型要做的事情：

```tsx
type NullablePerson = { [P in keyof Person]: Person[P] | null } // 可空类型
type PartialPerson = { [P in keyof Person]?: Person[P] } 		// 可选类型
```

但它更有用的地方是可以有一些通用版本。那就是像定义函数的泛型变量一样，在工具类型名之后紧跟一个被尖括号包裹的类型变量。然后，在使用到该工具类型时，也可以像调用函数那样传入指定的类型，并最终得到一个新的类型。

可以将工具类型视作一种函数，因为它们也是为了完成某些任务而设计的，或者说它们具有特定的功能性（这正是函数所独有的特点）。

```tsx
// 定义工具类型
type Nullable<T> = { [P in keyof T]: T[P] | null } 	// 可空类型
type Partialable<T> = { [P in keyof T]?: T[P] } 	// 可选类型

// 使用工具类型
type MyNullable = Nullable<{name: string; age: number; sex: string}>
type MyPartialable = Partialable<{name: string; age: number; sex: string}>
```

```tsx
// 结果如下：
type MyNullable = {
    name: string | null;
    age: number | null;
    sex: string | null;
}

type MyPartialable = {
    name?: string | undefined;
    age?: number | undefined;
    sex?: string | undefined;
}
```

在这些例子里，属性列表是 `keyof T` 且属性值类型是 `T[P]` 的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是[同态](https://en.wikipedia.org/wiki/Homomorphism)的，映射只作用于 `T` 的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设 `Person.name` 是只读的，那么 `Partial<Person>.name` 也将是只读的且为可选的。

##### 深度映射

默认情况下，工具类型只会映射到根属性，不会映射二级及以下的属性。

```tsx
interface IUserInfo {
    id: number;
    name: string;
    info: {
        a: number;
        b: string
    }
}

type T = Partial<IUserInfo>
/*
type T = {
    id?: number | undefined;
    name?: string | undefined;
    info?: {
        a: number;
        b: string;
    } | undefined;
}
*/
```

而要实现深度映射，使映射效果作用到更深的层次，则可以使用递归的方式进行深度遍历和分析。解决这个问题的关键在于，如何确定是否还具有二级属性，即：属性值本身是否是对象类型。要判断一个类型是否满足指定类型的标准，可以使用 `extends` 关键字。因为只有当继承者满足被继承者的类型要求后，`extends` 关键字才会允许继承发生。

当使用 `extends` 关键字来判断两个类型之间的是否具有继承关系且前者是否能够继承后者时，它要求在获得判断结果后必须返回类型。

```tsx
// 格式：A类型 extends B类型 ? 条件成立时返回的类型 : 条件失败时返回的类型;
type T = string extends object ? boolean : number; // type T = number

type T = string[] extends object ? boolean : number; // type T = boolean

type T = object extends object ? boolean : number; // type T = boolean

type T = {
    name: string
} extends {
    age: number
} ? boolean : number; // type T = number

type T = {
    name: string;
    age: number
} extends {
    age: number
} ? boolean : number; // type T = boolean
```

利用这一点，便可以判断在 `A extends object` 中，`A` 类型是否是 `object` 类型或其子类型。

```tsx
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
}
```

现在已经实现了深度映射，但是 `TS` 的类型检查机制并不能检测到下级属性的修饰符。只有当写到下级属性时，才能看到它们的修饰符。

```tsx
interface IUserInfo {
    id: number;
    name: string;
    info: {
        a: number;
        b: string
    }
}

type T = DeepPartial<IUserInfo>

let t: T = {
    id: 1,
    info: {
        a: 1 // 写到这里，才能知道a是可选属性
    }
}
```

但上面 `DeepPartial` 类型并不是完美的，当 `info` 本身就具有 `?` 修饰符时，会导致深度映射失败。因为此时 `info` 的类型不单单是一个 `object` 类型，而是一个包含 `undefined` 的联合类型。所以在 `T[P] extends object` 的判断中，会得到条件不成立的结果。

```tsx
// 对DeepPartial进一步的完善
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object | undefined ? DeepPartial<T[P]> : T[P];
}
```

##### 逆向映射

逆向映射，就是将属性的某个修饰符移除。在要移除的属性修饰符前面，使用一个 `-` 移除符。例如：`-?` 表示将可选属性转为必选属性。

```tsx
// 如下是必选工具类型的内部实现
type Required<T> = {
    [P in keyof T]-?: T[P];
}
```

同样的，`Required` 工具类型也只能映射到一级属性，对于下级属性是影响不到的。只能通过递归等方式自定义可深度映射的工具类型。

```tsx
interface IUserInfo {
    id: number;
    name: string;
    age?: number;
    info?: {
        a?: number;
        b?: string;
    };
    tup?: [number?, string?];
}

// 对一级可选属性的兼容
type DeepRequired<T> = {
    [P in keyof T]-?: T[P] extends object | undefined ? DeepRequired<T[P]> : T[P];
}

type T = DeepRequired<IUserInfo>;
/*
type T = {
    id: number;
    name: string;
    age: number;
    info: {
        a: number;
        b: string;
    }
    tup: [number, string];
}
*/
```

##### 只读属性

使用 `Readonly` 工具类型可以将属性设为只读，其原理就是在一级属性前加上一个 `readonly` 关键字，如下所示。

```tsx
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
}
```

```tsx
// 深度映射
type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object | undefined ? DeepReadonly<T[P]> : T[P];
}
```

而想要将只读属性恢复成普通的属性，只需将前缀的 `readonly` 关键字移除即可。

```tsx
type ResetReadonly<T> = {
    -readonly [P in keyof T]: T[P];
}

// 深度移除
type DeepResetReadonly<T> = {
    -readonly [P in keyof T]: T[P] extends object | undefined ? DeepResetReadonly<T[P]> : T[P];
}
```

##### 挑选属性

`Pick` 工具类型用于从指定的类型中挑出所需的属性，并将其组成一个新的类型返回。`Pick` 接收两个参数，首参指定源类型，次参以联合类型的方式指定所需的属性。

```tsx
interface IUserInfo {
    name: string;
    age: number;
    sex?: string;
    info?: {
        a?: number;
        b?: string;
    };
    tup?: [number, string];
}

type T = Pick<IUserInfo, "name" | "age">;
/*
type T = {
    name: string;
    age?: number | undefined;
}
*/
```

其原理如下，其中 `K extends keyof T` 表示参数 `K` 是一个继承自 `keyof T` 的类型，通常为其传入硬编码的属性字面量联合类型。

```tsx
// 类型K虽然继承自keyof T，但不能超过它的范围，因为只允许挑选已知的属性。
type Pick<T, K extends keyof T> = { 
    [P in K]: T[P]; 
}
```

```tsx
// K extends keyof T
// 当使用extends关键字继承一个联合类型时，意味着将继承者的类型限制在被继承者的联合类型范围之内。
type T = "a" extends "a" | "b" ? true : false; // type T = true
type T = "b" extends "a" | "b" ? true : false; // type T = true
type T = "c" extends "a" | "b" ? true : false; // type T = false

type T = "a" | "b" extends "a" | "b" ? true : false; 		// type T = true
type T = "a" | "b" | "c" extends "a" | "b" ? true : false; 	// type T = false
```

##### 记录类型

`Record` 类型用于构造一个新的对象类型，并将第一个参数作为其属性名的类型，第二个参数作为其属性值的类型。

```tsx
// 联合类型
type T = Record<"a" | "b" | "c", boolean>;
/*
type T = {
    a: boolean;
    b: boolean;
    c: boolean;
}
*/

// 单一类型
type T = Record<number, boolean>; // type T = {[x: number]: boolean;}
```

其原理如下：

```tsx
type Record<K extends string | number | symbol, T> = { [P in K]: T; }
```

##### 返回类型

`ReturnType` 工具类型用于获取函数类型中返回值的类型，它接收一个函数类型的参数。

```tsx
function fn(a: number): any {
    return "";
}

// 当typeof函数时，会获得其函数类型
type T = typeof fn; // type T = (a: number) => any

type U = ReturnType<T>; // type U = any
```

其原理如下，其中使用了 `infer` 关键字来推论返回值的类型。它引入了一个类型变量 `R` 来保存其推论的返回值类型，且这个类型变量 `R` 只能用在条件类型的真分支语句中。【`infer`：推论】

```tsx
// 推论返回值的类型，并且当传入的类型T满足条件（即：为函数类型）时，返回该推论结果；不满足则返回any型。
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any
```

##### 提取类型

`Extract` 工具类型用于提取两个类型中的交叉类型，接收两个参数。【`Extract`：提取，摘录】

```tsx
type A = Extract<"a" | "b", "a" | "b" | "c">; // type A = "a" | "b"
```

其原理如下：

```tsx
type Extract<T, U> = T extends U ? T : never
```

由其原理可知，当两者类型中有重叠部分时，返回 `T` 与 `U` 的交叉类型；无重叠部分时，返回 `never` 类型。

```tsx
type T = Extract<"a" | "b", "a" | "c" | "d">; // type T = "a"

type T = Extract<{a: string; b: string} | {c: string;}, {a: string;}>; // type T = {a: string; b: string;}
```

##### 排除类型

`Exclude` 工具类型用于从源类型中排除出指定的类型，接收两个参数（源类型，要排除的类型）。【`exclude`：排除】

```tsx
type Union = "a" | "b" | "c";

// 从Union类型中，排除出"b" | "c"类型
type T = Exclude<Union, "b" | "c">; // type T = "a"
```

其原理如下：

```tsx
type Exclude<T, U> = T extends U ? never : T
```

由其原理可知，当两者类型中有重叠部分时，返回 `never` 类型；无重叠时，表示从 `T` 中剔除与 `U` 的交叉类型，返回 `T` 的剩余部分。

```tsx
// 有交叉，去交叉。
type T = Exclude<"a" | "b", "b" | "c">; // type T = "a"

// 无交叉，无剔除。
type T = Exclude<"a" | "b", "c">; 		// type T = "a" | "b"

// 条件满足
type T = Exclude< "a", "a" | "b">; 			// type T = never
type T = Exclude< "a" | "b", "a" | "b">; 	// type T = never
```

由其原理可知，`Exclude` 工具类型最适合于联合类型。不能用于 `T` 继承自 `U` 的情况，否则会得到 `never` 类型，如下所示。

```tsx
// type T = never的情况
type T = Exclude<{a: string;}, {a: string;}>;

type T = Exclude<{a: string; b?: number;}, {a: string;}>;

type T = Exclude<{a: string; b?: number;}, {}>;

type T = Exclude<{a: string; b?: number; } | {c: string}, {}>;

// 推荐用法
type T = Exclude<{a: string;} | {c: string}, {a: string}>; // type T = {c: string;}

type T = Exclude<{a: string; b?: number;} | {c: string}, {a: string}>; // type T = {c: string;}
```

##### 删除属性

`Omit` 类型用于在源类型上构造一个新的对象类型，并将源类型中的指定属性删除。【`omit`：省略，删除】

```tsx
type UserInfo = {
    id: number;
    name: string;
    age?: number;
    sex?: string;
};

// Omit<源类型，要删除的属性类型>
type T = Omit<UserInfo, "age" | "sex">; // type T = {id: number; name: string;}
```

其原理如下：

```tsx
type Omit<T, K extends string | number | symbol> = { 
    [P in Exclude<keyof T, K>]: T[P]; 
}
```

由其原理可知，`Omit` 首先利用 `Exclude` 从源类型的属性中删除两者重叠的属性，然后将源类型中剩余的属性及其值置入新类型中。

##### 非空类型

`NonNullable` 类型用于从源类型中祛除空类型，即：`undefined` 和 `null`，不包括 `void` 类型。

```tsx
type T = NonNullable<number | string | undefined | null | void>; // type T = string | number | (void & {})
```

其原理如下：

```tsx
// 旧版写法：
type NonNullable<T> = T extends null | undefined ? never : T

// 新版写法：
type NonNullable<T> = T & {}
```

两版由于原理不同，所以对于 `void` 类型的处理也不同。

```tsx
type N1<T> = T extends null | undefined ? never : T;
type N2<T> = T & {};

type T1 = N1<void>; // type T1 = void
type T2 = N2<void>; // type T2 = void & {}
```

##### 参数类型

`Parameters` 类型用于获取指定函数类型中参数的类型，并将获得的类型放入一个元组类型中。

```tsx
function fn(a: string, b?: number, c = false): void {}

type T = Parameters<typeof fn>; // type T = [a: string, b?: number | undefined, c?: boolean | undefined]
```

其原理如下，其中使用 `infer` 推断参数的类型，并将其推论结果置于条件类型的真分支语句中。

```tsx
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never
```

由其原理可知，当传入的是函数类型时，返回其参数的类型；如不是函数类型，则返回 `never` 类型。

```tsx
type T = Parameters<(a: string, b: number) => void>; // type T = [a: string, b: number]
```

