# 语句

`ECMA-262` 描述了一些语句（也称为流控制语句），而 `ECMAScript` 中的大部分语法都体现在语句中。

语句是程序的关键，它用来描述程序的逻辑走向与全部功能，它们是构建逻辑与功能的基础结构和语法。

语句的好坏，体现了编程者的专业素养和逻辑思想，也直接决定了代码的质量和程序性能的高低。

<hr>

### 流程控制语句

##### `if`语句

`if` 语句是使用最频繁的语句之一。

`ECMAScript` 会自动调用 `Boolean()` 函数将条件表达式的值转换为布尔值。

```js
// 单if语句
if (condition) {
    statement;
}

// if...else语句
if (condition) {
    statement1;
} else {
    statement2;
}

// if...else if...else语句：连续判断，多重分支
if (condition1) {
    statement1;
} else if (condition2) {
    // 前面的条件都不满足时，判断该条件。
    statement2;
} else {
    statement3;
}

// 例如：判断区间
if (num >= 90 && num < 100) {
    // 区间：[90, 100)
} else if (num >= 80) {
    // 区间：[80, 90)
} else if (num >= 70) {
    // 区间：[70, 80)
} else if (num >=60) {
    // 区间：[60, 70)
} else {
    // 区间：[0, 60)
}
```



##### `switch`语句

`switch` 语句是与 `if` 语句紧密相关的一种流控制语句，两者有时还可以互换。【确切值使用`switch`，范围值使用`if`】

规则：`switch` 语句在比较每个条件的值时会**使用全等操作符**，因此不会强制转换数据类型。

```js
switch (expression) {
    case r1:
        statement1;
        break;
    case r2:
        statement2;
        break;
    ...
    default:
    	default statement;
}
```

注释：

- `expression`：既可以是条件【用条件去匹配结果】，也可以是一个已知的结果【用结果去匹配条件】。
- `case` 关键字：既可以跟一个确切的结果，也可以跟一个条件。总之，`case` 后面的是 `expression` 的待匹配项。
- `break` 关键字：用于立即终止当前的 `switch` 语句，防止向下击穿。【在函数中，还可以使用 `return` 来结束】
- `default` 关键字：当所有 `case` 项都不匹配时，最终的默认匹配项。
- 击穿：无视 `case` 的限制，依次执行下一 `case` 的语句，直至遇到 `break` 或者结束。

```js
// 通过条件匹配结果
switch (1) {
    case 1:
        console.log("星期一");
        break;
    case 2:
        console.log("星期二");
        break;
    case 3:
        console.log("星期三");
        break;
    case 4:
        console.log("星期四");
        break;
    case 5:
        console.log("星期五");
        break;
    case 6:
        console.log("星期六");
        break;
    case 7:
        console.log("星期日");
        break;
    default:
        console.log("无此项");
}

// 通过结果匹配条件
switch (1) {
    case 1 - 1:
        console.log("星期一");
        break;
    case 2 - 1:
        console.log("星期二");
        break;
    case 3 - 1:
        console.log("星期三");
        break;
    case 4 - 1:
        console.log("星期四");
        break;
    case 5 - 1:
        console.log("星期五");
        break;
    case 6 - 1:
        console.log("星期六");
        break;
    case 7 - 1:
        console.log("星期日");
        break;
    default:
        console.log("无此项");
}

// 击穿
switch (1) {
    case 1:
        console.log(1);
    case 2: // 该条件被击穿
        console.log(2);
        break;
    case 3:
        console.log(3);
        break;
    default:
        console.log(0);
}
```

<hr>

### 循环语句

循环语句的终止条件：

- 每次执行循环前，会先被调用 `Boolean()` 来转型其结果：为 `true` 继续循环，为 `false` 结束循环。
- 它通常被设计成限制循环次数的条件【`for`】，也可以被设计成复杂丰富的逻辑条件【`while`】。



#### `while`循环

`while` 系列循环的特点：计数器必须定义在整个循环结构的外面【有时会不安全】，在里面易导致死循环。

##### `do-while`

`do-while` 语句是一种**后测试循环语句**，即循环体中的代码执行后才会对退出条件进行求值。【至少执行一次】

```js
// 先执行一遍do的循环体语句，再对while的值进行判断。
do {
    statement;
} while (expression);

// 计数器在结构外面
let i = 0;
do {
    i += 2;
} while (i < 10);
```



##### `while`

`while` 语句是一种**先测试循环语句**，即先检测退出条件，符合条件才能执行循环体内的代码。【可能不会执行】

```js
// 只有条件符合，才能开启循环。
while (expression) {
    statement;
}

// 计数器在结构外面
let i = 0;
while (i < 10) {
    i += 2;
}

// 高阶while循环
let i = 10;
while (i--) {
    console.log(i);
}
```

<hr>

#### `for`循环

迭代变量：

- `for`： 迭代变量不能用 `const` 声明，因为更新迭代常量会报错。【只在首次声明，后续迭代更新】
- `for-in` 和 `for-of`：可以用 `const` 声明，以确保它不会在内部被修改。【每次先销毁，再重新声明】

至于，为什么可以用 `const` 声明，原因：`const` 受限于块级作用域，每次循环完之后立即销毁块级变量，下一次将重新声明。

循环终止：

- `for`：必须设置终止条件，否则会进入死循环。
- `for-in` 和 `for-of`：遍历完所有元素后，自动终止。



##### `for`

`for` 循环的特点：对计数器的定义被封装在循环结构内部，保证了安全性。它实际上是【对 `while` 的高度提炼与封装】

执行顺序：

- 首先声明一个计数器【该操作只在首次遇到 `for` 时执行一次】
- 判断终止条件：为 `true` 开启首次循环，为 `false` 直接结束。
- 更新计数器：执行完循环体语句后，更新计数器【最后更新】
- 继续判断条件，若继续循环，则：执行循环体 ==> 更新计数器 ==> 继续判断...

`for` 与 `while` 的比较：

- `for` 是对 `while` 的高度封装，而 `while` 能构造的循环比 `for` 更广。
- `for` 依赖于计数器，主要是实现一些与计数相关的数理逻辑。
- `while` 依赖于条件，只要条件合理，能实现任何复杂的逻辑。
- 因此，`for` 能实现的逻辑一定能用 `while` 实现，反之未必。

注释：

- 对于 `for` 来说，没有什么是必须的【顶部可以没有初始化语句、条件语句、更新语句】
- 如果只包含条件表达式，那么 `for` 循环实际上就变成了简单的 `while` 循环。

**高阶 `for` 循环**：由于 `for` 依赖于计数器，因此只要能够限制循环次数和及时更新计数器【避免死循环】即可。

```js
// 将计数器的声明与更迭统一封装到一处。
for (initialization; expression; post-loop-expression) {
    statement;
}
------------------------------------------------------------------------------------------------------------

// 死循环
for (; ;) {}

// 使用break退出循环
let i = 0; // 计数器定义在外面
for (; ;) {
    if (i > 9) break; // 定义界限
    console.log(i);
    i++; // 更新写在循环体最后
}

// 转换为简单的 while 循环
let i = 0;
for(; i < 10;) {
    i++;
}
------------------------------------------------------------------------------------------------------------

// 高阶for循环
// 利用数组实现高阶for循环是最常见的手段之一，因为：arr[arr.length] === undefined; 提供了天然的终止条件。
for (let i = 0, fn, arr = ["push", "shift", "pop"]; fn = arr[i++];) {
	console.log(fn);	// "push", "shift", "pop"
}

// 倒循环
for (let i = 10; i--;) {
    console.log(i); // 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
}

// 简单双重for循环：内外层的计数器相互独立，没有直接联系。
for (let i = 0; i < 10; i++) {
    // 外层管行数、趟数
    for (let j = 0; j < 10; j++) {
        // 内层管列数、一趟有多少次。
        // 例如：一共10趟，每趟10次，总共100次。
    }
}

// 高级双重for循环：外层计数器控制内层计数器，控制每趟次数。
// 正三角递增，扩充尾部
for (let i = 0; i < 10; i++) {
    for (let j = 0; j < i; j++) {
        // 每趟的次数不超过该趟。
        // 例如：当前是第5趟，该趟只有5次。
    }
}
// 倒三角递减，压缩首部
for (let i = 0; i < 10; i++) {
    for (let j = i; j < 10; j++) {
        // 趟数决定每趟次数的起点
        // 例如：当前是第3趟，该趟次数从3开始，有7次。
    }
}
```



##### `for-in`

`for-in` 语句是一种严格的迭代语句，用于枚举对象中的**非符号键属性**。

语法：`for (property in expression) { statement }` 

执行顺序：

- 初始化迭代变量
- 执行循环体，执行完毕后销毁块级变量
- 循环往复：初始化迭代变量 ==> 执行，销毁 ==> 初始化...【直至遍历完所有元素】

迭代对象：`for-in` 只能用来迭代对象和数组。

- 对象：每次循环，将对象的非符号键属性传递给迭代变量。
- 数组：每次循环，将数组的下标传递给迭代变量。

```js
let obj = {
    a: 1,
    b: 2,
    c: 3
}

// 每次循环，将对象的非符号键属性传递给key变量。
for (const key in obj) {
    console.log(key);
}
------------------------------------------------------------------------------------------------------------

// 遍历数组
for (const index in [2, 3, 1]) {
    console.log(index);
}
```



##### `for-of`

`for-of` 语句是一种严格的迭代语句，用于遍历具有迭代器的数组或类数组。

语法：`for (property of expression) { statement }` 

注释：`for-of` 每次循环将下标传递给迭代变量。

```js
for (const index of [2, 2, 2]) {
    console.log(index);
}
```

`ES2018` 对 `for-of` 语句进行了扩展，增加了 `for-await-of` 循环，以支持生成期约（`promise`）的异步可迭代对象。

<hr>

#### 标签语句

标签语句：主要用于终止循环。包括：标记，`break` 和 `continue`。

`break` 和 `continue` 语句为执行循环代码提供了更严格的控制手段。

区别：`break` 和 `continue` 都用于立即退出循环，但退出后：

- `break`：忽略循环体，执行后面的代码【不再执行循环】
- `continue`：继续从循环顶部开始执行【继续执行循环】



##### `break`

`break` 语句用于立即退出循环，并强制执行循环后的下一条语句。

```js
let arr = [];

for (let i = 0; ; i++) {
    if (i === 5) {
        break; // 退出并终止循环。
    }
    arr.push(i);
}
arr; // [0, 1, 2, 3, 4]
```



##### `continue`

`continue` 语句用于立即退出循环，并会再次从循环顶部开始执行。

```js
let arr = [];

for (let i = 0; i < 10; i++) {
    if (i === 5) {
        continue;
    }
    arr.push(i);
}
arr; // [0, 1, 2, 3, 4, 6, 7, 8, 9]
```



##### 标记

标记由开发者定义后面跟一个冒号，主要用于跳出多层循环。要配合 `break` 或 `continue` 使用，可将程序跳到标记处。

组合使用标签语句和 `break`、`continue` 能实现复杂的逻辑，但也容易出错。注意标签要**使用描述性强的文本**，而嵌套也不要太深。

```js
let num = 0;

for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 10; j++) {
        if (i === 5 && j === 5) {
            break; // 退出并终止当前（内层）循环，从外层继续。
        }
        num++;
    }
}
num; // 95

// 设置一个end标记，当它被触发时，将程序回到该位置。
let num = 0;

end: 
for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 10; j++) {
        if (i === 5 && j === 5) {
            break end; // 退出并终止到标记处，两层都被退出。
        }
        num++;
    }
}
num; // 55
------------------------------------------------------------------------------------------------------------

let num = 0;

for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 10; j++) {
        if (i === 5 && j === 5) {
        	continue; // 退出本次循环，继续内层循环。
    	}
    	num++;
    }
}
num; // 99

// continue：退出并跳过本次循环，到标记处。
let num = 0;

start:
for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 10; j++) {
        if (i === 5 && j === 5) {
        	continue start; // 退出到标记处，从外层继续。【相当于终止了内层循环】
    	}
    	num++;
    }
}
num; // 95
```

<hr>

### `with`语句

`with` 语句的用途是：将一块代码的顶层作用域设置为特定的对象【修改**作用域链顶端**】

注释：【`with` 也是**块级作用域**】

- 使用 `with` 语句的主要场景是**针对一个对象反复操作**，这时候将代码作用域设置为该对象能提供便利。
- 严格模式不允许使用 `with` 语句，否则会抛出错误。
- 由于 `with` 语句**影响性能且难于调试**其中的代码，通常不推荐在产品代码中使用 `with` 语句。

```js
let obj = {
    search: "?aaa",
    hostname: "xxx",
    href: "fff"
}

// 针对一个对象重复操作
let qs = obj.search,
    hostname = obj.hostname,
    url = obj.href;

// 使用with简化：将obj作为该块代码的顶层作用域。
with(obj) {
    // 可以直接使用obj中的属性。
    let qs = search,
        hostName = hostname,
        url = href;
}

// 修改with代码块的作用域链顶端
function fn() {
	let search = "sss",
        head = "hhh";
    
	with (obj) {
		console.log(search); // "?aaa"【顶层作用域】
		console.log(head); // "hhh"【第二层作用域】

		let qs = search,
            hostName = hostname,
            url = href;
	}
}
```

