# 严格模式

`ECMAScript 5` 首次引入严格模式的概念。严格模式用于选择以更严格的条件来检查 `JavaScript` 代码的错误，可以应用到全局，也可以应用到函数内部。严格模式的好处是可以提前发现错误，因此可以捕获某些 `ECMAScript` 问题导致的编程错误。

理解严格模式的规则非常重要，因为未来的 `ECMAScript` 会逐步强制全局使用严格模式。严格模式已得到所有主流浏览器的支持。



### 开启

要开启严格模式，需要使用严格模式编译指示（`pragma`），即：一个不赋值给任何变量的字符串：

```js
// 开启全局严格模式（编译指示必须书写在作用域的首部，否则就没有用）
"use strict";
```

使用这样一个在所有 `ECMAScript` 版本中都有效的字符串，就可以做到兼容不支持严格模式的 `JavaScript` 引擎。因为支持严格模式的引擎能识别它并启用严格模式，而不支持的引擎则会将这个编译指示当成一个未赋值的字符串字面量来处理。

如果把这个编译指示应用到全局作用域（即：函数外部），则整个脚本都会按照严格模式来解析。这意味着在最终会与其他脚本拼接为一个文件的脚本中添加了编译指示，则可能会将该文件中的所有 `JavaScript` 都置于严格模式之下（除非编译指示不在文件首部）。

也可以像下面这样只在一个函数内部开启严格模式（这是通常推荐的做法）：

```js
function doSomething() { 
    // 开启局部严格模式（同样地，编译指示必须书写在作用域的首部）
 	"use strict"; 
 	// 其他代码
}
```

如果你不能控制页面中的所有脚本，那么建议只在经过测试的特定函数中启用严格模式。



### 变量

在严格模式下，如何创建变量以及何时会创建变量都会发生变化。第一个变化是不允许意外创建全局变量。在非严格模式下，以下代码会导致创建全局变量：

```js
// 变量未声明就赋值
message = "Hello world!";
```

虽然这里的 `message` 没有前置任何声明类的关键字，也没有明确定义为全局对象的属性，但仍然会被自动创建为全局变量。在严格模式下，给未声明的变量赋值会在执行代码时抛出 `ReferenceError`。

```js
"use strict"; 

message = "Hello world!"; // Uncaught ReferenceError: message is not defined
```

相关的另一个变化是无法在变量上调用 `delete`。在非严格模式下允许这样，但可能会静默失败（返回 `false`）。

```js
// 删除变量（而不是属性）
let color = "red"; 
delete color;
```

在严格模式下，尝试删除变量则会导致错误：

```js
"use strict";

let color = "red";
delete color; // Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.
```

严格模式也对变量名的使用增加了限制。具体来说，它不允许变量名为 `implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static` 和 `yield`。这些是目前的保留字，可能在将来的 `ECMAScript` 版本中会用到。因此如果在严格模式下使用这些名称作为变量名，也会导致语法错误。

```js
"use strict";

let implements = "red"; // Uncaught SyntaxError: Unexpected strict mode reserved word
```



### 对象

在严格模式下操作对象比在非严格模式下更容易抛出错误。在非严格模式下会静默失败的情况，在严格模式下都倾向于抛出错误，而这也增加了开发中提前发现错误的可能性。

首先，严格模式在以下几种情况试图操纵对象的属性时都会抛出错误。

- 给只读属性赋值会抛出 `TypeError`。
- 在不可配置属性上使用 `delete` 会抛出 `TypeError`。

另外，与对象相关的限制也涉及通过对象字面量声明它们。在使用对象字面量时，属性名必须唯一。例如：

```js
// 两个属性重名。非严格模式：没有错误，且第二个属性会生效；严格模式：抛出 SyntaxError。
let person = { 
 	name: "Nicholas", 
 	name: "Greg" 
};
```

这里的对象 `person` 有两个叫作 `name` 的属性。第二个属性在非严格模式下是最终的属性；而在严格模式下，将导致语法错误。但 `ECMAScript 6` 删除了对重名属性的这个限制，即：在严格模式下命名重复的对象字面量属性也不会抛出错误。



### 函数

严格模式（无论是在全局开启的，还是在其局部开启的）要求命名函数参数必须唯一。看下面的例子：

```js
// 命名参数重名：非严格模式下只要不初始化参数都不会发生错误，且只有第二个参数有效。
function sum (num, num) {
    console.log(num, [...arguments]);
}

sum(1); 	// undefined [1]
sum(1, 2); 	// 2 [1, 2]

// 如果初始化参数，则非严格模式也会抛出错误。
function sum (num = 1, num = 2) {} 
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context
```

在非严格模式下，第一种函数声明不会抛出错误，但通过名称只能访问第二个 `num`。而它在严格模式下，则会抛出同上错误。

```js
// 无论是在全局严格模式中
"use strict";

function sum (num, num) {} 

// 还是在其局部严格模式中
function sum(num, num) { 
    "use strict";
}
```

`arguments` 对象在严格模式下也发生了一些变化。在非严格模式下，修改命名参数也会修改 `arguments` 对象中的值，二者是实时同步的。而在严格模式下，命名参数和 `arguments` 是相互独立的。例如：

```js
// 修改命名参数的值：非严格模式 arguments 会反映变化
(function (value) { 
 	value = "Bar"; 
 	console.log(value, arguments[0]); // 'Bar' 'Bar'
})('Foo'); 
```

这个例子在函数内部，将 `value` 修改为 `"Foo"`。在非严格模式下，这样也会修改 `arguments[0]` 的值，但在严格模式下则不会。

```js
// 修改命名参数的值：严格模式 arguments 不会反映变化
(function (value) { 
  	"use strict";
 	value = "Bar"; 
 	console.log(value, arguments[0]); // 'Bar' 'Foo'
})('Foo'); 
```

另一个变化是去掉了 `arguments.callee` 和 `fn.caller`。在非严格模式下，它们分别引用函数本身和调用函数。

```js
function inner() { 
	console.log(arguments.callee === inner); 		// true
    console.log(arguments.callee.caller === outer); // true
} 

function outer() {
    inner();
}

outer();
```

在严格模式下，访问或尝试设置这两个属性中的任何一个都会抛出 `TypeError`。例如：

```js
function inner() { 
    "use strict";
	console.log(arguments.callee); 	// 不允许
    console.log(inner.caller); 		// 不允许
} 

function outer() {
    inner();
}

outer();

// Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
```

另外，与变量一样，严格模式也限制了函数的命名，不允许将函数命为 `implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static` 和 `yield`。

关于函数的最后一个变化是：全局严格模式下块级作用域中的函数声明不再被提升到该块的外部，它只能在这个块中使用。而在非严格模式下，它会被提升到全局作用域或最近的函数作用域中。

```js
// 在块中声明函数：非严格模式下函数声明会被提升到全局作用域或最近的函数作用域中。
// 提升到全局作用域中
if (true) { 
 	function doSomething() {
        console.log('doing');
    } 
}
doSomething(); // 'doing'

// 提升到局部作用域中
function fn() {
    if (true) {
        function doSomething() {
            console.log('doing');
        }
    }
    doSomething(); // 'doing'
}
fn();

doSomething(); // Uncaught ReferenceError: doSomething is not defined
```

所有浏览器在非严格模式下都支持此语法，但只在外部开启严格模式时才会抛出错误，因为它不属于其局部严格模式的管理范畴。

```js
// 局部严格模式
if (true) {
    function doSomething() {
        "use strict";
        console.log('doing');
    }
}
doSomething(); // 'doing'

// 局部严格模式
function outer() {
    if (true) {
        function inner() {
            "use strict";
            console.log('doing');
        }
        inner(); // 'doing'
    }
    inner(); 	 // 'doing'
}
outer();

// 外部严格模式
function outer() {
    "use strict";
    if (true) {
        function inner() {
            console.log('doing');
        }
        inner(); // 'doing'
    }
    inner(); 	 // Uncaught ReferenceError: inner is not defined
}
outer();

// 全局严格模式
"use strict";
if (true) {
    function doSomething() {
        console.log('doing');
    }
    doSomething(); 	// 'doing'
}
doSomething(); 		// Uncaught ReferenceError: doSomething is not defined
```



#### 函数参数

`ES6` 增加了剩余操作符、解构操作符和默认参数，它们为函数组织、解构和定义参数提供了强大的支持。`ECMAScript 7` 又增加了一条限制，要求使用任何上述先进参数特性的函数内部都不能使用严格模式，否则会抛出错误。

```js
// 均报：Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list

function bar(a, b, c = 'd') { 
 	"use strict"; 
} 

function baz({a, b, c}) { 
 	"use strict"; 
} 

function qux(a, b, ...c) { 
 	"use strict"; 
}
```

不过，为了在严格模式中应用这些特性，全局严格模式是允许这样做的。

```js
"use strict"; 

function bar(a, b, c = 'd') {} 

function baz({a, b, c}) {} 

function qux(a, b, ...c) {}
```

`ES6` 增加的这些新特性期待参数与函数体在相同的模式下进行解析。如果允许编译指示 `"use strict"` 出现在函数体内，`JS` 解析器就需要在解析函数参数之前先检查函数体内是否存在这个编译指示，而这会带来很多问题。为此，`ES7` 规范增加了这个约定，目的是让解析器在解析函数之前就确切知道该使用什么模式。



#### `eval()`

`eval()` 函数在严格模式下也有变化，最大的变化是 `eval()` 不会再在包含上下文中创建变量或函数。`eval()` 可以识别和执行字符串形式的任何 `JS` 代码。非严格模式下，如果在其中使用 `ES3` 语法声明变量，则这些变量将会成为其包含上下文中的变量。若使用 `ES6` 的 `let` 或 `const` 声明变量，则这些变量会被限制在 `eval()` 的局部作用域之中。

```js
// 非严格模式
// 在 eval() 中创建ES3变量
eval("var x = 10"); 
console.log(x); // 10

eval("y = 20"); 
console.log(y); // 20

// 在 eval() 中创建ES6变量
eval("let x = 10; console.log(x);"); 	// 10
console.log(x); // Uncaught ReferenceError: x is not defined

eval("const y = 20; console.log(y);"); 	// 20
console.log(y); // Uncaught ReferenceError: y is not defined
```

严格模式下，在 `eval()` 中创建的任何变量都会被限制在其局部作用域中。同样地，也不允许在其中不声明就使用变量。

```js
// 严格模式
"use strict";

// 在 eval() 中创建ES3变量
eval("var x = 10; console.log(x);"); // 10
console.log(x); // Uncaught ReferenceError: x is not defined

// 使用未声明的变量
eval("y = 20; console.log(y);"); 	// Uncaught ReferenceError: y is not defined
```

在 `eval()` 中声明的变量和函数会位于 `eval()` 执行期间的一个特殊的作用域里，该 `eval()` 一旦执行完毕就会立即销毁它们。

```js
"use strict"; 

let result = eval("let x = 10, y = 11; x + y"); // eval() 会返回函数字符串（最后一句是此函数的返回值）的返回值
console.log(result); // 21
```

这里在 `eval()` 中声明了变量 `x` 和 `y`，再返回它们相加后得到的结果。变量 `result` 会保存 `x` 和 `y` 相加的结果 21，虽然 `x` 和 `y` 在调用 `eval()` 结束后就已经不存在了，但结果已经被保存下来了。

需要注意的是，在 `eval()` 中对函数返回值执行后置自增减，会导致这个自增减发生在 `eval()` 执行结束之后，因此应尽量避免。

```js
let res1 = eval("let x = 10; x++;");
let res2 = eval("let x = 10; x++; x;");

console.log(res1); // 10
console.log(res2); // 11
```



#### `eval` 与 `arguments`

严格模式明确不允许使用 `eval` 和 `arguments` 作为标识符和操作它们的值。例如：

```js
// 将 eval 和 arguments 重新定义为变量
let eval = 10; 
let arguments = "Hello world!";
```

在非严格模式下，可以重写 `eval` 和 `arguments`。在严格模式下，这样会导致语法错误。

```js
"use strict";

let eval = 10; 					// Uncaught SyntaxError: Unexpected eval or arguments in strict mode
let arguments = "Hello world!"; // Uncaught SyntaxError: Unexpected eval or arguments in strict mode
```

不能用它们作为标识符，这意味着像下面这样使用它们都会导致抛出语法错误：

- 将他们当作变量来声明或重写；
- 被用作函数名或者函数参数名；
- 在 `try/catch` 语句中被用作异常名称。



### `this` 强制转型

`JavaScript` 中最大的一个安全问题，也是经常最令人困惑的一个问题，就是在某些情况下 `this` 的值是如何确定的。在使用函数的 `apply()` 或 `call()` 方法修改 `this` 的指向时，在非严格模式下传入 `null` 或 `undefined` 值会导致 `this` 被强制转型为全局对象。在严格模式下，则始终以指定值作为函数 `this` 的值，无论指定的是什么值（包括 `null` 和 `undefined`）。例如：

```js
// 非严格模式
function fn() { 
 	console.log(this); 
} 

fn.call(null); // Window {window: Window, self: Window, document: document, name: '', ...}
```

这里在调用 `fn.call()` 时传入 `null` 作为 `this` 的值，在非严格模式下该函数的 `this` 值是全局对象 `window`。在严格模式下，该函数的 `this` 则是传入的值 `null`（如果传入的是 `undefined`，那么就是 `undefined`；如果是 1，那么就是 1；……）。

```js
// 严格模式
function fn() { 
    "use strict";
 	console.log(this); 
} 

fn.call(null); // null
```

通常，函数会将其 `this` 的值转型为一种对象类型，这种行为经常被称为 “装箱”（`boxing`）。这意味着原始值会转型为它们的包装对象类型。

```js
function foo() { 
 	console.log(this); 
} 

foo.call(); 	// Window {window: Window, self: Window, document: document, name: '', ...}
foo.call(2); 	// Number {2}
```

在严格模式下执行以上代码时，`this` 的值不会再 “装箱”，而是 ”是什么就是什么“：

```js
function foo() { 
 	"use strict"; 
 	console.log(this);
} 

foo.call();		// undefined 
foo.call(2); 	// 2
```



### 类与模块

类和模块都是 `ECMAScript 6` 新增的代码容器特性。在之前的 `ECMAScript` 版本中没有类和模块这两个概念，因此不用考虑从语法上兼容之前的 `ECMAScript` 版本。为此，`TC39` 委员会决定在 `ES6` 的类和模块中默认开启严格模式。

对于类，这包括类声明和类表达式，其构造函数、实例方法、静态方法、获取方法和设置方法都在严格模式下。对于模块，所有在其内部定义的代码都处于严格模式。



### 其他变化

严格模式下还有其他一些需要注意的变化。



#### 禁用 `with`

首先是消除 `with` 语句。`with` 语句改变了标识符解析时的方式，严格模式下为简单起见已去掉了这个语法。因此，在严格模式下使用 `with` 会导致语法错误：

```js
"use strict"; 

with(location) { 
 	console.log(href); 
}
// Uncaught SyntaxError: Strict mode code may not include a with statement
```



#### 八进制字面量

严格模式也从 `JavaScript` 中去掉了八进制字面量。八进制字面量以前导 0 开始，一直以来是很多错误的源头。

```js
// 使用八进制字面量
console.log(010); // 8
```

严格模式下使用八进制字面量会导致报错（在预编译阶段就直接报错，整个脚本都不会被执行），应使用完整的 `0o` 前缀来代替：

```js
"use strict"; 

console.log(010); 	// Uncaught SyntaxError: Octal literals are not allowed in strict mode.
console.log(0o10); 	// 8
```

`ECMAScript 5` 还修改了非严格模式下的 `parseInt()`，将八进制字面量当作带前导 0 的十进制字面量来看待。例如：

```js
// 在 parseInt() 中使用八进制字面量（无论是在严格模式还是非严格模式中，结果都一样）
console.log(parseInt("010")); 	// 10

console.log(parseInt("0o10")); 	// 0
```

