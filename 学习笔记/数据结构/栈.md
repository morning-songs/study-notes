# 栈

栈：只提供了一个固定的端口来插入和删除数据，先放入的被沉入栈底，后放入的被置入栈顶。于是，呈现一个：先进后出，后进先出的规律。



### 实现

##### 简单实现

```js
class Stack {
    constructor() {
        this.stack = [];
    }
    // 添加单条数据
    push(item) {
        this.stack.push(item);
    }
    // 批量添加数据
    batch(...items) {
        this.stack.push(...items);
    }
    // 静态读取数据
    peek() {
        if(!this.size()) return console.warn("栈已空");
        return this.stack[this.size() - 1];
    }
    // 动态读取数据
    pop() {
        if(!this.size()) return console.warn("栈已空");
        return this.stack.pop();
    }
    // 清空栈
    clear() {
        this.stack = [];
    }
    // 栈长度
    size() {
        return this.stack.length;
    }
}
```

使用

```js
let stack = new Stack();

// 单条存储
stack.push(1);
stack.push(2);
stack.push(3);

// 批量存储
stack.batch(1, 2, 3);

// 静态读取
stack.peek(); // 3
stack.peek(); // 3

// 动态读取
stack.pop(); // 3
stack.pop(); // 2
stack.pop(); // 1
stack.pop(); // "栈已空", undefined

// 清空栈
stack.clear();

// 栈长度
stack.size(); // 0
```

##### 单例封装

为了保护栈的安全，通常应该将其封装起来，只对外暴露操作方法。

```js
const Stack = (function() {
    let stack = [];
    return class {
        constructor() {
            stack = []; // 这里，不能返回出去！！！
        }
        // 添加单条数据
        push(item) {
            stack.push(item);
        }
        // 批量添加数据
        batch(...items) {
            stack.push(...items);
        }
        // 静态读取数据
        peek() {
            if(!this.size()) return console.warn("栈已空");
            return stack[this.size() - 1];
        }
        // 动态读取数据
        pop() {
            if(!this.size()) return console.warn("栈已空");
            return stack.pop();
        }
        // 清空栈
        clear() {
            stack = [];
        }
        // 栈长度
        size() {
            return stack.length;
        }
    }
})();
```

上述将栈封装成单例之后，每次重新创建时，都会清空栈。注意，`new Stack()` 创建的是操作栈的实例，而不是栈实例。

```js
let stack1 = new Stack();
stack1.push(1);

let stack2 = new Stack();
stack2.push(2);
stack2.push(3);

// 二者维护同一个栈（自动重置）
console.log(stack1.size()); // 2
console.log(stack2.size()); // 2

console.log(stack1.peek()); // 3
console.log(stack2.peek()); // 3
```

如果不希望在创建操作栈实例时自动清空栈，而是通过 `clear()` 手动清空，则可以去掉构造器。

```js
const Stack = (function() {
    let stack = [];
    return class {
        // 添加单条数据
        push(item) {
            stack.push(item);
        }
        // 批量添加数据
        batch(...items) {
            stack.push(...items);
        }
        // 静态读取数据
        peek() {
            if(!this.size()) return console.warn("栈已空");
            return stack[this.size() - 1];
        }
        // 动态读取数据
        pop() {
            if(!this.size()) return console.warn("栈已空");
            return stack.pop();
        }
        // 清空栈
        clear() {
            stack = [];
        }
        // 栈长度
        size() {
            return stack.length;
        }
    }
})();
```

```js
let stack1 = new Stack();
stack1.push(1);

let stack2 = new Stack();
stack2.push(2);
stack2.push(3);

// 二者维护同一个栈（手动重置）
console.log(stack1.size()); // 3
console.log(stack2.size()); // 3

console.log(stack1.peek()); // 3
console.log(stack2.peek()); // 3
```

如果只需要有一个操作栈的对象的话，则可以再简化封装。

```js
const stack = (function () {
    let stack = [];
    return {
        // 添加单条数据
        push(item) {
            stack.push(item);
        },
        // 批量添加数据
        batch(...items) {
            stack.push(...items);
        },
        // 静态读取数据
        peek() {
            if (!this.size()) return console.warn("栈已空");
            return stack[this.size() - 1];
        },
        // 动态读取数据
        pop() {
            if (!this.size()) return console.warn("栈已空");
            return stack.pop();
        },
        // 清空栈
        clear() {
            stack = [];
        },
        // 栈长度
        size() {
            return stack.length;
        }
    }
})();

stack.push(1);
stack.clear();

stack.push(2);
stack.push(3);

console.log(stack.size()); // 2
console.log(stack.peek()); // 3
```

##### 隐藏封装

在单例封装中，始终只有一个栈。无论创建多少个操作栈的实例，它们都是在底层维护同一个栈，而不是各自的栈。

使用 `Symbol` 实例属性来存储栈，既可以将栈封装起来不被外部访问到，同时又可以每次都产生新的相互独立的栈。

```js
const Stack = (function () {
    let sym = Symbol();
    return class Stack {
        constructor() {
            this[sym] = []; // 这里，不能返回出去！！！
        }
        // 添加单条数据
        push(item) {
            this[sym].push(item);
        }
        // 批量添加数据
        batch(...items) {
            this[sym].push(...items);
        }
        // 静态读取数据
        peek() {
            if (!this.size()) return console.warn("栈已空");
            return this[sym][this.size() - 1];
        }
        // 动态读取数据
        pop() {
            if (!this.size()) return console.warn("栈已空");
            return this[sym].pop();
        }
        // 清空栈
        clear() {
            this[sym] = [];
        }
        // 栈长度
        size() {
            return this[sym].length;
        }
    }
})();

let stack1 = new Stack();
stack1.push(1);

let stack2 = new Stack();
stack2.push(2);
stack2.push(3);

// 二者维护各自的栈
console.log(stack1.size()); // 1
console.log(stack2.size()); // 2

console.log(stack1.peek()); // 1
console.log(stack2.peek()); // 3
```



### 应用

##### 转二进制

将某个进制的数转换为二进制数时，可使用栈来存储每一个二进制位上的数字。

```js
// 十进制转为二进制
function conversionDToB(num) {
    const stack = new Stack();
    let str = "";
    
    // 入栈
    while(num > 0) {
        stack.push(num % 2); // 存余数
        num = num / 2 | 0; 	 // 向下取得整数商，也可以 ==> num = Math.floor(num / 2);
    }
    
    // 出栈
    while(stack.size()) {
        str += stack.pop();
    }
    
    return str;
}

conversionDToB(10); // "1010"
conversionDToB(17); // "10001"
conversionDToB(23); // "10111"
```

##### 回文检测

判断一个字符串是否为回文（即顺读、倒读其效果都一样的修辞法）字符串，如：上海自来水来自海上。

```js
function isPalindrome(str) {
    const stack = new Stack();
    let res = "";
    // 入栈
    [...str].forEach(s => stack.push(s)); // 或者：stack.batch(...str);
    // 出栈
    while(stack.size()) {
        res += stack.pop();
    }
    return res === str;
}

isPalindrome("123456787654321"); // true
isPalindrome("上海自来水来自海上"); // true
isPalindrome("黄山落叶松叶落山黄"); // true
isPalindrome("出走少年归来亦少年"); // false
```

