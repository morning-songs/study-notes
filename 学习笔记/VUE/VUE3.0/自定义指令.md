# 自定义指令

##### 初识

`vue3`的自定义指令是以`v`开头的小驼峰式变量，其值为指令的配置对象，在对象中通过钩子函数来配置指令的行为。

```html
<div v-loading="999">被v-loading自定义指令绑定的元素</div>
<script>
// 当该变量被当作属性绑定到DOM上时，当作自定义指令使用。其他情况下，只是一个普通对象。
let vLoading = {
    mounted(el, binding) {
        console.log(el, binding); // el：绑定的DOM元素；binding：指令绑定的信息对象
    }
}
</script>
```

<hr>

### 全局指令

##### 文件管理

在`src`下新建`directives`目录，用来存放全局的自定义指令。将其入口`index.js`文件导入到`main.js`中执行。

注释：当使用`use`方法将插件挂载到全局时，该插件必须导出一个方法或者一个带有`install`方法的方法集对象。

```js
// 在main文件中
// 导入文件
import directives from "./directives/index"
// 当作插件，挂载到全局使用
app.use(directives);

// 在index文件中
// 导出一个对象方法集或方法
export default {
    // install方法：当该文件被use当作插件使用时，会先调用install方法。【没有install方法的文件是不能作为插件来使用的】
    install(app) {
        console.log(app); // app就是调用该插件的应用实例对象。如：app.use(directives);
    }
}
```



##### 注册全局指令

在`install`钩子函数中，应用实例通过调用`directive`方法注册全局指令。

参数：`directive(指令名称，配置对象) // 使用时以v-开头即可`

建议：当全局指令较多时，一般将指令的配置对象单独在一个文件中定义，文件与`index`文件同级即可。

```js
// 在index文件中
// 导入各指令的配置对象
import loading from "./loading"

export default {
    install(app) {
        // 注册一个全局的自定义指令：loading
        app.directive("loading", loading); // 使用时：以v-loading作为属性
    }
}

// 在loading文件中
export default {
    /*	参数：
		el：指令绑定的DOM虚拟元素
		binding：指令绑定的信息对象，包括绑定的值以及配置项信息
    */
    
    // 当指令绑定的DOM元素被挂载到页面上时，触发mounted方法
    mounted(el, binding) {},
    
    // 当指令绑定的值变化时，触发updated方法（初始时触发一次）
    updated(el, binding) {
        // 指令绑定的值，在binding对象的value属性中。
    }
}
```



##### 设计加载框

使用全局自定义指令设计一个全局可使用的`loading`加载框。

提示：根据一个布尔值，决定是否加载该`loading`框，该布尔值最好是使用计算属性监听。

注释：加载`loading`框通常用于要加载的数据量较大，且未加载完成时提示正在加载。【一般用到列表加载中】

```html
<ul v-loading="loading">
    <li></li>
</ul>

<script setup>
	let loading = computed(() => {
        return songsData.length <= 0; // 无元素时加载loading框，有元素时取消loading框。
    })
</script>
```



##### 封装组件

以封装`loading`框为例

注释：

- `vue3`移除了`extend`方法，统一使用`createApp`方法来创建`vue`应用实例，而`vue`的应用实例必须挂载到真实的`DOM`元素上。
- 将`vue`应用实例挂载到真实的`DOM`元素上之后，该`DOM`元素的引用在其组件实例的`$el`属性上。
- 若该`DOM`元素并未存在页面的结构中，还需要将其通过`appendChild`方法插入到页面的`DOM`中。

```html
<!-- 封装全局的loading组件 -->
<template>
	<div class="loading-wrap">
        <div class="loading-content">
            <img width="24" height="24" src="../assets/loading.gif" alt="加载" />
            <p class="desc">正在载入...</p>
        </div>
    </div>
</template>
<style lang="less" scoped>
    .loading-wrap {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        .loading-content {
            text-align: center;
            .desc {
                line-height: 20px;
                font-size: @font-size-small;
                color: @light-color-m;
            }
        }
    }
</style>
```

```js
// 在directives目录下的loading.js中
import { createApp } from "vue"; // 导入createApp方法
import Loading from "@/components/Loading" // 导入Loading组件

// 导出指令的配置对象
export default {
    mounted(el, binding) {
        // 传入一个组件，得到一个vue应用实例
        let loadApp = createApp(Loading); 
        // 挂载到真实DOM上之后，得到该组件的实例对象。
        let instance = loadApp.mount(document.createElement("div")); // 给组件创建一个真实的父容器
        // 将该DOM元素（父容器）插入到页面上指定的DOM结构（指令绑定的元素）中
        if(binding.value) {
            // 当指令绑定的值为true时，将加载框DOM元素作为子元素插入到指令绑定的元素中。
            el.appendChild(instance.$el);
            
            // 为指令绑定的元素添加定位属性，以方便其子元素精准定位。
            let allStyle = getComputedStyle(el), // 获取指令绑定元素的所有样式
                arr = ["relative", "absolute", "fixed"];
            // 判断该元素是否具有定位属性
            if(arr.indexOf(allStyle.position) === -1) {
                el.style.position = "relative"; // 不具有时，添加relative定位。
            }
        }
    }
}
```



##### 优化弹框

加载弹框后，需要在合适的时候关闭它。此时，可以将弹框的`DOM`引用作为属性添加到父元素节点上。

```js
// 在directives目录下的loading.js中
import { createApp } from "vue"; // 导入createApp方法
import Loading from "@/components/Loading" // 导入Loading组件

// 导出指令的配置对象
export default {
    mounted(el, binding) {
        // 传入一个组件，得到一个vue应用实例
        let loadApp = createApp(Loading); 
        // 挂载到真实DOM上之后，得到该组件的实例对象。
        let instance = loadApp.mount(document.createElement("div")); // 给组件创建一个真实的父容器
        // 将instance的入口元素绑定到el节点上。
        el.instance = instance.$el;
        // 将该DOM元素（父容器）插入到页面上指定的DOM结构（指令绑定的元素）中
        if(binding.value) {
            // 当指令绑定的值为true时，将加载框DOM元素作为子元素插入到指令绑定的元素中。
            append(el);
        }
    },
    updated(el, binding) {
        if(binding.value) {
            // 当指令绑定的值为true时，将加载框DOM元素作为子元素插入到指令绑定的元素中。
            append(el);
        } else {
            // 当指令绑定的值为false时，将加载框DOM元素从指令绑定的元素中移除。
            remove(el);
        }
    }
}

// 定义添加节点的方法
function append(el) {
    // 将el.instance元素作为子元素插入到el中
    el.appendChild(el.instance);
    
    // 为指令绑定的元素添加定位属性，以方便其子元素精准定位。
	let allStyle = getComputedStyle(el), // 获取指令绑定元素的所有样式
		arr = ["relative", "absolute", "fixed"];
    
	// 判断该元素是否具有定位属性
	if(arr.indexOf(allStyle.position) === -1) {
		el.style.position = "relative"; // 不具有时，添加relative定位。
	}
}

// 定义移除节点的方法
function remove(el) {
    // 移除子节点
    el.removeChild(el.instance);
    
    // 清除定位属性
    el.style.position = "static";
}
```

**注释**：当需要修改弹框的定位位置时，需要先加穿透。

```css
/deep/ .loading-wrap {
	top: 150px !important;
}
```

