# 框架

### 介绍

小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 `APP` 体验的服务。

整个小程序框架系统分为两部分：**[逻辑层](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/)**（`App Service`）和 **[视图层](https://developers.weixin.qq.com/miniprogram/dev/framework/view/)**（`View`）。小程序提供了自己的视图层描述语言 `WXML` 和 `WXSS`，以及基于 `JavaScript` 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

##### 响应的数据绑定

框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。

```html
<!-- 视图层 -->
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
```

```js
// 逻辑层
// 定义数据
var helloData = {
  	name: 'Weixin'
}

// 注册页面
Page({
  	data: helloData,
  	changeName: function(e) {
    	// 修改数据以更新视图
    	this.setData({
      		name: 'MINA'
    	})
  	}
})
```

- 开发者通过框架将逻辑层数据中的 `name` 与视图层的 `name` 进行了绑定，所以在页面一打开的时候会显示 `Hello Weixin!`；
- 当点击按钮的时候，视图层会发送 `changeName` 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
- 回调函数触发后，逻辑层执行 `setData` 的操作，随即将 `data` 中的 `name` 从 `Weixin` 变为 `MINA`。因为该数据和视图层已经绑定了，所以视图层会自动改变为 `Hello MINA!`。

##### 页面管理

框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。

##### 基础组件

框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑。开发者可以通过自由地组合这些基础组件，创建出强大的微信小程序。

##### 丰富的 `API`

框架提供了丰富的微信原生 `API`，开发者可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。



### 视图层

框架的视图层由 `WXML` 与 `WXSS` 编写，由组件来进行展示。它将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

- `WXML`（`WeiXin Markup language`）用于描述页面的结构。
- `WXS`（`WeiXin Script`）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。
- `WXSS`（`WeiXin Style Sheet`）用于描述页面的样式。
- 组件（`Component`）是视图的基本组成单元。



#### `WXML`

`WXML`（`WeiXin Markup Language`）是框架设计的一套标签语言，结合 [基础组件](https://developers.weixin.qq.com/miniprogram/dev/component/)、[事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，可以构建出页面的结构。

##### 数据绑定

`WXML` 中的动态数据均来自对应 `Page` 的 `data`。

###### 简单绑定

数据绑定使用 `Mustache` 语法（即双大括号 `{{}}`）将变量包裹起来，可作用于组件内容、组件属性和组件指令。如下所示：

（1）组件内容：将组件的内容绑定为 `data`。

```html
<view> {{ message }} </view>
```

```js
Page({
  	data: {
    	message: 'Hello MINA!'
  	}
})
```

（2）组件属性（需要在双引号之内）：将组件的属性值绑定为 `data`。

```html
<view id="item-{{id}}"> </view>
```

```js
Page({
  	data: {
    	id: 0
  	}
})
```

（3）组件指令（需要在双引号之内）：将组件的指令（亦称控制属性）值绑定为 `data`。

```html
<view wx:if="{{condition}}"> </view>
```

```js
Page({
  	data: {
    	condition: true
  	}
})
```

###### 表达式

可以在 `{{}}` 内插入任何 `js` 表达式来进行简单的运算，然后将其结果作为绑定值。由于小程序仅支持通过事件来调用函数，因此不支持在 `{{}}` 插入任何的函数或 `API` 调用（`WXS` 脚本导出的函数除外）。但它支持如下几种方式：

（1）字面量：支持直接使用字面量作为绑定值。

- 原始值：仅支持数字、字符串和布尔值。
- 数组：支持数组，且会自动展开它。
- 对象：支持对象，但不能单独使用。`Mustache` 语法只允许两个 `{{}}`，因此对象直接插入属性即可，如 `{{foo: 'foo'}}`。

```html
<checkbox checked="{{false}}"></checkbox>
```

***特别注意：这里不要直接写 `checked="false"`（尽管没有 `{{}}`），其计算结果是一个字符串，转成 `boolean` 类型后是真值。***

（1）三元运算

```html
<view hidden="{{flag ? true : false}}"> Hidden </view>
```

```js
Page({
 	data: {
		flag: true
  	}
})
```

（2）基本运算

```html
<view> {{a + b}} + {{c}} + d </view>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2,
    	c: 3
  	}
})
```

（3）逻辑判断

```html
<view wx:if="{{length > 5}}"> </view>
```

```js
Page({
  	data: {
    	length: 1
  	}
})
```

（5）路径运算

```html
<view>{{object.key}} {{array[0]}}</view>
```

```js
Page({
  	data: {
    	object: {
      		key: 'Hello '
    	},
    	array: ['MINA']
  	}
})
```

###### 组合

也可以在 `Mustache` 内直接进行组合，构成新的对象或者数组。

（1）数组：不支持调用任何数组 `API`。

```html
<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
```

```js
Page({
  	data: {
    	zero: 0
  	}
})
```

最终组合成的数组是 `[0, 1, 2, 3, 4]`。

（2）对象：不支持调用任何对象 `API`，且直接书写属性即可。对象通常用来传递数据，单独定义成其他属性的值是没有意义的。

```html
<!-- 关于此元素的用法，详见本节-模板 -->
<template is="objectCombine" data="{{foo: a, bar: b}}"></template>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2
  	}
})
```

最终组合成的对象是 `{foo: 1, bar: 2}`。

（3）扩展运算符：可以用扩展运算符 `...` 来将一个对象展开：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
      		b: 2
    	},
    	obj2: {
      		c: 3,
      		d: 4
    	}
  	}
})
```

最终组合成的对象是 `{a: 1, b: 2, c: 3, d: 4, e: 5}`。

（4）同名简写：如果对象的 `key` 和 `value` 相同，也可以间接地表达。

```html
<template is="objectCombine" data="{{foo, bar}}"></template>
```

```js
Page({
  	data: {
    	foo: 'my-foo',
    	bar: 'my-bar'
  	}
})
```

最终组合成的对象是 `{foo: 'my-foo', bar:'my-bar'}`。

（5）随意组合：上述方式可以随意组合，但是如果有存在变量名相同的情况，则后边的会覆盖前面的，如：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
     		b: 2
    	},
    	obj2: {
      		b: 3,
      		c: 4
    	},
    	a: 5
  	}
})
```

最终组合成的对象是 `{a: 5, b: 3, c: 6}`。

**注意：** 花括号和引号之间如果有空格，将最终被解析成为字符串，如下所示。

```html
<view wx:for="{{[1,2,3]}} ">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{[1,2,3] + ' '}}">{{item}}</view>
```

这样做会带来一些渲染意外，即：将数组的元素分隔符（`,`）也视作元素，而空格（也可换做其他字符）则被视作最后一个元素。

```html
<view>1</view>
<view>,</view>
<view>2</view>
<view>,</view>
<view>3</view>
<view> </view>
```

##### 条件渲染

###### `wx:if`

在框架中，可在某元素上使用 `wx:if` 指令，然后根据其值的布尔性来决定是否渲染该元素：

```html
<view wx:if="{{true}}"> True —— 被渲染的元素 </view>
<view wx:if="{{false}}"> false —— 不被渲染的元素 </view>
```

当然，也可以用 `wx:elif` 和 `wx:else` 来添加其他条件块。同样的，`elif` 块可以有多个，而 `else` 块只能有一个。

```html
<view wx:if="{{1 > 3}}"> 1 </view>
<view wx:elif="{{2 > 3}}"> 2 </view>
<view wx:elif="{{3 > 3}}"> 3 </view>
<view wx:else> 4 </view>
```

###### `block wx:if`

因为 `wx:if` 是一个控制属性，所以需要将它添加到一个标签上。如果要一次性判断多个组件标签，则可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```html
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

**注意：** `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，且只接受控制属性（即：组件指令）。

###### `wx:if` 与 `hidden`

因为 `wx:if` 中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架会有一个局部渲染的过程，以此来确保条件块在切换时被销毁或重新渲染。

同时 `wx:if` 也是 **惰性的**，如果在初始渲染条件为 `false`，则框架什么也不会做，只在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 属性就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏而已。

```html
<view hidden> 被隐藏的组件 </view> 
<view hidden="{{false}}"> 被显示的组件 </view> <!-- 注意：与hidden="false"的区别 -->
```

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁的切换，用 `hidden` 会更好；如果在运行时条件不大可能会改变（即切换不频繁），则用 `wx:if` 比较好。

##### 列表渲染

###### `wx:for`

在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中的每个元素来重复渲染该组件。

通常，数组当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`。因此，不需要额外定义，直接使用它们即可。

```html
<view wx:for="{{array}}">
  	{{index}}: {{item.message}}
</view>
```

```js
Page({
 	data: {
    	array: [
            {
      			message: 'foo',
    		}, {
      			message: 'bar'
    		}
        ]
  	}
})
```

不过，使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  	{{idx}}: {{itemName.message}}
</view>
```

`wx:for` 也可以嵌套，例如下边是一个九九乘法表：

```html
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  	<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    	<view wx:if="{{j <= i}}">
      		{{j}} * {{i}} = {{i * j}}
    	</view>
  	</view>
</view>
```

###### `block wx:for`

类似 `block wx:if`，也可以将 `wx:for` 用在 `<block/>` 标签上，以渲染一个包含多节点的结构块。例如：

```html
<block wx:for="{{[1, 2, 3]}}">
  	<view> {{index}}: {{item}}</view>
</block>
```

###### `wx:key`

如果列表中项目的位置会动态改变或者会有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [`input`](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[`switch`](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），则需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供：

1. 字符串：代表 `item` 的某个属性。该属性的值必须是在此列表中唯一的字符串或数字值，且不能动态改变。
2. 保留关键字 `*this`（带星号）：代表 `item` 本身。这种表示须要 `item` 本身是一个唯一的字符串或者数字。

```html
<view wx:for="{{arr1}}" wx:key="id">{{item.id}}</view> <!-- 绑定：item.id -->

<view wx:for="{{arr2}}" wx:key="*this">{{item}}</view> <!-- 绑定：item自身 -->
```

```js
Page({
    data: {
        arr1: [
            {id: 0},
            {id: 1},
            {id: 2}
        ],
        arr2: [0, 1, 2]
    }
})
```

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，从而确保使组件保持自身的状态，并且提高列表渲染时的效率。

**注意：如果不提供 `wx:key`，会报一个 `warning`。 但如果明确知道该列表是静态的，或者不必关注其顺序，则可以选择忽略它。**

###### 示例代码

```html
<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>

<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
<button bindtap="addNumberToFront"> Add to the front </button>
```

```js
Page({
  	data: {
    	objectArray: [
      		{id: 5, unique: 'unique_5'},
      		{id: 4, unique: 'unique_4'},
      		{id: 3, unique: 'unique_3'},
      		{id: 2, unique: 'unique_2'},
      		{id: 1, unique: 'unique_1'},
      		{id: 0, unique: 'unique_0'},
    	],
    	numberArray: [1, 2, 3, 4]
  	},
  	switch: function(e) {
    	const length = this.data.objectArray.length
    	for (let i = 0; i < length; ++i) {
      		const x = Math.floor(Math.random() * length)
      		const y = Math.floor(Math.random() * length)
      		const temp = this.data.objectArray[x]
      		this.data.objectArray[x] = this.data.objectArray[y]
      		this.data.objectArray[y] = temp
    	}
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addToFront: function(e) {
    	const length = this.data.objectArray.length
    	this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addNumberToFront: function(e){
    	this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    	this.setData({
      		numberArray: this.data.numberArray
    	})
  	}
})
```

###### 注意事项

当 `wx:for` 的值为字符串时，会将这个字符串拆分解析成字符串数组。

```html
<view wx:for="array">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{['a', 'r', 'r', 'a', 'y']}}">{{item}}</view>
```

##### 模板

`WXML` 提供了模板（`<template>`），可以在模板中定义代码片段，然后在不同的地方调用。

###### 定义模板

使用 `name` 属性，作为模板的名字（其他模板可通过该名字来调用此模板）。然后在 `<template/>` 内定义代码片段，如：

```html
<!--
  	index: int
  	msg: string
  	time: string
-->
<template name="msgItem">
  	<view>
    	<text> {{index}}: {{msg}} </text>
    	<text> Time: {{time}} </text>
  	</view>
</template>
```

此模板（无 `is` 属性）代码不会被显示，其中的数据（如这里的 `index`、`msg`、`time`）均由使用者模板通过其 `data` 属性来传入。

###### 使用模板

使用 `is` 属性（值为模板名）来表示当前模板使用指定模板中的代码。然后，将模板所需要的数据通过 `data` 属性传入，如：

```html
<template is="msgItem" data="{{...item}}"/> <!-- 模板中的代码会被显示，模板本身不显示 -->
```

```js
Page({
  	data: {
    	item: {
            index: 0,
            msg: 'this is a template',
            time: '2023-05-02'
    	}
  	}
})
```

`is` 属性也可以使用 `Mustache` 语法，来动态决定具体渲染哪个模板：

```html
<template name="odd">
  	<view> odd </view>
</template>
<template name="even">
  	<view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
  	<template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
</block>
```

###### 模板的作用域

模板拥有自己的作用域，只能访问使用者模板通过 `data` 属性传入的数据以及模板定义文件 `WXML` 中定义的 `<wxs>` 模块数据。

```html
<wxs module="log">
    var foo = 'foo';

    module.exports = {
    	foo: foo
    }
</wxs>

<template name="Log">
  	<view>{{log.foo}} -- log</view>
</template>

<template is="Log"></template>
```

关于 `<wxs>` 的用法，参见下节 `WXS`。

##### 引用

`WXML` 提供了两种文件引用的方式：`import` 和 `include`。

###### `import`

`import` 可以在该文件中使用目标文件定义的 `template`，如：

在 `item.wxml` 中定义一个叫 `item` 的 `template`：

```html
<!-- item.wxml -->
<template name="item">
  	<text>{{text}}</text>
</template>
```

在 `index.wxml` 中引用 `item.wxml`，就可以使用此文件定义的 `item` 模板：

```html
<!-- index.wxml -->
<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>
```

###### `import` 的作用域

`import` 有作用域的概念，即只会 `import` 目标文件中定义的 `template`，而不会 `import` 目标文件 `import` 的 `template`。

**如：`C import B`，`B import A`，则在 `C` 中可以使用 `B` 定义的`template`，在 `B` 中可以使用 `A` 定义的`template`，但是 `C` 不能使用 `A` 定义的`template`。因为这种 `import` 对 `template` 只有使用权，而没有所有权**。

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<import src="b.wxml"/>
<template is="B"/>
<template is="A"/>  <!-- Error! Can not use tempalte when not import A. -->
```

###### `include`

而 `include` 可以将目标文件的整个代码（除了 `<template/>` 和 `<wxs/>` 之外）引入，相当于是拷贝到 `include` 的位置，如：

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 却没有了！ -->
```

上述引用关系为：`C include B`，`B import A`。这样一来，`B` 就将自身对 `A` 的使用权分享给了 `C`，但由于 `<template/>` 不被包含，因此 `C` 对 `B` 没有使用权（除非又 `import` 它）。

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<import src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 也能被正常使用了！ -->
```



#### `WXSS`

`WXSS`（`WeiXin Style Sheets`）是一套样式语言，用于描述 `WXML` 的组件样式。也就是，用来决定 `WXML` 的组件应该怎么显示。

为了适应广大的前端开发者，`WXSS` 具有 `CSS` 大部分特性。同时为了更适合开发微信小程序，`WXSS` 对 `CSS` 进行了扩充以及修改。

与 `CSS` 相比，`WXSS` 扩展的特性有：

- 尺寸单位
- 样式导入

##### 尺寸单位

`rpx`（`responsive pixel`，响应式像素）可以根据屏幕宽度进行自适应，官方规定屏幕宽为 `750rpx`。如在 `iPhone6` 上，屏幕宽度为 `375px` 且共有 750 个物理像素，则 `750rpx` = `375px` = 750 物理像素，即 `1rpx` = `0.5px` = 1 物理像素。

|      设备      | `rpx` 换算 `px`（屏幕宽度/750） | `px` 换算 `rpx`（750/屏幕宽度） |
| :------------: | :-----------------------------: | :-----------------------------: |
|   `iPhone5`    |         `1rpx = 0.42px`         |         `1px = 2.34rpx`         |
|   `iPhone6`    |         `1rpx = 0.5px`          |          `1px = 2rpx`           |
| `iPhone6 Plus` |        `1rpx = 0.552px`         |         `1px = 1.81rpx`         |

**建议：** 开发微信小程序时设计师可以用 `iPhone6` 作为视觉稿的标准。

```css
/* 以 iPhone6 为标准开发(1px = 2rpx): 原先写 100px，现在可写成 200rpx */
view {
    width: 200rpx; /* => 100px */
}
```

**注意：** 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

此外，还有三个跟像素相关的专业术语，`DPR`、`DPI` 和 `PPI`。分别是指：

- `DPR`：设备像素比（`Device Pixel Ratio`），是物理像素和 `CSS` 像素的比例。
- `DPI`：设备独立像素（`Device Independent Pixel`），也称逻辑像素（每英寸像素点，跟 `CSS` 像素很像），与设备无关。
- `PPI`：每英寸像素（`Pixels Per Inch`），亦称像素密度（即屏幕一英寸有多少个物理像素点）。

|    机型    | 物理像素分辨率（设备） | 逻辑像素分辨率（`CSS`） | `PPI` | `DPR` |
| :--------: | :--------------------: | :---------------------: | :---: | :---: |
| `iPhone4`  |       640 × 960        |        320 × 480        |  326  |   2   |
| `iPhone5`  |       640 × 1136       |        320 × 568        |  326  |   2   |
| `iPhone6`  |       750 × 1334       |        375 × 667        |  326  |   2   |
| `iPhone6p` |      1242 × 2208       |        414 × 736        |  401  |   3   |

##### 样式导入

使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，且必须用 `;` 表示语句结束。

```less
/** common.wxss **/
.small-p {
  	padding: 5px;
}
```

```less
/** app.wxss **/
@import "common.wxss";
.middle-p {
  	padding: 15px;
}
```

注意：在不加重 `CSS` 权重的情况下，导入的样式优先级低于本文件中的样式，但高于全局样式。

##### 内联样式

框架组件上支持使用 `style` 属性来直接定义组件的样式，被称为内联样式，优先级很高。

注意：静态的样式应统一写到 `class` 中，`style` 通常接收动态的样式（通过使用 `{{}}`）。在运行时会对其进行解析，因此要尽量避免将静态的样式写进 `style` 中，以免影响渲染速度。

```html
<view style="color:{{color}};" />
```

##### 选择器

`WXSS` 并未支持全部 `CSS` 选择器，目前支持的选择器有：

| 选择器                           | 样例             | 样例描述                                   |
| :------------------------------- | :--------------- | :----------------------------------------- |
| `.class`（类选择器）             | `.intro`         | 选择所有拥有 `class="intro"` 的组件        |
| `#id`（`ID` 选择器）             | `#firstname`     | 选择拥有 `id="firstname"` 的组件           |
| `element`（元素选择器）          | `view`           | 选择所有 `view` 组件                       |
| `element, element`（并集选择器） | `view, checkbox` | 选择所有 `view` 组件和所有 `checkbox` 组件 |
| `::after`（伪对象选择器）        | `view::after`    | 在 `view` 组件后边插入内容                 |
| `::before`（伪对象选择器）       | `view::before`   | 在 `view` 组件前边插入内容                 |

##### 样式覆盖

定义在 `app.wxss` 中的样式为全局样式，作用于每一个页面。在 `page` 的 `wxss` 文件中定义的样式为页面样式，只作用在对应的页面，并会覆盖 `app.wxss` 中相同的选择器。另外，组件样式会覆盖页面样式。于是，组件样式 > 页面样式 > 导入样式 > 全局样式。



#### `WXS`

`WXS`（`WeiXin Script`）是小程序独有的一套脚本语言，结合 `WXML`，可以构建出页面的结构。

`WXS` 之于 `WXML` 的作用如同 `JavaScript` 之于 `HTML`，同样拥有 `.wxs` 文件和 `<wxs>` 标签。其中，`.wxs` 文件相当于 `.js` 文件，而 `<wxs>` 标签则相当于 `<script type="module">` 标签。尽管如此，`WXS` 与 `JavaScript` 也是两种不同的语言，它有自己的语法。虽然借鉴了 `JavaScript`，但并不总和 `JavaScript` 一致。

##### 简介

首先，`WXS` 有以下几个特点：

1. `WXS` 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
2. `WXS` 与 `JavaScript` 是不同的语言，有自己的语法，并不和 `JavaScript` 一致。`WXS` 中没有全局对象，虽然其 `this` 也默认指向 `Window`，但 `Window` 并未被定义，因此在全局或局部作用域中使用 `this` 会报 `ReferenceError`（对象内方法除外）。
3. `WXS` 的运行环境和其他 `JavaScript` 代码是隔离的，`WXS` 中不能调用其他 `JavaScript` 文件中定义的函数，也不能调用小程序提供的 `API`。
4. 由于运行环境的差异，在 `iOS` 设备上小程序内的 `WXS` 会比 `JavaScript` 代码快 2 ~ 20 倍。在 `android` 设备上二者的运行效率无差异。

其次，它并不会显示在页面上，主要用来做页面渲染和简单的页面数据处理。

###### 页面渲染

```html
<!--wxml-->
<wxs module="m1">
	var msg = "hello world";

	module.exports.message = msg;
</wxs>

<view> {{m1.message}} </view>
```

最终渲染：

```html
<view> hello world </view>
```

###### 数据处理

```js
// page.js
Page({
  	data: {
    	array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  	}
})
```

```html
<!--wxml-->
<!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
<wxs module="m1">
	var getMax = function(array) {
  		var max = undefined;
  		for (var i = 0; i < array.length; ++i) {
    		max = max === undefined ? array[i] : (max >= array[i] ? max : array[i]);
  		}
  		return max;
	}

	module.exports.getMax = getMax;
</wxs>
    
<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
<view> {{m1.getMax(array)}} </view> <!-- {{}}支持调用WXS脚本导出的函数 -->
```

最终输出：

```html
<view> 5 </view>
```

##### 模块

每一个 `.wxs` 文件和 `<wxs>` 标签都是一个单独的模块。每个模块都有自己独立的作用域，即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。如前所述， `<wxs>` 模块全局和局部作用域中的 `this` 默认指向 `Window`，但 `Window` 并未被定义。

```html
<wxs module="m1">
	console.log(this); // ReferenceError: Window is not defined
</wxs>
```

一个模块要想对外暴露其内部的私有变量与函数，就只能通过 `module.exports` 来实现（这是类似 `Node` 的风格）。

###### `.wxs` 文件

在微信开发者工具里面，右键可以直接创建 `.wxs` 文件，然后在其中直接编写 `WXS` 脚本代码（具体语法参见下文）即可。

```js
// /pages/comm.wxs

// 仅支持var关键字
var foo = "'hello world' from comm.wxs";

// 未支持箭头函数
var bar = function(d) {
  	return d;
}

// 未支持ES6同名简写
module.exports = {
  	foo: foo,
  	bar: bar
};
```

上例在 `/pages/comm.wxs` 的文件中编写了 `WXS` 代码。该 `.wxs` 文件可以被其他的 `.wxs` 文件或 `WXML` 中的 `<wxs>` 标签引用。

###### `<wxs>` 标签

在 `WXML` 文件中嵌入 `<wxs>` 标签，就如同在 `HTML` 文件中嵌入 `<script type="module">` 标签一样。这虽是一个不太恰当的比喻（因为框架的帮助，`WXML` 可以通过模块名和 `{{}}` 来使用 `<wxs>` 导出的数据和方法，而 `HTML` 不可以），但有助于理解 `<wxs>` 标签。

|  属性名  |   类型   | 默认值 | 说明                                                         |
| :------: | :------: | :----: | :----------------------------------------------------------- |
| `module` | `String` |        | 当前 `<wxs>` 标签的模块名。必填字段。                        |
|  `src`   | `String` |        | 引用 `.wxs` 文件的相对路径。仅当本标签为 **单闭合标签** 或 **标签的内容为空** 时有效。 |

（1）**`module` 属性**

`module` 属性是当前 `<wxs>` 标签的模块名。在同一 `WXML` 文件内，建议其值唯一，如有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同 `WXML` 文件之间的 `wxs` 模块名不会相互覆盖。

`module` 属性值的命名必须符合下面两个规则：

- 首字符必须是：字母（`a-z, A-Z`）、下划线（`_`），二者之一。
- 剩余字符可是：字母（`a-z, A-Z`）、下划线（`_`）、数字（0 - 9），三者之一。

```html
<wxs module="foo">
    // 与在.wxs文件中书写是一样的。
	var some_msg = "hello world";
    var fn = function() {
    	return 'fn';
    };
	module.exports = {
  		msg : some_msg,
    	fn: fn
	}
</wxs>
<view> {{foo.msg}} -- {{foo.fn()}}</view> <!-- {{}}支持调用WXS脚本导出的函数 -->
```

最终输出：

```html
<view> hello world -- fn </view>
```

上面例子声明了一个名为 `foo` 的模块，它将 `some_msg` 变量暴露出来，供当前页面使用，而未导出的内容对外部是不可见的。

（2）**`src` 属性**

`src` 属性可以用来引用其他的 `wxs` 模块文件。

引用的时候，要注意如下几点：

- 相对路径：只能引用 `.wxs` 模块文件，且必须使用相对路径和后缀名。
- 单例对象：`wxs` 模块均为单例，`wxs` 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 `wxs` 模块对象。
- 惰性计算：如果一个 `wxs` 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

```js
// /pages/index/index.js

Page({
  	data: {
    	msg: "'hello wrold' from js",
  	}
})
```

```html
<!-- /pages/index/index.wxml -->

<wxs src="./../comm.wxs" module="some_comms"></wxs>

<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo -->
<view> {{some_comms.bar(some_comms.foo)}} </view>

<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg -->
<view> {{some_comms.bar(msg)}} </view>
```

页面输出：

```html
<view> 'hello world' from comm.wxs </view>
<view> 'hello wrold' from js </view>
```

上述例子在文件 `/pages/index/index.wxml` 中通过 `<wxs>` 标签引用了 `/pages/comm.wxs` 模块。

（3）**作用域**

`<wxs>` 模块是只属于且直接属于定义它的 `WXML` 文件的，只能在定义此模块的 `WXML` 文件中被访问到。

```html
<template name="Log">
  	<wxs module="log">
      	var foo = 'foo';

      	module.exports = {
        	foo: foo
      	}
  	</wxs>
  	<view>{{log.foo}} -- log</view>
</template>

<view>{{log.foo}} -- log</view>
<template is="Log"></template>
```

最终渲染：

```html
<view>foo -- log</view>
<view>foo -- log</view>
```

因此，当其他 `WXML` 文件使用 `<include>` 或 `<import>` 引用本 `WXML` 中的代码时，`<wxs>` 模块不会被引入到目标 `WXML` 文件中。

```html
<!-- pages/log/index.wxml -->

<wxs module="log">
  	var foo = 'foo';
  	module.exports = {
    	foo: foo
  	}
</wxs>

<view>{{log.foo}} -- log</view>
```

```html
<!-- pages/index/index.wxml -->

<include src="../log/index" />
```

最终渲染：

```html
<view> -- log</view>
```

即使定义在 `<template>` 标签中，也是带不走的，虽然它依然可以访问此模块导出的数据。

```html
<!-- pages/log/index.wxml -->

<template name="Log">
    <!-- <wxs>是只属于定义它的WXML文件的，因此，定义在<template>内或外都是一样带不走的 -->
    <wxs module="log">
        var foo = 'foo';

        module.exports = {
            foo: foo
        }
	</wxs>
    
  	<view>{{log.foo}} -- log</view>
</template>

<view>{{log.foo}} -- log</view>
```

```html
<!-- pages/index/index.wxml -->

<import src="../log/index" />
<template is="Log"></template>
<include src="../log/index" />
```

最终渲染：

```html
<view>foo -- log</view>
<view> -- log</view>
```

###### `module` 对象

每个 `wxs` 模块均有一个内置的 `module` 对象，它拥有一个 `exports` 属性，通过该属性，可以对外共享本模块的私有变量与函数。

```js
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}

// module对象跟Node中的用法相似。
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```html
<!-- page/index/index.wxml -->

<wxs src="./../tools.wxs" module="tools" />
<view> {{tools.msg}} </view>
<view> {{tools.bar(tools.FOO)}} </view> 
```

最终输出：

```html
<view> some msg </view>
<view> 'hello world' from tools.wxs </view>
```

###### `require` 函数

要在 `.wxs` 模块中引用其他 `wxs` 模块文件，可以使用 `require` 函数。引用规则和注意事项与 `<wxs>` 的 `src` 引用一样。

```js
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```js
// /pages/logic.wxs

var tools = require("./tools.wxs");

console.log(tools.FOO); 				// "'hello world' from tools.wxs"
console.log(tools.bar("logic.wxs")); 	// "logic.wxs"
console.log(tools.msg); 				// "some msg"
```

```html
<!-- /page/index/index.wxml -->

<wxs src="./../logic.wxs" module="logic" />
```

当然，不使用 `src`，直接在 `<wxs>` 中使用 `require()` 导入也是可以的。

```html
<!-- /page/index/index.wxml -->

<wxs module="logic">
    var tools = require("./tools.wxs");

    console.log(tools.FOO); 				// "'hello world' from tools.wxs"
    console.log(tools.bar("logic.wxs")); 	// "logic.wxs"
    console.log(tools.msg); 				// "some msg"
</wxs>
```

##### 变量

###### 声明

`WXS` 仅支持了使用 `var` 关键字来声明变量（与 `javascript` 一样，会有变量提升）。没有声明的变量直接赋值使用，会被定义为全局变量（虽然没有全局对象）。如果只声明变量而不赋值，则默认值为 `undefined`。

```html
<wxs module="m1">
	var a = b = 1, c;
    
    console.log(a, b, c); // 1 1 undefined
</wxs>

<wxs module="m2">
  	console.log(b); // 1
    console.log(a); // ReferenceError: a is not defined
    console.log(c); // ReferenceError: c is not defined
</wxs>
```

`WXS` 虽然没有全局对象，但仍有全局变量的概念。需要注意的是，使用 `var` 声明的变量是独属于此模块的局部变量，而未使用 `var` 声明的变量才是全局变量，这与 `JavaScript` 不同，如上所示。

###### 变量名

变量命名必须符合下面两个规则：

- 首字符必须是：字母（`a-z, A-Z`）、下划线（`_`），二者之一。
- 剩余字符可是：字母（`a-z, A-Z`）、下划线（`_`）、数字（0 - 9），三者之一。

###### 保留标识符

以下标识符不能作为变量名：

|     保      |     留     |    标     |   识    |     符      |
| :---------: | :--------: | :-------: | :-----: | :---------: |
|  `delete`   |   `void`   | `typeof`  | `null`  | `undefined` |
|    `NaN`    | `Infinity` |   `var`   |  `if`   |   `else`    |
|   `true`    |  `false`   | `require` | `this`  | `function`  |
| `arguments` |   return   |   `for`   | `while` |    `do`     |
|   `break`   | `continue` | `switch`  | `case`  |  `default`  |

##### 注释

与 `JavaScript` 一样，`WXS` 主要有 2 种注释的方法。

- 单行注释：`// 最多能注释一行`
- 多行注释：`/* 可注释多行 */`

##### 运算符

`WXS` 支持的运算符，及其优先级如下表所示。

| 优先级 |  运算符  |    说明    |  结合性  |
| :----: | :------: | :--------: | :------: |
|   20   |   `()`   |    括号    |  `N/A`   |
|   19   |   `.`    |  成员访问  | 从左到右 |
|        |   `[]`   |  成员访问  | 从左到右 |
|        |  `fn()`  |  函数调用  | 从左到右 |
|   17   |   `++`   |  后置递增  |  `N/A`   |
|        |   `--`   |  后置递减  |  `N/A`   |
|   16   |   `!`    |   逻辑非   | 从右到左 |
|        |   `~`    |   按位非   | 从右到左 |
|        |   `+`    |  正值运算  | 从右到左 |
|        |   `-`    |  负值运算  | 从右到左 |
|        |   `++`   |  前置递增  | 从右到左 |
|        |   `--`   |  前置递减  | 从右到左 |
|        | `typeof` |  类型检测  | 从右到左 |
|        |  `void`  |   `void`   | 从右到左 |
|        | `delete` |  删除成员  | 从右到左 |
|   14   |   `*`    |    乘法    | 从左到右 |
|        |   `/`    |    除法    | 从左到右 |
|        |   `%`    |    取模    | 从左到右 |
|   13   |   `+`    |    加法    | 从左到右 |
|        |   `-`    |    减法    | 从左到右 |
|   12   |   `<<`   |  按位左移  | 从左到右 |
|        |   `>>`   |  按位右移  | 从左到右 |
|        |  `>>>`   | 无符号右移 | 从左到右 |
|   11   |   `<`    |    小于    | 从左到右 |
|        |   `<=`   |  小于等于  | 从左到右 |
|        |   `>`    |    大于    | 从左到右 |
|        |   `>=`   |  大于等于  | 从左到右 |
|   10   |   `==`   |    等号    | 从左到右 |
|        |   `!=`   |   非等号   | 从左到右 |
|        |  `===`   |   全等号   | 从左到右 |
|        |  `!==`   |  非全等号  | 从左到右 |
|   9    |   `&`    |   按位与   | 从左到右 |
|   8    |   `^`    |  按位异或  | 从左到右 |
|   7    |   `｜`   |   按位或   | 从左到右 |
|   6    |   `&&`   |   逻辑与   | 从左到右 |
|   5    |  `｜｜`  |   逻辑或   | 从左到右 |
|   4    | `?` `:`  | 条件运算符 | 从右到左 |
|   3    |   `=`    |    赋值    | 从右到左 |
|        |   `+=`   |    赋值    | 从右到左 |
|        |   `-=`   |    赋值    | 从右到左 |
|        |   `*=`   |    赋值    | 从右到左 |
|        |   `/=`   |    赋值    | 从右到左 |
|        |   `%=`   |    赋值    | 从右到左 |
|        |  `<<=`   |    赋值    | 从右到左 |
|        |  `>>=`   |    赋值    | 从右到左 |
|        |  `>>>=`  |    赋值    | 从右到左 |
|        |   `&=`   |    赋值    | 从右到左 |
|        |   `^=`   |    赋值    | 从右到左 |
|        |  `｜=`   |    赋值    | 从右到左 |
|   0    |   `,`    |    逗号    | 从左到右 |

##### 语句

与 `JavaScript` 一样，`WXS` 也支持以下 4 种语句：`if`、`switch`、`for` 和 `while`。

###### `if`

```js
// if
if (expression) statement;

if (expression)
 	statement;

if (expression) {
  	statement;
}

// if-else
if (expression) statement;
else statement2;

if (expression)
  	statement1;
else
  	statement2;

if (expression) {
  	statement1;
} else {
  	statement2;
}

// if-else if-else
if (expression1) {
  	statement1;
} else if (expression2) {
  	statement2;
} else if (expression3) {
  	statement3;
} else {
  	statement4;
}
```

###### `switch`

```js
switch (expression) {
  	case variable:
    	statement1;
  	case number:
    	statement2;
    	break;
  	case boolean:
    	statement3;
    	break;
  	case string:
    	statement4;
  	default:
    	statement5;
}
```

注意：`default` 分支可以省略不写。`case` 关键词后面只能直接使用：变量、数字、布尔值、字符串，不可以使用表达式。

###### `for`

```js
for (语句; 语句; 语句)
  	语句;

for (语句; 语句; 语句) {
  	代码块;
}
```

支持使用 `break`，`continue` 关键词。

###### `while`

```js
while (表达式)
  	语句;

while (表达式){
  	代码块;
}

do {
  	代码块;
} while (表达式)
```

支持使用 `break`，`continue` 关键词。

##### 数据类型

`WXS` 语言目前共有以下 8 种数据类型，这些类型都不可以通过其构造器来创建，只能使用相应的字面量或方法来创建。

|     数     |    据    |    类     |    型    |
| :--------: | :------: | :-------: | :------: |
|  `Number`  | `String` | `Boolean` | `Object` |
| `Function` | `Array`  |  `Date`   | `RegExp` |

###### `Number`

`Number` 仅支持字面量创建，包括两种数值：整数，小数。

|     属性      | 描述                    |
| :-----------: | :---------------------- |
| `constructor` | 返回字符串 `"Number"`。 |

|       方        |        法        |
| :-------------: | :--------------: |
|   `toString`    | `toLocaleString` |
|    `valueOf`    |    `toFixed`     |
| `toExponential` |  `toPrecision`   |

```js
(10).constructor; // "Number"
```

###### `String`

`String` 仅支持字面量创建，有两种写法：单引号，双引号。

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"String"`。 |
|   `length`    | 返回字符串长度。        |

|      方       |         法          |
| :-----------: | :-----------------: |
|  `toString`   |      `valueOf`      |
|   `charAt`    |    `charCodeAt`     |
|   `concat`    |      `indexOf`      |
| `lastIndexOf` |   `localeCompare`   |
|    `match`    |      `replace`      |
|   `search`    |       `slice`       |
|    `split`    |     `substring`     |
| `toLowerCase` | `toLocaleLowerCase` |
| `toUpperCase` | `toLocaleUpperCase` |
|    `trim`     |                     |

```js
"".constructor; // "String"
```

###### `Boolean`

`Boolean` 仅支持字面量创建，只有两个特定的值：`true` 和 `false`。

|     属性      | 描述                     |
| :-----------: | ------------------------ |
| `constructor` | 返回字符串 `"Boolean"`。 |

|     方     |    法     |
| :--------: | :-------: |
| `toString` | `valueOf` |

```js
true.constructor; // "Boolean"
```

###### `Object`

`Object` 仅支持字面量，是一种无序的键值对。

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"Object"`。 |

|    方法    | 描述                             |
| :--------: | -------------------------------- |
| `toString` | 返回字符串 `"[object Object]"`。 |

```js
{}.constructor // "Object"
```

###### `Function`

`Function` 仅支持使用关键字声明的定义方式，尚未支持箭头函数。

|     属性      | 描述                      |
| :-----------: | ------------------------- |
| `constructor` | 返回字符串 `"Function"`。 |
|   `length`    | 返回函数的形参个数。      |

|    方法    | 描述                                 |
| :--------: | ------------------------------------ |
| `toString` | 返回字符串 `"[function Function]"`。 |

`function` 里面可以使用 `arguments` 关键词，该关键词目前只支持以下的属性：

- `length`：实参个数。
- `[index]`：每个实参所依次对应的下标。

```js
(function() {}).constructor; // "Function"
```

###### `Array`

`Array` 仅支持字面量创建。

|     属性      | 描述                   |
| :-----------: | ---------------------- |
| `constructor` | 返回字符串 `"Array"`。 |
|   `length`    | 数组长度               |

|      方       |      法       |
| :-----------: | :-----------: |
|  `toString`   |   `concat`    |
|    `join`     |     `pop`     |
|    `push`     |   `reverse`   |
|    `shift`    |    `slice`    |
|    `sort`     |   `splice`    |
|   `unshift`   |   `indexOf`   |
| `lastIndexOf` |    `every`    |
|    `some`     |   `forEach`   |
|     `map`     |   `filter`    |
|   `reduce`    | `reduceRight` |

```js
[].constructor; // "Array"
```

###### `Date`

生成 `Date` 对象仅支持使用 `getDate`函数，返回一个当前时间的对象。

```text
getDate()
getDate(milliseconds)
getDate(datestring)
getDate(year, month-1, day, hours, minutes, seconds, milliseconds)
```

|      参数      | 描述                                                         |
| :------------: | ------------------------------------------------------------ |
| `milliseconds` | 从 1970 年 1 月 1 日 `00:00:00 UTC` 开始计算的毫秒数         |
|  `datestring`  | 日期字符串，其格式可为：<br /> （1）`"month day, year hours:minutes:seconds"`<br /> （2）`"year-month-day hours:minutes:seconds"` |

```js
getDate(); 							// Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
getDate(1683118557440); 			// Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
getDate('2023-5-3 20:55:57'); 		// Wed May 03 2023 00:00:00 GMT+0800 (中国标准时间)
getDate('5 3, 2023 20:55:57'); 		// Wed May 03 2023 00:00:00 GMT+0800 (中国标准时间)
getDate(2023, 4, 3, 20, 55, 57, 0); // Wed May 03 2023 20:55:57 GMT+0800 (中国标准时间)
```

|     属性      |         描述          |
| :-----------: | :-------------------: |
| `constructor` | 返回字符串 `"Date"`。 |

|          支          |        持         |          的          |          方          |          法          |
| :------------------: | :---------------: | :------------------: | :------------------: | :------------------: |
|      `toString`      |  `toDateString`   |    `toTimeString`    |   `toLocaleString`   | `toLocaleDateString` |
| `toLocaleTimeString` |     `valueOf`     |      `getTime`       |    `getFullYear`     |   `getUTCFullYear`   |
|      `getMonth`      |   `getUTCMonth`   |      `getDate`       |     `getUTCDate`     |       `getDay`       |
|     `getUTCDay`      |    `getHours`     |    `getUTCHours`     |     `getMinutes`     |   `getUTCMinutes`    |
|     `getSeconds`     |  `getUTCSeconds`  |  `getMilliseconds`   | `getUTCMilliseconds` | `getTimezoneOffset`  |
|      `setTime`       | `setMilliseconds` | `setUTCMilliseconds` |     `setSeconds`     |   `setUTCSeconds`    |
|     `setMinutes`     |  `setUTCMinutes`  |      `setHours`      |    `setUTCHours`     |      `setDate`       |
|     `setUTCDate`     |    `setMonth`     |    `setUTCMonth`     |    `setFullYear`     |   `setUTCFullYear`   |
|    `toUTCString`     |   `toISOString`   |       `toJSON`       |                      |                      |

```js
getDate().constructor; // "Date"
```

###### `RegExp`

生成 `regexp` 对象仅支持使用 `getRegExp` 函数。

```
getRegExp(pattern[, flags])
```

|   参数    | 描述                                                         |
| :-------: | ------------------------------------------------------------ |
| `pattern` | 正则表达式的内容（字符串）。                                 |
|  `flags`  | 修饰符。仅支持：`g` —— `global`， `i` —— `ignoreCase`， `m` —— `multiline`。 |

```js
getRegExp("x", "g"); //=> /x/g
```

|     属性      | 描述                    |
| :-----------: | ----------------------- |
| `constructor` | 返回字符串 `"RegExp"`。 |
|   `source`    | 请参考 `ES5` 标准       |
|   `global`    | 请参考 `ES5` 标准       |
| `ignoreCase`  | 请参考 `ES5` 标准       |
|  `multiline`  | 请参考 `ES5` 标准       |
|  `lastIndex`  | 请参考 `ES5` 标准       |

|     方     |   法   |
| :--------: | :----: |
|   `exec`   | `test` |
| `toString` |        |

```js
getRegExp().constructor; // "RegExp"
```

###### 类型判断

判断 `WXS` 的数据类型，主要有以下两种方式：

- `WXS` 将各个数据类型的 `constructor` 重写为返回对应类型的字符串。因此，可以使用 `constructor` 属性来进行判断。
- 当然，使用 `typeof`（与 `JS` 的行为一样）也可以来区分部分数据类型。

```js
var arr1 = [1, '', true, {}, function(){}, [], getDate(), getRegExp()],
	arr2 = [1, '', true, {}, function(){}, [], getDate(), getRegExp()];

arr1.map(function(item, index, arr) {
    arr[index] = item.constructor;
});

arr2.map(function(item, index, arr) {
    arr[index] = typeof item;
});

console.log(arr1); // ["Number", "String", "Boolean", "Object", "Function", "Array", "Date", "RegExp"]
console.log(arr2); // ["number", "string", "boolean", "object", "function", "object", "object", "object"]
```

##### 基础类库

###### `console`

| 方法  | 描述                                                         |
| :---: | :----------------------------------------------------------- |
| `log` | 用于在 `console` 窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。 |

###### `Math`

|    属     |   性    |
| :-------: | :-----: |
|    `E`    | `LN10`  |
|   `LN2`   | `LOG2E` |
| `LOG10E`  |  `PI`   |
| `SQRT1_2` | `SQRT2` |

|   方    |    法    |
| :-----: | :------: |
|  `abs`  |  `acos`  |
| `asin`  |  `atan`  |
| `atan2` |  `ceil`  |
|  `cos`  |  `exp`   |
| `floor` |  `log`   |
|  `max`  |  `min`   |
|  `pow`  | `random` |
| `round` |  `sin`   |
| `sqrt`  |  `tan`   |

```js
Math.E; // 2.718281828459045
```

###### `JSON`

|        方法         | 描述                                                   |
| :-----------------: | ------------------------------------------------------ |
| `stringify(object)` | 将 `object` 对象转换为 `JSON` 字符串，并返回该字符串。 |
|   `parse(string)`   | 将 `JSON` 字符串转化成对象，并返回该对象。             |

###### `Number`

|         属          |         性          |
| :-----------------: | :-----------------: |
|     `MAX_VALUE`     |     `MIN_VALUE`     |
| `NEGATIVE_INFINITY` | `POSITIVE_INFINITY` |

###### `Date`

|   方    |  法   |
| :-----: | :---: |
| `parse` | `UTC` |
|  `now`  |       |

###### `Global`

|     属      |     性     |
| :---------: | :--------: |
|    `NaN`    | `Infinity` |
| `undefined` |            |

|     方      |          法          |
| :---------: | :------------------: |
| `parseInt`  |     `parseFloat`     |
|   `isNaN`   |      `isFinite`      |
| `decodeURI` | `decodeURIComponent` |
| `encodeURI` | `encodeURIComponent` |

注释：实际上并没有 `Global` 对象，它在这里表示全局。也就是说，上述属性和方法都是全局可用的变量。



#### 事件系统

##### 简介

什么是事件？

- 事件是视图层到逻辑层的通讯方式。
- 事件可以将用户的行为反馈到逻辑层进行处理。
- 事件可以绑定在组件上，当事件被触发时，就会执行逻辑层中对应的事件处理函数。
- 事件对象可以携带额外的信息，如 `id`，`dataset`，`touches` 等等。

##### 使用方式

使用事件，只要经过以下两步：

- 在组件上使用相应的事件属性绑定事件处理函数。
- 在相应的 `Page` 定义中定义相应的事件处理函数。

```html
<view bind:tap="tapName">点击</view> 
<!-- 注意：
	1、bind的值必须是字符串，如 "tapName"
	2、bind后面的冒号可以省略，如 bindtap
-->
```

```js
Page({
  	tapName: function(event) {
    	console.log(event)
  	}
});
```

##### `WXS` 绑定

从基础库版本 `2.4.4` 开始，支持使用 `WXS` 函数绑定事件。`WXS` 函数接受 2 个参数：第一个是 `event`，在原有的 `event` 的基础上加了 `event.instance` 属性；第二个参数是 `ownerInstance`，和 `event.instance` 一样是一个 `ComponentDescriptor` 对象。

具体使用如下：

- 在 `WXS` 中，定义并导出事件处理函数。
- 在组件上，使用事件属性绑定处理函数。

```html
<wxs module="m">
	function tapName(event, ownerInstance) {
  		console.log('tap Weixin')
	}
	module.exports = {
  		tapName: tapName
	}
</wxs>

<view bindtap="{{m.tapName}}">点击</view> <!-- 注意：绑定的WXS函数必须用{{}}括起来 -->
```

`ownerInstance` 包含了一些方法，可以设置组件的样式和 `class`。具体包含方法以及为什么要用 `WXS` 函数响应事件，参见下文。

###### 背景

有频繁用户交互的效果在小程序上表现是比较卡顿的。例如页面有 2 个元素 `A` 和 `B`，用户在 `A` 上做 `touchmove` 手势，要求 `B` 也跟随移动的情况，[`movable-view`](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html) 就是一个典型的例子。一次 `touchmove` 事件的响应过程为：

1. `touchmove` 事件从视图层抛到逻辑层（第一次通信）
2. 逻辑层处理 `touchmove` 事件，再通过 `setData` 来改变 `B` 的位置（第二次通信）

一次 `touchmove` 的响应需要经过 2 次逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 `setData` 渲染也会阻塞其它脚本的执行，从而导致了整个用户交互的动画过程会有延迟。

###### 实现方案

本方案基本的思路是减少通信的次数，让事件在视图层响应。小程序的框架分为视图层（`Webview`）和逻辑层（`App Service`），这样分层的目的是便于管控，但开发者的代码只能运行在逻辑层。而本方案就是要让开发者的代码必须运行在视图层，其流程如下：

<img src="images/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%90%E6%A1%86%E6%9E%B6%E3%80%91/interative-model.b746ab92.png" alt="img" style="zoom: 67%;" />

使用 `WXS` 函数来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件。`WXS` 函数除了纯逻辑的运算，还可以通过封装好的 `ComponentDescriptor` 实例来访问和设置组件的类名与样式。但对于交互动画，设置 `style` 和 `class` 就足够了。

```js
var wxsFunction = function(event, ownerInstance) {
    var instance = ownerInstance.selectComponent('.classSelector') // 获取指定的组件实例
    instance.setStyle({
        "font-size": "14px" // 支持 rpx
    })
    instance.getDataset()
    instance.addClass("className")
    // ...
    return false // 不再往上冒泡，相当于调用了同时调用了 stopPropagation 和 preventDefault
}
```

其中，首参 `event` 在小程序原有事件对象基础上增加了 `instance` 属性，它是触发此事件的组件实例。而 `ownerInstance` 参数是触发此事件的组件的父组件实例。如果触发事件的组件是在页面内，则 `ownerInstance` 表示的是该页面实例。

组件实例 `ComponentDescriptor` 没有属性（如 `className` 等），只拥有如下方法：

|              方法               | 参数                                        | 描述                                                         |                           最低版本                           |
| :-----------------------------: | :------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------: |
|        `selectComponent`        | 选择器字符串                                | 返回指定组件的 `ComponentDescriptor` 实例                    |                                                              |
|      `selectAllComponents`      | 选择器字符串                                | 返回指定组件的 `ComponentDescriptor` 实例数组                |                                                              |
|           `setStyle`            | `Object/string`                             | 设置组件的行间样式，支持 `rpx`。因为是行间样式，所以设置的样式优先级比组件 `wxml` 里面定义的样式高。不能设置最顶层页面的样式。 |                                                              |
| `addClass/removeClass/hasClass` | 类名字符串                                  | 设置组件的 `class`，从后面添加。样式的优先级不取决于其类名在 `class` 中的顺序，而取决于这些样式在 `CSS` 文件中的定义顺序（除非刻意加大权重）。不能设置最顶层页面的 `class`。 |                                                              |
|          `getDataset`           | 无                                          | 返回当前组件/页面的 `dataset` 对象。                         |                                                              |
|          `callMethod`           | `(fnName, args)`                            | 调用当前组件/页面在逻辑层定义的函数。`fnName` 是函数名称，`args` 是函数的参数。 |                                                              |
|     `requestAnimationFrame`     | `Function`                                  | 和原生 `requestAnimationFrame` 一样。用于设置动画。          |                                                              |
|           `getState`            | 无                                          | 返回一个 `object` 对象，当有局部变量需要存储起来以供后续使用的时候用这个方法。 |                                                              |
|         `triggerEvent`          | `(eventName, detail)`                       | 触发自定义事件，和组件的 [`triggerEvent`](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html) 一致。 |                                                              |
|       `getComputedStyle`        | `Array<string>`                             | 参数与 [`SelectorQuery`](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/NodesRef.fields.html) 的 `computedStyle` 一致 | [2.11.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|          `setTimeout`           | `(fn, number)`                              | 与原生 `setTimeout` 一致。用于创建定时器。                   | [2.14.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|         `clearTimeout`          | `Number`                                    | 与原生 `clearTimeout` 一致。用于清除定时器。                 | [2.14.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|     `getBoundingClientRect`     | 无                                          | 返回值与 [`SelectorQuery`](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/NodesRef.boundingClientRect.html) 的 `boundingClientRect` 一致 | [2.14.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|            `animate`            | `(selector, keyframes, duration, callback)` | 执行关键帧动画，详见 [动画](https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html) | [2.9.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|        `clearAnimation`         | `(selector, options, callback)`             | 清除关键帧动画                                               | [2.9.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

```js
// 获取指定的组件实例
var instance = ownerInstance.selectComponent('.classSelector') 		// 此页面第一个
var instances = ownerInstance.selectAllComponents('.classSelector') // 此页面所有的

// 设置组件的行间样式
instance.setStyle({
    "color": "red",
    "font-size": "32rpx" // 支持rpx，且必须以原生CSS样式名为键。
})

instance.setStyle("color: red; font-size: 36rpx;")

// 设置组件的类名
instance.addClass("test") 			// 已有的不会再添加。
instance.addClass("test1 test2") 	// 可一次性添加多个。虽然wxml能够识别，但hasClass和removeClass会将其视作一个类名
instance.hasClass("test") 			// true
instance.hasClass("test1") 			// false
instance.hasClass("test2") 			// false
instance.hasClass("test1 test2") 	// true
instance.removeClass("test")
instance.removeClass("test1 test2")
instance.hasClass("test") 			// false

// 获取组件的dataset
instance.getDataset()

// 调用父组件的逻辑层方法（即：页面js文件中的方法）
/*
Page({
	fn: function(data) {
		console.log(data)
	}
})
*/
ownerInstance.callMethod("fn", 1) // 只支持传入一个参数
/*
	在非自定义组件上调用该方法是非法的，应该在父组件（也有可能是页面）上调用它。
	因此，为了避免错误，不应该在 event.instance 而应该在 ownerInstance 上调用它。
*/
```

`WXS` 运行在视图层，里面的逻辑毕竟能做的事件比较少，需要有一个机制和逻辑层的代码通信。上面的 `callMethod` 是 `WXS` 代码调用逻辑层代码的方法，而 `WxsPropObserver` 是逻辑层代码调用 `WXS` 逻辑的机制（借助 `setData` 触发 `WXS` 的 `WxspropObserver`）。

###### 使用方法

基本步骤：

- `WXS` 定义并导出事件处理函数和在属性改变时触发的函数。
- `WXML` 定义事件和绑定事件处理函数。

```js
// pages/index/index.js
Page({
    data: {
        propValue: "old"
    },
    change(data) {
        this.setData({propValue: data})
    }
})
```

```js
// pages/index/index.wxs
module.exports = {
    tap: function(event, ownerInstance) {
        ownerInstance.callMethod("change", "new")
    },
    propObserver: function(newValue, oldValue, ownerInstance, instance) {
        console.log('prop observer', newValue, oldValue)
    }
}
```

```html
<!-- pages/index/index.wxml -->
<wxs module="m" src="./index.wxs"></wxs>
<view change:prop="{{m.propObserver}}" prop="{{propValue}}" bindtap="{{m.tap}}">点击</view>
```

上面的 `change:prop`（属性前面带 `change:` 前缀）用于绑定当 `prop` 属性（值必须用 `{{}}` 括起来）被设置时触发的 `WXS` 函数。类似 `Component` 定义的 `properties` 里面的 `observer` 属性，在 `setData({propValue: newValue})` 调用之后会触发。

**注意**：

- `WXS` 函数必须用 `{{}}` 括起来。当 `prop` 的值被设置时 `WXS` 函数就会触发，而不只是 `prop` 值发生改变。因此，在页面初始化的时候会调用一次 `WxsPropObserver` 的函数。
- `change:` 可以为任何组件属性绑定监听器，包括自定义属性。但被绑定属性的值应该来自逻辑层，因为监听器在 `setData()` 修改相应的属性值之后触发。

###### 注意事项

1. 目前还不支持 [原生组件](https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html) 的事件、[`input`](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 和 [`textarea`](https://developers.weixin.qq.com/miniprogram/dev/component/textarea.html) 组件的 `bindinput` 事件。
2. 1.02.1901170 及以后版本的开发者工具上支持交互动画，最低版本基础库是 2.4.4。
3. 目前在 `WXS` 函数里面仅支持 `console.log` 方式打印日志定位问题，但连续的重复日志会被过滤掉。

##### 事件分类

事件分为冒泡事件和非冒泡事件：

1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

`WXML` 的冒泡事件列表：

|         类型         | 触发条件                                                     |                           最低版本                           |
| :------------------: | :----------------------------------------------------------- | :----------------------------------------------------------: |
|     `touchstart`     | 手指触摸动作开始                                             |                                                              |
|     `touchmove`      | 手指触摸后移动                                               |                                                              |
|    `touchcancel`     | 手指触摸动作被打断，如来电提醒，弹窗                         |                                                              |
|      `touchend`      | 手指触摸动作结束                                             |                                                              |
|        `tap`         | 手指触摸后马上离开                                           |                                                              |
|     `longpress`      | 手指触摸后，超过 `350ms` 再离开。如果指定了事件回调函数并触发了这个事件，则 `tap` 事件将不被触发 | [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
|      `longtap`       | 手指触摸后，超过 `350ms` 再离开（推荐使用 `longpress` 事件代替） |                                                              |
|   `transitionend`    | 会在 `WXSS transition` 或 `wx.createAnimation` 动画结束后触发 |                                                              |
|   `animationstart`   | 会在一个 `WXSS animation` 动画开始时触发                     |                                                              |
| `animationiteration` | 会在一个 `WXSS animation` 一次迭代结束时触发                 |                                                              |
|    `animationend`    | 会在一个 `WXSS animation` 动画完成时触发                     |                                                              |
|  `touchforcechange`  | 在支持 `3D Touch` 的 `iPhone` 设备，重按时会触发             | [1.9.90](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

**注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 [`form`](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 的 `submit` 事件，[`input`](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 的 `input` 事件，[`scroll-view`](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html) 的 `scroll` 事件，（详见各个 [组件](https://developers.weixin.qq.com/miniprogram/dev/component/)）**。

##### 普通事件

事件绑定的写法类似于组件的属性，如：

```html
<view bindtap="handleTap">点击</view>
```

如果用户点击这个 `view` ，则页面的 `handleTap` 会被调用。事件绑定函数也可以是一个数据绑定，如：

```html
<view bindtap="{{ handlerName }}">
    Click here!
</view>
```

此时，页面的 `this.data.handlerName` 必须是一个字符串，用来指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。

自基础库版本 [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，在大多数组件和自定义组件中，`bind` 后可以紧跟一个冒号，且其含义不变，如 `bind:tap` 。自基础库版本 [2.8.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，在所有组件中开始提供这个支持。

##### 阻止冒泡

除 `bind` 外，也可以用 `catch` 来绑定事件。与 `bind` 不同， `catch` 会阻止事件向上冒泡。

例如在下边这个例子中，点击 `inner view` 会先后调用 `handleTap3` 和 `handleTap2`（因为 `tap` 事件会冒泡到 `middle view`，而 `middle view` 阻止了 `tap` 事件冒泡，使其不再向父节点传递），点击 `middle view` 会触发 `handleTap2`，点击 `outer view` 会触发 `handleTap1`。

```html
<view id="outer" bindtap="handleTap1">
  	outer view
  	<view id="middle" catchtap="handleTap2">
    	middle view
    	<view id="inner" bindtap="handleTap3">
      		inner view
    	</view>
  	</view>
</view>
```

##### 互斥事件

自基础库版本 [2.8.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，除 `bind` 和 `catch` 外，还可以使用 `mut-bind` 来绑定事件。一个 `mut-bind` 触发后，如果事件冒泡到其他节点上，其他节点上的 `mut-bind` 绑定函数不会被触发，但 `bind` 绑定函数和 `catch` 绑定函数依旧会被触发。

换而言之，所有 `mut-bind` 是 “互斥” 的，只有其中一个绑定函数会被触发。同时，它完全不影响 `bind` 和 `catch` 的绑定效果。

例如在下边这个例子中，点击 `inner view` 会先后调用 `handleTap3` 和 `handleTap2`，点击 `middle view` 会调用 `handleTap2` 和 `handleTap1`，点击 `outer view` 则只会调用 `handleTap1`。

```html
<view id="outer" mut-bind:tap="handleTap1">
  	outer view
  	<view id="middle" bindtap="handleTap2">
    	middle view
    	<view id="inner" mut-bind:tap="handleTap3">
      		inner view
    	</view>
  	</view>
</view>
```

##### 事件捕获

自基础库版本 [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用 `capture-bind`、`capture-catch` 关键字，后者将中断捕获阶段和取消冒泡阶段。

在下面的代码中，点击 `inner view` 会先后调用 `handleTap2`、`handleTap4`、`handleTap3`、`handleTap1`。

```html
<view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
  	outer view
  	<view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
    	inner view
  	</view>
</view>
```

如果将上面代码中的第一个 `capture-bind` 改为 `capture-catch`，将只触发 `handleTap2`。

```html
<view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2">
  	outer view
  	<view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
    	inner view
  	</view>
</view>
```

##### 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

**`BaseEvent` 基础事件对象属性列表：**

|      属性       |   类型    | 说明                           |                          基础库版本                          |
| :-------------: | :-------: | :----------------------------- | :----------------------------------------------------------: |
|     `type`      | `String`  | 事件类型                       |                                                              |
|   `timeStamp`   | `Integer` | 事件生成时的时间戳             |                                                              |
|    `target`     | `Object`  | 触发事件的组件的一些属性值集合 |                                                              |
| `currentTarget` | `Object`  | 当前组件的一些属性值集合       |                                                              |
|     `mark`      | `Object`  | 事件标记数据                   | [2.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

**`CustomEvent` 自定义事件对象属性列表（继承 `BaseEvent`）：**

|   属性   |   类型   | 说明       |
| :------: | :------: | :--------- |
| `detail` | `Object` | 额外的信息 |

**`TouchEvent` 触摸事件对象属性列表（继承 `BaseEvent`）：**

|       属性       |  类型   | 说明                                         |
| :--------------: | :-----: | :------------------------------------------- |
|    `touches`     | `Array` | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| `changedTouches` | `Array` | 触摸事件，当前变化的触摸点信息的数组         |

**特殊事件： [`canvas`](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html) 中的触摸事件不可冒泡，所以没有 `currentTarget`。**

###### `type`

代表事件的类型。

###### `timeStamp`

从页面打开到触发事件所经过的毫秒数。

###### `target`

触发事件的源组件。

|   属性    |   类型   | 说明                                              |
| :-------: | :------: | :------------------------------------------------ |
|   `id`    | `String` | 事件源组件的 `id`                                 |
| `dataset` | `Object` | 事件源组件上由 `data-` 开头的自定义属性组成的集合 |

###### `currentTarget`

该事件绑定的组件。

|   属性    |   类型   | 说明                                            |
| :-------: | :------: | :---------------------------------------------- |
|   `id`    | `String` | 当前组件的 `id`                                 |
| `dataset` | `Object` | 当前组件上由 `data-` 开头的自定义属性组成的集合 |

```html
<view id="outer" bindtap="handleTap1">
  	outer view
  	<view id="middle" catchtap="handleTap2">
    	middle view
    	<view id="inner" bindtap="handleTap3">
      		inner view
    	</view>
  	</view>
</view>
```

**说明：`target` 和 `currentTarget` 可以参考上例中，点击 `inner view` 时，`handleTap3` 收到的事件对象 `target` 和 `currentTarget` 都是 `inner`，而 `handleTap2` 收到的事件对象 `target` 是 `inner`，`currentTarget` 是 `middle`。**

`dataset` 属性

在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。

在 `WXML` 中，这些自定义数据以 `data-` 开头，多个单词由连字符 `-` 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：

- `data-element-type` ，最终会呈现为 `event.currentTarget.dataset.elementType` ；
- `data-elementType` ，最终会呈现为 `event.currentTarget.dataset.elementtype` 。

```html
<view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"> DataSet Test </view>
```

```js
Page({
  	bindViewTap: function(event) {
        console.log(event.currentTarget.dataset) // {alphaBeta: "1", alphabeta: "2"}
  	}
})
```

###### `mark`

在基础库版本 [2.7.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 以上，可以使用 `mark` 来识别具体触发事件的 `target` 节点。此外，`mark` 还可以用于承载一些自定义数据（类似于 `dataset`）。

当事件触发时，事件冒泡路径上所有的 `mark` 会被合并，并返回给事件回调函数（即使事件没有冒泡，也会 `mark`）。

```html
<view mark:myMark="last">
  	<button mark:anotherMark="leaf" catchtap="bindButtonTap">按钮</button>
</view>
```

在上述 `WXML` 中，如果按钮被点击，将触发 `bindViewTap` 和 `bindButtonTap` 两个事件，事件携带的 `event.mark` 将包含 `myMark` 和 `anotherMark` 两项。

```js
Page({
  	bindButtonTap: function(e) {
    	console.log(e.mark) // {anotherMark: "leaf", myMark: "last"}
  	}
})
```

`mark` 和 `dataset` 很相似，主要区别在于：`mark` 会包含从触发事件的节点到根节点上所有的 `mark:` 属性值；而 `dataset` 仅包含一个节点的 `data-` 属性值。

注意事项：

- 如果存在同名的 `mark`，父节点的 `mark` 会被子节点覆盖。
- 在自定义组件中接收事件时，`mark` 不包含自定义组件外的节点的 `mark`。
- 不同于 `dataset`，节点的 `mark` 不会做连字符和大小写转换。

###### `detail`

自定义事件所携带的数据。如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见 [组件](https://developers.weixin.qq.com/miniprogram/dev/component) 定义中各个事件的定义。

点击事件的 `detail` 带有的 `x, y` 同 `pageX, pageY` 一样，代表敲击点距离文档左上角的距离。

###### `touches`

`touches` 是一个数组，每个元素都为一个 `Touch` 对象（`canvas` 触摸事件中携带的 `touches` 是 `CanvasTouch` 数组）， 表示当前停留在屏幕上的触摸点。

`Touch` 对象

|        属性        |   类型   | 说明                                                         |
| :----------------: | :------: | :----------------------------------------------------------- |
|    `identifier`    | `Number` | 触摸点的标识符                                               |
|   `pageX, pageY`   | `Number` | 距离文档左上角的距离，文档的左上角为原点 ，横向为 `X` 轴，纵向为 `Y` 轴 |
| `clientX, clientY` | `Number` | 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 `X` 轴，纵向为 `Y` 轴 |

`CanvasTouch` 对象

|     属性     |   类型   | 说明                                                         |
| :----------: | :------: | :----------------------------------------------------------- |
| `identifier` | `Number` | 触摸点的标识符                                               |
|    `x, y`    | `Number` | 距离 `Canvas` 左上角的距离，`Canvas` 的左上角为原点 ，横向为 `X` 轴，纵向为 `Y` 轴 |

###### `changedTouches`

`changedTouches` 数据格式同 `touches`，表示有变化的触摸点的集合。如从无变有（`touchstart`），位置变化（`touchmove`），从有变无（`touchend`、`touchcancel`）。



#### 双向绑定

基础库 2.9.3 开始支持，低版本需做 [兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

##### 绑定语法

在 `WXML` 中，普通的属性绑定是单向的。例如：

```html
<input value="{{value}}" />
```

如果使用 `this.setData({ value: 'leaf' })` 来更新 `value`，`this.data.value` 和输入框的中显示的值都会被更新为 `leaf`；但如果用户修改了输入框里的值，却不会同时改变 `this.data.value`。

如果需要在用户输入的同时改变 `this.data.value`，需要借助简易双向绑定机制。此时，可以在对应属性前加上 `model:` 前缀。

```html
<input model:value="{{value}}" />
```

这样，如果输入框的值被改变了，`this.data.value` 也会同时改变。同时，`WXML` 中所有绑定了 `value` 的位置也会被一同更新，而 [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) 也会被正常触发。

用于双向绑定的 `{{}}` 有如下限制：

- `{{}}` 内外不能有任何多余字符，如：`model:value=" {{value}}"`
- 只能绑定一个 `data` 数据，如：`model:value="{{value}}"`。
- 目前，尚不能 `data` 路径

```js
<input model:value="值为 {{value}}" /> 	<!-- 不能参杂其他字符 -->
<input model:value="{{ a + b }}" /> 	 <!-- 只能绑定一个数据 -->
<input model:value="{{ a.b }}" /> 		 <!-- 尚未支持数据路径 -->
```

##### 自定义组件的双向绑定

双向绑定同样可以使用在自定义组件上。

```js
// custom-component.js
Component({
  	properties: {
    	myValue: String
  	}
})
```

```html
<!-- custom-component.wxml -->
<input model:value="{{myValue}}" />
```

这个自定义组件将自身的 `myValue` 属性双向绑定到了组件内输入框的 `value` 属性上。然后，页面可以像这样使用该组件：

```html
<custom-component model:my-value="{{pageValue}}" />
```

当输入框的值变更时，自定义组件的 `myValue` 属性会同时变更。这样，页面的 `this.data.pageValue` 也会同时变更，页面 `WXML` 中所有绑定了 `pageValue` 的位置也会被一同更新。

##### 自定义组件的双向更新

自定义组件还可以自己触发双向绑定更新，做法就是：使用 `setData` 设置自身的属性。例如：

```js
// custom-component.js
Component({
  	properties: {
    	myValue: String
  	},
  	methods: {
    	update: function() {
      		// 更新 myValue
      		this.setData({
        		myValue: 'leaf'
      		})
    	}
  	}
})
```

如果页面这样使用这个组件：

```html
<custom-component model:my-value="{{pageValue}}" />
```

当组件使用 `setData` 更新 `myValue` 时，页面的 `this.data.pageValue` 也会同时变更，页面 `WXML` 中所有绑定了 `pageValue` 的位置也会被一同更新。



#### 基础组件

框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考 [组件文档](https://developers.weixin.qq.com/miniprogram/dev/component/)。

什么是组件：

- 组件是视图层的基本组成单元。
- 组件自带一些功能以及与微信风格一致的样式。
- 一个组件通常包括开始标签和结束标签，其属性用来修饰这个组件，其内容在两个标签之内。

```html
<tagname property="value">
	Content goes here ...
</tagname>
```

**注意：所有组件与属性都是小写，以连字符 `-` 连接**

##### 属性类型

|      类型      |      描述      | 注解                                                         |
| :------------: | :------------: | :----------------------------------------------------------- |
|   `Boolean`    |     布尔值     | 组件写上该属性，不管是什么值都被当作 `true`；只有组件上没有该属性时，属性值才为 `false`。 如果属性值为变量，变量的值会被转换为 `Boolean` 类型 |
|    `Number`    |      数字      | `1`，`2.5`                                                   |
|    `String`    |     字符串     | `"string"`                                                   |
|    `Array`     |      数组      | `[ 1, "string" ]`                                            |
|    `Object`    |      对象      | `{ key: value }`                                             |
| `EventHandler` | 事件处理函数名 | `"handlerName"` 是 [`Page`](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html) 中定义的事件处理函数名 |
|     `Any`      |    任意属性    |                                                              |

##### 公共属性

所有组件都有以下属性：

|      属性名      |      类型      |      描述      | 注解                                                         |
| :--------------: | :------------: | :------------: | :----------------------------------------------------------- |
|       `id`       |    `String`    | 组件的唯一标示 | 保持整个页面唯一                                             |
|     `class`      |    `String`    | 组件的样式类名 | 在对应的 `WXSS` 中定义的样式类名                             |
|     `style`      |    `String`    | 组件的内联样式 | 可以动态设置的内联样式                                       |
|     `hidden`     |   `Boolean`    |  组件是否显示  | 所有组件默认显示                                             |
|     `data-*`     |     `Any`      |   自定义属性   | 组件上触发事件时，会发送给事件处理函数                       |
| `bind* / catch*` | `EventHandler` | 组件的事件属性 | 详见 [事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) |

##### 特殊属性

几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，详细请参考各个 [组件](https://developers.weixin.qq.com/miniprogram/dev/component/) 的定义。



#### 节点信息



#### 显示区域



#### 分栏模式



#### 动画



#### 初始渲染缓存





### 逻辑层



#### 注册程序



#### 注册页面



#### 页面生命周期



#### 页面路由



#### 模块化



#### `API`





### 场景值



### 框架接口





