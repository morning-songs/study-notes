# 符号型

​		`Symbol`（符号）是 `ES6` 新增的数据类型，符号是原始值，它们是唯一的、不可更改的。符号的用途是确保对象的属性使用的是唯一的标识符，对象内部不会发生属性冲突的危险。符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。`Object` 原型上也提供了一些方法，可以更方便地发现符号属性。



### 基本用法

符号没有字面量语法，只能使用`Symbol`函数，创建一个唯一性的符号。

符号描述：

- 创建符号时，可以传入一个字符串参数，来对符号进行描述。【非字符串型的参数会被转换为字符串型】
- 将来可以通过这个描述来调试代码。但是，这个参数与符号定义或标识完全无关，它仅仅是一种描述信息。
- 符号描述只支持字符串型，可通过符号实例的`description`属性查看，属于只读属性。

```js
// 符号没有字面量语法，打印的结果与创建时一样。
let s = Symbol(); // Symbol()
s = Symbol(1); // Symbol(1)
s = Symbol("s"); // Symbol("s");

// 唯一性
let s = Symbol("s"),
    os = Symbol("s");
s === os; // false

// 原始值拷贝
os = s;
s === os; // true

// 符号描述：description只读属性
let s = Symbol(); // s.description === undefined

s = Symbol(1); // s.description === "1"
```

最重要的是，`Symbol`不能与`new`一起使用。因此符号永远都是原始值，它们不允许被`new`包装为符号型对象。

这是因为`Symbol`并不是`constructor`，如果要将符号包装为对象，可借助`Object`函数。

```js
// Symbol不是constructor，不能被new调用执行。
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor

// 借助Object函数，可以将任何类型包装为对象。
typeof Object(Symbol()); // "object"
```



##### 全局注册表

当需要共享和重用符号实例时，可以调用`Symbol.for`方法，在全局的符号注册表中创建一个可重用的符号。

全局注册表：以符号的描述为键。对键执行幂等操作：调用时检查是否存在该键，不存在创建，存在则返回。

注意：符号具有唯一性，在全局注册表中定义的符号与使用`Symbol`定义的符号相互独立，各自唯一。

```js
// 注册或重用全局符号
let s = Symbol.for("s"); // 初次使用该描述调用时，在表中注册一个键并创建符号。
let os = Symbol.for("s"); // 该键已存在于表中，直接返回该键对应的符号。
s === os; // true，重用同一个符号。

// 全局注册表中定义的符号与Symbol定义的符号。
let s = Symbol("s"),
    os = Symbol.for("s");
s === os; // false
```

查询全局注册表：使用`Symbol.keyFor`方法来查询注册表，传入符号来查询该符号在表中对应的键。

```js
// 全局符号：返回对应的键
let s = Symbol.for("s");
Symbol.keyFor(s); // "s"

// 普通符号：返回undefined
let os = Symbol("s");
Symbol.keyFor(os); // undefined
```



##### 符号属性

凡是可以使用字符串或数值作为属性的地方，都可以使用符号来代替。

场景：包括对象字面量属性、`defineProperty`和`defineProperties`定义的属性。

注释：因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。

```js
// 对象字面量只能在计算属性语法中使用符号作为属性，通常用[]包裹。
let s1 = Symbol("s1"),
    s2 = Symbol("s2"),
    s3 = Symbol("s3"),
    s4 = Symbol("s4");

let o = {
    a: "a",
    [s1]: "s1"
}

o[s1]; // "s1"，调用时，也要用[]的方式访问。


// 使用Object.defineProperty定义对象的属性。
Object.defineProperty(o, s2, {
    value: "s2"
})

// 使用Object.defineProperties定义对象的属性。
Object.defineProperties(o, {
    [s3]: {
        value: "s3"
    },
    [s4]: {
        value: "s4"
    }
})
```

**查看对象属性**：【符号属性对于循环来说是不可见的】

- 常规属性：使用`Object.getOwnPropertyNames()`方法，返回对象上的常规属性【数组】。
- 符号属性：使用`Object.getOwnPropertySymbols()`方法，返回对象上的符号属性【数组】。
- 所有属性：使用`Reflect.ownKeys()`方法，返回对象上的常规属性和符号属性【数组】。
- 描述符对象：使用`Object.getOwnPropertyDescriptors()`方法，返回对象上常规属性和符号属性的描述符【对象】。

```js
let s1 = Symbol("s1"),
    s2 = Symbol("s2");

let o = {
    a: "a",
    b: "b",
    [s1]: "s1",
    [s2]: "s2"
}

// 获取常规属性
Object.getOwnPropertyNames(o); // ["a", "b"]

// 获取符号属性
Object.getOwnPropertySymbols(o); // [Symbol(s1), Symbol(s2)]

// 获取所有属性
Reflect.ownKeys(o); // ['a', 'b', Symbol(s1), Symbol(s2)]

// 获取描述符对象
Object.getOwnPropertyDescriptors(o); // {a: {…}, b: {…}, Symbol(s1): {…}, Symbol(s2): {…}}

// 遍历属性：符号属性对循环不可见
let o = {
    [Symbol('foo')]: 'foo val', 
 	[Symbol('bar')]: 'bar val',
    a: 1
}

for (const key in o) {
    console.log(key); // "a"
}
```



### 内置符号

`ES 6` 引入了一批常用内置符号，以 `Symbol` 工厂函数字符串属性的形式存在。

这些内置符号最重要的用途之一就是重新定义它们，从而改变原生结构的行为。

比如，`for-of` 循环会在相关对象上使用 `Symbol.iterator` 属性。

那么就可以通过在自定义对象上重新定义 `Symbol.iterator` 的值，来改变 `for-of` 在迭代该对象时的行为。

注意：所有内置符号属性都是不可写、不可枚举、不可配置的。但可以修改它们的值来改变原生的行为。

引用简写：在 `ECMAScript` 规范中，经常会引用符号，前缀为`@@`。比如，`@@iterator` 指的就是 `Symbol.iterator`。



##### 异步迭代器

**`Symbol.asyncIterator`** 符号表示实现异步迭代器 `API` 的函数。

注释：

- 该方法返回对象默认的 `AsyncIterator`（异步迭代器），由 `for-await-of` 语句使用。

- `for-await-of` 循环会利用这个函数执行异步迭代操作。
- 循环时，它们会调用 `Symbol.asyncIterator`属性中的函数，并期望返回一个实现迭代器 `API` 的对象。
- 很多时候，返回的对象是实现该异步迭代器 `API`的 `AsyncGenerator`。【`AsyncGenerator`：异步生成器】

```js
class Foo { 
 	async *[Symbol.asyncIterator]() {} 
} 

let f = new Foo(); 
console.log(f[Symbol.asyncIterator]()); 
// AsyncGenerator {<suspended>}
```

技术上，这个由 `Symbol.asyncIterator` 函数生成的对象应该通过其 `next()`方法陆续返回`Promise` 实例。

可以通过显式地调用 `next()` 方法返回，也可以隐式地通过异步生成器函数返回。



##### 对象实例认可

**`Symbol.hasInstance`** 符号，用于判断一个对象是否是由指定的构造器构造出来的（决定构造器是否认可该对象是它的实例）。

该方法由`instanceof`操作符使用，`instanceof` 操作符可以用来确定一个对象实例的原型链上是否具有指定的原型。

注释：

- 在 `ES6` 中，`instanceof` 操作符会使用 `Symbol.hasInstance` 函数来确定关系。
- 直接通过构造器执行 `Symbol.hasInstance` 方法，也可以得到同样的效果，只是对调了一下操作数。
- 这个符号属性定义在 `Function` 的原型上，因此默认在所有函数和类上都可以调用。

```js
function Foo() {} 
let f = new Foo(); 
console.log(Foo[Symbol.hasInstance](f)); // true 

class Bar {} 
let b = new Bar(); 
console.log(Bar[Symbol.hasInstance](b)); // true
```

由于`instanceof`操作符会自动在原型链上寻找对这个属性的定义，就跟在原型链上寻找其他属性一样。

因此，可以在继承的类上通过静态方法重新定义这个函数：

```js
class Bar {} 
class Baz extends Bar { 
	// 重写静态方法：当通过该符号属性的方法判断Baz与Bar的关系时，返回false
	static [Symbol.hasInstance]() { 
		return false; 
	} 
} 

let b = new Baz(); 
// 判断Baz的实例时，正常返回
console.log(Bar[Symbol.hasInstance](b)); // true 
console.log(b instanceof Bar); // true 
// 判断Baz构造器时，返回false
console.log(Baz[Symbol.hasInstance](b)); // false 
console.log(b instanceof Baz); // false
```



##### 是否展开数组

**`Symbol.isConcatSpreadable`** 符号是一个布尔值属性，用于决定在执行`concat`方法时是否展开参数数组或类数组中的元素。

数组对象默认情况下会被打平到已有的数组，类数组对象默认情况下会整个被追加到数组末尾。

- `false` 或假值会将整个数组或类数组直接被追加到数组的末尾。

- `true` 或真值会导致数组或类数组中的所有元素被打平到数组中。

- 非数组或非类数组对象不允许被 展开 / 打平。

注意：类数组中的元素指的是以数字下标为属性的值且具有数组的严格顺序，非数字属性不是类数组的元素。

另外，**`Symbol.isConcatSpreadable`** 符号属性的初始值是`undefined`。【`spread`：展开】

```js
let init = [0],
    arr = [1, 2, 3],
    obj = {
        0: 1,
        1: 2,
        3: 4, // 类数组中的元素具有严格的下标顺序，没定义的元素默认为empty。
        a: "a", // 非数字属性，不是类数组元素，作为内置属性来使用。
        length: 4 // 必须存在类数组的关键性属性：length。length一般应只反映元素的个数（包括空缺的元素）。
    };

// 默认情况下，展开参数数组中的元素。
init.concat(arr); // [0, 1, 2, 3]

// 默认情况下，不展开类数组中的元素。
init.concat(obj); // [0, {0: 1, length: 1}]

// 允许在该类数组被concat连接时，展开其中的所有元素（只包括数字属性）。
obj[Symbol.isConcatSpreadable] = true;
init.concat(obj); // [0, 1, 2, empty, 4]

// 将整个数组连接到末尾，并添加该符号属性。
arr[Symbol.isConcatSpreadable] = false;
init.concat(arr); // [0, [1, 2, 3]]
```



##### 迭代器

**`Symbol.iterator`** 符号是一个方法，表示实现迭代器 `API` 的函数。

注释：

- 该方法返回对象默认的迭代器。由 `for-of` 语句使用。
- `for-of` 循环这样的语言结构会利用这个函数执行迭代操作。
- 循环时，它们会调用以 `Symbol.iterator` 为键的函数，并默认这个函数会返回一个实现迭代器 `API` 的对象。
- 很多时候，返回的对象是实现该 `API` 的 `Generator`。

```js
class Foo { 
 	*[Symbol.iterator]() {} 
} 

let f = new Foo(); 
console.log(f[Symbol.iterator]()); 
// Generator {<suspended>}
```



##### 匹配字符串

**`Symbol.match`** 符号是一个正则表达式方法，该方法用正则表达式去匹配字符串。由 `String.prototype.match()`方法使用。

注释：

- `String.prototype.match()`方法会使用 `Symbol.match` 属性中的函数来对正则表达式求值。
- 正则表达式的原型上默认有这个符号函数的定义，因此所有正则表达式实例默认是这个 `String` 方法的有效参数。
- 给这个方法传入非正则表达式值会导致该值被转换为 `RegExp` 对象。
- `Symbol.match` 函数接收一个参数，就是调用 `match()` 方法的字符串实例。

```js
// 正则表达式原型上定义了该方法
console.log(RegExp.prototype[Symbol.match]); 
// ƒ [Symbol.match]() { [native code] }

// 使用includes重写Symbol.match方法，让其使用字符串实例。
class FooMatcher { 
	static [Symbol.match](target) { 
     	return target.includes('foo'); 
	} 
} 
console.log('foobar'.match(FooMatcher)); // true 
console.log('barbaz'.match(FooMatcher)); // false 

class StringMatcher { 
	constructor(str) { 
		this.str = str; 
	} 
    
	[Symbol.match](target) { 
		return target.includes(this.str); 
	} 
} 
console.log('foobar'.match(new StringMatcher('foo'))); // true 
console.log('barbaz'.match(new StringMatcher('qux'))); // false
```



##### 替换字符串

**`Symbol.replace`** 符号是一个正则表达式方法，用于替换一个字符串中匹配到的子串。由 `String.prototype.replace()`方法使用。

注释：

- `String.prototype.replace()` 方法会使用以 `Symbol.replace` 为键的函数来对正则表达式求值。
- 正则表达式的原型上默认有这个函数的定义，给这个方法传入非正则表达式值会导致该值被转换为 `RegExp` 对象。
- `Symbol.replace` 函数接收两个参数，即调用 `replace()` 方法的字符串实例和替换字符串。

```js
// 使用split和join重写Symbol.replace方法
class FooReplacer { 
	static [Symbol.replace](target, replacement) { 
		return target.split('foo').join(replacement); 
	} 
} 
console.log('barfoobaz'.replace(FooReplacer, 'qux')); 
// "barquxbaz" 

class StringReplacer { 
	constructor(str) { 
		this.str = str; 
	} 
    
	[Symbol.replace](target, replacement) { 
		return target.split(this.str).join(replacement); 
	} 
} 
console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')); 
// "barquxbaz"
```



##### 搜索子串下标

 **`Symbol.search`** 符号是一个正则表达式方法，用于在字符串中匹配指定子串的索引。由 `String.prototype.search()`方法使用。

注释：

- `String.prototype.search()` 方法会使用以 `Symbol.search` 为键的函数来对正则表达式求值。
- 正则表达式的原型上默认有这个函数的定义，给这个方法传入非正则表达式值会导致该值被转换为 `RegExp` 对象。
- `Symbol.search` 函数接收一个参数，就是调用 `search()` 方法的字符串实例。

```js
// 使用indexOf重写Symbol.search方法
class FooSearcher { 
	static [Symbol.search](target) { 
		return target.indexOf('foo'); 
	} 
} 
console.log('foobar'.search(FooSearcher)); // 0 
console.log('barfoo'.search(FooSearcher)); // 3 
console.log('barbaz'.search(FooSearcher)); // -1 

class StringSearcher { 
	constructor(str) { 
		this.str = str; 
	} 
    
	[Symbol.search](target) { 
		return target.indexOf(this.str); 
	} 
} 
console.log('foobar'.search(new StringSearcher('foo'))); // 0 
console.log('barfoo'.search(new StringSearcher('foo'))); // 3 
console.log('barbaz'.search(new StringSearcher('qux'))); // -1
```



##### 构造派生对象

**`Symbol.species`** 符号是一个函数值，表示创建派生对象的构造函数。【`species`：种类，物种】

这个符号属性在内置的数据类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。

用 `Symbol.species` 定义静态的获取器（`getter`）方法，可以覆盖新创建实例的原型定义：

```js
class Bar extends Array {} 
class Baz extends Array { 
    // 重写get方法，当其创建的实例被修改时触发。
	static get [Symbol.species]() { 
		return Array; // 将原型修改为Array，主要针对instanceof操作符的检测。
	} 
} 

let bar = new Bar(); 
console.log(bar instanceof Array); // true 
console.log(bar instanceof Bar); // true 
bar = bar.concat('bar'); 
console.log(bar); // Bar ['bar']
console.log(bar instanceof Array); // true 
console.log(bar instanceof Bar); // true 

let baz = new Baz(); 
console.log(baz instanceof Array); // true 
console.log(baz instanceof Baz); // true 
baz = baz.concat('baz'); // 添加元素之后，将原型修改为指定值。
console.log(baz); // ['baz'] <==> Array ['baz']
console.log(baz instanceof Array); // true 
console.log(baz instanceof Baz); // false
```



##### 拆分字符串

**`Symbol.split`** 符号是一个正则表达式方法，用于在匹配子串的索引位置拆分字符串。由 `String.prototype.split()` 方法使用。

注释：

- `String.prototype.split()`方法会使用以 `Symbol.split` 为键的函数来对正则表达式求值。
- 正则表达式的原型上默认有这个函数的定义，给这个方法传入非正则表达式值会导致该值被转换为 `RegExp` 对象。
- `Symbol.split` 函数接收一个参数，就是调用 `split()` 方法的字符串实例。

```js
// 使用split重写Symbol.split方法
class FooSplitter { 
	static [Symbol.split](target) { 
		return target.split('foo'); // 按指定的字符片段将字符串切割为数组。
	} 
} 
console.log('barfoobaz'.split(FooSplitter)); // ["bar", "baz"]
 
class StringSplitter { 
	constructor(str) { 
		this.str = str; 
	} 
    
	[Symbol.split](target) { 
		return target.split(this.str); 
	} 
} 
console.log('barfoobaz'.split(new StringSplitter('foo'))); // ["bar", "baz"]
```



##### 转为原始值

 **`Symbol.toPrimitive`** 符号是一个方法，用于将对象转换为相应的原始值。由 `ToPrimitive`  抽象操作使用。

注释：

- 很多内置操作符都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。【隐式转换】
- 对于一个自定义的对象实例，通过在这个实例的 `Symbol.toPrimitive` 属性上定义一个函数可以改变默认行为。
- 根据提供给这个函数的参数（`string`、`number` 或 `default`），可以控制返回的原始值：

```js
class Foo {} 
let foo = new Foo(); 
console.log(3 + foo); // "3[object Object]" 
console.log(3 - foo); // NaN 
console.log(String(foo)); // "[object Object]" 

class Bar { 
	constructor() { 
        // 在对象实例上添加Symbol.toPrimitive方法，控制返回的原始值。
		this[Symbol.toPrimitive] = function(hint) { 
            // 参数为要被转换的类型，支持string和number，其余类型均为default。
			switch (hint) { 
				case 'number': 
					return 3; 
				case 'string': 
					return 'string bar'; 
				case 'default': 
				default: 
				return 'default bar'; 
			} 
		} 
	} 
}

let bar = new Bar(); 
console.log(3 + bar); // "3default bar"【加号有两种运算模式，不好区分，所以选择默认类型】 
console.log(3 - bar); // 0 
console.log(String(bar)); // "string bar"
```



##### 字符串表示

**`Symbol.toStringTag`** 符号用于创建对象的默认字符串描述。由内置方法 `Object.prototype.toString()` 使用。

注释：

- 通过 `toString()` 方法获取对象标识时，会检索由 `Symbol.toStringTag` 指定的实例标识符，默认为 `"Object"`。
- 内置类型已经指定了这个值，但自定义的类实例还需要明确定义：

```js
// 内置类型实例
let s = new Set(); 
console.log(s); // Set(0) {} 
console.log(s.toString()); // [object Set] 
console.log(s[Symbol.toStringTag]); // Set 

// 自定义类实例，未指定时为默认的字符串描述
class Foo {} 
let foo = new Foo(); 
console.log(foo); // Foo {} 
console.log(foo.toString()); // [object Object] 
console.log(foo[Symbol.toStringTag]); // undefined 

// 自定义类实例，指定字符串描述
class Bar { 
	constructor() { 
		this[Symbol.toStringTag] = 'Bar'; 
	} 
} 
let bar = new Bar(); 
console.log(bar); // Bar {} 
console.log(bar.toString()); // [object Bar] 
console.log(bar[Symbol.toStringTag]); // Bar
```



##### 禁止`with`访问

**`Symbol.unscopables`** 符号是一个对象，该对象所有的以及继承的属性，都会从关联对象的 `with` 环境绑定中排除。

注释：为关联对象设置该符号属性并将其属性的值设为 `true`时，就可以阻止这些属性出现在 `with` 环境绑定中。

```js
let o = { foo: 'bar' }; 

// 未阻止访问时，在with环境中可访问关联对象的所有属性。
with (o) { 
	console.log(foo); // bar 
} 

// 配置Symbol.unscopables属性，使对象中的属性在with中不可见。
o[Symbol.unscopables] = { 
	foo: true // true值不是必须的，因为该对象中的所有属性（包括继承的属性）都会被阻止。
}; 

with (o) { 
	console.log(foo); // ReferenceError：foo is not defined
}
```

注意：由于根本不推荐使用 `with`，因此也不推荐使用 `Symbol.unscopables`。