# 链表

当在数组中插入和删除元素时，会导致其后的所有元素重新排序。如果不希望引起后续的元素重排序，则可以使用链表。因为链表不是以数字排序的，它没有顺序上的连续性，而是通过一个个结点链接而成的。每个结点都可通过一个关系（即：指针）指向下一个结点。



### 定义

链表（`linked list`）是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749?fromModule=lemma_inlink)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782?fromModule=lemma_inlink)，[数据元素](https://baike.baidu.com/item/数据元素/715313?fromModule=lemma_inlink)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素?fromModule=lemma_inlink)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域。 相比于[线性表](https://baike.baidu.com/item/线性表/3228081?fromModule=lemma_inlink)[顺序结构](https://baike.baidu.com/item/顺序结构/9845234?fromModule=lemma_inlink)，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到 `O(1)` 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 `O(n)` 的时间，而线性表和顺序表相应的时间复杂度分别是 `O(logn)` 和 `O(1)`。

使用链表结构可以克服[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)随机读取的优点，同时链表由于增加了结点的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域，空间开销比较大。链表最明显的好处就是，常规[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)排列关联项目的方式可能不同于这些数据项目在[记忆体](https://baike.baidu.com/item/记忆体/3029693?fromModule=lemma_inlink)或[磁盘](https://baike.baidu.com/item/磁盘/2842227?fromModule=lemma_inlink)上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的[节点](https://baike.baidu.com/item/节点/865052?fromModule=lemma_inlink)，但是不允许[随机存取](https://baike.baidu.com/item/随机存取/4610937?fromModule=lemma_inlink)。链表有很多种不同的类型：[单向链表](https://baike.baidu.com/item/单向链表/8671935?fromModule=lemma_inlink)，[双向链表](https://baike.baidu.com/item/双向链表/2968731?fromModule=lemma_inlink)以及[循环链表](https://baike.baidu.com/item/循环链表/3228465?fromModule=lemma_inlink)。链表可以在多种编程语言中实现。像 `Lisp` 和 `Scheme` 这样的语言的内建[数据类型](https://baike.baidu.com/item/数据类型/10997964?fromModule=lemma_inlink)中就包含了链表的存取和操作。程序语言或[面向对象语言](https://baike.baidu.com/item/面向对象语言?fromModule=lemma_inlink)，如 `C`、`C++` 和 `Java` 依靠易变工具来生成链表。



### 实现

##### 单向链表

```js
const LinkedList = (function() {
    // 创建数据结点
    class DataNode {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.next = null; 	// 下一结点
        }
    }
    // 链头
    const HEAD = Symbol("head");
    // 创建链表结构
    return class LinkedList {
        constructor() {
            this[HEAD] = null;
            this.size = 0;
        }
        // 添加结点
        append(data) {
            this.size++;
            // 根据数据，生成结点。
            const node = new DataNode(data); 
            let target = this[HEAD];
            // 无链头时，设置链头。
            if(!target) {
                return this[HEAD] = node; 
            }
            // 有链头时，寻找链尾。
            while(target.next) {
                target = target.next;
            }
            // 找到链尾，链接链尾。
            return target.next = node;
        }
        // 查找结点
        find(index) {
            let target = this[HEAD];
            while(target && index-- > 0) {
                target = target.next;
            }
            return target;
        }
        // 插入结点：在指定的位置上插入
        insert(index, data) {
            const node = new DataNode(data);
            let prevNode = null,
                nextNode = null;
            if(index < 1) {
                nextNode = this[HEAD];
                this[HEAD] = node;
            } else {
                prevNode = this.find(index - 1);
                if(!prevNode) return console.warn(index + " 已超出界限");
                nextNode = prevNode.next;
                prevNode.next = node;
            }
            node.next = nextNode;
            this.size++;
        }
        // 插入结点：在指定的结点后插入
        insertByData(oldData, newData) {
            const node = new DataNode(newData);
            let target = this[HEAD];
            while(target.data !== oldData) {
                target = target.next;
                if(!target) return console.warn("链表中不存在指定的数据");
            }
            let nextNode = target.next;
            target.next = node;
            node.next = nextNode;
            this.size++;
        }
        // 删除结点：在指定的位置上删除
        remove(index) {
            const prevNode = this.find(index - 1);
            if (!prevNode || !prevNode.next) return console.warn(index + " 已超出边界");
            if (index < 1) {
                this[HEAD] = this[HEAD].next;
            } else {
                prevNode.next = prevNode.next.next;
            }
            this.size--;
        }
        // 删除结点：在指定的结点处删除
        removeByData(data) {
            let target = this[HEAD];
            if(target.data === data) {
                this.size--;
                return this[HEAD] = target.next;
            }
            while(target.next) {
                if(target.next.data === data) {
                    this.size--;
                    return target.next = target.next.next;
                }
                target = target.next;
            }
        }
        // 打印链表
        print() {
            let target = this[HEAD];
            while(target) {
                console.log(target.data);
                target = target.next;
            }
        }
    }
})();
```

使用

```js
let linkedList = new LinkedList();

linkedList.append(1);
linkedList.append(2);
linkedList.append(3);

console.log(linkedList.find(0)); // DataNode {data: 1, next: DataNode}
console.log(linkedList.find(1)); // DataNode {data: 2, next: DataNode}
console.log(linkedList.find(2)); // DataNode {data: 3, next: null}

linkedList.insert(3, 0);
linkedList.insertByData(3, 4);

linkedList.insert(6, 0); 		// "6 已超出界限"
linkedList.insertByData(5, 4); 	// "链表中不存在指定的数据"

linkedList.remove(1);
linkedList.removeByData(4);

linkedList.remove(6); 		// "6 已超出界限"
linkedList.removeByData(5); // 静默失败

console.log(linkedList.size); // 3
```

##### 循环链表

循环链表，就是指将链表的首尾相连 —— 链尾指回链头。

##### 双向链表

双向链表（`double linked list`），就是在结点中增加指向前一个结点的指针，使一个结点可以轻松地找到前后的结点。

```js
const DoubleLinkedList = (function () {
    class DataNode {
        constructor(data, link) {
            this.data = data; 	// 当前结点的数据
            this.prev = null;	// 上一结点
            this.next = null; 	// 下一结点
            this.link = link;   // 当前链表
        }
        // 在当前结点前插入新结点
        insertBefore(data) {
            const node = new DataNode(data, this.link),
                  prev = this.prev;
            if (prev) {
                prev.next = node;
                node.prev = prev;
            } else {
                this.link[HEAD] = node;
            }
            node.next = this;
            this.prev = node;
            this.link.size++;
            return node;
        }
        // 在当前结点后插入新结点
        insertAfter(data) {
            const node = new DataNode(data, this.link),
                  next = this.next;
            if (next) {
                node.next = next;
                next.prev = node;
            } else {
                this.link[FOOT] = node;
            }
            node.prev = this;
            this.next = node;
            this.link.size++;
            return node;
        }
        // 删除自身
        remove() {
            const prev = this.prev,
                  next = this.next;
            // 移除链头，更新链头
            if(!prev) this.link[HEAD] = next; 
            // 移除链尾，更新链尾
            if(!next) this.link[FOOT] = prev;
            prev && (prev.next = next); // 重置前结点、新链尾的next
            next && (next.prev = prev); // 重置后结点、新链头的prev
            this.link.size--;
        }
    }
    const HEAD = Symbol("head"),
          FOOT = Symbol("foot");
    return class DoubleLinkedList {
        constructor() {
            this[HEAD] = null;
            this[FOOT] = null;
            this.size = 0;
        }
        // 添加结点
        append(data) {
            const node = new DataNode(data, this);
            if (this[FOOT]) {
                // 有链尾时，接入链尾。
                node.prev = this[FOOT];
                this[FOOT].next = node;
            } else {
                // 无链尾时，也无链头。
                this[HEAD] = node;
            }
            this[FOOT] = node; // 更新链尾
            this.size++;
            return node;
        }
        // 打印链表
        print() {
            let target = this[HEAD];
            while (target) {
                console.log(target.data);
                target = target.next;
            }
        }
    }
})();
```

使用

```js
const doubleLinkedList = new DoubleLinkedList();

let j = doubleLinkedList.append("甲");
let y = doubleLinkedList.append("乙");
let b = doubleLinkedList.append("丙");

let d = y.insertBefore("丁");
let w = y.insertAfter("戊");

d.insertBefore("己");
d.insertAfter("庚");

w.insertBefore("壬");
w.insertAfter("癸");

j.remove();
b.remove();

console.log(doubleLinkedList); // 7
```

