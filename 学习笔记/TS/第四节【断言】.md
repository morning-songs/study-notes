# 类型断言

### `never` 类型

`never` 类型的值，表示：“永远不存在的值”，或“永远获取不到的值”。

常发生在死循环和无限递归等场景中，它们大多都是因为永远获取不到一个临界值（终止值或开关），而永远得不到终止。

另外，由于 `JS` 是单线程执行的。因此一旦同步执行发生错误，就会立即终止程序，那么后面的代码也会永远得不到结果。

```tsx
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {}
}
```

`never` 类型常用于排除错误，它是所有类型的子类型（即：可以赋值给任何类型）。但是，`never` 类型的变量只接受 `never` 类型的值，即使是 `any` 类型也不可以。

```tsx
// 注意：never类型没有字面量，并且在异常后程序通常会终止，因此会很少使用它。
let ne: never;

function error(message: string): never {
    throw new Error(message);
}

ne = error('终止程序，以获得一个never类型的值'); // 赋给一个never类型的值
```



### `unknown` 类型

`TypeScript 3.0` 引入了一个顶级的 `unknown` 类型。 对照于 `any`，`unknown` 是类型安全的。 任何值都可以赋给 `unknown`，但是当没有类型断言或基于控制流的类型细化时 `unknown` 不可以赋值给其它类型，除了它自己和 `any` 外。 同样地，在 `unknown` 没有被断言或细化到一个确切类型之前，是不允许在其上进行任何操作的。

##### `any` 的问题

由于 `any` 类型能够兼容所有的类型。因此 `any` 类型的变量可以存储所有类型的值。而变量一旦被定义成了 `any` 类型，那么它就会失去类型检查机制（编译或赋值时都不会检查其值类型）。因此 `any` 型变量又可以赋给几乎所有类型的变量，除了 `never` 等特殊的类型外。

```tsx
// any类型的变量可以存储所有类型的值
let an: any = 1;
an = '丸子';
an = true;

// any型变量也可以赋给除never外的其他类型的变量
let num: number = an;
let str: string = an;
let obj: object = an;
```

无论是在交换两个变量的值，还是在引用另一个变量的值时，`TS` 的类型检查机制都会首先确定：“要赋的值是否符合变量的类型要求”，只有当类型符合时，才会将该值赋给指定的变量。

```tsx
let a: number | string;

a = 1;

let b: number | boolean = a; // 值为number型，符合变量的类型要求，允许赋值。

a = 'a';

let c: string | array = a;	 // 值为string型，符合变量的类型要求，允许赋值。
```

而这对于已经失去了类型检查机制的 `any` 型变量来说，在赋值时不会检查它的值类型，所以它的值可以轻松地被几乎所有类型的变量所引用（`never` 等特殊类型除外）。

这样就会带来一种奇特的怪象（“原先看似不合理的操作，实际上都得到了合理的执行”），它使得 `any` 类型的变量几乎完全如同 `JS` 的变量一样随心所欲，肆意破坏类型保护机制。

```tsx
let an: any = 1; // 注意：此时，an的值为number型，但an变量始终为any型。变量的类型不会随着值类型的变化而变化。

// any型变量可以赋给其他类型的变量，尽管它存储的值类型不合规定。
let num: number = an;
let str: string = an;
let obj: object = an;

console.log(typeof num); // 'number'
console.log(typeof str); // 'number'
console.log(typeof obj); // 'number'
```

而 `unknown` 类型（不定型，未知型），正是为了弥补 `any` 类型的这些缺陷所设计出来的，虽然它也不尽完美。

##### `unknown` 型

首先，`unknown` 型数据也可以赋值给 `any` 型变量。除此之外，它只能赋值给 `unknown` 型变量。不过，能够赋值给 `any` 型变量的数据也都可以赋值给 `unknown` 型变量。

```tsx
let un: unknown;

// 能够赋值给any型变量的数据也都可以赋值给unknown型变量
un = 1;
un = 'a';
un = [];

// unknown型变量只能赋值给同类型或any的型变量（亮点所在）
let an: any = un;
```

`unknown` 型变量，因为其类型不明确或未知，所以它们只能赋值给同类型或 `any` 的型变量。这正是它较之 `any` 型变量的亮点所在。

```tsx
// 将unknown型变量赋值给其他类型，会导致报错。进一步杜绝了变量保存不合变量类型要求的值。
let un: unknown = 1;

// 尽管已知值类型符合变量的类型要求，也不允许将unknown型变量赋值给number型变量。
let num: number = un; // Type 'unknown' is not assignable to type 'number'.
```

**注意**：在严格模式下，大多数类型的变量在使用前都必须要先进行赋值。但这些类型是例外：`undefined`、`void`、`any` 和 `unknown`。



### 类型断言

类型断言：就是将对某个值的类型检查任务交给程序员，由程序员推断并告诉 `TS` 该值的类型，进而阻止 `TS` 去猜测这个值的类型。因为，有时候你会比 `TypeScript` 更加了解某个值的详细信息。通过类型断言这种方式可以告诉编译器：“相信我，我知道自己在干什么”。 

类型断言没有运行时的影响，只是在编译阶段起作用。 `TS` 会假设程序员，已经对数据进行了必要的检查，并相信程序员的推断结果。

更重要的一点是，`TS` 只负责编译，不负责执行。`TS` 只将 `ts` 文件编译成 `js` 文件，而执行 `js` 文件的是机器。因此，`TS` 所有的类型约束和类型检查都只发生在编译期，它没有执行期（实际上，`TS` 目前也只有编译器，而没有执行器。它自身都是使用 `JS` 开发的）。

因此，如果某些表达式的结果在编译期无法确定，只能等待它被执行后才能得到结果的话，`TS` 就会预先提醒潜在的类型安全危险。

```tsx
// 因此，TS只能做静态的类型检查。
let arr: number[] = [1, 2, 3, 4];

// 找出arr中第一个大于2的元素，并将其赋值给num
let num: number = arr.find(i => i > 2); // Type 'number | undefined' is not assignable to type 'number'.
```

上面这段代码看起来没有问题，但实际上它在书写完就会报出错误。因为，`num` 变量的值是一个表达式，而这个表达式只能在执行后才知道其结果。`TS` 获取不到表达式的结果，就将其推论为 `undefined`。而这样，便会因为值类型与变量类型不匹配而提示类型错误。

要解决这个问题，只需告诉 `TS` 的类型检查机制，这个表达式的值类型即可。然后在 `TS` 编译时，它就会使用这个类型去匹配变量类型。

在需要自己断言的值后面，使用一个 `as` 关键字加上断言的类型，来告诉 `TS` 你对该值类型的断言结果。

```tsx
let arr: number[] = [1, 2, 3, 4];

// 断言arr.find(i => i > 2)表达式的值类型为number类型
let num: number = arr.find(i => i > 2) as number;

// 类型断言，还有一种不推荐的写法：在值前面使用<类型>
let num: number = <number>arr.find(i => i > 2);
```

注意：类型断言只能用在 `TS` 的类型推论机制无法明确一个值的类型的情况。当 `TS` 已经明确知道该值的类型时，还试图使用类型断言去蒙骗它，会被认为是“有意的行为”，这会引发编译错误。因此，不要滥用类型断言。

```tsx
// 禁止的行为
let num: number = '1' as number; // Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.

// 允许的行为
let num: number = 100 as number;
```

实际上，`TS` 对大多数的表达式都会提前获取其结果以推断值类型。但对于调用 `API` 或函数获取结果的表达式，可能无法获取到结果。

```tsx
// 编译报错
let num: number;

// 调用函数或方法
function fn() {
    num = 30;
};
fn();

console.log(num); // Variable 'num' is used before being assigned.
```

当值是通过调用函数或方法 `API` 的方式获取而来时，`TS` 会因为没有执行能力而获取不到结果，然后选择忽略一切方法和函数的调用。

```tsx
// 但TS能够获取自执行函数表达式的结果，因为内部的函数已经被转换成了普通的表达式。
let num: number;

// 自执行的函数表达式
(function () {
    num = 30;
})();

console.log(num); // 30
```

##### `JS` 迁移

当想要将使用 `JS` 代码开发的项目升级或迁移到 `TS` 时，要特别留意类型方面的注意事项。比如下面的 `JS` 代码。

```js
let person = {};

person.name = 'wanzi';
person.age = 16;
```

上面代码在 `JS` 中没有任何问题，但在 `TS` 中，类型推论机制不会将 `{}` 推论为 `object` 类型，而是直接将其视作一种 `{}` 类型。然后该类型会因为没有 `name` 和 `age` 等用户自定义的属性而报错。此时，就可以给它应用类型断言，将其断言为对象类型。

```tsx
// 初始化时给一个空对象，后续再向其中添加属性。
let person = {} as {name: string, age: number};

console.log(person); // {}

// 后续只能添加已知的属性，但它们都已经不是必须的了。
person.name = 'wanzi';

console.log(person); // {name: 'wanzi'}
```

如果直接对变量进行类型注解，那么每个指定的属性都是必须设置的。而这也正是类型断言比类型注解更灵活的地方。

```tsx
// 注解的每个属性都是必须的，且初始化值必须符合要求
let person: {name: string, age: number} = {
    name: 'wanzi',
    age: 16
};
```

关于迁移，更多参考：[`JavaScript` 迁移](https://www.tslang.cn/docs/handbook/migrating-from-javascript.html) 

##### 非空断言

`ES8` 支持在调用 `API` 时，在 `.` 的前面使用 `?` 来判断调用者是否有意义（即：不为 `undefined` 或 `null`）。只有当意义时，才会调用相应的 `API`；即使没有意义，也只会返回 `undefined`，从而避免了无意义的报错。

```js
let arr; // 值为undefined

// 如果直接对其调用pop，则会发生类型错误。
arr.pop(); // Uncaught TypeError: Cannot read properties of undefined (reading 'push')

// 而对其使用可选链运算符(?)就能避免报错。
arr?.pop(); // undefined
```

`TS` 则通过一个 `!` 来支持非空断言，即：断言某个值一定不是空类型（此处指 `undefined` 型或 `null` 型），以打消 `TS` 的类型顾虑。

```tsx
// 值域中包含undefined和null类型，则使用前必须保证它一定有意义。
let str: string | undefined | null;

// 因为str还没有指定具体的值，所以其值类型是不明确的。
// 则TS会因为该值的类型可能为空值类型，而提示语法错误。
str.toString(); // 'str' is possibly 'null' or 'undefined'.
```

此时，可以使用非空断言来将值类型中的空类型排除在外，使 `TS` 编译器相信该值一定有意义（即使它实际上没有意义）。

```tsx
let str: string | undefined | null;

// 告诉TS该值的类型一定非空，应允许其通过编译。
// 但如果值确实是空值，那么一定会在执行期报错。
str!.toString();
```

虽然使用非空断言使得 `str!.toString()` 通过了编译期，但由于 `str` 的值确实为 `undefined`，所以会在执行期抛出类型错误。

另外，由于非空断言的存在，所以允许变量在严格模式下即使没赋任何值也可以被正常使用。而这，可能会导致意外的情况发生。

```tsx
let str: string;

// 断言该值非空，那么就可以正常使用它
console.log(str!); // undefined

console.log(str!.length); // Cannot read properties of undefined (reading 'length')
```

更多参考：[`TypeScript` 非空断言](https://cloud.tencent.com/developer/article/1610693) 

##### 赋值断言

严格模式下，`TS` 的变量在使用前必须要赋值。然而使用非空断言可以打破这个限制，如前所述。

其实，在非空断言的基础上，还有一种叫赋值断言的语法，即：断言赋给该变量的值一定有意义。

```tsx
// 当TS知道变量的值有意义之后，就不会再严格要求它使用前一定赋值了。
// 这样，对于TS无法调用方法API或函数获取结果的问题便可以得到解决。
let num!: number; // 断言该变量的值一定有意义。

// 调用函数或方法
function fn() {
    num = 30;
};
fn();

console.log(num * 2); // 60
```

当然，使用非空断言也可以解决这个问题。非空断言与赋值断言无异，只是非空断言需要在每次使用时断言，而赋值断言只需断言一次。

```tsx
let num: number;

// 调用函数或方法
function fn() {
    num = 30;
};
fn();

// 在每次使用变量时，都需要进行断言
console.log(num!); 		// 30
console.log(num! * 2); 	// 60
```

尤其是在访问或重写可选属性时，非空断言可以解决其类型纠纷的问题，因为可选属性实际上就是在原有类型上联合一个 `undefined`。

```tsx
interface IT {
    name: string;
    age: number;
    sex?: string;
    info?: {
        a?: number;
        b?: number;
    };
}

let t: IT = {
    name: '',
    age: 0,
    info: {
        a: 1
    }
}

// 没有问题，因为在联合类型中选择了一种
t.sex = ''; 	
// 提示报错，因为上一级info可能没有意义
t.info.b = 0; // 't.info' is possibly 'undefined'.

// 此时，就可以对info进行非空断言
t.info!.b = 0;

// 为了更方便赋值，也可以取出info
let t_info = t.info!;
t_info.b = 0;
```

##### 联合类型

联合类型也会引发潜在的类型危险，因为联合类型有时会让 `TS` 在类型推论中裁决不定。特别是当使用某个类型特有的属性或方法时，会因为其他类型没有这样的属性和方法而报错。

```tsx
interface ITest1 {
    name: string;
    getName(): void
}
interface ITest2 {
    name: string;
    sayName(): void
}

function fn(arg: ITest1 | ITest2): boolean {
    if (typeof arg.getName === 'function') {
        return true;
    }
    return false;
}
```

上面的代码，会因为 `ITest2` 接口类型没有 `getName()` 方法，提示语法错误。要解决这个问题，只需要在使用接口的特有属性或者方法时，明确指定接口类型即可。此时，就可以使用类型断言（另外，这里使用 `?.` 运算符是没有用的）。

```tsx
// 类型断言
function fn(arg: ITest1 | ITest2): boolean {
    // 明确指定使用哪个接口类型，避免TS类型检查犯难
    if (typeof (arg as ITest1).getName === 'function') {
        return true;
    }
    return false;
}
```

##### 任意类型

当在某个类型上使用该类型本身不具有的属性或方法时，会导致编译报错。如前所述，如下所示。

```tsx
let num: number = 1;

console.log(num.length); // Property 'length' does not exist on type 'number'.
```

而此时，还可以将其值断言为 `any` 类型。因为 `any` 型数据不会被类型检查，所以就能阻止在编译时报错，使它顺利度过编译期。

```tsx
let num: number = 1;

// any型变量可以访问任何类型的属性和方法，并且不会报错。
console.log((num as any).length); // undefined
console.log((num as any).concat); // undefined

// 但如果调用其他类型的方法，则会因不存在而在执行期报错。
console.log((num as any).push()); // num.pop is not a function
```

尤其是，`TS` 不允许在 `window` 对象上自定义属性，因为这些属性是 `window` 对象原先不具有的。

```tsx
window.a = 1; // Property 'a' does not exist on type 'Window & typeof globalThis'.
```

但这在 `JS` 中是完全支持的行为，如果要让 `TS` 也允许这种行为，可以将 `window` 对象断言为 `any` 型来对其移除类型检查机制。

```tsx
(window as any).a = 1;
```

另外，也可以将 `any` 类型断言为一个具体的类型。常用在获取 `any` 的型函数返回值的场景中，明知返回值的类型时。

```tsx
function getData(a: number): any {
    return a < 5 ? '' : [];
}

let str: string = getData(4); // 存入any型数据

// 因为返回值的类型为any型，所以编译器不会觉察到错误。
str.push(); // 但在执行时，会因为没有该方法而报错。
```

此时，为了避免在执行期报错，可以将 `any` 型数据断言为一个确切的类型。这样错误就会提前在编译时显现，也就能提前纠正它。

```tsx
let str: string = getData(4) as string; // 断言结果为string类型

// 此时，编译器就能够觉察到错误，并提前预报了。
str.push(); // Property 'push' does not exist on type 'string'.
```

然而，编译器完全信任程序的断言能力。如果程序员断言失误或者将其恶意断言为其他类型，编译器也不会觉察到任何问题。

```tsx
let str: string = getData(7) as string; // 断言结果为string类型，实际存入的是一个数组。

console.log(str); // []
```

由于，编译器会对你的断言深信不疑。所以，即使实际存入的是数组，也不能调用数组的 `API`，因为你已经告诉编译器它是字符类型。

```tsx
let str: string = getData(7) as string;

// 编译器会将str视作字符串类型，即使你知道存入的其实是数组。
str.push(); // Property 'push' does not exist on type 'string'.
```

