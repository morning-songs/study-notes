# 组件进阶

### 动态组件

使用条件渲染指令来切换选项卡，(`display:none`)达不到过渡的动画效果。`Vue`为此特定设计了动态组件。



##### 动态组件【`component`】

在入口元素中，使用`<component>`标签，来动态获取并渲染指定组件。使用`is`属性来指定要渲染的组件名。

案例：设计一个选项切换卡

```html
<style>
    .tab-btn {
        width : 150px;
        height : 40px;
        border : 0;
        cursor : pointer;
        background-color : #e0e2e2;
        color : #000;
        border-radius : 20px;
    }
    .actived {
        color : #fff;
        background-color : #47d1f3;
    }
</style>
<div id = "app">
    <button
    	v-for = "item in tabs"
        :key = "item"
       	:class = "['tab-btn', {actived : activedTab === item}]"
        @click = "activedTab = item"
    >
    {{item}}
    </button>
    <component :is = "activeTabComponent"></component>
</div>
<script src="./js/vue2.6.14.js"></script>
<script>
	Vue.component('tabs-monday', {
        template : `<div>特战荣耀</div>`
    });
    Vue.component('tabs-tuesday', {
        template : `<div>且试天下</div>`
    });
    Vue.component('tabs-wednesday', {
        template : `<div>双城之战</div>`
    });
    const vm = new Vue({
        el : "#app",
        data : {
            tabs : ["monday", "tuesday", "wednesday"],
            activedTab : "monday"
        },
        computed : {
            activeTabComponent () {
                return "tabs-" + this.activedTab;
            }
        }
    })
</script>
```

注意：

- `HTML`中有特定用途的元素不应作为入口元素来使用，如：`table`，`form`，`ul`，`ol`等。
- 有特殊要求时，可以在控件中直接使用`is`属性，将该控件作为组件来渲染，如：`<tr is=""></tr>`。这意味着所有的 `attribute` 都会作为 `DOM attribute` 被绑定。对于像 `value` 这样的 `property`，若想让其如期工作，你需要使用 [`.prop` 修饰器](https://v2.cn.vuejs.org/v2/api/#v-bind)。
- `table` 还可以将`<component>`放入`td`中使用，如：`<td><component is></component></td>`。

`is` 的值不仅可以是一个组件名，还可以是一个选项对象。更多参考：[动态组件](https://v2.cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6) 

```html
<style>
    .tab-button {
        padding: 6px 10px;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
        border: 1px solid #ccc;
        cursor: pointer;
        background: #f0f0f0;
        margin-bottom: -1px;
        margin-right: -1px;
    }
    .tab-button:hover {
        background: #e0e0e0;
    }
    .tab-button.active {
        background: #e0e0e0;
    }
    .tab {
        border: 1px solid #ccc;
        padding: 10px;
    }
</style>
<div id="dynamic-component-demo" class="demo">
    <button
		v-for="tab in tabs"
		v-bind:key="tab.name"
		v-bind:class="['tab-button', { active: currentTab.name === tab.name }]"
		v-on:click="currentTab = tab"
    >
        {{ tab.name }}
    </button>

    <component v-bind:is="currentTab.component" class="tab"></component>
</div>

<script>
    var tabs = [
        {
            name: "Home",
            component: {
                template: "<div>Home component</div>"
            }
        },
        {
            name: "Posts",
            component: {
                template: "<div>Posts component</div>"
            }
        },
        {
            name: "Archive",
            component: {
                template: "<div>Archive component</div>"
            }
        }
    ];

    new Vue({
        el: "#dynamic-component-demo",
        data: {
            tabs: tabs,
            currentTab: tabs[0]
        }
    });
</script>
```



##### 静态切换【`keep-alive`】

在使用动态组件时，是通过`is`属性来实现切换组件功能的。但`is`切换组件的本质是：每一次根据模板结构重新构建。

这就导致了一个问题，动态切换组件无法缓存之前的状态，如：按钮选中，输入值等。它在异步请求中，则表现优异。

当希望在来回切换选项后，各组件能够保持切换前的状态时，可以使用`<keep-alive>`将它们包裹起来，使其继续生存。

```html
<div id = "app">
	<keep-alive>
    	<component is = ""></component> <!-- 使各组件继续生存，切换时不被销毁 -->
    </keep-alive>
</div>
```

<hr>

### 插槽【`slot`】

在封装组件时，可以预留插口，来接收使用者向插口中填充个性的内容。

例如：默认情况下，在渲染时组件标签中的内容会被丢弃。此时，就可以预留插槽，来接收并渲染它们。

```html
<div id = "app">
    <test>看不见我看不见我……</test> <!-- 默认地，组件标签中的内容会被template的DOM结构覆盖掉 -->
</div>
<script>
	Vue.component('test', {
        template : `<div>
        				test组件<br/>
        				<slot></slot> <!--预留插口-->
    				</div>`
    })
</script>
```



##### 默认内容

使用插槽时，可以在插槽内设置默认内容，仅当没有接收到任何内容时显示。



##### 具名插槽

插槽可以通过`name`属性命名，配合`v-slot`指令，来接收指定的`<template>`中的内容。

```html
<div id = "app">
    <test>
        <template v-slot:wanzi>
        	<h3>丸子---收拾东西，要下课了！</h3>
        </template>
        <!--组件标签中没有插槽接收的内容都会被丢弃-->
        <p>一段被丢弃的内容……</p>
    </test>
</div>
<script>
	Vue.component('test', {
        template : `<div>
        				test组件<br/>
        				<slot name = "wanzi"></slot> <!--具名插槽-->
    				</div>`
    })
    const vm = new Vue({
    	el: "#app"
    })
</script>
```

简写指令：插槽在开发中经常使用，因此，`v-slot`指令可简写为`#`

注意：在组件标签中，没有被插槽接收的内容都会被丢弃掉。此时可以预留一个匿名插槽或默认插槽来接收它们。



##### 默认插槽

默认插槽：`<slot name = "default"></slot>`，作用与匿名插槽基本相同。



##### 作用域插槽

一般插槽是将页面上绑定元素中的内容传递给对应的组件使用，而作用域插槽则是将组件内部的数据传递给页面上绑定的元素。

在插槽上可以自定义属性来传递本组件内部的数据，然后在对应的`template`中通过`v-slot`指令接收【接收值是一个对象】

注意：

- 该接收对象通常命名为`slotProps`，它会接收来自对应插槽的除`name`之外的所有属性及值。
- 在`template`中，就可以直接使用组件内部的数据。而`template`最终会与插槽结合渲染出数据。
- 作用域插槽主要用于与父组件或其他组件进行通信时，传递内部的数据。
- 如果不需要通信，则直接在插槽中使用内部数据即可，不必来回折腾。

```html
<!--不通信-->
<div id = "app">
    <test>
        <template v-slot:wanzi></template>
    </test>
</div>
<script>
	Vue.component('test', {
        data () {
            return {
                userName : "wanzi",
                age : 14
            };
        },
        template : `<div>
        				test组件<br/>
        				<slot name = "wanzi">
    						{{userName}}---{{age}}
    					</slot>
    				</div>`
    });
<!--通信-->
<div id = "app">
    <test>
        <template #wanzi = "slotProps"> <!--该对象也可以直接解构: #wanzi = "{user, age}"-->
        	{{slotProps}}---{{slotProps.user}}---{{slotProps.age}}<br/>
            {{fn(slotProps)}}
        </template>
    	<!-- 解构用法：
            <template #wanzi = "{user, age}">
            	{{user}}---{{age}}
    		</template>
        -->
    </test>
</div>
<script>
	Vue.component('test', {
        data () {
            return {
                userName : "wanzi",
                age : 14
            };
        },
        // 在template中，通过插槽将自身组件的数据传递出去（传给v-slot绑定的元素）。
        template : `<div>
        				test组件<br/>
        				<slot name = "wanzi" :user = "userName" :age = "age"></slot> <!--具名插槽-->
    				</div>`
    });
    const vm = new Vue({
        el : "#app",
        data : {
            docName : '',
            docAge : 0
        },
        methods : {
            fn (docMsg) {
                this.docName = docMsg.user;
                this.docAge = docMsg.age;
                return "收到！";
            }
        }
    })
</script>
```

