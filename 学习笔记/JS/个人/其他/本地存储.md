# 客户端存储

​		随着 `Web` 应用程序的出现，直接在客户端存储用户信息的需求也随之出现。这背后的想法是合理的，因为与特定用户相关的信息应该保存在用户的机器上。无论是登录信息、个人偏好，还是其他数据，`Web` 应用程序提供者都需要有办法把它们保存在客户端。对该问题的第一个解决方案就是 `cookie`，`cookie` 由古老的网景公司发明，由《`Persistent Client State: HTTP Cookies`》规范所定义。然而今天，`cookie` 只是在客户端存储数据的一个选项了。



### `cookie`

​		`HTTP cookie` 通常也叫作 `cookie`，最初用于在客户端存储会话信息。这个规范要求服务器在响应 `HTTP` 请求时，通过发送 `Set-Cookie HTTP` 头部包含会话信息。例如，下面是包含这个头部的一个 `HTTP` 响应：

```
HTTP/1.1 200 OK 
Content-type: text/html 
Set-Cookie: name=value 
Other-header: other-header-value
```

​		这个 `HTTP` 响应会设置一个名为 `"name"`，值为 `"value"` 的 `cookie`。名和值在发送时都会经过 `URL` 编码。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 `HTTP` 头部 `Cookie` 再将它们发回服务器，比如：

```
GET /index.jsl HTTP/1.1 
Cookie: name=value 
Other-header: other-header-value
```

​		这些发送回服务器的额外信息可用于唯一标识发送请求的客户端。



#### 限制

​		**`cookie` 是与特定域绑定的。**设置 `cookie` 后，它会与请求一起发送到创建它的域。这个限制能保证 `cookie` 中存储的信息只对被认可的接收者开放，而不会被其他域访问。

​		因为 `cookie` 存储在客户端机器上，所以为保证它不会被恶意利用，浏览器会施加限制。同时，`cookie` 也不会占用太多磁盘空间。

​		通常，只要遵守以下大致的限制，就不会在任何浏览器中碰到问题：

- 不超过 300 个 `cookie`；
- 每个 `cookie` 不超过 4096 字节；
- 每个域不超过 20 个 `cookie`；
- 每个域不超过 81 920 字节。

​		每个域能设置的 `cookie` 总数也是受限的，但不同浏览器的限制不同。例如：

- 最新版 `IE` 和 `Edge` 限制每个域不超过 50 个 `cookie`；
- 最新版 `Firefox` 限制每个域不超过 150 个 `cookie`；
- 最新版 `Opera` 限制每个域不超过 180 个 `cookie`；
- `Safari` 和 `Chrome` 对每个域的 `cookie` 数没有硬性限制。

​		如果 `cookie` 总数超过了单个域的上限，浏览器就会删除之前设置的 `cookie`。`IE` 和 `Opera` 会按照最近最少使用（`LRU`，`Least Recently Used`）原则删除之前的 `cookie`，以便为新设置的 `cookie` 腾出空间。`Firefox` 好像会随机删除之前的 `cookie`，因此为避免不确定的结果，最好不要超出限制。

​		浏览器也会限制 `cookie` 的大小。大多数浏览器对 `cookie` 的限制是不超过 4096 字节，上下可以有一个字节的误差。为跨浏览器兼容，最好保证 `cookie` 的大小不超过 4095 字节。这个大小限制适用于一个域的所有 `cookie`，而不是单个 `cookie`。

​		如果创建的 `cookie` 超过最大限制，则该 `cookie` 会被静默删除。注意，一个字符通常会占 1 字节。如果使用多字节字符（如 `UTF-8 Unicode` 字符），则每个字符最多可能占 4 字节。



#### `cookie` 的构成

​		`cookie` 在浏览器中是由以下参数构成的（名值对，`expires`：过期时间，`domain`：域，`path`：路径，`secure`：安全标志）。

- 名称：唯一标识 `cookie` 的名称。`cookie` 名本身不区分大小写，因此 `myCookie` 和 `MyCookie` 是同一个名称。不过，实践中最好是区分 `cookie` 名的大小写，因为一些服务器软件可能这样对待它们。`cookie` 名必须经过 `URL` 编码。
- 值：存储在 `cookie` 里的字符串值。这个值必须经过 `URL` 编码。
- 域：`cookie` 有效的域。发送到这个域的所有请求都会包含对应的 `cookie`。这个值可能包含子域（如 `www.wrox.com`），也可以不包含（如 `.wrox.com` 表示对 `wrox.com` 的所有子域都有效）。如果不明确设置，则默认为设置 `cookie` 的域。
- 路径：只在请求 `URL` 中包含此路径时才会把 `cookie` 发送到服务器。例如：可以指定 `cookie` 只能由 `/books/` 及其子路由访问，因此只访问 `/` 下的页面就不会发送 `cookie`，即使请求的是同一个域。
- 过期时间：表示何时删除 `cookie` 的时间戳（即：多久之后就不再将其发给服务器了）。默认情况下，浏览器会话结束后会删除所有 `cookie`。不过，也可以设置删除 `cookie` 的时间。这个值采取 `GMT` 的格式（`Wdy`, `DD-Mon-YYYY HH:MM:SS GMT`），用于指定删除 `cookie` 的具体时间。这样，即使关闭浏览器，`cookie` 也会保留在用户机器上。把过期时间设置为过去会立即删除此 `cookie`。
- 安全标志：设置之后，只在使用 `SSL` 安全连接的情况下才会把 `cookie` 发送到服务器。例如，请求 `https://www.wrox.com` 会发送 `cookie`，而请求 `http://www.wrox.com` 则不会。

​		这些参数在 `Set-Cookie` 头部中使用分号加空格隔开，比如：

```
Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com 
```

​		这个头部设置了一个名为 `"name"`，值为 `"value"` 的 `cookie`。它将在 2007 年 1 月 22 日 `7:10:24` 过期，且只对 `www.wrox.com` 及其他 `wrox.com` 的子域（如：`p2p.wrox.com`）有效。

​		安全标志 `secure` 是 `cookie` 中唯一的非名/值对，只需一个 `secure` 就可以了。比如：

```
Set-Cookie: name=value; domain=.wrox.com; path=/; secure 
```

​		这里创建的 `cookie` 对所有 `wrox.com` 的子域及该域中的所有页面都有效（已由 `path=/` 指定）。不过，这个 `cookie` 只能在 `SSL` 连接上（本地主机除外）发送，因为设置了 `secure` 标志。

​		域、路径、过期时间和安全标志只是用于告诉浏览器什么情况下应该在请求中包含 `cookie`。这些参数并不会随请求发送给服务器，实际发送的只有 `cookie` 的名/值对（在请求头中通过 `Cookie` 头部指定）。

```
Cookie: name=value
```



#### `JS` 中的 `cookie`

​		在 `JavaScript` 中处理 `cookie` 比较麻烦，因为接口过于简单，没有 `Cookie` 构造函数，只有 `BOM` 提供了一个 `document.cookie` 属性。根据用法不同，该属性的表现也会不同。当使用该属性获取值时，`document.cookie` 返回包含页面中所有有效 `cookie` 组成的一个字符串（根据域、路径、过期时间和安全标志设置），以分号分隔，如下面的例子所示：

```
name1=value1; name2=value2; name3=value3
```

​		所有名和值都是经过 `URL` 编码的，因此必须使用 `decodeURIComponent()` 解码。

​		在设置值时，可以通过 `document.cookie` 属性设置新的 `cookie` 字符串。这个字符串在被解析后会添加到原有 `cookie` 中。设置 `document.cookie` 不会覆盖之前存在的任何 `cookie`，除非设置了已有的 `cookie`。

```js
document.cookie = "name1=wz";
document.cookie = "name2=cy";
document.cookie = "name1=xy";

console.log(document.cookie); // 'name2=cy; name1=xy'
```

​		设置 `cookie` 的格式如下，与 `Set-Cookie` 头部的格式一样：

```
name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure
```

​		在所有这些参数中，只有 `cookie` 的名称和值是必需的。下面是个简单的例子：

```js
document.cookie = "name=Nicholas";
```

​		这行代码会创建一个名为 `"name"` 的会话 `cookie`，其值为 `"Nicholas"`。这个 `cookie` 在每次客户端向服务器发送请求时都会被带上，在浏览器关闭时就会被删除。虽然在名称或值中不需要编码任何字符，但最好还是使用 `encodeURIComponent()` 对分别名称和值进行编码，比如：

```js
document.cookie = encodeURIComponent("name") + "=" + encodeURIComponent("Nicholas");
```

​		要为创建的 `cookie` 指定额外的信息，只要像 `Set-Cookie` 头部一样直接在后面追加相同格式的字符串即可：

```js
document.cookie = encodeURIComponent("name") + "=" + encodeURIComponent("Nicholas") 
    			+ "; domain=.wrox.com; path=/";
```

​		因为在 `JavaScript` 中读写 `cookie` 不是很直观，所以可以通过辅助函数来简化相应的操作。与 `cookie` 相关的基本操作有读、写和删除。这些在 `CookieUtil` 对象中表示如下：

```js
class CookieUtil { 
 	static get(name) { 
 		let cookie = document.cookie,
        	cookieName = `${encodeURIComponent(name)}=`, 
 			cookieStart = cookie.indexOf(cookieName), 
 			cookieValue = null; 
        
 		if (cookieStart > -1) { 
 			let cookieEnd = cookie.indexOf(";", cookieStart); 
 			if (cookieEnd == -1) { 
 				cookieEnd = cookie.length; 
 			} 
 			cookieValue = decodeURIComponent(cookie.substring(cookieStart + cookieName.length, cookieEnd)); 
 		} 
 		return cookieValue; 
 	} 
    
 	static set(name, value, expires, path, domain, secure) { 
 		let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}` 
 		if (expires instanceof Date) { 
 			cookieText += `; expires=${expires.toGMTString()}`; 
 		} 
 		if (path) { 
 			cookieText += `; path=${path}`; 
 		} 
 		if (domain) { 
 			cookieText += `; domain=${domain}`; 
 		} 
 		if (secure) { 
 			cookieText += "; secure"; 
 		} 
 		return document.cookie = cookieText; 
 	} 
    
 	static unset(name, path, domain, secure) { 
 		CookieUtil.set(name, "", new Date(0), path, domain, secure); 
 	} 
};
```

​		`CookieUtil.get()` 方法用于取得给定名称的 `cookie` 值。为此，需要在 `document.cookie` 返回的字符串中查找是否存在名称后面加上等号（有等号，才有值）。如果有值，则使用 `indexOf()` 再查找该位置后面的分号（表示该 `cookie` 的末尾）。如果没有找到分号，说明这个 `cookie` 在字符串末尾，因此字符串剩余部分都是 `cookie` 的值。取得 `cookie` 值后使用 `decodeURIComponent()` 解码，然后返回。如果没有找到 `cookie`，说明没有值，则返回 `null`。

​		`CookieUtil.set()` 方法用于设置页面上的 `cookie`，接收多个参数：`cookie` 名称、`cookie` 值、可选的 `Date` 对象（表示何时删除 `cookie`）、可选的 `URL` 路径、可选的域以及可选的布尔值（表示是否添加 `secure` 标志）。这些参数以它们的使用频率为序，只有前两个是必需的。在方法内部，使用了 `encodeURIComponent()` 对名称和值进行编码，然后再依次检查其他参数。如果 `expires` 参数是 `Date` 对象，则使用 `Date` 对象的 `toGMTString()` 方法添加一个 `expires` 选项来获得正确的日期格式。剩下的代码就是简单地追加 `cookie` 字符串，最终设置给 `document.cookie`。

​		没有直接删除已有 `cookie` 的方法。为此，需要再次设置同名 `cookie`（包括相同路径、域和安全选项），但要将其过期时间设置为某个过去的时间。`CookieUtil.unset()` 方法实现了这些处理。这个方法接收 4 个参数：要删除 `cookie` 的名称、可选的路径、可选的域和可选的安全标志。

​		这些参数会传给 `CookieUtil.set()`，将 `cookie` 值设置为空字符串，将过期时间设置为 1970 年 1 月 1 日（以 0 毫秒初始化的 `Date` 对象的值）。这样可以保证删除 `cookie`。

​		可以像下面这样使用这些方法（在服务器环境或热更新页面中执行它们）：

```js
// 设置 cookie 
CookieUtil.set("name", "Nicholas"); 
CookieUtil.set("book", "Professional JavaScript"); 

// 读取 cookie 
alert(CookieUtil.get("name")); // "Nicholas" 
alert(CookieUtil.get("book")); // "Professional JavaScript" 

// 删除 cookie 
CookieUtil.unset("name"); 
CookieUtil.unset("book"); 

// 设置有路径、域和过期时间的 cookie 
CookieUtil.set("name", "Nicholas", "/books/projs/", "www.wrox.com", new Date("January 1, 2010")); 

// 删除刚刚设置的 cookie 
CookieUtil.unset("name", "/books/projs/", "www.wrox.com"); 

// 设置安全 cookie 
CookieUtil.set("name", "Nicholas", null, null, null, true);
```

​		这些方法通过处理解析和 `cookie` 字符串构建，简化了使用 `cookie` 存储数据的操作。注意：由于 `cookie` 是在服务环境下交换的信息，因此对 `cookie` 的操作应该在服务器环境下进行。另外，`Chrome` 在无服务环境下会将 `document.cookie` 设为只读的空字符串。



#### 子 `cookie`

​		为绕过浏览器对每个域 `cookie` 数的限制，有些开发者提出了子 `cookie` 的概念。子 `cookie` 是存储在单个 `cookie` 的小块数据，本质上是使用 `cookie` 的值在单个 `cookie` 中存储多个名/值对。最常用的子 `cookie` 模式如下：

```
name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5
```

​		子 `cookie` 的格式类似于查询字符串。这些值可以存储为单个 `cookie`，而不用单独存储为自己的名/值对。结果就是网站或 `Web` 应用程序能够在单域 `cookie` 数限制下存储更多的结构化数据。

​		要操作子 `cookie`，就需要再添加一些辅助方法。解析和序列化子 `cookie` 的方式不一样，且因为对子 `cookie` 的使用而变得更复杂。比如，要取得某个子 `cookie`，就需要先取得 `cookie`，然后在解码值之前需要先像下面这样找到子 `cookie`：

```js
class SubCookieUtil { 
 	static get(name, subName) { 
 		let subCookies = SubCookieUtil.getAll(name); 
 		return subCookies ? subCookies[subName] : null;
	} 
    
 	static getAll(name) { 
 		let cookie = document.cookie,
            cookieName = encodeURIComponent(name) + "=", 
 			cookieStart = cookie.indexOf(cookieName), 
 			cookieValue = null, 
 			cookieEnd, 
 			subCookies, 
 			parts, 
 			result = {}; 
        
 		if (cookieStart > -1) { 
			cookieEnd = cookie.indexOf(";", cookieStart); 
 			if (cookieEnd == -1) { 
 				cookieEnd = cookie.length; 
 			} 
 			cookieValue = cookie.substring(cookieStart + cookieName.length, cookieEnd); 
            
 			if (cookieValue.length > 0) { 
				subCookies = cookieValue.split("&"); 
 				for (let i = 0, len = subCookies.length; i < len; i++) { 
					parts = subCookies[i].split("="); 
 					result[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]); 
 				} 
 				return result; 
 			} 
 		} 
 		return null; 
 	} 
    
 	// 省略其他代码
};
```

​		取得子 `cookie` 有两个方法：`get()` 和 `getAll()`。`get()` 用于取得一个子 `cookie` 的值，`getAll()` 用于取得所有子 `cookie`，并以对象形式返回，对象的属性是子 `cookie` 的名称，值是子 `cookie` 的值。`get()` 方法接收两个参数：`cookie` 的名称和子 `cookie` 的名称。这个方法先调用 `getAll()` 取得所有子 `cookie`，然后返回要取得的子 `cookie`（如果不存在则返回 `null`）。

​		`SubCookieUtil.getAll()` 方法在解析 `cookie` 值方面与 `CookieUtil.get()` 方法非常相似。但 `SubCookieUtil.getAll()` 方法不会立即解码 `cookie` 的值，而是先用和号（`&`）拆分，将所有子 `cookie` 保存到数组。然后，再基于等号（`=`）拆分每个子 `cookie`，使 `parts` 数组的第一个元素是子 `cookie` 的名称，第二个元素是子 `cookie` 的值。然后，两个元素都使用 `decodeURIComponent()` 解码，并添加到 `result` 对象，最后返回 `result` 对象。如果 `cookie` 不存在则返回 `null`。

​		可以像下面这样使用这些方法：

```js
document.cookie = 'data=name=Nicholas&book=Professional%20JavaScript';

// 取得所有子 cookie 
let data = SubCookieUtil.getAll("data"); 
console.log(data.name); // "Nicholas" 
console.log(data.book); // "Professional JavaScript"

// 取得个别子 cookie 
console.log(SubCookieUtil.get("data", "name")); // "Nicholas" 
console.log(SubCookieUtil.get("data", "book")); // "Professional JavaScript"
```

​		要写入子 `cookie`，可以使用另外两个方法：`set()` 和 `setAll()`。这两个方法的实现如下：

```js
class SubCookieUtil { 
 	// 省略之前的代码
    
 	static set(name, subName, value, expires, path, domain, secure) { 
 		let subcookies = SubCookieUtil.getAll(name) || {}; 
		subcookies[subName] = value; 
 		SubCookieUtil.setAll(name, subcookies, expires, path, domain, secure); 
 	} 
    
 	static setAll(name, subcookies, expires, path, domain, secure) { 
 		let cookieText = encodeURIComponent(name) + "=", 
 			subcookieParts = new Array(), 
 			subName; 
 		for (subName in subcookies){ 
 			if (subName.length > 0 && subcookies.hasOwnProperty(subName)){ 
 				subcookieParts.push( 
                    `${encodeURIComponent(subName)}=${encodeURIComponent(subcookies[subName])}`
                ); 
 			} 
 		} 
 		if (subcookieParts.length > 0) { 
 			cookieText += subcookieParts.join("&"); 
 			if (expires instanceof Date) { 
 				cookieText += `; expires=${expires.toGMTString()}`; 
 			} 
 			if (path) { 
 				cookieText += `; path=${path}`; 
 			} 
 			if (domain) { 
 				cookieText += `; domain=${domain}`; 
 			} 
 			if (secure) { 
 				cookieText += "; secure"; 
 			} 
 		} else { 
 			cookieText += `; expires=${(new Date(0)).toGMTString()}`; 
 		} 
 		document.cookie = cookieText; 
 	} 
    
 	// 省略其他代码
};
```

​		`set()` 方法接收 7 个参数：`cookie` 的名称、子 `cookie` 的名称、子 `cookie` 的值、可选的用于设置 `cookie` 过期时间的 `Date` 对象、可选的 `cookie` 路径、可选的 `cookie` 域和可选的是否设置安全标志的布尔值。所有可选的参数都作用于 `cookie` 本身，而不是子 `cookie`。为了在同一个 `cookie` 中存储多个子 `cookie`，路径、域和 `secure` 标志都必须相同。过期时间作用于整个 `cookie`，可以在写入个别子 `cookie` 时另行设置。在这个方法内部，第一步是取得给定 `cookie` 名称下包含的所有子 `cookie`。逻辑或操作符（`||`）在这里用于 `getAll()` 返回 `null` 的情况下将 `subcookies` 设置为新对象。然后，在 `subcookies` 上设置完子 `cookie` 的值，再将参数传给 `setAll()`。

​		`setAll()` 方法接收 6 个参数：`cookie` 的名称、包含所有子 `cookie` 的对象，然后是 `set()` 方法中使用的 4 个可选参数。这个方法会在 `for-in` 循环中迭代第二个参数的属性。为保证只存储合适的数据，这里使用了 `hasOwnProperty()` 方法确保只有实例属性才会被序列化为子 `cookie`。因为存在属性名等于空字符串的可能，所以在添加到 `subcookieParts` 数组之前先检查其长度。该数组包含子 `cookie` 的名/值对，这样我们可以方便地使用 `join()` 方法以和号将它们拼接成字符串。剩下的逻辑与 `CookieUtil.set()` 一样。

​		可以像下面这样使用这些方法：

```js
// 预计 document.cookie = 'data=name=Nicholas&book=Professional%20JavaScript' 

// 设置两个子 cookie 
SubCookieUtil.set("data", "name", "Nicholas"); 
SubCookieUtil.set("data", "book", "Professional JavaScript"); 

// 设置所有子 cookie 并传入过期时间
SubCookieUtil.setAll("data", {name: "Nicholas", book: "Professional JavaScript"}, new Date("1 1, 2010")); 

// 修改 "name" 的值并修改整个 cookie 的过期时间
SubCookieUtil.set("data", "name", "Michael", new Date("February 1, 2010"));
```

​		最后一组子 `cookie` 相关的方法是要删除子 `cookie` 的。常规 `cookie` 可以通过直接设置过期时间为某个过去的时间删除，但删除子 `cookie` 没有这么简单。为了删除子 `cookie`，需要先取得所有子 `cookie`，把要删除的那个删掉，然后再把剩下的子 `cookie` 全部设置回去。下面是相关方法的实现：

```js
class SubCookieUtil { 
 	// 省略之前的代码
    
 	static unset(name, subName, path, domain, secure) { 
 		let subcookies = SubCookieUtil.getAll(name); 
 		if (subcookies) { 
			delete subcookies[subName]; // 删除
			SubCookieUtil.setAll(name, subcookies, null, path, domain, secure); 
 		} 
 	} 
    
 	static unsetAll(name, path, domain, secure) { 
 		SubCookieUtil.setAll(name, null, new Date(0), path, domain, secure); 
 	} 
}
```

​		这里定义的这两个方法有两个不同的目的。`unset()` 方法用于从 `cookie` 中删除一个子 `cookie`，其他的子 `cookie` 不受影响；而 `unsetAll()` 方法与 `CookieUtil.unset()` 一样，会删除整个 `cookie`。与 `set()` 和 `setAll()` 一样，路径、域和 `secure` 标志必须与创建 `cookie` 时使用的一样。可以像下面这样使用这两个方法：

```js
// 只删除"name"子 cookie 
SubCookieUtil.unset("data", "name"); 

// 删除整个 cookie 
SubCookieUtil.unsetAll("data");
```

​		如果实际开发中担心碰到每个域的 `cookie` 限制，则可以考虑使用子 `cookie` 这个方案。此时要特别注意 `cookie` 的大小，不要超过对单个 `cookie` 大小的限制（最好不超过 4095 字节）。



#### 注意事项

​		还有一种叫作 `HTTP-only` 的 `cookie`。`HTTP-only` 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为 `JavaScript` 无法取得这种 `cookie` 的值。

​		因为所有 `cookie` 都会作为请求头部由浏览器发送给服务器，所以在 `cookie` 中保存大量信息可能会影响特定域中浏览器的请求性能。保存的 `cookie` 越大，请求完成的时间就越长。即使浏览器对 `cookie` 大小有限制，但最好还是尽可能只通过 `cookie` 保存必要的信息，以避免性能问题。

​		对 `cookie` 的限制及其特性决定了 `cookie` 并不是存储大量数据的理想方式。因此，其他客户端存储技术出现了。

​		注意：不要在 `cookie` 中存储重要或敏感的信息。因为 `cookie` 数据不是保存在安全环境中的，所以任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 `cookie` 中。

##### 跨域发送 `cookie`

​		使用 `fetch()` 发起请求时，默认情况下，只会在请求 `URL` 与页面的源同源时才会携带 `cookie`。参见《网络请求》章节《跨源资源共享》一节中的”凭据请求“。

```js
// 若页面的源为：http://127.0.0.1:3000
fetch("http://127.0.0.1:3000/"); // 同源请求，会自动携带页面中的所有cookie。
```

​		如果要使用 `fetch()` 在跨域请求中携带 `cookie`，则首先要做如下的配置。

- 客户端：在 `fetch()` 的第二个参数 `init` 对象中，配置 `credentials` 为 `"include"`。参见《网络请求》。
- 服务器：设置如下的两个响应头。
  - `"Access-Control-Allow-Origin"`：发送请求的页面的源（不可以是 `"*"`）。
  - `"Access-Control-Allow-Credentials"`：`"true"`。

​		配置好以上信息后，浏览器就会在跨域请求中自动携带 `cookie` 了。

```js
// 若页面的源为：http://127.0.0.1:3000
fetch("http://127.0.0.1:5000/"); // 跨域请求，此时也会自动携带页面中的所有cookie。
```



#### `cookieStore`

​		`cookieStore` 是 `Chrome` 实现的新特性，用于原生支持浏览器对 `cookie` 的操作，以期约的形式实现异步管理 `cookie`。此特性仅在安全上下文中（`HTTPS`）以及部分或所有支持的浏览器中可用（本地服务环境除外），故以此特性添加的 `cookie` 总是包含 `secure`。

​		目前 `Edge` 和 `Opera` 都已实现了它，但 `Firefox` 和 `Safari` 还未实现。

```js
console.log(cookieStore); // CookieStore {onchange: null}
/*
CookieStore {
	onchange: null,
	[[Prototype]]: CookieStore {
		delete: ƒ delete(),
		get: ƒ (),
		getAll: ƒ getAll(),
		onchange: (...),
		set: ƒ (),
		constructor: ƒ CookieStore(),
		Symbol(Symbol.toStringTag): "CookieStore",
		get onchange: ƒ onchange(),
		set onchange: ƒ onchange(),
		[[Prototype]]: EventTarget
	}
}
*/
```

​		可以看到 `cookieStore` 主要有 5 个方法，前 4 个方法天然支持 `Promise`。

- `set`：设置 `cookie`，可以是 `set(name, value)`，也可以是 `set({name, value})`；
- `get`：获取 `cookie`，可以是 `get(name)`，或者 `get({name})`；
- `getAll`：获取所有的 `cookie`；
- `delete`：删除 `cookie`；
- `onchange`：监听 `cookie` 的变化；

##### 设置

​		`cookieStore.set()` 方法用于设置 `cookie`，并返回一个 `Promise` 状态，表示是否设置成功。

```js
// 直接传入名值对
cookieStore
    .set('username', 'wenzi')
  	.then(() => console.log('设置username成功'))
  	.catch(() => console.error('设置username失败'));
```

​		如果我们想要设置更多的属性，例如过期时间，可以传入一个 `Object` 类型：

```js
// 传入一个对象
cookieStore.set({
    name: 'age',
    value: 18,
    expires: Date.now() + 24 * 60 * 60 * 1000, // 一天后过期
    domain: "127.0.0.1",
    path: "/"
})
  	.then(() => console.log('设置age成功'))
  	.catch(() => console.error('设置age失败'));
```

​		`value` 中所有的数据都会默认先执行 `toString()`，然后再进行存储。因此有些非基本类型的数据，最好先转换好。

##### 获取

​		`cookieStore.get(name)`方法用于获取 `name` 对应的 `cookie`，以 `Promise` 格式返回所有的属性：

```js
await cookieStore.get('age');
```

​		`get()` 方法还可以接收一个 `Object` 类型，测试后发现，`key` 的值只能是 `name`：

```js
cookieStore.get({ name: 'age' })
	.then((data) => console.log(data))
	.catch((e) => console.log(e));

/*
{
	domain: null, 
	expires: 1681112932141, 
	name: "age", 
	partitioned: false, 
	path: "/", 
	sameSite: "strict",
	secure: true,
	value: "18",
	[[Prototype]]: Object
}
*/
```

​		当获取的 `cookie` 不存在时，则返回一个 `Promise<null>`。

##### 全取

​		`cookieStore.getAll()` 方法可以获取当前所有的 `cookie`，以 `Promise<[]>` 的形式返回，数组中的每一项与通过 `get()` 方式获取到的格式一样；若当前域没有 `cookie`，或者获取不到指定的 `cookie`，则为空数组。

```js
cookieStore.getAll()
	.then((data) => console.log(data))
	.catch((e) => console.log(e));

/*
[
	{domain: null, expires: 1681113098537, name: 'age', partitioned: false, path: '/', …},
	{domain: null, expires: 1681113275190, name: 'username', partitioned: false, path: '/', …}
]
*/
```

​		`getAll()` 方法也可以像 `get()` 一样是使用，通过传入一个 `name` 来获取对应的 `cookie`，但仍以数组的形式返回：

```js
cookieStore.getAll('username').then((data) => console.log(data));

cookieStore.getAll({ name: 'username' }).then((data) => console.log(data));
```

##### 删除

​		`cookieStore.delete(name)` 用来删除指定的 `cookie`：

```js
cookieStore
  	.delete('age')
  	.then(() => console.log('删除age成功'))
  	.catch(() => console.error('删除age失败'));
```

​		删除成功后则会提示删除成功。即使删除一个不存在的 `cookie`，也会提示删除成功。

##### 监听

​		我们可以通过添加 `change` 事件，来监听 `cookie` 的变化。无论是通过 `cookieStore` 操作，还是直接操作 `document.cookie`，都能被监听到。该事件的事件对象上有两个重要的字段：`changed` 数组和 `deleted` 数组，当修改 `cookie` 时，则 `changed` 数组里为刚才修改的 `cookie`；当删除 `cookie` 时，则 `deleted` 数组里为刚才删除的 `cookie`。

```js
// 事件监听应在相关操作之前设置。
cookieStore.addEventListener('change', (event) => {
  	const type = event.changed.length ? 'change' : 'delete';
  	const data = (event.changed.length ? event.changed : event.deleted).map((item) => item.name);

  	console.log(`刚才进行了 ${type} 操作，相关的cookie有：${JSON.stringify(data)}`);
});
```

​		注意：`change` 事件监听的只有两种操作：修改和删除。其中，修改操作是指调用 `set()`，而删除操作仅仅指调用 `delete()`。过去，通过 `document.cookie` 设置或者删除的 `cookie`，也会触发该事件，但均被认为是在修改 `cookie`，而不是删除。

```js
cookieStore.set({name: 'username', value: 18}).then(() => console.log('设置username成功'));   // 触发
cookieStore.set({ name: 'username', value: 18 }).then(() => console.log('设置username成功')); // 触发
document.cookie = encodeURIComponent("age") + "=" + encodeURIComponent("18");				// 不触发

cookieStore.delete('username').then((d) => console.log('删除username成功')); // 触发
cookieStore.delete('username').then((d) => console.log('删除username成功')); // 不触发
```

​		另外，每次设置 `cookie` 时，即使两次的 `name` 和 `value` 完全一样，也会触发 `change` 事件。如果删除一个不存在的 `cookie`，则不会触发 `change` 事件。

更多参考：[`CookieStore MDN`](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore)、[一个操作 `cookie` 的原生方法 `cookieStore`](https://zhuanlan.zhihu.com/p/357297681) 



### `Web Storage`

​		`Web Storage` 最早是网页超文本应用技术工作组（`WHATWG`，`Web Hypertext Application Technical Working Group`）在 `Web Applications 1.0` 规范中提出的。这个规范中的草案最终成为了 `HTML5` 的一部分，后来又独立成为自己的规范。`Web Storage` 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 `cookie` 的问题。

​		`Web Storage` 规范最新的版本是第 2 版，这一版规范主要有两个目标：

- 提供除 `cookie` 外的其他存储会话数据的途径；
- 提供一个跨会话的持久化存储大量数据的机制。

​		第 2 版定义了两个对象：`localStorage` 和 `sessionStorage`。`localStorage` 是永久存储机制，`sessionStorage` 是跨会话的存储机制。这两种浏览器存储 `API` 提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009 年之后所有主要供应商发布的浏览器版本都在 `window` 对象上支持了 `localStorage` 和 `sessionStorage`。

​		注意：`Web Storage` 第 1 版曾使用过 `globalStorage`，不过目前 `globalStorage` 已被废弃。



#### `cookie` 与 `session`

##### 会话 `cookie`

​		`cookie` 的内容主要包括：名值对、过期时间、路径、域和安全标志。路径、域和安全标志一起构成了 `cookie` 的作用范围。若不设置时间，则表示这个 `cookie` 的生命期为浏览器会话期间，也就是说关闭浏览器窗口，`cookie` 就会消失。像这种生命期为浏览器会话期的 `cookie` 被称为会话 `cookie`，它们的过期时间（`Expires/Max-Age`）被浏览器标识为字符串 `"Session"`（意即：会话）。

​		会话 `cookie` 一般存储在内存中而非硬盘里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把 `cookie` 保存到硬盘上，这意味着关闭后再打开浏览器这些 `cookie` 仍然存在，直到超过设定的过期时间。对于保存在内存里的 `cookie`，不同的浏览器有着不同的处理方式。

##### `session`

​		`Session` 在计算机中，尤其是在网络应用中，称为“会话控制”。将 `session` 直接翻译成中文比较困难，一般都译成 **时域**。在计算机专业术语中，`Session` 是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。以及如果需要的话，可能还有一定的操作空间。

​		`Session` 的工作原理如下：

- 用户首次访问网站：用户首次访问网站时，服务器会为该用户创建一个 `Session`。`Session` 的创建方式有很多，如使用 `cookie`、`URL` 重写等等。
- 服务器存储 `Session` 信息：服务器将用户信息存储在 `Session` 中。
- `Session ID` 的传递：服务器会将 `Session ID` 传递给客户端，以便下次用户访问网站时能够识别用户。`Session ID` 可以通过使用 `cookie`、`URL` 重写等方式传递。
- 用户再次访问网站：当用户再次访问网站时，客户端会将 `Session ID` 传递给服务器。服务器会根据此 `Session ID` 查询出对应的 `Session`，并读取其中存储的用户信息。
- `Session` 的销毁：`Session` 有一个过期时间，当用户一段时间内没有访问网站时，`Session` 就会被销毁。`Session` 的销毁可以由服务器自动处理，也可以由开发者手动处理。

​		当程序需要为某个客户端的请求创建一个 `session` 时，服务器首先检查这个客户端的请求里是否已包含了一个 `session` 标识（称为 `session id`）。如果包含则说明此前已经为该客户端创建过 `session`，服务器就按照 `session id` 把这个 `session` 检索出来使用（检索不到，会新建一个）；如果客户端请求不包含 `session id`，则为客户端创建一个 `session` 并且生成一个与此 `session` 相关联的 `session id`。`session id` 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 `session id` 将在本次响应中被返回给客户端保存。保存这个 `session id` 的方式可以采用 `cookie`，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。

##### `session` 和 `cookie` 的区别

​		`cookie` 和 `session` 的主要区别如下：

- `cookie` 数据存放在用户的浏览器上，而 `session` 数据放在服务器上。
- `cookie` 不是很安全，别人可以分析存放在本地的 `cookie` 并进行 `cookie` 欺骗，考虑到安全应当使用 `session`。
- `session` 会在一定时间内保存在服务器上，访问增多会占用服务器的性能。若考虑减轻服务器性能方面，则可以使用 `cookie`。
- 单个 `cookie` 保存的数据不能超过 `4K`，很多浏览器都限制一个站点最多保存 20 个 `cookie`。
- 建议将登录信息等重要信息存放为 `session`，其他非重要信息如果需要保留，可以放在 `cookie` 中。
- `session` 保存在服务器，客户端不知道其中的信息；`cookie` 保存在客户端，服务器能够知道其中的信息。
- `session` 中保存的是对象，`cookie` 中保存的是字符串。
- `session` 不能区分路径，同一个用户在访问一个网站期间，所有的 `session` 在任何一个地方都可以访问到，而 `cookie` 中如果设置了路径参数，那么同一个网站中不同路径下的 `cookie` 互相是访问不到的。

##### `Web Storage` 和 `cookie` 的区别

​		`Web Storage` 的概念和 `cookie` 相似，区别是 `Web Storage` 是为了更大容量存储设计的，而 `cookie` 的大小是受限的，并且每次请求一个新的页面的时候 `cookie` 都会被发送过去，这样无形中浪费了带宽。另外 `cookie` 还需要指定作用域，不可跨域调用。

​		除此之外，`Web Storage` 拥有 `setItem`、`getItem`、`removeItem`、`clear` 等方法，不像 `cookie` 那样需要前端开发者自己封装用以管理 `cookie` 的工具箱。
​		然而 `cookie` 也是不可或缺的，`cookie` 的作用是与服务器进行交互，作为 `http` 规范的一部分而存在，而 `Web Storage` 仅仅是为了在本地存储数据而生的。
​		`sessionStorage`、`localStorage`、`cookie` 都是在浏览器端存储的数据，其中 `sessionStorage` 的概念很特别，引入了一个 “浏览器窗口” 的概念，`sessionStorage` 是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在；关闭窗口后，`sessionStorage` 就会被销毁，同时 “独立” 打开的不同窗口。即使是在同一个页面中，`sessionStorage` 对象也是不同的。

​		`Web Storage` 带来的好处：

- 减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据。因此，它减少了不必要的数据请求，减少了数据在浏览器和服务器之间不必要的来回传递。
- 快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多。本地数据可以立即获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，就可以立即显示。
- 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用 `sessionStorage` 就非常方便。

##### 浏览器存储与服务器端存储的区别

​		其实数据既可以在浏览器本地存储，也可以在服务器端存储。

​		浏览器可以保存一些数据，需要的时候直接从本地存取，`sessionStorage`、`localStorage` 和 `cookie` 都是由浏览器存储在本地的数据。服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。

- 服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。
- 服务器端也可以保存用户的临时会话数据，服务器端的 `session` 机制，如 `jsp` 的 `session` 对象，数据保存在服务器上。

​		实际上，服务器和浏览器之间仅需传递 `session id` 即可，服务器根据 `session id` 找到对应用户的 `session` 对象。会话数据仅在一段时间内有效，这个时间就是 `server` 端设置的 `session` 有效期。

​		服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。服务器存储数据安全一些，浏览器只适合存储一般数据。

##### `sessionStorage`、`localStorage` 和 `cookie` 的区别

​		共同点：都是保存在浏览器端的，受同源策略限制的数据。

​		区别：

- `cookie` 数据始终在同源的 `http` 请求中携带（即使不需要），即 `cookie` 在浏览器和服务器间来回传递，而 `sessionStorage` 和`localStorage` 不会自动把数据发送给服务器，仅在本地保存。`cookie` 数据还有路径（`path`）的概念，可以限制 `cookie` 只属于某个路径。
- 存储大小限制也不同，`cookie` 数据不能超过 `4K`，同时因为每次 `http` 请求都会携带 `cookie`、所以 `cookie` 只适合保存很小的数据，如会话标识。`sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 `5M` 或更大。
- 数据有效期不同，`sessionStorage` 仅在当前浏览器窗口关闭之前有效；`localStorage` 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；非会话 `cookie` 在其过期之前都有效（即使窗口关闭或浏览器关闭），会话 `cookie` 则在窗口关闭后消失。
- 作用域不同，`sessionStorage` 不在不同的浏览器窗口中共享，即使是同一个页面；`localstorage` 在所有同源窗口中都是共享的；`cookie` 也是在所有同源窗口中都是共享的。
- `Web Storage` 支持事件通知机制，可以将数据更新的通知发送给监听者。而 `cookie` 没有监听事件（除了 `cookieStore` 外）。
- `Web Storage` 的 `api` 接口使用更方便。

​		`sessionStorage` 与页面 `js` 数据对象的区别：页面中一般的 `js` 对象的生存期仅在当前页面有效，因此在刷新页面或转到另一页面后，数据就不存在了。而 `sessionStorage` 只要在同源的同窗口中，刷新页面或进入同源的不同页面，数据都始终存在，也就是说只要浏览器不关闭，数据都会保留。

##### `localStorage` 和 `sessionStorage`

​		具体来说，`Web Storage` 又分为两种：

- `sessionStorage`：将数据保存在 `session` 对象中。所谓 `session`，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。`session` 对象可以用来保存在这段时间内所要求保存的任何数据。
- `localStorage`：将数据保存在客户端本地的硬件设备（通常指硬盘，也可以是其他硬件设备）中。即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。

​		这两者的区别在于，`sessionStorage` 为临时保存，而 `localStorage` 为永久保存。`localStorage` 的特点就是，当浏览器关闭，我们在 `localStorage` 存储的数据还会存在，不会随着浏览器关闭而消失。

​		`sessionStorage` 和 `localStorage` 的功能及用法完全相同，唯一不同是生命周期。从字面上也不难看出：`sessionStorage` 为会话临时保存（存储在内存中），而 `localStorage` 为本地永久保存（存储在硬盘中）。

​		更多参考：[三分钟了解 `cookie`、`session`、`sessionStorage`、`localStorage`](https://blog.csdn.net/qq_42774501/article/details/122528832) 



#### `Storage` 类型

​		`Storage` 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。`Storage` 的实例与其他对象一样，但有以下方法。

- `clear()`：删除所有值；不在 `Firefox` 中实现。
- `getItem(name)`：取得给定 `name` 的值。
- `key(index)`：取得给定索引位置上的 `name`。
- `removeItem(name)`：删除给定 `name` 的名/值对。
- `setItem(name, value)`：设置给定 `name` 的值。

​		`getItem()`、`removeItem()` 和 `setItem()` 方法可以直接或间接通过 `Storage` 对象调用。因为每个数据项都作为属性存储在该对象上，所以可以使用点或方括号操作符访问这些属性，通过同样的操作来设置值，也可以使用 `delete` 操作符删除属性。即便如此，通常还是建议使用方法而非属性来执行这些操作，以免意外重写某个已存在的对象成员。

​		通过 `length` 属性可以确定 `Storage` 对象中保存了多少名/值对。我们无法确定对象中所有数据占用的空间大小，尽管 `IE8` 提供了 `remainingSpace` 属性，用于确定还有多少存储空间（以字节计）可用。

​		注意：`Storage` 类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。并且，这种转换不能在获取数据时撤销。



#### `sessionStorage` 对象

​		`sessionStorage` 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时清空未设过期的会话 `cookie` 类似。存储在 `sessionStorage` 中的数据不受页面刷新影响，且可以在浏览器崩溃并重启后恢复（取决于浏览器，`Firefox` 和 `WebKit` 支持，`IE` 不支持）。

​		因为 `sessionStorage` 对象与服务器会话紧密相关，所以在运行本地文件时不能使用（现在可以）。存储在 `sessionStorage` 对象中的数据只能由最初存储数据的页面使用，在多页应用程序中的用处有限。

​		因为 `sessionStorage` 对象是 `Storage` 的实例，所以可以通过使用 `setItem()` 方法或直接给属性赋值给它添加数据。下面是使用这两种方式的例子：

```js
// 使用方法存储数据
sessionStorage.setItem("name", "Nicholas"); 

// 使用属性存储数据
sessionStorage.book = "Professional JavaScript";
```

​		所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。具体 `API` 的实现可能不会立即把数据写入磁盘（而是使用某种不同的物理存储），但这个区别在 `JavaScript` 层面是不可见的。通过 `Web Storage` 写入的任何数据都可以立即被读取。

​		老版 `IE` 以异步方式实现了数据写入，因此给数据赋值的时间和数据写入磁盘的时间可能存在延迟。对于少量数据，这里的差别可以忽略不计，但对于大量数据，就可以注意到 `IE` 中 `JavaScript` 恢复执行的速度比其他浏览器更快。这是因为实际写入磁盘的进程被转移了。在 `IE8` 中可以在数据赋值前调用 `begin()`、之后调用 `commit()` 来强制将数据写入磁盘。比如：

```js
// 仅适用于 IE8 
sessionStorage.begin(); 
sessionStorage.name = "Nicholas"; 
sessionStorage.book = "Professional JavaScript"; 
sessionStorage.commit();
```

​		以上代码确保了 `"name"` 和 `"book"` 在 `commit()` 调用之后会立即写入磁盘。调用 `begin()` 是为了保证在代码执行期间不会有写入磁盘的操作。对于少量数据，这个过程不是必要的，但对于较大的数据量，如文档，则可以考虑使用这种事务性方法。

​		对存在于 `sessionStorage` 上的数据，可以使用 `getItem()` 或直接访问属性名来取得。下面是使用这两种方式的例子：

```js
// 使用方法取得数据
let name = sessionStorage.getItem("name"); 

// 使用属性取得数据
let book = sessionStorage.book;
```

​		可以结合 `sessionStorage` 的 `length` 属性和 `key()` 方法遍历所有的值：

```js
for (let i = 0, len = sessionStorage.length; i < len; i++){ 
 	let key = sessionStorage.key(i); 
 	let value = sessionStorage.getItem(key); 
 	console.log(`${key}=${value}`); 
}
```

​		这里通过 `key()` 先依次取得数据名称，然后使用该名称通过 `getItem()` 取得值，以此依次访问 `sessionStorage` 中的名值对。

​		当然，更简便的方式是使用 `for-in` 循环迭代 `sessionStorage` 的值：

```js
for (let key in sessionStorage){ 
 	let value = sessionStorage.getItem(key); 
 	console.log(`${key}=${value}`); 
}
```

​		每次循环，`key` 都会被赋予 `sessionStorage` 中的一个名称；但这里也会返回内置方法和 `length` 属性，因此需要将他们排除。

```js
for (let key in sessionStorage) {
    if(!Object.hasOwn(sessionStorage, key)) continue;
    let value = sessionStorage.getItem(key);
    console.log(`${key}=${value}`);
}
```

​		要从 `sessionStorage` 中删除数据，可以使用 `delete` 操作符直接删除对象属性，也可以使用 `removeItem()` 方法。下面是使用这两种方式的例子：

```js
// 使用 delete 删除值
delete sessionStorage.name; 

// 使用方法删除值
sessionStorage.removeItem("book");
```

​		还有一个可以一次性清空 `sessionStorage` 的 `clear()` 方法。

```js
sessionStorage.clear(); // 清空sessionStorage
```

​		`sessionStorage` 对象应该主要用于存储只在会话期间有效的小块数据。如果需要跨会话持久存储数据，可以使用 `globalStorage` 或 `localStorage`。



#### `localStorage` 对象

​		在修订的 `HTML5` 规范里，`localStorage` 对象取代了 `globalStorage`（已废除），作为在客户端持久存储数据的机制。要访问同一个 `localStorage` 对象，页面必须来自同一个域（子域也不可以）、在相同的端口上使用相同的协议。

​		因为 `localStorage` 是 `Storage` 的实例，所以可以像使用 `sessionStorage` 一样使用 `localStorage`。比如下面这几个例子：

```js
// 使用方法存储数据
localStorage.setItem("name", "Nicholas"); 

// 使用属性存储数据
localStorage.book = "Professional JavaScript"; 

// 使用方法取得数据
let name = localStorage.getItem("name"); 

// 使用属性取得数据
let book = localStorage.book;

// 清空localStorage
localStorage.clear(); 
```

​		两种存储方法的区别在于，存储在 `localStorage` 中的数据会一直保留，直到通过 `JavaScript` 删除或用户主动清除浏览器缓存。`localStorage` 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失，相当于存储在硬件磁盘上。



#### 存储事件

​		每当 `Storage` 对象发生变化时，都会触发 `storage` 事件。使用属性或 `setItem()` 设置值、使用 `delete` 或 `removeItem()` 删除值，以及每次调用 `clear()` 时都会在窗口上触发这个事件。这个事件的事件对象有如下的一些属性，但均只读。

| 属性（只读）  |                             类型                             | 描述                                      |
| :-----------: | :----------------------------------------------------------: | :---------------------------------------- |
|   `target`    | [`EventTarget`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget) | 事件目标（`DOM` 树中的最大目标）          |
|    `type`     | [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) | 事件的类型（即：`"storage"`）             |
|   `bubbles`   | [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) | 事件是否可冒泡                            |
| `cancelable`  | [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) | 事件是否可取消                            |
|     `key`     | [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) (`string`) | 正在发生更改的键                          |
|  `oldValue`   | [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) (`string`) | 正在更改键的旧值                          |
|  `newValue`   | [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) (`string`) | 正在更改键的新值（若键被删除则为 `null`） |
|     `url`     | [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) (`string`) | 更改键的文档地址                          |
| `storageArea` | [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) | 受到影响的 `Storage` 对象                 |

​		事实上，除了 `Window` 接口，`onstorage` 事件处理程序属性也可用于以下对象：

- [`HTMLBodyElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLBodyElement)
- [`HTMLFrameSetElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFrameSetElement)
- [`SVGSVGElement`](https://developer.mozilla.org/en-US/docs/Web/API/SVGSVGElement)

​		可以使用如下代码监听 `storage` 事件：

```js
window.addEventListener("storage", (event) => console.log(`Storage changed for ${event.domain}`));
```

​		过去，在 `sessionStorage` 和 `localStorage` 上的任何更改都会触发 `storage` 事件，且 `storage` 事件不会区分这两者。现在，只有 `localStorage` 变化时才会触发它。当 `localStorage` 在另一个文档的上下文中被修改时，才触发 `Window` 接口的存储事件。这个事件对正在进行更改的页面不起作用，因为它实际上是让同域的其他页面使用存储去同步所做更改的一种方法。因此，只有在同一域的另一页面中修改 `localStorage`，才会使当前页面中的 `storage` 事件被触发。这可以在两个窗口中打开同一个在线页面，然后通过在其中一个页面中修改 `localStorage`，来触发另一个页面中的 `storage` 事件。



#### 限制

​		与其他客户端数据存储方案一样，`Web Storage` 也有限制。具体的限制取决于特定的浏览器。一般来说，客户端数据的大小限制是按照每个源（协议、域名和端口）来设置的，因此每个源有固定大小的数据存储空间。分析存储数据的页面的源可以加强这一限制。

​		不同浏览器给 `localStorage` 和 `sessionStorage` 设置了不同的空间限制，但大多数会限制为每个源 `5MB`。关于每种媒介的新配额限制信息表，可以参考 `web.dev` 网站上的文章《`Storage for the Web`》。

​		要了解关于 `Web Storage` 限制的更多信息，可以参考 `dev-test.nemikor` 网站的 `“Web Storage Support Test”` 页面。



### `IndexedDB`

​		`Indexed Database API` 简称 `IndexedDB`（索引数据库），是浏览器中存储结构化数据的一个方案。用于代替已废弃的 `Web SQL Database API`。`IndexedDB` 背后的思想是创造一套 `API`，方便 `JavaScript` 对象的存储和获取，同时也支持查询和搜索。

​		`IndexedDB` 的设计几乎完全是异步的。为此，大多数操作以请求的形式执行，这些请求会异步执行，产生成功的结果或错误。绝大多数 `IndexedDB` 操作要求添加 `onerror` 和 `onsuccess` 事件处理程序来确定输出。

​		2017 年，新发布的主流浏览器（`Chrome`、`Firefox`、`Opera`、`Safari`）完全支持 `IndexedDB`。`IE10/11` 和 `Edge` 浏览器部分支持 `IndexedDB`。



#### 数据库

​		`IndexedDB` 是类似于 `MySQL` 或 `Web SQL Database` 的数据库。与传统数据库最大的区别在于，`IndexedDB` 使用对象存储而不是表格来保存数据。`IndexedDB` 数据库就是在一个公共命名空间下的一组对象存储，类似于 `NoSQL` 风格的实现。

##### 打开数据库

​		使用 `IndexedDB` 数据库的第一步是调用 `indexedDB.open()` 方法开启数据库，需要给它传入一个数据库名称。如果该数据库已经存在，则会发送一个打开它的请求；如果不存在，则会发送创建并打开它的请求。这个方法返回一个 `IDBOpenDBRequest` 的实例。

```js
let db, // 数据库实例
 	request, // 操作请求实例
 	version = 1; // 数据库版本

// 打开或创建后再打开指定版本的admin数据库
request = indexedDB.open("admin", version); 

console.log(request); // IDBOpenDBRequest {result: IDBDatabase, error: null, source: null, ...}
/*
IDBOpenDBRequest {
	error: null,
	onblocked: (event) => {…},
	onerror: (event) => {…},
	onsuccess: (event) => {…},
	onupgradeneeded: (event) => {…},
	readyState: "done",
	result: IDBDatabase {name: 'admin', version: 1, objectStoreNames: DOMStringList, ...},
	source: null,
	transaction: null,
	[[Prototype]]: IDBOpenDBRequest
}
*/
```

​		以前，`IndexedDB` 使用 `setVersion()` 方法指定版本号。但这个方法目前已废弃。如上述代码所示，要在打开数据库的时候就指定版本。这个版本号会被转换为一个 `unsigned long long` 数值，因此不要使用小数、0 或负数，而要使用正整数。指定数据库版本的参数可以省略（如果省略，那么默认创建的版本号是 1，默认打开的版本是当前版本）。

##### 监听打开

​		当使用 `open()` 请求打开数据库时，可以在其返回的实例上添加 `onerror` 和 `onsuccess` 事件来监听打开请求的结果。如下：

```js
// 打开失败时
request.onerror = (event) => console.log(`Failed to open: ${event.target.errorCode}`); 

// 打开成功时
request.onsuccess = (event) => db = event.target.result;
```

​		这两个事件处理程序的 `event.target` 都指向 `IDBOpenDBRequest` 实例本身。如果 `onsuccess` 事件处理程序被调用，则说明连接成功，此时数据库（`IDBDatabase`）实例会被保存到 `event.target.result` 和 `request.result` 中。上面，将该实例保存到 `db` 变量中。此后，所有与数据库相关的操作都要在 `db` 对象上进行。如果打开数据库期间发生错误，则 `onerror` 会被调用，此时表示问题的错误码会被保存到 `event.target.errorCode` 中。

​		注意：默认地，当数据库升级后，再打开其旧版本会触发失败。以前，出错时会使用 `IDBDatabaseException` 表示 `IndexedDB` 发生的错误。但现在，它已被标准的 `DOMExceptions` 取代。

##### 升级数据库

​		`IndexedDB` 数据库只能被升级，且升级后，不能再打开低于当前版本的数据库。升级数据库，只需在调用 `open()` 时传入一个高于当前版本的版本值即可。

```js
request = indexedDB.open("admin", 2); // 从版本1升级到版本2
```

​		在 `open()` 返回的 `IDBOpenDBRequest` 实例上还有一个 `upgradeneeded` 事件和 `blocked` 事件，同样的，它们的 `event.target` 也都指向 `IDBOpenDBRequest` 实例自身。`upgradeneeded` 事件在每次升级数据库时触发，首次创建数据库时也会触发它。`blocked` 事件则在上一次的数据库连接还未关闭时触发，因为一个网页只能同时连接一个数据库。

```js
request.onupgradeneeded = (event) => {
    console.log('upgradeneeded', event.target === request); // "upgradeneeded" true
};

request.onblocked = (event) => {
    console.log('blocked', event.target === request); // "blocked" true
};
```

​		值得一提的是，由于 `upgradeneeded` 在创建数据库时也会触发，因此，它总是在 `success` 和 `error` 之前触发。

```js
// 初次创建以及每次升级版本时
request.onupgradeneeded = (event) => {
    console.log('onupgradeneeded');
    db = event.target.result;
};

// 每次打开失败时
request.onerror = (event) => console.log(`Failed to open: `, event.target === request);

// 每次打开成功时
request.onsuccess = (event) => {
    console.log('success', db);
};
```

​		注意：不能只基于上一个版本做升级，升级逻辑应适配所有的场景。例如：可以从无、第 1 版、第 2 版等，直接升到当前最新版！

> 举个例子：
>
> ​		假如你的数据库经历过两次升级，版本号由 1，到 2，又到了现在的 3。那么在做 2 到 3 的升级时，你不能只写 2 到 3 这一个升级逻辑，你的逻辑必须能够适配 1 到 3 的升级，以及从无直接到 3 的创建。
> ​		因为用户可能是第一次打开你的网站，本地压根就不存在该数据库，这时要进行直接到 3 的创建；用户也可能在你的版本还是 1的时候打开过你的网站，但直到现在版本升到 3 了才再次打开，这时就要进行 1 到 3 的升级。

​		更多参考：[`indexDB` 出坑指南](https://www.shuzhiduo.com/A/gAJG4N015Z/) 



#### 对象存储

​		建立数据库连接（即：开启数据库）之后，下一步就是使用对象存储（`Object Store`）。如果数据库版本与期待的不一致，那么可能需要创建对象存储。不过，在创建对象存储前，有必要先想一想要存储什么类型的数据。

##### 对象存储键

​		假设要存储包含用户名、密码等内容的用户记录。可以用如下对象来表示一条记录：

```js
let user = { 
 	username: "007", // 此对象中选择"007"作为主键最为合适
 	firstName: "James", 
 	lastName: "Bond", 
 	password: "foo" 
};
```

​		创建对象存储时必须为其指定一个标识键，亦称为**主键**（`primaryKey`）。观察这个对象，可以很容易地看出最适合作为对象存储键的是 `username` 属性的值。主键必须全局唯一，因为在大多数情况下，它都是访问数据的唯一凭据。

##### 数据库模式

​		数据库的版本决定了数据库的模式（包括数据库中的对象存储和这些对象存储的结构）。如果数据库不存在，则 `open()` 操作会创建该数据库，然后触发 `upgradeneeded` 事件。可以为这个事件设置处理程序，并在该处理程序中创建数据库模式。如果数据库存在，而你指定了一个升级版的版本号，也会立即触发 `upgradeneeded` 事件，因此还可以在该事件处理程序中更新数据库模式。

​		下面的代码演示了为存储上述用户信息而如何创建对象存储：

```js
request.onupgradeneeded = (event) => { 
 	const db = event.target.result; 
    
 	// 如果存在则删除当前 objectStore。测试的时候可以这样做，但这样会在每次触发该事件时删除已有数据。
 	if (db.objectStoreNames.contains("users")) db.deleteObjectStore("users"); 
    
    // 创建一个名为users的对象存储，其标识键为对象username属性的值。
 	db.createObjectStore("users", { keyPath: "username" }); 
};
```

​		可以通过给 `db.objectStoreNames.contains()` 传入一个对象存储名，来查询指定的对象存储是否已存在。如果要删除对象存储，则可以调用 `db.deleteObjectStore()` 并传入指定的对象存储名。创建对象存储则需要调用 `db.createObjectStore()` 方法，它可接收两个参数：对象存储名和配置对象。在配置对象中，必须通过 `keyPath` 属性来指定该对象存储的标识键路径（该对象存储中的每个对象都将以此路径确定自己的标识键，例如：以 `username` 属性值为标识键）。

##### 对象存储实例

​		`db.createObjectStore()` 返回一个 `IDBObjectStore` 的实例，即：对象存储实例。它拥有如下的属性和原型方法：

```
IDBObjectStore {
    autoIncrement: false,
	indexNames: DOMStringList {length: 0},
	keyPath: "username",
	name: "users",
	transaction: IDBTransaction {mode: 'versionchange', db: IDBDatabase, ...},
	[[Prototype]]: IDBObjectStore {
		add: ƒ add(),
		autoIncrement: (...),
		clear: ƒ clear(),
		count: ƒ count(),
		createIndex: ƒ createIndex(),
		delete: ƒ delete(),
		deleteIndex: ƒ deleteIndex(),
		get: ƒ (),
		getAll: ƒ getAll(),
		getAllKeys: ƒ getAllKeys(),
		getKey: ƒ getKey(),
		index: ƒ index(),
		indexNames: (...),
		keyPath: (...),
		name: (...),
		openCursor: ƒ openCursor(),
		openKeyCursor: ƒ openKeyCursor(),
		put: ƒ put(),
		transaction: (...),
		constructor: ƒ IDBObjectStore(),
		Symbol(Symbol.toStringTag): "IDBObjectStore",
		get autoIncrement: ƒ autoIncrement(),
		get indexNames: ƒ indexNames(),
		get keyPath: ƒ keyPath(),
		get name: ƒ name(),
		set name: ƒ name(),
		get transaction: ƒ transaction(),
		[[Prototype]]: Object
    }
}
```

​		其中，`name` 和 `keyPath` 都是必须在创建时就指定的两个属性：`name` 是该对象存储的名称，`keyPath` 是该对象存储的标识键的路径。对象存储实例可以通过调用事务的 `objectStore()` 方法来获得，然后获得的对象存储实例的 `transaction` 属性就会指向该事务。



#### 事务

​		创建了对象存储之后，剩下的所有操作都是通过事务完成的。事务要通过调用数据库对象的 `transaction()` 方法创建。任何时候，只要想要读取或修改数据，都要通过事务把所有修改操作组织起来。

##### 创建事务

​		最简单的情况下，可以像下面这样创建事务，事务至少应该在数据库连接成功时才创建：

```js
let db = null, 
    version = 1, 
    request = indexedDB.open("admin", version); 

// 初次创建以及每次升级版本时
request.onupgradeneeded = (event) => {
    db = event.target.result;
    db.createObjectStore("users", { keyPath: "username" }); 
};

// 每次打开失败时
request.onerror = (event) => console.log(`Failed to open: `, event.target === request);

// 每次打开成功时
request.onsuccess = (event) => {
    let transaction = db.transaction();
};
```

​		过去，可以不指定参数，如此该事务对数据库中所有的对象存储只有只读权限。而现在，必须指定一个参数。可以指定首参为一个或多个要访问的对象存储的名称。该方法返回一个 `IDBTransaction` 的实例，其中包含一个指向创建该事务的数据库实例的 `db` 属性。

```js
let transaction = db.transaction("users"); // IDBTransaction {mode: 'readonly', db: IDBDatabase, ...}
/*
IDBTransaction {
	db: IDBDatabase {name: 'admin', version: 1, ...}, // 该事务所属的数据库实例
	durability: "default",
	error: null,
	mode: "readonly",
	objectStoreNames: DOMStringList {0: 'users', length: 1},
	onabort: null,
	oncomplete: null,
	onerror: null,
	[[Prototype]]: IDBTransaction {
		abort: ƒ abort(),
		commit: ƒ commit(),
		db: (...),
		durability: (...),
		error: (...),
		mode: (...),
		objectStore: ƒ objectStore(), // 获取对象存储实例的方法
		objectStoreNames: (...),
		onabort: (...),
		oncomplete: (...),
		onerror: (...),
		constructor: ƒ IDBTransaction(),
		Symbol(Symbol.toStringTag): "IDBTransaction",
		get db: ƒ db(),
		get durability: ƒ durability(),
		get error: ƒ error(),
		get mode: ƒ mode(),
		get objectStoreNames: ƒ objectStoreNames(),
		get onabort: ƒ onabort(),
		set onabort: ƒ onabort(),
		get oncomplete: ƒ oncomplete(),
		set oncomplete: ƒ oncomplete(),
		get onerror: ƒ onerror(),
		set onerror: ƒ onerror(),
		[[Prototype]]: EventTarget
	}
}
*/
```

​		这样可以确保在事务期间只加载 `users` 对象存储的信息。如果想要访问多个对象存储，可以给第一个参数传入一个字符串数组：

```js
let transaction = db.transaction(["users", "anotherStore"]);
```

​		传入的对象存储必须都存在，否则会报错。它们的名称会以伪数组的形式被记录在事务实例的 `objectStoreNames` 属性中。

##### 事务模式

​		如前所述，每个事务都默认以只读的方式访问对象存储。如果要修改访问模式，可以传入第二个参数。这个参数是下列的三个字符串之一：`"readonly"`、`"readwrite"` 或 `"versionchange"`。

|       值        | 描述                                                         |
| :-------------: | :----------------------------------------------------------- |
|   `readonly`    | 只允许读取对象存储，默认值。                                 |
|   `readwrite`   | 允许读取和写入对象存储。                                     |
| `versionchange` | 允许执行任何操作，包括删除与创建对象存储和索引。此模式用于更新使用 `open()` 启动的事务的版本号。这种模式的事务无法与其他事务并发运行。这种模式下的事务被称为 “升级事务”。 |

​		过去，事务的版本号由 `setVersion()` 来启动；但现在它已被 `open()` 所取代。

​		另外，使用 `db.createObjectStore()` 创建的对象存储的事务模式默认为 `versionchange`。因为当触发 `onupgradeneeded` 时会开启升级事务模式。因此，当在 `onupgradeneeded` 中创建事务时，会触发以下事务错误：不能在运行升级事务时启动事务。

​		下面的代码，允许事务对 `users` 对象存储进行读写。

```js
let transaction = db.transaction("users", "readwrite");
```

##### 使用事务

​		创建好事务之后，就可以通过调用事务实例的 `objectStore()` 方法并传入对象存储的名称来获取特定的对象存储实例了。然后，可以在对象存储实例上使用 `add()` 和 `put()` 方法添加和更新对象，使用 `get()` 取得指定的对象，使用 `delete()` 删除指定的对象，使用 `clear()` 删除所有对象。其中，`get()` 和 `delete()` 以对象标识键为参数，`add()` 和 `put()` 以对象为参数，`clear()` 不接收参数。

```js
const transaction = db.transaction("users"), 	// 创建只读取users对象存储的事务
      store = transaction.objectStore("users"); // 获取对象存储实例

let addReq = store.add({username: "007", password: "foo"}), // 请求添加一个对象
    putReq = store.put({username: "007", password: "bar"}), // 请求更新特定对象
	getReq = store.get("007"), 								// 请求获取特定对象
    delReq = store.delete("007"), 							// 请求删除特定对象
    clsReq = store.clear(); 								// 请求删除所有对象
```

​		这 5 个方法每一个都会创建新的请求对象（`IDBRequest` 的实例）。它们的 `result` 属性不尽相同，`source` 属性为当前操作的对象存储实例，`transaction` 属性为当前正在运行该请求的事务。这 5 个请求对象的 `result` 属性值如下，默认为 `undefined`：

- `get`：请求操作的对象，即：通过标识键获取到的对象。
- `add`：请求操作的对象的标识键，即：本次操作添加的对象的标识键。
- `put`：请求操作的对象的标识键，即：本次操作更新的对象的标识键。
- `delete`：`undefined`。
- `clear`：`undefined`。

```
IDBRequest {
	error: null,
	onerror: null,
	onsuccess: null,
	readyState: "done",
	result: undefined,
	source: IDBObjectStore {name: 'users', keyPath: 'username', ...},
	transaction: IDBTransaction {mode: 'readonly', db: IDBDatabase, ...},
	[[Prototype]]: IDBRequest
}
```

​		这 5 个请求对象都可以添加 `onsuccess` 和 `onerror` 事件来监听请求状态，事件目标均为请求对象本身。

```js
// 请求失败
request.onerror = (event) => console.log(event.target === request); 	// true

// 请求成功
request.onsuccess = (event) => console.log(event.target === request); 	// true
```

##### 监听事务

​		因为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：`onerror` 和 `oncomplete`。这两个事件可以用来获取事务级的状态信息，其中，`oncomplete` 的事件目标为事务实例本身，而 `onerror` 的事件目标为 `IDBRequest` 实例。

```js
// 事务发生错误
transaction.onerror = (event) => console.log(event.target instanceof IDBRequest); // true

// 事务成功完成
transaction.oncomplete = (event) => console.log(event.target === transaction);	  // true
```

​		当某个请求操作失败而导致事务发生错误时，`onerror` 实际上会先后触发两次，因为事务失败还会导致事务取消。第一次的事件目标为一个指出问题的 `IDBRequest` 实例，第二次的事件目标为导致该事务取消的请求对象。

​		注意，无法通过 `oncomplete` 事件处理程序的 `event` 对象去访问 `get()` 请求返回的任何数据。因此，仍然需要通过 `get()` 请求的 `onsuccess` 事件处理程序来获取数据对象。

```js
request.onsuccess = (event) => console.log(event.target.result); // 打印获取到的对象
```

##### 添加对象

​		对象存储实例上的 `add()` 和 `put()` 都可用于向对象存储中插入一个新的对象。它们都接收一个参数，即：要存储的对象，然后把传入的对象保存到对象存储中。两者在插入对象的功能上是完全一样的。

```js
// 使用add插入新对象
store.add({username: "007", firstName: "James", lastName: "Bond", password: "foo"}); 

// 使用put插入新对象
store.put({username: "008", firstName: "James", lastName: "Bond", password: "foo"}); 
```

##### 更新对象

​		但这两个方法的作用不同，`add()` 专门用于插入对象，而 `put()` 主要用于更新对象。因此，当给它们传入标识键已存在的对象时，`add()` 会导致错误，而 `put()` 会在对象存储中重写该对象。

```js
// 使用add插入已存在的对象
store.add({username: "007", password: "bar"}); // 发生错误

// 使用put更新已存在的对象
store.put({username: "008", password: "bar"}); // 更新成功
```

​		如果想验证每次请求成功与否，则可以把请求对象保存到一个变量中，然后为它添加 `onerror` 和 `onsuccess` 事件处理程序：

```js
// users 是一个用户数据的数组
let request, 
 	requests = []; 

for (let user of users) { 
 	request = store.put(user); // 添加或更新对象
    
 	request.onerror = () => { 
 		// 处理错误
 	}; 
 	request.onsuccess = () => { 
 		// 处理成功
 	}; 
    
 	requests.push(request); 
}
```

​		创建并填充了数据后，就可以查询对象存储了。查询方式有：使用特定主键、使用游标、使用键范围和使用索引。



#### 游标

​		使用事务可以通过一个标识键取得一条记录。如果想**取得多条数据**，则需要在事务中创建一个游标。游标是一个指向结果集的指针。与传统数据库查询不同，游标不会事先收集所有结果。相反，**游标默认指向第一个结果**，并在接到指令前不会主动移到下一条数据。

##### 创建游标

​		需要在对象存储上调用 `openCursor()` 方法创建游标，默认指向对象存储中的第一个结果。

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      request = store.openCursor(); // 使用游标来代替get的单一查询
```

​		`openCursor()` 方法也返回一个 `IDBRequest` 实例，其 `result` 属性是游标匹配的结果，为 `IDBCursorWithValue` 实例或 `null`。

```
IDBCursorWithValue {
	direction: "next",
	key: "007",
	primaryKey: "007",
	request: IDBRequest {result: IDBCursorWithValue, source: IDBObjectStore, ...},
	source: IDBObjectStore {name: 'users', keyPath: 'username', indexNames: DOMStringList, ...},
	value: {username: '007', password: 'bar'}
	[[Prototype]]: IDBCursorWithValue
}
```

​		在这个 `IDBCursorWithValue` 实例中，`direction` 表示该游标前进的方向，`primaryKey` 是该游标当前使用的主键（可能是对象键或索引键），`key` 是当前对象的主键，`value` 是当前对象，`request` 是当前的请求对象实例，`source` 是当前的对象存储实例。

##### 游标查询

​		`openCursor()` 方法返回一个 `IDBRequest` 实例，因此可以为它添加 `onsuccess` 和 `onerror` 事件处理程序来监听游标的状态。这两个事件目标都指向 `IDBRequest` 实例自身。

```js
// 创建成功
request.onsuccess = (event) => { 
 	console.log(event.target === request); // true
}; 

// 创建失败
request.onerror = (event) => { 
 	console.log(event.target === request); // true
};
```

​		当触发 `onsuccess` 事件时，其 `event.target.result` 保存着在对象存储中匹配到的记录，该记录是 `IDBCursorWithValue` 的实例（有该记录时）或 `null`（没有记录时）。

​		可以像下面这样取得一个结果：

```js
request.onsuccess = (event) => { 
 	const cursor = event.target.result; 
 	if (cursor) { // 永远要检查
 		console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`); 
 	} 
};
```

​		注意，这个例子中的 `cursor.value` 保存着实际的对象。正因为如此，在显示它之前才需要使用 `JSON` 来编码。

##### 更新对象

​		游标可用于更新当前对象。通过在当前游标结果上调用 `update()` 方法可使用指定的对象更新当前游标对应的对象。与其他类似操作一样，调用 `update()` 会创建一个新请求，因此如果想知道结果，需要添加 `onsuccess` 和 `onerror` 事件来获悉：

```js
request.onsuccess = (event) => { 
 	const cursor = event.target.result; 
 	let value, 
 		updateRequest; 
    
 	if (cursor) { // 永远要检查
 		if (cursor.key === "010") { 
 			value = cursor.value; // 取得当前对象
 			value.password = "magic!"; // 更新密码
 			updateRequest = cursor.update(value); // 请求保存更新后的对象
 			updateRequest.onsuccess = (event) => { // 处理成功
 				console.log(event.target === updateRequest); // true
 			}; 
 			updateRequest.onerror = (event) => { // 处理错误
 				console.log(event.target === updateRequest); // true
 			}; 
 		} 
 	} 
};
```

​		调用 `cursor.update()` 返回一个 `IDBRequest` 实例，它跟调用 `store.put()` 返回的实例很相似。其 `result` 为当前更新的对象的主键，`source` 为当前更新的游标结果（即：本次 `update()` 的调用者），`transaction` 为当前正在运行该请求的事务。

```
IDBRequest {
	error: null,
	onerror: (e) => {…},
	onsuccess: (e) => {…},
	readyState: "done",
	result: "010",
	source: IDBCursorWithValue {direction: 'next', key: '010', primaryKey: '010', ...},
	transaction: IDBTransaction {mode: 'readwrite', db: IDBDatabase, ...},
	[[Prototype]]: IDBRequest
}
```

##### 删除对象

​		也可以在当前游标结果上调用 `delelte()` 来删除当前游标对应的对象，与 `update()` 一样，这也会创建一个请求：

```js
request.onsuccess = (event) => { 
 	const cursor = event.target.result; 
 	let value, 
 		deleteRequest; 
    
 	if (cursor) { // 永远要检查
 		if (cursor.key == "foo") { 
 			deleteRequest = cursor.delete(); // 请求删除对象（不需要任何参数）
 			deleteRequest.onsuccess = () => { // 处理成功
 				console.log(event.target === deleteRequest); // true
 			}; 
 			deleteRequest.onerror = () => { // 处理错误
 				console.log(event.target === deleteRequest); // true
 			}; 
 		} 
 	} 
};
```

​		如果事务没有修改对象存储的权限，则调用 `update()` 和 `delete()` 都会抛出错误，而不是触发 `onerror`。

##### 移动游标

​		默认情况下，每个游标只会创建一个请求，并停在结果集中的第一条记录。可调用下列中的一个方法，将游标移动到指定的位置。

- `continue(key)`：移动到结果集中的下一条记录。参数 `key` 是可选的。如果没有指定 `key`，游标就移动到下一条记录；如果指定了，则游标移动到指定的主键（必须大于当前游标的位置）。
- `advance(count)`：游标向前移动指定的 `count` 条记录。比如：向前移动到第 2 条记录。

​		这两个方法都会更新当前的请求对象（更新其 `result` 属性），并让游标重用它请求，因此也会再次触发 `onsuccess` 和 `onerror` 处理程序，直至不再需要。例如，下面的代码将会自动迭代当前结果集中的所有记录：

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      request = store.openCursor(); // 创建游标（返回一个请求对象）

request.onsuccess = (event) => { 
 	const cursor = event.target.result; 
 	if (cursor) { // 永远要检查
 		console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`); 
 		cursor.continue(); // 移动到下一条记录
 	} else { 
 		console.log("Done!"); 
 	} 
};
```

​		调用 `cursor.continue()` 会更新当前请求对象并再次触发其 `onsuccess` 事件处理程序。在没有更多记录时，`onsuccess` 事件处理程序最后一次被调用，此时 `event.target.result` 等于 `null`。

​		当给 `cursor.continue()` 指定一个主键时，必须为其添加判断，否则会因为提供的参数小于或等于当前游标的位置而报错。

```js
request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (cursor) { // 永远要检查
        console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
        if(cursor.key !== '010') {
            cursor.continue('010'); // 移动到指定的主键（参数必须大于当前游标的位置）
        }
    } else {
        console.log("Done!");
    }
};
```

​		注意：`continue` 和 `advance` 的共同点是：它们都直接跳到指定的位置，而忽略中间的记录。区别是：`continue` 由于条件限制的缘故会停留在指定位置上；`advance` 则会从指定位置在结果集中继续向前移动到指定条记录，直至最后一条。

​		例如，一共有 12 条数据，当前的游标位置为 001。然后，调用 `continue('010')` 与调用 `advance(2)` 默认呈现如下的结果：

```
// continue('010')
Key: 001, Value: {"username":"001","password":"bar"}
Key: 010, Value: {"username":"010","password":"bar"}
Uncaught DOMException: Failed to execute 'continue' on 'IDBCursor': The parameter is less than or equal to this cursor's position.

// advance(2)
Key: 001, Value: {"username":"001","password":"bar"}
Key: 003, Value: {"username":"003","password":"bar"}
Key: 005, Value: {"username":"005","password":"bar"}
Key: 007, Value: {"username":"007","password":"bar"}
Key: 009, Value: {"username":"009","password":"bar"}
Key: 011, Value: {"username":"011","password":"bar"}
Done!
```

##### 游标方向

​		`openCursor()` 方法实际上可以接收两个参数，第一个用于指定键范围，第二个用于指定游标前进方向。通常，游标都是从对象存储的第一条记录开始，每次调用 `continue()` 或 `advance()` 都会默认向最后一条记录前进。这样的游标默认方向为 `"next"`。如果对象存储中有重复的记录，可能需要游标跳过那些重复的项。为此，可以给 `openCursor()` 的第二个参数传入 `"nextunique"`：

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      request = store.openCursor(null, "nextunique");
```

​		注意，`openCursor()` 的第一个参数是 `null`，表示默认的键范围是所有值。此游标会遍历对象存储中的记录，从第一条记录开始迭代，到最后一条记录，但会跳过重复的记录。

​		另外，也可以创建在对象存储中反向移动的游标，从最后一项开始向第一项移动。此时，则需要给 `openCursor()` 传入 `"prev"` 或 `"prevunique"` 作为第二个参数（同样为了避免重复）。例如：

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      request = store.openCursor(null, "prevunique");
```

​		在使用 `"prev"` 或 `"prevunique"` 打开游标时，每次调用 `continue()` 或 `advance()` 都会在对象存储中反向移动游标。

##### 获取数据

​		由上可知，游标的默认起点为第一条数据。使用 `continue()` 可以获取一条或所有数据，使用 `advance()` 可以间隔地获取数据。

​		获取一条数据：按特定的主键获取对应的数据。

```js
request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (!cursor) return;
    // 查询该主键对应的数据
    if (cursor.key !== '010') return cursor.continue('010'); 
    // 获得该主键对应的数据
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
};
```

​		获取所有数据：`continue()` 和 `advance()` 都可以实现。

```js
// 第一种方式：
request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (!cursor) return;
    // 获得数据
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
    return cursor.continue(); // 继续查询下一条数据
};

// 第二种方式：
request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (!cursor) return;
    // 获得数据
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
    return cursor.advance(1); // 继续查询下一条数据
};
```

​		间隔地获取数据：

```js
request.onsuccess = (event) => {
    const cursor = event.target.result;
    if (!cursor) return;
    // 获得数据
    console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`);
    return cursor.advance(2); // 继续查询下下条数据
};
```



#### 键范围

​		单单使用游标获取数据还不太理想，因为它无法获取一定范围内的数据。若要如此，则还需要键范围（`key range`）的配合。

​		每个键范围都是 `IDBKeyRange` 的实例，它们有如下的基本属性。其中，`lower` 和 `upper` 分别表示作为范围下限和上限的标识键，默认 `undefined`；`lowerOpen` 和 `upperOpen` 分别表示是否舍弃下限键和上限键的布尔值，默认 `false`，舍弃界限键后转为 `true`。

```js
IDBKeyRange {lower: undefined, upper: undefined, lowerOpen: false, upperOpen: false}
```

​		`IDBKeyRange` 原型上只有一个 `includes()` 方法。而要指定范围的边界，则需要调用 `IDBKeyRange` 上的静态方法，共有四种。

##### 范围下限

​		第一种键范围可以定义结果集的下限。下限表示游标开始的位置。例如，下面的键范围保证游标从 `"007"` 这个键开始，直到最后：

```js
// 从"007"记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound("007");
// IDBKeyRange {lower: '007', upper: undefined, lowerOpen: false, upperOpen: true}
```

​		如果想从 `"007"` 后面的记录开始，可以再传入第二个参数 `true`，它会使 `lowerOpen` 被转为 `true`：

```js
// 从"007"的下一条记录开始，直到最后
const lowerRange = IDBKeyRange.lowerBound("007", true);
// IDBKeyRange {lower: '007', upper: undefined, lowerOpen: true, upperOpen: true}
```

##### 范围上限

​		第二种键范围可以定义结果集的上限，通过调用 `upperBound()` 方法可以指定游标不会越过的记录。下面的键范围保证游标从头开始并在到达键为 `"ace"` 的记录时停止：

```js
// 从头开始，到"ace"记录为止
const upperRange = IDBKeyRange.upperBound("ace");
// IDBKeyRange {lower: undefined, upper: 'ace', lowerOpen: true, upperOpen: false}
```

​		如果不想包含终止键，可以在第二个参数传入 `true`，它会使 `upperOpen` 被转为 `true`：

```js
// 从头开始，到"ace"的前一条记录为止
const upperRange = IDBKeyRange.upperBound("ace", true);
// IDBKeyRange {lower: undefined, upper: 'ace', lowerOpen: true, upperOpen: true}
```

##### 范围界限

​		要同时指定下限和上限，可以使用 `bound()` 方法。这个方法接收四个参数：下限的键、上限的键、可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限。下面是几个例子：

```js
// 从"007"记录开始，到"ace"记录停止
const boundRange = IDBKeyRange.bound("007", "ace"); 
// 从"007"的下一条记录开始，到"ace"记录停止
const boundRange = IDBKeyRange.bound("007", "ace", true); 
// 从"007"的下一条记录开始，到"ace"的前一条记录停止
const boundRange = IDBKeyRange.bound("007", "ace", true, true); 
// 从"007"记录开始，到"ace"的前一条记录停止
const boundRange = IDBKeyRange.bound("007", "ace", false, true);
```

##### 范围坍缩

​		最后一种是使用 `only()` 方法（只接收一个参数）并传入想要获取的键，这个范围保证只获取键为 `"007"` 的值。

```js
const onlyRange = IDBKeyRange.only("007");
// IDBKeyRange {lower: '007', upper: '007', lowerOpen: false, upperOpen: false}
```

​		使用这个范围创建的游标类似于直接在对象存储上调用 `get("007")`。因为这个范围已经坍缩到一处，即：它的上下限是重合的。

##### 创建游标

​		定义好范围之后，把它传给 `openCursor()` 方法，就可以获得位于该范围内的游标：

```js
const store = db.transaction("users", "readwrite").objectStore("users"), 
      range = IDBKeyRange.bound("003", "007"), 
      request = store.openCursor(range); // 请求获取游标

// 监听游标状态
request.onsuccess = function(event) { 
 	const cursor = event.target.result; 
 	if (!cursor) return;
 	console.log(`Key: ${cursor.key}, Value: ${JSON.stringify(cursor.value)}`); 
 	cursor.continue(); // 查询下一条记录
};
```

​		这个例子，将会找出键范围为 `["003", "007"]` 内的所有对象。



#### 索引

​		对某些数据集，可能需要**为对象存储指定多个标识键**。例如，如果同时记录了用户 `ID` 和用户名，那么可能需要通过二者中的任何一种方式来获取用户数据。为此，可以考虑将用户 `ID` 作为主键，然后在用户名上创建索引。

##### 创建索引

​		通过在对象存储上调用 `createIndex()` 方法来创建索引，该方法只能在运行升级事务模式时使用，即：在 `upgradeneeded` 中。

```js
request.onupgradeneeded = (event) => {
    db = event.target.result;
    // 创建一个名为users的对象存储，则主键为对象ID属性的值。
    const store = db.createObjectStore("users", { keyPath: "ID" });
    // 创建一个名为usernameIndex的索引，则索引键为对象username属性的值。
    store.createIndex("usernameIndex", "username", { unique: true });
};
```

​		`createIndex()` 的第一个参数是该索引的名称，第二个参数是该索引的标识键路径，第三个参数是包含键 `unique` 的 `options` 对象。这个选项中的 `unique` 应该必须指定，表示这个键是否必须在所有记录中保持唯一。设置后，这个键就必须是唯一的，意味着无法再向对象存储中添加索引键相同的对象。

```
createIndex(indexName, keyPath, options)
```

​		`createIndex()` 返回一个 `IDBIndex` 实例，其上拥有许多与对象存储相同的属性和原型方法。

```
IDBIndex {
	keyPath: "username",
	multiEntry: false,
	name: "usernameIndex",
	objectStore: IDBObjectStore {name: 'users', keyPath: 'ID', transaction: IDBTransaction, ...},
	unique: true,
	[[Prototype]]: IDBIndex {
		count: ƒ count(),
		get: ƒ (),
		getAll: ƒ getAll(),
		getAllKeys: ƒ getAllKeys(),
		getKey: ƒ getKey(),
		keyPath: (...),
		multiEntry: (...),
		name: (...),
		objectStore: (...),
		openCursor: ƒ openCursor(),
		openKeyCursor: ƒ openKeyCursor(),
		unique: (...),
		constructor: ƒ IDBIndex(),
		Symbol(Symbol.toStringTag): "IDBIndex",
		get keyPath: ƒ keyPath(),
		get multiEntry: ƒ multiEntry(),
		get name: ƒ name(),
		set name: ƒ name(),
		get objectStore: ƒ objectStore(),
		get unique: ƒ unique(),
		[[Prototype]]: Object
	}
}
```

##### 获取索引

​		`createIndex()` 返回的是 `IDBIndex` 索引实例。在对象存储上调用 `index()` 方法可以获得指定的索引实例。例如，要获取一个已存在的名为 `"usernameIndex"` 的索引，可以像下面这样：

```js
// 打开成功时
request.onsuccess = (event) => {
    db = db || event.target.result;
    
    const transaction = db.transaction("users"),
          store = transaction.objectStore("users"),
          index = store.index("usernameIndex");
};
```

##### 创建游标

​		索引非常像对象存储。可以在索引上使用 `openCursor()` 方法创建新游标，这个游标与在对象存储上调用 `openCursor()` 创建的游标完全一样。只是其 `result.key` 属性中保存的是索引键而不是主键，主键保存在 `result.primaryKey` 属性上。下面看一个例子：

```js
const store = db.transaction("users", 'readwrite').objectStore("users"), 
      index = store.index("usernameIndex"), 
      request = index.openCursor(); 

store.put({
    ID: '001',
    username: 'wz'
});

request.onsuccess = (event) => { 
	console.log(event.target.result);
};
```

​		打印的 `result` 属性如下所示：

```
IDBCursorWithValue {
	direction: "next",
	key: "wz",
	primaryKey: "001",
	request: IDBRequest {result: IDBCursorWithValue, error: null, source: IDBIndex, ...},
	source: IDBIndex {name: 'usernameIndex', objectStore: IDBObjectStore, keyPath: 'username', ...},
	value: {ID: '001', username: 'wz'},
	[[Prototype]]: IDBCursorWithValue
}
```

​		使用 `openKeyCursor()` 方法也可以在索引上**创建特殊游标**。这个方法接收的参数与 `openCursor()` 方法一样。最大的不同在于，它返回值的 `result` 属性是 `IDBCursor` 实例，其上没有 `value` 属性。

```js
const store = db.transaction("users", 'readwrite').objectStore("users"), 
      index = store.index("usernameIndex"), 
      request = index.openKeyCursor(); 

request.onsuccess = (event) => { 
	console.log(event.target.result);
};
```

​		打印结果如下：

```
IDBCursor {
	direction: "next",
	key: "wz",
	primaryKey: "001",
	request: IDBRequest {result: IDBCursorWithValue, error: null, source: IDBIndex, ...},
	source: IDBIndex {name: 'usernameIndex', objectStore: IDBObjectStore, keyPath: 'username', ...},
	[[Prototype]]: IDBCursor {
		advance: ƒ advance(),
		continue: ƒ continue(),
		continuePrimaryKey: ƒ continuePrimaryKey(),
		delete: ƒ delete(),
		direction: (...),
		key: (...),
		primaryKey: (...),
		request: (...),
		source: (...),
		update: ƒ update(),
		constructor: ƒ IDBCursor(),
		Symbol(Symbol.toStringTag): "IDBCursor",
		get direction: ƒ direction(),
		get key: ƒ key(),
		get primaryKey: ƒ primaryKey(),
		get request: ƒ request(),
		get source: ƒ source(),
		[[Prototype]]: Object
	}
}
```

##### 获取数据

​		可以使用 `get()` 方法并传入索引键，然后通过索引取得单条记录，这会创建一个新请求：

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      index = store.index("usernameIndex"), 
      request = index.get("wz"); // 找到第一条符合的数据

// 获取成功
request.onsuccess = (event) => { 
 	console.log(event.target.result); // {ID: '001', username: 'wz'}
}; 
// 获取错误
request.onerror = (event) => { 
 	console.log(event);
};
```

##### 获取主键

​		如果想只取得给定索引键的主键，则可以使用 `getKey()` 方法。它返回一个 `IDBRequest` 实例，其 `result` 属性就是主键：

```js
const transaction = db.transaction("users"), 
      store = transaction.objectStore("users"), 
      index = store.index("usernameIndex"), 
      request = index.getKey("wz"); 

// 处理成功
request.onsuccess = (event) => { 
 	console.log(event.target.result); // '001'
};
```

​		在这个 `onsuccess` 事件处理程序中，`event.target.result` 中应该是用户 `ID`。任何时候，都可以使用 `IDBIndex` 对象的下列属性取得索引的相关信息。

- `name`：索引的名称。
- `keyPath`：调用 `createIndex()` 时传入的索引键路径。
- `objectStore`：索引对应的对象存储。
- `unique`：表示索引键是否在对象存储中唯一的布尔值。

##### 索引键集

​		对象存储自身也有一个 `indexNames` 属性，保存着与之相关的索引的名称。如此便可以方便地了解对象存储上已存在哪些索引：

```js
const store = db.transaction("users").objectStore("users"),
      indexNames = store.indexNames; // 伪数组

for (let indexName of Array.from(indexNames)) {
    console.log(indexName); // 'usernameIndex'
}
```

##### 删除索引

​		在对象存储上调用 `deleteIndex()` 方法并传入索引的名称可以删除指定的索引，它与创建索引一样必须在升级事务模式下调用：

```js
request.onupgradeneeded = (event) => {
	// 省略前面代码...
    store.deleteIndex("usernameIndex");
};
```

​		因为删除索引不会影响对象存储中的数据，所以这个操作没有回调。



#### 并发问题

​		`IndexedDB` 虽然是网页中的异步 `API`，但仍存在并发问题。如果同一浏览器的两个不同标签页中同时打开了同一个网页，则有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形。有问题的操作是设置数据库为新版本，而版本变化只能在浏览器只有一个标签页使用数据库时才能完成。

​		第一次打开数据库时，添加 `onversionchange` 事件处理程序非常重要。另一个同源标签页将数据库打开到新版本时，将执行此回调。对这个事件最好的回应是立即关闭数据库，以便完成版本升级。例如：

```js
let request, database; 

request = indexedDB.open("admin", 1); 
request.onsuccess = (event) => { 
 	database = event.target.result; 
 	database.onversionchange = () => database.close(); 
};
```

​		应该在每次成功打开数据库后都指定 `onversionchange` 事件处理程序。记住，`onversionchange` 有可能会被其他标签页触发。

​		通过始终都指定这些事件处理程序，可以保证 `Web` 应用程序能够更好地处理与 `IndexedDB` 相关的并发问题。



#### 限制

​		`IndexedDB` 的很多限制实际上与 `Web Storage` 一样。首先，`IndexedDB` 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享。这意味着 `www.wrox.com` 和 `p2p.wrox.com` 会对应不同的数据存储。

​		其次，每个源都有可以存储的空间限制。当前 `Firefox` 的限制是每个源 `50MB`，而 `Chrome` 是 `5MB`。移动版 `Firefox` 有 `5MB` 限制，如果用度超出配额则会请求用户许可。

​		目前，`Chrome`、`Firefox` 和 `Edge` 都已允许本地文档访问 `IndexedDB` 数据库。



#### 封装

​		综上所述，下面尝试对对 `IndexedDB` 数据库进行封装。

```js

```



### 小结

​		`Web Storage` 定义了两个对象用于存储数据：`sessionStorage` 和 `localStorage`。前者用于严格保存浏览器在一次会话期间的数据，但是数据会在浏览器关闭时被删除。后者则用于在会话之外持久保存数据。

​		`IndexedDB` 是类似于 `SQL` 数据库的结构化数据存储机制。不同的是，`IndexedDB` 存储的是对象，而不是数据表。对象存储是通过定义键然后添加数据来创建的。游标用于查询对象存储中的特定数据，而索引可以针对特定属性实现更快的查询。

​		有了这些存储手段，就可以在客户端通过使用 `JavaScript` 存储可观的数据。因为这些数据没有加密，所以要注意不能使用它们存储敏感信息。

