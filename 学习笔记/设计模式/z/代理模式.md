# 代理模式

在代理模式（`Proxy Pattern`）中，一个类代理另一个类的功能。这种类型的设计模式属于结构型模式。

在代理模式中，我们创建代理现有对象的对象，以便向外界提供功能接口。例如 `Vue3` 的 `MVVM` 模型就采用了代理模式。

代理模式：通过一个对外暴露的对象（代理对象）去管理对一个不对外暴露的对象（目标对象）的操作。简单来说，就是用一个对象去控制对另一个对象的操作。代理的作用是：使用者无法直接操作目标对象（但代理对象可以）时，可通过操作代理对象来达到目的。



### 介绍

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

**关键代码：**实现与被代理类组合。

**应用实例：**

- `Windows` 里面的快捷方式。
- 猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。
- 买火车票不一定在火车站买，也可以去代售点。
- 一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。

**优点：**

- 职责清晰。
- 高扩展性。
- 智能化。

**缺点：**

- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

**使用场景：**按职责来划分，通常有以下使用场景：

- 远程代理。
- 虚拟代理。 
- `Copy-on-Write` 代理。 
- 保护（`Protect or Access`）代理。 
- `Cache` 代理。
- 防火墙（`Firewall`）代理。
- 同步化（`Synchronization`）代理。
- 智能引用（`Smart Reference`）代理。

**注意事项：** 

- 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
- 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。



### 实现

##### 简单实现

`ES6` 新增了 `Proxy` 对象，该对象实现了典型的代理模式。

```js
// 代理目标（不对外暴露）
const user = {
    name: "wz",
    age: 16,
    sex: "女"
};

// 代理对象（暴露对隐藏的目标对象的基本操作）
let userProxy = new Proxy(user, {
    // 访问对象属性时触发
    get(target, key) {
        switch(key) {
            case "name":
            case "sex":
                return console.warn(`禁止访问${key}属性`);
            default:
                return target[key];
        }
    },
    // 修改对象属性时触发
    set(target, key, value) {
       	switch(key) {
            case "name":
            case "sex":
                return console.warn(`禁止修改${key}属性`);
            default:
                return target[key] = value;
        }
    }
});
```

当希望对代理目标进行一些操作时，可通过代理对象代为处理（或代管）这些操作，它会将代理的操作结果反映到目标对象上。

```js
console.log(userProxy); // Proxy(Object) {name: 'wz', age: 16, sex: '女'}

console.log(userProxy.name); // "禁止访问name属性"
console.log(userProxy.age);  // 16
console.log(userProxy.sex);  // "禁止访问sex属性"

userProxy.name = "cy"; // "禁止修改name属性"
userProxy.age = 18;
userProxy.sex = "男";  // "禁止修改sex属性"

console.log(userProxy); // Proxy(Object) {name: 'wz', age: 18, sex: '女'}
```

##### 代理加载

代理对象，也可用来代管资源的加载，如图片懒加载。下面演示一个未加载完时显示缩略图，加载完后显示原图的例子。

首先，定义一个操作目标图片的方法。

```js
let image = (function() {
    // 创建并插入或获取已有图片节点
    let img = document.createElement("img");
    document.body.appendChild(img);
    
    // 返回一个目标对象（它只暴露给代理对象）
    return {
        setSrc(src) {
            img.src = src;
        }
    }
}());
```

然后，定义操作目标的代理对象。

```js
let proxyImage = (function() {
    let tepmImg = new Image();
    
    tepmImg.onload = function() {
        image.setSrc(this.src); // 原图在虚拟图片中加载完毕后，设置给目标图片。
    }
    
    return {
        setSrc(src) {
            image.setSrc("缩略图url");  // 先给目标图片一个缩略图地址
            tepmImg.src = src; 		   // 再给虚拟图片设置原图的地址
        }
    }
}());
```

最后，直接使用代理对象传入原图地址即可。

```js
proxyImage.setSrc("原图url");
```

