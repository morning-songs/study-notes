# 框架

### 介绍

小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 `APP` 体验的服务。

整个小程序框架系统分为两部分：**[逻辑层](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/)**（`App Service`）和 **[视图层](https://developers.weixin.qq.com/miniprogram/dev/framework/view/)**（`View`）。小程序提供了自己的视图层描述语言 `WXML` 和 `WXSS`，以及基于 `JavaScript` 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

##### 响应的数据绑定

框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。

```html
<!-- 视图层 -->
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
```

```js
// 逻辑层
// 定义数据
var helloData = {
  	name: 'Weixin'
}

// 注册页面
Page({
  	data: helloData,
  	changeName: function(e) {
    	// 修改数据以更新视图
    	this.setData({
      		name: 'MINA'
    	})
  	}
})
```

- 开发者通过框架将逻辑层数据中的 `name` 与视图层的 `name` 进行了绑定，所以在页面一打开的时候会显示 `Hello Weixin!`；
- 当点击按钮的时候，视图层会发送 `changeName` 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
- 回调函数触发后，逻辑层执行 `setData` 的操作，随即将 `data` 中的 `name` 从 `Weixin` 变为 `MINA`。因为该数据和视图层已经绑定了，所以视图层会自动改变为 `Hello MINA!`。

##### 页面管理

框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。

##### 基础组件

框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑。开发者可以通过自由地组合这些基础组件，创建出强大的微信小程序。

##### 丰富的 `API`

框架提供了丰富的微信原生 `API`，开发者可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。



### 视图层

框架的视图层由 `WXML` 与 `WXSS` 编写，由组件来进行展示。它将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。

- `WXML`（`WeiXin Markup language`）用于描述页面的结构。
- `WXS`（`WeiXin Script`）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。
- `WXSS`（`WeiXin Style Sheet`）用于描述页面的样式。
- 组件（`Component`）是视图的基本组成单元。



#### `WXML`

`WXML`（`WeiXin Markup Language`）是框架设计的一套标签语言，结合 [基础组件](https://developers.weixin.qq.com/miniprogram/dev/component/)、[事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，可以构建出页面的结构。

##### 数据绑定

`WXML` 中的动态数据均来自对应 `Page` 的 `data`。

###### 简单绑定

数据绑定使用 `Mustache` 语法（即双大括号 `{{}}`）将变量包裹起来，可作用于组件内容、组件属性和组件指令。如下所示：

（1）组件内容：将组件的内容绑定为 `data`。

```html
<view> {{ message }} </view>
```

```js
Page({
  	data: {
    	message: 'Hello MINA!'
  	}
})
```

（2）组件属性（需要在双引号之内）：将组件的属性值绑定为 `data`。

```html
<view id="item-{{id}}"> </view>
```

```js
Page({
  	data: {
    	id: 0
  	}
})
```

（3）组件指令（需要在双引号之内）：将组件的指令（亦称控制属性）值绑定为 `data`。

```html
<view wx:if="{{condition}}"> </view>
```

```js
Page({
  	data: {
    	condition: true
  	}
})
```

###### 表达式

可以在 `{{}}` 内插入任何 `js` 表达式来进行简单的运算，然后将其结果作为绑定值。由于小程序仅支持通过事件来调用函数，因此不支持在 `{{}}` 插入任何的函数或 `API` 调用。但它支持如下几种方式：

（1）字面量：支持直接使用字面量作为绑定值。

- 原始值：仅支持数字、字符串和布尔值。
- 数组：支持数组，且会自动展开它。
- 对象：支持对象，但不能单独使用。`Mustache` 语法只允许两个 `{{}}`，因此对象直接插入属性即可，如 `{{foo: 'foo'}}`。

```html
<checkbox checked="{{false}}"></checkbox>
```

***特别注意：这里不要直接写 `checked="false"`（尽管没有 `{{}}`），其计算结果是一个字符串，转成 `boolean` 类型后是真值。***

（1）三元运算

```html
<view hidden="{{flag ? true : false}}"> Hidden </view>
```

```js
Page({
 	data: {
		flag: true
  	}
})
```

（2）基本运算

```html
<view> {{a + b}} + {{c}} + d </view>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2,
    	c: 3
  	}
})
```

（3）逻辑判断

```html
<view wx:if="{{length > 5}}"> </view>
```

```js
Page({
  	data: {
    	length: 1
  	}
})
```

（5）路径运算

```html
<view>{{object.key}} {{array[0]}}</view>
```

```js
Page({
  	data: {
    	object: {
      		key: 'Hello '
    	},
    	array: ['MINA']
  	}
})
```

###### 组合

也可以在 `Mustache` 内直接进行组合，构成新的对象或者数组。

（1）数组：不支持调用任何数组 `API`。

```html
<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>
```

```js
Page({
  	data: {
    	zero: 0
  	}
})
```

最终组合成的数组是 `[0, 1, 2, 3, 4]`。

（2）对象：不支持调用任何对象 `API`，且直接书写属性即可。对象通常用来传递数据，单独定义成其他属性的值是没有意义的。

```html
<!-- 关于此元素的用法，详见本节-模板 -->
<template is="objectCombine" data="{{foo: a, bar: b}}"></template>
```

```js
Page({
  	data: {
    	a: 1,
    	b: 2
  	}
})
```

最终组合成的对象是 `{foo: 1, bar: 2}`。

（3）扩展运算符：可以用扩展运算符 `...` 来将一个对象展开：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
      		b: 2
    	},
    	obj2: {
      		c: 3,
      		d: 4
    	}
  	}
})
```

最终组合成的对象是 `{a: 1, b: 2, c: 3, d: 4, e: 5}`。

（4）同名简写：如果对象的 `key` 和 `value` 相同，也可以间接地表达。

```html
<template is="objectCombine" data="{{foo, bar}}"></template>
```

```js
Page({
  	data: {
    	foo: 'my-foo',
    	bar: 'my-bar'
  	}
})
```

最终组合成的对象是 `{foo: 'my-foo', bar:'my-bar'}`。

（5）随意组合：上述方式可以随意组合，但是如果有存在变量名相同的情况，则后边的会覆盖前面的，如：

```html
<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template>
```

```js
Page({
  	data: {
    	obj1: {
      		a: 1,
     		b: 2
    	},
    	obj2: {
      		b: 3,
      		c: 4
    	},
    	a: 5
  	}
})
```

最终组合成的对象是 `{a: 5, b: 3, c: 6}`。

**注意：** 花括号和引号之间如果有空格，将最终被解析成为字符串，如下所示。

```html
<view wx:for="{{[1,2,3]}} ">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{[1,2,3] + ' '}}">{{item}}</view>
```

这样做会带来一些渲染意外，即：将数组的元素分隔符（`,`）也视作元素，而空格（也可换做其他字符）则被视作最后一个元素。

```html
<view>1</view>
<view>,</view>
<view>2</view>
<view>,</view>
<view>3</view>
<view> </view>
```

##### 条件渲染

###### `wx:if`

在框架中，可在某元素上使用 `wx:if` 指令，然后根据其值的布尔性来决定是否渲染该元素：

```html
<view wx:if="{{true}}"> True —— 被渲染的元素 </view>
<view wx:if="{{false}}"> false —— 不被渲染的元素 </view>
```

当然，也可以用 `wx:elif` 和 `wx:else` 来添加其他条件块。同样的，`elif` 块可以有多个，而 `else` 块只能有一个。

```html
<view wx:if="{{1 > 3}}"> 1 </view>
<view wx:elif="{{2 > 3}}"> 2 </view>
<view wx:elif="{{3 > 3}}"> 3 </view>
<view wx:else> 4 </view>
```

###### `block wx:if`

因为 `wx:if` 是一个控制属性，所以需要将它添加到一个标签上。如果要一次性判断多个组件标签，则可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 `wx:if` 控制属性。

```html
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

**注意：** `<block/>` 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，且只接受控制属性（即：组件指令）。

###### `wx:if` 与 `hidden`

因为 `wx:if` 中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架会有一个局部渲染的过程，以此来确保条件块在切换时被销毁或重新渲染。

同时 `wx:if` 也是 **惰性的**，如果在初始渲染条件为 `false`，则框架什么也不会做，只在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 属性就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏而已。

```html
<view hidden> 被隐藏的组件 </view> 
<view hidden="{{false}}"> 被显示的组件 </view> <!-- 注意：与hidden="false"的区别 -->
```

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁的切换，用 `hidden` 会更好；如果在运行时条件不大可能会改变（即切换不频繁），则用 `wx:if` 比较好。

##### 列表渲染

###### `wx:for`

在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中的每个元素来重复渲染该组件。

通常，数组当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`。因此，不需要额外定义，直接使用它们即可。

```html
<view wx:for="{{array}}">
  	{{index}}: {{item.message}}
</view>
```

```js
Page({
 	data: {
    	array: [
            {
      			message: 'foo',
    		}, {
      			message: 'bar'
    		}
        ]
  	}
})
```

不过，使用 `wx:for-item` 可以指定数组当前元素的变量名，使用 `wx:for-index` 可以指定数组当前下标的变量名：

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  	{{idx}}: {{itemName.message}}
</view>
```

`wx:for` 也可以嵌套，例如下边是一个九九乘法表：

```html
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  	<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    	<view wx:if="{{j <= i}}">
      		{{j}} * {{i}} = {{i * j}}
    	</view>
  	</view>
</view>
```

###### `block wx:for`

类似 `block wx:if`，也可以将 `wx:for` 用在 `<block/>` 标签上，以渲染一个包含多节点的结构块。例如：

```html
<block wx:for="{{[1, 2, 3]}}">
  	<view> {{index}}: {{item}}</view>
</block>
```

###### `wx:key`

如果列表中项目的位置会动态改变或者会有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [`input`](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[`switch`](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），则需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供：

1. 字符串：代表 `item` 的某个属性。该属性的值必须是在此列表中唯一的字符串或数字值，且不能动态改变。
2. 保留关键字 `*this`（带星号）：代表 `item` 本身。这种表示须要 `item` 本身是一个唯一的字符串或者数字。

```html
<view wx:for="{{arr1}}" wx:key="id">{{item.id}}</view> <!-- 绑定：item.id -->

<view wx:for="{{arr2}}" wx:key="*this">{{item}}</view> <!-- 绑定：item自身 -->
```

```js
Page({
    data: {
        arr1: [
            {id: 0},
            {id: 1},
            {id: 2}
        ],
        arr2: [0, 1, 2]
    }
})
```

当数据改变触发渲染层重新渲染的时候，会校正带有 `key` 的组件，框架会确保他们被重新排序，而不是重新创建，从而确保使组件保持自身的状态，并且提高列表渲染时的效率。

**注意：如果不提供 `wx:key`，会报一个 `warning`。 但如果明确知道该列表是静态的，或者不必关注其顺序，则可以选择忽略它。**

###### 示例代码

```html
<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>

<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
<button bindtap="addNumberToFront"> Add to the front </button>
```

```js
Page({
  	data: {
    	objectArray: [
      		{id: 5, unique: 'unique_5'},
      		{id: 4, unique: 'unique_4'},
      		{id: 3, unique: 'unique_3'},
      		{id: 2, unique: 'unique_2'},
      		{id: 1, unique: 'unique_1'},
      		{id: 0, unique: 'unique_0'},
    	],
    	numberArray: [1, 2, 3, 4]
  	},
  	switch: function(e) {
    	const length = this.data.objectArray.length
    	for (let i = 0; i < length; ++i) {
      		const x = Math.floor(Math.random() * length)
      		const y = Math.floor(Math.random() * length)
      		const temp = this.data.objectArray[x]
      		this.data.objectArray[x] = this.data.objectArray[y]
      		this.data.objectArray[y] = temp
    	}
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addToFront: function(e) {
    	const length = this.data.objectArray.length
    	this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    	this.setData({
      		objectArray: this.data.objectArray
    	})
  	},
  	addNumberToFront: function(e){
    	this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    	this.setData({
      		numberArray: this.data.numberArray
    	})
  	}
})
```

###### 注意事项

当 `wx:for` 的值为字符串时，会将这个字符串拆分解析成字符串数组。

```html
<view wx:for="array">{{item}}</view>

<!-- 等同于 -->
<view wx:for="{{['a', 'r', 'r', 'a', 'y']}}">{{item}}</view>
```

##### 模板

`WXML` 提供了模板（`<template>`），可以在模板中定义代码片段，然后在不同的地方调用。

###### 定义模板

使用 `name` 属性，作为模板的名字（其他模板可通过该名字来调用此模板）。然后在 `<template/>` 内定义代码片段，如：

```html
<!--
  	index: int
  	msg: string
  	time: string
-->
<template name="msgItem">
  	<view>
    	<text> {{index}}: {{msg}} </text>
    	<text> Time: {{time}} </text>
  	</view>
</template>
```

此模板（无 `is` 属性）代码不会被显示，其中的数据（如这里的 `index`、`msg`、`time`）均由使用者模板通过其 `data` 属性来传入。

###### 使用模板

使用 `is` 属性（值为模板名）来表示当前模板使用指定模板中的代码。然后，将模板所需要的数据通过 `data` 属性传入，如：

```html
<template is="msgItem" data="{{...item}}"/> <!-- 模板中的代码会被显示，模板本身不显示 -->
```

```js
Page({
  	data: {
    	item: {
            index: 0,
            msg: 'this is a template',
            time: '2023-05-02'
    	}
  	}
})
```

`is` 属性也可以使用 `Mustache` 语法，来动态决定具体渲染哪个模板：

```html
<template name="odd">
  	<view> odd </view>
</template>
<template name="even">
  	<view> even </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
  	<template is="{{item % 2 == 0 ? 'even' : 'odd'}}"/>
</block>
```

###### 模板的作用域

模板拥有自己的作用域，只能使用 `data` 传入的数据以及模板定义文件中定义的 `<wxs />` 模块（详见下文 ——  `WXS`）。

##### 引用

`WXML` 提供了两种文件引用的方式：`import` 和 `include`。

###### `import`

`import` 可以在该文件中使用目标文件定义的 `template`，如：

在 `item.wxml` 中定义一个叫 `item` 的 `template`：

```html
<!-- item.wxml -->
<template name="item">
  	<text>{{text}}</text>
</template>
```

在 `index.wxml` 中引用 `item.wxml`，就可以使用此文件定义的 `item` 模板：

```html
<!-- index.wxml -->
<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>
```

###### `import` 的作用域

`import` 有作用域的概念，即只会 `import` 目标文件中定义的 `template`，而不会 `import` 目标文件 `import` 的 `template`。

**如：`C import B`，`B import A`，则在 `C` 中可以使用 `B` 定义的`template`，在 `B` 中可以使用 `A` 定义的`template`，但是 `C` 不能使用 `A` 定义的`template`。因为这种 `import` 对 `template` 只有使用权，而没有所有权**。

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<import src="b.wxml"/>
<template is="B"/>
<template is="A"/>  <!-- Error! Can not use tempalte when not import A. -->
```

###### `include`

而 `include` 可以将目标文件的整个代码（除了 `<template/>` 和 `<wxs/>` 之外）引入，相当于是拷贝到 `include` 的位置，如：

```html
<!-- a.wxml -->
<template name="A">
  	<text> A template </text>
</template>
```

```html
<!-- b.wxml -->
<import src="a.wxml"/>
<template name="B">
 	<text> B template </text>
</template>
```

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 却没有了！ -->
```

上述引用关系为：`C include B`，`B import A`。这样一来，`B` 就将自身对 `A` 的使用权分享给了 `C`，但由于 `<template/>` 不被包含，因此 `C` 对 `B` 没有使用权（除非又 `import` 它）。

```html
<!-- c.wxml -->
<include src="b.wxml"/>
<import src="b.wxml"/>
<template is="A"/> <!-- template A 可以被正常使用了！ -->
<template is="B"/> <!-- template B 也能被正常使用了！ -->
```



#### `WXSS`

`WXSS`（`WeiXin Style Sheets`）是一套样式语言，用于描述 `WXML` 的组件样式。也就是，用来决定 `WXML` 的组件应该怎么显示。

为了适应广大的前端开发者，`WXSS` 具有 `CSS` 大部分特性。同时为了更适合开发微信小程序，`WXSS` 对 `CSS` 进行了扩充以及修改。

与 `CSS` 相比，`WXSS` 扩展的特性有：

- 尺寸单位
- 样式导入

##### 尺寸单位

`rpx`（`responsive pixel`，响应式像素）可以根据屏幕宽度进行自适应，官方规定屏幕宽为 `750rpx`。如在 `iPhone6` 上，屏幕宽度为 `375px` 且共有 750 个物理像素，则 `750rpx` = `375px` = 750 物理像素，即 `1rpx` = `0.5px` = 1 物理像素。

|      设备      | `rpx` 换算 `px`（屏幕宽度/750） | `px` 换算 `rpx`（750/屏幕宽度） |
| :------------: | :-----------------------------: | :-----------------------------: |
|   `iPhone5`    |         `1rpx = 0.42px`         |         `1px = 2.34rpx`         |
|   `iPhone6`    |         `1rpx = 0.5px`          |          `1px = 2rpx`           |
| `iPhone6 Plus` |        `1rpx = 0.552px`         |         `1px = 1.81rpx`         |

**建议：** 开发微信小程序时设计师可以用 `iPhone6` 作为视觉稿的标准。

```css
/* 以 iPhone6 为标准开发(1px = 2rpx): 原先写 100px，现在可写成 200rpx */
view {
    width: 200rpx; /* => 100px */
}
```

**注意：** 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。

此外，还有三个跟像素相关的专业术语，`DPR`、`DPI` 和 `PPI`。分别是指：

- `DPR`：设备像素比（`Device Pixel Ratio`），是物理像素和 `CSS` 像素的比例。
- `DPI`：设备独立像素（`Device Independent Pixel`），也称逻辑像素（每英寸像素点，跟 `CSS` 像素很像），与设备无关。
- `PPI`：每英寸像素（`Pixels Per Inch`），亦称像素密度（即屏幕一英寸有多少个物理像素点）。

|    机型    | 物理像素分辨率（设备） | 逻辑像素分辨率（`CSS`） | `PPI` | `DPR` |
| :--------: | :--------------------: | :---------------------: | :---: | :---: |
| `iPhone4`  |       640 × 960        |        320 × 480        |  326  |   2   |
| `iPhone5`  |       640 × 1136       |        320 × 568        |  326  |   2   |
| `iPhone6`  |       750 × 1334       |        375 × 667        |  326  |   2   |
| `iPhone6p` |      1242 × 2208       |        414 × 736        |  401  |   3   |

##### 样式导入

使用 `@import` 语句可以导入外联样式表，`@import` 后跟需要导入的外联样式表的相对路径，且必须用 `;` 表示语句结束。

```less
/** common.wxss **/
.small-p {
  	padding: 5px;
}
```

```less
/** app.wxss **/
@import "common.wxss";
.middle-p {
  	padding: 15px;
}
```

注意：在不加重 `CSS` 权重的情况下，导入的样式优先级低于本文件中的样式，但高于全局样式。

##### 内联样式

框架组件上支持使用 `style` 属性来直接定义组件的样式，被称为内联样式，优先级很高。

注意：静态的样式应统一写到 `class` 中，`style` 通常接收动态的样式（通过使用 `{{}}`）。在运行时会对其进行解析，因此要尽量避免将静态的样式写进 `style` 中，以免影响渲染速度。

```html
<view style="color:{{color}};" />
```

##### 选择器

`WXSS` 并未支持全部 `CSS` 选择器，目前支持的选择器有：

| 选择器                           | 样例             | 样例描述                                   |
| :------------------------------- | :--------------- | :----------------------------------------- |
| `.class`（类选择器）             | `.intro`         | 选择所有拥有 `class="intro"` 的组件        |
| `#id`（`ID` 选择器）             | `#firstname`     | 选择拥有 `id="firstname"` 的组件           |
| `element`（元素选择器）          | `view`           | 选择所有 `view` 组件                       |
| `element, element`（并集选择器） | `view, checkbox` | 选择所有 `view` 组件和所有 `checkbox` 组件 |
| `::after`（伪对象选择器）        | `view::after`    | 在 `view` 组件后边插入内容                 |
| `::before`（伪对象选择器）       | `view::before`   | 在 `view` 组件前边插入内容                 |

##### 样式覆盖

定义在 `app.wxss` 中的样式为全局样式，作用于每一个页面。在 `page` 的 `wxss` 文件中定义的样式为页面样式，只作用在对应的页面，并会覆盖 `app.wxss` 中相同的选择器。另外，组件样式会覆盖页面样式。于是，组件样式 > 页面样式 > 导入样式 > 全局样式。



#### `WXS`

`WXS`（`WeiXin Script`）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。`WXS` 与 `JavaScript` 是不同的语言，有自己的语法。虽然借鉴了 `JavaScript`，但并不总和 `JavaScript` 一致。

##### 模块

每一个 `.wxs` 文件和 `<wxs>` 标签都是一个单独的模块。

每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。

一个模块要想对外暴露其内部的私有变量与函数，只能通过 `module.exports` 实现。

###### `.wxs` 文件

在**微信开发者工具**里面，右键可以直接创建 `.wxs` 文件，然后在其中直接编写 `WXS` 脚本。

```wxs
// /pages/comm.wxs

var foo = "'hello world' from comm.wxs";
var bar = function(d) {
  	return d;
}

module.exports = {
  	foo: foo,
  	bar: bar
};
```

上例在 `/pages/comm.wxs` 的文件中编写了 `WXS` 代码。该 `.wxs` 文件可以被其他的 `.wxs` 文件或 `WXML` 中的 `<wxs>` 标签引用。

###### `module` 对象

每个 `wxs` 模块均有一个内置的 `module` 对象。该对象具有如下属性：

- `exports`：通过该属性，可以对外共享本模块的私有变量与函数。

```text
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```html
<!-- page/index/index.wxml -->

<wxs src="./../tools.wxs" module="tools" />
<view> {{tools.msg}} </view>
<view> {{tools.bar(tools.FOO)}} </view>
```

页面输出：

```text
some msg
'hello world' from tools.wxs
```

###### `require` 函数

在`.wxs`模块中引用其他 `wxs` 文件模块，可以使用 `require` 函数。

引用的时候，要注意如下几点：

- 只能引用 `.wxs` 文件模块，且必须使用相对路径。
- `wxs` 模块均为单例，`wxs` 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 `wxs` 模块对象。
- 如果一个 `wxs` 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

```text
// /pages/tools.wxs

var foo = "'hello world' from tools.wxs";
var bar = function (d) {
  	return d;
}
module.exports = {
  	FOO: foo,
  	bar: bar,
};
module.exports.msg = "some msg";
```

```wxs
// /pages/logic.wxs

var tools = require("./tools.wxs");

console.log(tools.FOO);
console.log(tools.bar("logic.wxs"));
console.log(tools.msg);
```

```html
<!-- /page/index/index.wxml -->

<wxs src="./../logic.wxs" module="logic" />
```

控制台输出：

```text
'hello world' from tools.wxs
logic.wxs
some msg
```

###### `<wxs>` 标签

|  属性名  |   类型   | 默认值 | 说明                                                         |
| :------: | :------: | :----: | :----------------------------------------------------------- |
| `module` | `String` |        | 当前 `<wxs>` 标签的模块名。必填字段。                        |
|  `src`   | `String` |        | 引用 `.wxs` 文件的相对路径。仅当本标签为**单闭合标签**或**标签的内容为空**时有效。 |

###### `module` 属性

`module` 属性是当前 `<wxs>` 标签的模块名。在单个 `wxml` 文件内，建议其值唯一。有重复模块名则按照先后顺序覆盖（后者覆盖前者）。不同文件之间的 `wxs` 模块名不会相互覆盖。

`module` 属性值的命名必须符合下面两个规则：

- 首字符必须是：字母（`a-zA-Z`），下划线（`_`）
- 剩余字符可以是：字母（`a-zA-Z`），下划线（`_`）， 数字（0 - 9）

```html
<!--wxml-->

<wxs module="foo">
var some_msg = "hello world";
module.exports = {
  msg : some_msg,
}
</wxs>
<view> {{foo.msg}} </view>
```

页面输出：

```text
hello world
```

上面例子声明了一个名字为 `foo` 的模块，将 `some_msg` 变量暴露出来，供当前页面使用。

###### `src` 属性

`src` 属性可以用来引用其他的 `wxs` 文件模块。

引用的时候，要注意如下几点：

- 只能引用 `.wxs` 文件模块，且必须使用相对路径。
- `wxs` 模块均为单例，`wxs` 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 `wxs` 模块对象。
- 如果一个 `wxs` 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。

```js
// /pages/index/index.js

Page({
  data: {
    msg: "'hello wrold' from js",
  }
})
```

```html
<!-- /pages/index/index.wxml -->

<wxs src="./../comm.wxs" module="some_comms"></wxs>
<!-- 也可以直接使用单标签闭合的写法
<wxs src="./../comm.wxs" module="some_comms" />
-->

<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo -->
<view> {{some_comms.bar(some_comms.foo)}} </view>
<!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg -->
<view> {{some_comms.bar(msg)}} </view>
```

页面输出：

```text
'hello world' from comm.wxs
'hello wrold' from js
```

上述例子在文件 `/page/index/index.wxml` 中通过 `<wxs>` 标签引用了 `/page/comm.wxs` 模块。

###### 注意事项

- `<wxs>` 模块只能在定义模块的 `WXML` 文件中被访问到。使用 `<include>` 或 `<import>` 时，`<wxs>` 模块不会被引入到对应的 `WXML` 文件中。
- `<template>` 标签中，只能使用定义该 `<template>` 的 `WXML` 文件中定义的 `<wxs>` 模块。



##### 变量



##### 注释



##### 运算符



##### 语句



##### 数据类型



##### 基础类库



#### 事件系统



#### 双向绑定



#### 基础组件



#### 节点信息



#### 显示区域



#### 分栏模式



#### 动画



#### 初始渲染缓存





### 逻辑层



#### 注册程序



#### 注册页面



#### 页面生命周期



#### 页面路由



#### 模块化



#### `API`





### 场景值



### 框架接口





