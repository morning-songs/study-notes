# 高级路由

##### 工作流程

`Vue Router`插件会监听路由的变化（通常是地址栏），获取到变化的路由片段，拿到`index.js`中的路由配置对象中去匹配`path`的值。

从这个角度来说，`path`相当于匹配规则。匹配到对应的路由后，会去加载和渲染它所对应的组件【渲染的地方必须要提供一个出口】

注意：

- `router-view`匿名渲染出口可以设置多个，但它们只会重复渲染同一个组件，因此一般只需要一个默认出口即可。

<hr>

### 动态路由

在`path`中插入动态参数，这些动态参数匹配到的路由片段会被`Vue Router`自动传递给对应的组件。

##### 开启`props`传参

可以在各个路由的配置对象中，设置`props`属性的值为`true`，表示开启`props`数据形式的组件传参功能。

接收`props`参数：在对应的组件实例中配置`props`项，来接收动态路由的参数。

```js
// 在index.js的路由配置对象中
{
    path : '/article/:wanzi', // 设置动态路由参数：wanzi
    component : () => import('@/views/ArticleTemp'),
    props : true // 开启props的组件传参功能
}

// 在对应vue组件的实例对象中
export default {
    name : 'ArticleTemp',
    props : ["wanzi"] // 接收动态路由参数
}
```

<hr>

### 嵌套路由

嵌套路由，一般常用于实现在页面中切换子组件的功能，类似于选项卡。



##### 配置子路由对象

在父路由的配置对象中，通过配置`children`项，来定义嵌套路由 / 子路由的配置对象。

```js
// 在index.js文件中
const routes = [
    {
    	path : "/about",
    	component : () => import("@/views/About"),
        // 配置子路由的处理，/about/me，/about/company
    	children : [
        	{
        		path : "me", // 直接写要拼接的路由片段，不要以/开头，如：/me，会被错误解析到根目录
            	component : () => import("@/components/AboutMe")
        	},
            {
                path : "company",
                component : () => import("@/components/AboutCompany")
            },
            {
                path : "", // 定义子路由片段为空，表示当前面的子路由都匹配不上时，匹配该路由。
                component:
            }
    	]
	}
]
```



##### 设置渲染出口

在父路由的配置对象中，通过`childre`项配置好其子路由对象后，还需要在其父路由所对应的组件中为这些子路由的组件提供渲染出口。

```html
<!-- 在About.vue文件中 -->
<template>
	<div id="about-page">
        <h2>关于我的页面</h2>
        
        <!-- 1、定义子路由导航组件：通过点击切换路由，而不是手动输入 -->
        <router-link to="/about/me">关于我</router-link>
        <router-link to="/about/company">关于公司</router-link>
        
        <!-- 2、为子路由对应的组件提供渲染出口，渲染该组件的子路由组件 -->
        <router-view></router-view>
    </div>
</template>
```

<hr>

### 路由补充

##### 路由信息对象

每个路由都对应着一个组件，也对应着一个路由信息对象，在路由对应的组件中通过`this.$route`可以访问这个路由信息对象。

这个路由信息对象包含了该路由的基本相关信息，如：`path`，`name`，`query`等，相当于组件的路由配置对象。

注意：

- `this.$router`指的是通过`new`创建出来的路由的实例对象，与`this.$route`不同。
- `this.$route`只读，一般用来获取路由信息；而`this.$router`不仅可读，还可以调用它上面的方法。



##### 编程式导航

在页面中需要用户点击链接来跳转到目标的导航方式，被称为“**声明式导航**”，如：`<router-link>`，`<a>`。

编程式导航：指程序在跳转过程中根据用户的状态等，自动修改导航的地址，使用户前往其他页面的导航方式。

常用的编程式导航`API`有`push`和`go`两种，是`$router`路由实例对象上的两个方法。

- `push`：导航到指定的路由，类似于重定向，将本次跳转记录到历史记录中。【最新访问处于记录的最顶部】
- `go`：在历史记录中，以该条记录为起点，前进或后退指定的记录条数（一维坐标系）【正：前进/向上/右；负：后退/向下/左】

```html
<template>
    <div>404, 页面不存在</div>
</template>
<script>
    // 使用push指定导航
	export default {
        name : "NotFound",
        mounted () {
            // 当通过路由要渲染该组件时，在挂载完毕后，导航/跳回首页。
            this.$router.push("/");
        }
    }
    
    // 设置跳转时间
    export default {
        name : "NotFound",
        data () {
            return {
                second : 5
            }
        },
        mounted () {
            let timer = setInterval(() => {
                this.second--;
                if (this.second <= 0) {
                    clearInterval(timer);
                    // 直接切换至指定的路由
                    this.$router.push("/");
                    // 导航到首页，并携带查询参数
                    this.$router.push({path: "/", query:{cherry: "美少女"}});
                }
            },1000)
        }
    }
    
    // 使用go
    export default {
        name : "NotFound",
        data () {
            return {
                second : 5
            }
        },
        mounted () {
            let timer = setInterval(() => {
                this.second--;
                // 向后退一条，左走一步（类似于一维坐标系）
                this.$router.go(-1);
                // 向前进一条，右走一步
                this.$router.go(1);
                if (this.second <= 0) {
                    clearInterval(timer);
                }
            },1000)
        }
    }
</script>
```



##### 命名视图

此前，使用多个匿名渲染出口组件，只渲染渲染同一个组件。现在，可以给他们命名来渲染指定的组件。

在路由配置对象中，设置`components`取代`component`，并配合具名渲染出口来渲染出多个不同的组件。

```vue
<template>
	<!--在App.vue文件中，为渲染出口命名-->
	<div id="page-views">
        <router-view></router-view>	<!--默认的渲染出口-->
        <router-view name="a"></router-view> <!--命名为a渲染出口，只-->
        <router-view name="b"></router-view> <!--命名为b渲染出口-->
    </div>
</template>
<script>
	// 在index.js文件中，配置某段路由的配置对象
    {
        path : "/",
        name : "Home",
        components : {
            default : Home, // 设置默认的、匿名渲染出口渲染的组件
            a : () => import("@/components/AboutMe"), // 设置a渲染出口渲染的组件
            b : () => import("@/components/AboutCompany"), // 设置b渲染出口渲染的组件 
        }
    }
</script>
```



##### 重定向路由

可以在某个路由的配置对象中，设置`redirect`选项。当匹配到该路由时，强制转换到指定的路由。

```js
{
    path : '/about',
    redirect : '/Article', // 重定向到指定的路由，如：/Article。原先的路由进不去了。
    // redirect : {name: "About"}, // 使用命名路由
    component : () => import('@/views/About'),
}
```



##### 路由别名

路由别名：是一段可以用来代替`path`值的路由片段，但不是完全等同，有些功能可能会丢失。

路由别名是区别于命名路由的：命名路由是一个名称，路由别名是一段路径且可以多个。

注意：虽然别名可以用来代替输入长的原路由值，但它会导致作用于`router-link-exact-active`的选中样式丢失。

```js
{
    path : '/about',
    name : 'About',
    alias : '/a', // 设置path路由的别名，常用于代替输入过长的path值
    // alias : ["/a", "/b"], // 设置多个别名。
    component : () => import('@/views/About'),
}
```



##### 路由元数据

配置路由对象的`meta`项，设置该路由`$route`应携带的少量简短的元数据，包括：网页标题等【大量的数据应使用组件】

路由配置 / 信息对象的数据信息，一般是由后端来提供的。如：`path`，`name`，`meta`等。

<hr>

### 导航守卫

当从一个路由跳转到另一个路由时，有一个离开当前路由和进入目标路由的状态。这两个状态分别对应两个钩子函数。

如：当离开当前路由时，提醒用户是否离开当前页面，继续访问。或者进入目标路由前，判断用户是否具有访问权限。

导航守卫可简单分为：全局守卫和独享守卫；独享守卫有：路由守卫和组件守卫；守卫也有前置守卫和后置守卫之分。

##### 全局前置守卫【`beforeEach`】

全局前置守卫：当监听到路由变化并获取到变化的路由片段时，会先经过该守卫的拦截处理，然后去匹配`path`值。

全局前置守卫会拦截所有的路由跳转，一般在路由实例对象上执行该方法。如：`router.beforeEach()`

每个守卫的回调函数都支持三个参数：`to`，`from`，`next`。

- `to`：目标路由的信息对象
- `from`：离开路由的信息对象
- `next`：一个方法，不传参直接执行表示将拦截到的路由放行，让它前往下一个任务的处理。

注意：在未执行`next()`方法，将放行路由之前，这段路由无法去匹配`path`，它所对应的组件便一直得不到渲染。

`next`传参：

- 无参数：表示直接放行，执行下一个任务。如果没有待执行任务，当前的导航状态会转换为`confirmed（ok/成功）`
- `false`：表示中断当前的导航，不允许去访问目标路由。
- 路由值：表示导航到指定的路由，将该片段直接拼接在根地址后面。

```js
// index.js中
router.beforeEach((to, from, next) => {
    if (to.path === '/article') {
        next("/abck"); // 如果要访问"/article"路由，会被导航到"/abck"路由
    } else {
        next();
    }
})
```

注意：由于全局前置守卫会拦截所有的路由，因此，拦截路由后必须要设置条件来放行，否则会进入死循环【重定向必须要设置条件】

```js
// index.js中
router.beforeEach((to, from, next) => {
    // 未执行next()放行路由，导致重复访问并拦截该路由
    next("/login"); // 重定向--访问--拦截--重定向--访问--拦截--……，进入死循环
    // next(); // 不设置条件是无法阻止的，条件可以写在meta中携带过来
})
```

##### 路由前置守卫【`beforeEnter`】

在路由的配置对象中，通过`beforeEnter()`方法设置该路由的独享前置守卫，它只会拦截处理该路由。

```js
// index.js中，配置某路由的对象
{
    path : "/article",
    component : () => import("@/views/Article"),
    beforeEnter (to, from, next) {
        next();
    }
}
```



#### 组件独享守卫

##### 组件前置守卫

在组件的配置对象中，通过`beforeRouteEnter()`方法，设置该组件的独享前置守卫。

全局守卫和路由守卫，都只是对路由进行拦截处理，他们并不会去获取组件内的数据。

当路由被放行后，在进入或离开组件时，也会先经过组件独享守卫的拦截处理【路由】

注意：

- 组件前置守卫会比组件的`beforeCreate()`生命钩子函数先触发【获取不到组件实例】
- 组件独享守卫，主要是监听组件对应的路由，进入和离开该组件时的两个状态。
- 要想在组件前置守卫中，获取组件实例，可以给`next`传一个回调，第一个参数即为实例

```js
export default {
    name : "About",
    // 设置组件前置守卫
    beforeRouteEnter (to, from, next) {
        console.log(this); // 此时组件实例还未创建，未初始化
        // 通过异步方式获取组件实例
        next( vm => { // 第一个形参即为组件的实例对象
            console.log("组件实例对象：", vm);
        })
    }
}
```

##### 组件后置守卫

组件后置守卫`beforeRouteLeave()`，在路由离开组件时触发，此时已经可以获取到组件实例对象。

```js
export default {
    name : "About",
    // 设置组件前置守卫
    beforeRouteEnter (to, from, next) {
        console.log(this); // 此时组件实例还未创建，未初始化
        // 通过异步方式获取组件实例
        next( vm => { // 第一个形参即为组件的实例对象
            console.log("组件实例对象：", vm);
        })
    },
    // 设置组件后置守卫
    beforeRouteLeave (to, from, next) {
        console.log(this); // 组件实例对象
    }
}
```

<hr>

### 锚点切换

##### 切换滚动

在页面的不同位置上定义锚点，当切换至该组件时，跳转到指定的锚点，还可以发生滚动的行为。

在路由实例对象`router`中，配置`scrollBehavior`项方法。定义路由切换时，页面的滚动位置。

参数：`scrollBehavior`方法支持三个参数，常用的是`to`和`from`，与守卫中的`to`和`from`一样。

通过`return`返回一个对象，包含对`x`和`y`值的定义。`x`：横向滚动距离；`y`：纵向滚动距离。

```js
// 在router的index.js文件中
const router = new VueRouter({
    mode: 'history',
    routes,
    // 定义路由切换时，页面的滚动位置(坐标或者锚点)
    scrollBehavior (to, from) {
        // 返回需要滚动到页面的坐标位置（不带单位）
        return {x: 0, y: 100};
    }
})
// 通过这种方式，设置的页面滚动，会作用于所有的组件切换。
```

##### 定义锚点

锚点通过`id`属性，定义在指定的元素上。当切换路由时，与携带的`hash`片段进行匹配，切换到指定位置。

```html
<!-- 子组件：在Article组件中，定义三个锚点 -->
<div id="wanzi1">
    锚点1
</div>
<div id="wanzi2">
    锚点2
</div>
<div id="wanzi3">
    锚点3
</div>

<!-- 父组件：在根组件中，设置/article路由的hash片段 -->
<router-link to="/article#wanzi2">文章</router-link>
```

##### 配置`selector`

若要使用锚点跳转，就不能使用切换滚动的功能。此时，需要配置`return`对象的`selector`选项【与`id`号对应】

```js
// 在router的index.js文件中
const router = new VueRouter({
    mode: 'history',
    routes,
    scrollBehavior (to, from) {
        return {
            // 跳转到指定的锚点位置，hash片段
            selector : to.hash,
            behavior : "smooth" // 定义过渡的平滑效果，可以自己设置效果
            // selector : "#wanzi2" // 也可以是一段具体的hash片段，对应着id
        };
        // 一般需要加层判断，避免路由中没有携带hash片段
        if (to.hash) {
            return {
                selector : to.hash // 通过原生的querySelector()方法，获取id号
            };
        }else {
            return {}; // 当hash为空时，应返回一个空对象。
        }
    }
})
```

