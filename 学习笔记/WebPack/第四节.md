# 兼容处理

低版本的浏览器，可能无法识别 `HTML5` 的标签和语法。不过，浏览器对无法识别的 `HTML5` 标签，会将其兼容为 `div` 或 `span` 元素。



### 样式兼容

`CSS3` 提供了许多炫酷好用的样式，但低版本的浏览器可能无法给予支持。例如：高版本 `CSS` 十六进制的颜色值，后两位表示透明度。

```css
p {
    color: #12121200; /* 前六位表示颜色值（低版本语法），后两位表示透明度（高版本语法） */
}
```

另外，各浏览器对所支持样式的实现方式不尽相同。这意味着同样的 `CSS` 代码在不同的浏览器中，可能呈现出不同的效果。因此，带浏览器前缀的 `CSS` 代码也可能是为了消除浏览器之间的样式差异，获得统一标准的样式效果。

像这些具有兼容性问题的样式，都必须进行兼容处理，使得它们能够在指定的浏览器上呈现出预期的样式效果。

##### 加载程序

使用 `postcss-loader`，处理 `CSS` 兼容性代码的问题，使指定的浏览器能够如期呈现样式效果。

```shell
npm i postcss-loader -D
```

在使用 `postcss-loader` 前，还需要对 `postcss-loader` 进行配置，并在其上使用 `postcss-preset-env` 扩展插件来完成样式兼容。

```shell
npm i postcss-preset-env -D
```

```js
module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/i,
                use: [
                    "style-loader",
                    "css-loader",
                    {
                        // 指定使用postcss-loader
                        loader: "postcss-loader",
                        // 配置该loader，指定要使用哪些功能
                        options: {
                            // 允许设置postCss选项和插件
                            postcssOptions: {
                                // 挂载要使用的扩展插件
                                plugins: [require("postcss-preset-env")]
                            }
                        }
                    }
                ]
            }
        ]
    }
}
```

`postcss-loader` 主要用于处理 `CSS` 的兼容性代码，所以在使用高级 `CSS` 的 `loader` 时，应置于其左边。

```js
{
    test: /\.less$/i,
        use: [
            "style-loader",
            "css-loader",
            {
                loader: "postcss-loader",
                options: {
                    postcssOptions: {
                        plugins: [require("postcss-preset-env")]
                    }
                }
            },
            "less-loader"
        ]
}
```

##### 配置优化

首先，由于 `postcss-loader` 的配置是一个对象。因此，可以将其先使用变量提取保存，然后在需要时使用。

```js
const postcssLoader = {
    loader: "postcss-loader",
    options: {
        postcssOptions: {
            plugins: [require("postcss-preset-env")]
        }
    }
};

module.exports = {
    module: {
        rules: [
            {
                test: /\.less$/i,
                use: ["style-loader", "css-loader", postcssLoader, "less-loader"]
            }
        ]
    }
}
```

不过，`postcss-loader` 也想到了这一点。因此它专门提供了一个 `postcss.config.js` 配置文件，可在里面对该 `loader` 进行配置。

```js
// 在postcss.config.js文件中
module.exports = {
    plugins: [require("postcss-preset-env")]
}
```

在 `postcss.config.js` 文件中只需导出要使用的插件即可，然后在模块配置的 `use` 数组中便可直接使用 `"postcss-loader"` 了。因为它会自动寻找并导入 `postcss.config.js` 文件中的配置，将这些配置应用到 `postcss-loader` 上。

但要注意的是，`postcss.config.js` 文件必须被创建在项目的根目录下，否则可能找不到它。

```js
// 在webpack.config.js文件中
module.exports = {
    module: {
        rules: [
            {
                test: /\.less$/i,
                use: ["style-loader", "css-loader", "postcss-loader", "less-loader"]
            }
        ]
    }
}
```

更多参考：[`postcss-loader`](https://webpack.docschina.org/loaders/postcss-loader#root) 

##### 导入样式

有时，我们会需要在 `CSS` 文件中导入的其他 `CSS` 文件（例如：将公共代码提取到单独的文件中）。

```css
@import url("./a.css");
```

然而，`postcss-loader` 并不能对这些在 `CSS` 中导入的其他 `CSS` 文件也进行兼容性处理。它只能处理在 `js` 文件中导入的 `css` 文件。

```js
import "./b.css"
```

要使得这些 `CSS` 文件能够被 `postcss-loader` 进行兼容处理，则需要对 `css-loader` 进行配置，使未经处理的 `CSS` 文件被回滚处理。

```js
{
    test: /\.css$/i,
    use: [
        "style-loader",
        {
            loader: "css-loader",
            options: {
                importLoaders: 1
            }
        },
        "postcss-loader"
    ]
}
```

`importLoaders` 选项允许你配置在 `css-loader` 之前有多少 `loader` 应用于 `@import` 的资源与 `CSS` 模块 / `ICSS` 导入。

```js
{
    test: /\.less$/i,
    use: [
        "style-loader",
        {
            loader: "css-loader",
            options: {
                importLoaders: 1
            }
        },
        "postcss-loader",
        "less-loader"
    ]
}
```

更多参考：[`importLoaders`](https://webpack.docschina.org/loaders/css-loader#importloaders)、[`css-loader`](https://webpack.docschina.org/loaders/css-loader#root) 

##### 模块样式

在入口 `js` 文件中导入的 `css` 文件，最终会被插入到入口页面的 `style` 元素中，成为全局样式被使用。



### `Babel`

`Babel` 是一个 [`JavaScript`](https://baike.baidu.com/item/JavaScript/321142?fromModule=lemma_inlink)[编译器](https://baike.baidu.com/item/编译器/8853067?fromModule=lemma_inlink)，允许开发人员使用最前沿的 `JavaScript` 编写代码，然后 `Babel` 将其转换为老式的 `JS`，让更多的[浏览器](https://baike.baidu.com/item/浏览器/213911?fromModule=lemma_inlink)能够理解。

`Babel` 是一个基于浏览器的、用于试验下一代 `JavaScript` 特性的交互式解释器。其主要应用如下：

- 转换语法
- 目标环境中缺少的 `Polyfill` 功能（通过第三方 `polyfill`，例如 `core-js`）
- 源代码转换（`codemods`）

更多参考：[`Babel` 中文网](https://babel.docschina.org/) 

##### 加载程序

使用 `babel-loader` 及其辅助包 `@babel/preset-env`，来处理 `JS` 兼容性代码的问题（将高版本 `ES` 语法转为兼容的低版本语法）。

```shell
npm i babel-loader @babel/preset-env -D
```

##### 工具配置

处理 `JS` 兼容问题，只需要使用 `babel-loader` 一个 `loader` 即可，剩下的配置都是对该 `loader` 的增强。这里，`use` 使用对象形式。

```js
{
    test: /\.js$/i,
    exclude: /node_modules/, // 将node_modules中的js文件排除在外
    use: {
        loader: "babel-loader",
        options: {
            presets: ["@babel/preset-env"] // 指定预设工具，将高级ES语法转换为ES5语法（只能转换基础语法）
        }
    }
}
```

注意：

- 打包项目时，不应该打包 `node_modules` 中的 `js` 文件。因此，在配置工 `babel` 具时，要将这些文件排除在外。
- 但是 `babel-loader` 只能转换高级 `ES` 中的基础性语法（如：关键字、运算符），对于高级 `API` 是无法处理的。

更多参考：[`presets`](https://babel.docschina.org/docs/en/presets/)、[`@babel/preset-env`](https://babel.docschina.org/docs/en/babel-preset-env/) 

##### 高级语法

```js
// ES6+的高级API
new Promise((res, rej) => {
    res("success");
}).then((data) => {
    console.log(data);
});
```

要将 `ES6+` 高级 `API` 转换为浏览器都兼容的低版本的 `ES5` 语法，则要使用 `core-js` 和 `regenerator-runtime` 工具。

这两个包是老项目使用的低版本（`Babel 7.4.0`）处理工具 [`@babel/polyfill`](https://babel.docschina.org/docs/en/babel-polyfill/) 被淘汰后的替代品，用于新版本的项目。

```shell
npm i core-js regenerator-runtime -D
```

修改预设配置

```js
{
    test: /\.js$/i,
    exclude: /node_modules/,
    use: {
        loader: "babel-loader",
        options: {
            presets: [
                [
                    "@babel/preset-env",
                    {
                        useBuiltIns: "usage", // 按需导入（按照项目中使用到的API，自动按需导入相应的core.js来处理）
                        corejs: "3.27" // 指定core.js的版本（可在package.json中查看下载core-js的版本，并使用它）
                    }
                ]
            ]
        }
    }
}
```

##### 配置优化

使用 `babel` 工具，也可以将工具配置提取出来，存储在项目根目录下的 `babel.config.js` 文件中。

```js
// 在babel.config.js中
module.exports = {
    presets: [
        [
            "@babel/preset-env",
            {
                useBuiltIns: "usage",
                corejs: "3.27"
            }
        ]
    ]
}
```

在 `babel.config.js` 中导出 `presets` 配置后，在 `webpack.config.js` 中便可以直接在 `use` 数组使用 `"babel-loader"` 了。

```js
{
    test: /\.js$/i,
    exclude: /node_modules/,
    use: ["babel-loader"]
}
```

##### 手动导入

将 `useBuilIns` 设为 `"usage"`，会按照项目对高级 `API` 使用的情况（即：需求）自动导入相应的 `core.js` 来进行兼容处理。

如果将其值设为 `"entry"`，则要在入口 `js` 文件中手动 `import` 导入 `core-js` 和 `regenerator-runtime` 这两个工具的文件。

```js
// 在babel.config.js中
module.exports = {
    presets: [
        [
            "@babel/preset-env",
            {
                useBuiltIns: "entry",
                corejs: "3.27"
            }
        ]
    ]
}
```

```js
// 在入口js文件中
import "core-js/stable";
import "regenerator-runtime/runtime.js";
```

注意：由于将这两个 `js` 文件手动导入到入口 `js` 文件中，所有最终它们也会被打包到 `main.js` 中。因此，这是不推荐的行为。



### `TS` 打包

要处理将 `ts` 文件打包转换为 `js` 文件，需要安装和使用 `ts-loader`（文件解析包）和 `typescript`（语法解析包）。

```shell
npm i ts-loader typescript -D
```

模块配置

```js
{
    test: /\.ts$/i,
    use: ["ts-loader"]
}
```

如果项目入口文件使用 `ts` 的话，则还需要修改项目打包的入口配置。

```js
module.exports = {
    entry: "./src/index.ts"
}
```

##### 初始配置

在打包和编译 `ts` 文件之前，项目根目录下必须要有 `TS` 的初始化配置文件 `tsconfig.json`（在 `ts` 初始化后获得）。

```shell
tsc --init
```

##### 兼容处理

上述的两个包已将 `ts` 文件转为 `js` 文件，但还需要处理 `js` 文件的兼容性问题。此时，只需在模块配置中加入 `babel` 的配置即可。

```js
{
    test: /\.ts$/i,
    use: ["babel-loader", "ts-loader"]
}
```

##### 编译错误

`ts` 编译器报错并不会阻止 `webpack` 打包程序的进行，也就是说，即使查到 `ts` 文件中存在语法错误也会被正常编译打包成 `js` 文件。

此时，要想在 `ts` 编译器检查出错误时阻断 `webpack` 的打包进程，就需要对打包指令进行重新配置。例如：在 `package.json` 定义一条新的打包指令 `build`，并设其值为 `"tsc && webpack"`（表示：如果 `tsc` 执行通过，再执行 `webpack`；否则，不会执行 `webpack`）。

```json
{
    "scripts": {
        "build": "tsc && webpack"
    }
}
```

使用新的打包指令

```shell
npm run build
```

##### 同名文件

执行 `tsc` 指令，默认情况下会在源 `ts` 文件的同级目录下生成一个同名的 `js` 文件。然而，在使用 `webpack` 打包时是不需要生成这些同名文件的。要阻止生成同名的 `js` 文件，可以在定义新指令时，在 `tsc` 指令后追加 `--noEmit`，如下所示。

```json
{
    "scripts": {
        "build": "tsc --noEmit && webpack"
    }
}
```

