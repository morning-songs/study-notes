# 其他

### `Diff`

​		`diff`（`The Diffing Algorithm`）算法，是虚拟`DOM`中采用的算法。用于找出新旧虚拟 `DOM` 之间的差异，目的是尽可能地做到节点的复用，而不是删除又创建。它把树形结构按照层级分解，只比较同级元素，类型相同则保留，不同则删除后重建。



#### 协调

​		`React` 提供的声明式 `API` 让开发者可以在对 `React` 的底层实现并不了解的情况下编写应用。在开发者编写应用时，可以保持相对简单的心智，但开发者无法了解其内部的实现原理。本节描述了在实现 `React` 的 `"diffing"` 算法过程中所作出的设计决策，以保证组件更新可预测，且在繁杂业务场景下依然保持应用的高性能。



##### 设计动机

​		在某一时间节点调用 `React` 的 `render()` 方法，会创建一棵由 `React` 元素组成的树（更新前的）。在下一次 `state` 或 `props` 更新时，相同的 `render()` 方法会返回一棵不同的树（更新后的）。`React` 需要基于这两棵树之间的差别来判断如何高效的更新 `UI`，以保证当前 `UI` 与最新的树保持同步。

​		此算法有一些通用的解决方案，即：生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用 [最优的算法](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf)，该算法的复杂程度仍为 O(n<sup>3</sup>)，其中 `n` 是树中元素的数量。

​		如果在 `React` 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 `React` 在以下两个假设的基础之上提出了一套 `O(n)` 的启发式算法：

1. 只在同级的元素之间进行比较，两个不同类型的元素会产生出不同的树；
2. 开发者可以使用 `key` 属性标识哪些子元素在不同的渲染中可能是不变的。

​		在实践中，我们发现以上假设在几乎所有实用的场景下都成立。于是，便设计出了 `diffing` 算法。



#### `Diffing` 算法

​		当对比两棵树时，`React` 首先比较这两棵树的根节点（深度优先，同级比较）。不同类型的根节点元素会有不同的形态。

​		`React` 的 `diff` 算法是分成两次遍历的：

- 第一次遍历：将新树与旧树中的节点按索引一一对比。如果可以复用，则比对下一个索引上的节点，否则结束第一轮的遍历。
  - 如果所有的新节点都在第一轮中处理完了，那么就将剩余的旧节点都删除。如果还有新节点没处理，则进行第二轮遍历。
- 第二次遍历：把剩余的旧节点放入一个 `map` 中，遍历剩余的新节点，按 `key` 在 `map` 里比对。如果存在，则表示可以复用它。
  -  第二轮遍历结束后，删除剩余的旧节点（表示：新树中不再需要的），增建剩余的新节点（表示：新树中重新定义的）。

​		注释：在存放旧节点的 `map` 中，以节点的 `key` 为 `key`。以节点的 `key` 为 `map` 的 `key`，使用新节点的 `key` 来判断复用性。

​		更多参考：[`React diff` 算法超详细讲解](https://www.jb51.net/article/266761.htm)、[图解 `React` 的 `diff` 算法](https://zhuanlan.zhihu.com/p/553744711) 

##### 元素类型不同

​		当根节点为不同类型的元素时，`React` 会拆卸原有的树并且建立起新的树。举个例子，当一棵树的根元素从 `<a>` 变成 `<img>`，从 `<Article>` 变成 `<Comment>`，或从 `<Button>` 变成 `<div>` 时都会触发一个完整的重建流程。

​		当卸载一棵树时，对应的 `DOM` 节点也会被销毁。组件实例将执行 `componentWillUnmount()` 方法。当建立一棵新的树时，对应的 `DOM` 节点会被创建以及插入到 `DOM` 中。组件实例将执行 `UNSAFE_componentWillMount()` 方法，紧接着 `componentDidMount()` 方法。所有与之前的树相关联的 `state` 也会被销毁。（注释：`UNSAFE_componentWillMount()` 已废弃）

​		在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：

```jsx
// 更新前的DOM树
<div>
  	<Counter />
</div>

// 更新后的DOM树
<span>
  	<Counter />
</span>
```

​		`React` 会销毁 `Counter` 组件并且重新装载一个新的组件。

##### 元素类型相同

​		当对比两个相同类型的 `React` 元素时，`React` 会保留 `DOM` 节点，只比对和更新有改变的属性。比如：

```jsx
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

​		通过对比这两个元素，`React` 知道只需要修改 `DOM` 元素上的 `className` 属性即可。

​		又如：当更新 `style` 属性时，`React` 仅更新有所更变的属性。

```jsx
<div style={{color: 'red', fontWeight: 'bold'}} />

<div style={{color: 'green', fontWeight: 'bold'}} />
```

​		通过对比这两个元素，`React` 知道只需要修改 `DOM` 元素上的 `color` 样式，无需修改 `fontWeight`。

​		在处理完当前节点之后，`React` 会继续对子节点进行递归。

##### 组件类型相同

​		当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 `state` 一致。`React` 将更新该组件实例的 `props` 以保证与最新的元素保持一致，并且调用该实例的 `UNSAFE_componentWillReceiveProps()`、`UNSAFE_componentWillUpdate()` 以及 `componentDidUpdate()` 方法。（注释：`UNSAFE_componentWillReceiveProps()` 和 `UNSAFE_componentWillUpdate()` 已废弃）

​		下一步，调用 `render()` 方法，`diff` 算法将在之前的结果以及新的结果中进行递归。

##### 子节点的递归

​		默认情况下，当递归 `DOM` 节点的子元素时，`React` 会**同时遍历两个子元素的列表**；当产生差异时，生成一个 `mutation`。另外，如果没有显示地指定 `key` 值，那么 `React` 将**默认使用索引**用作为列表项目的 `key` 值。

​		在子元素列表末尾新增元素时，更新开销比较小。比如：

```jsx
<ul>
  	<li>first</li>
  	<li>second</li>
</ul>

<ul>
  	<li>first</li>
  	<li>second</li>
  	<li>third</li>
</ul>
```

​		`React` 会先匹配两个 `<li>first</li>` 对应的树，然后匹配第二个元素 `<li>second</li>` 对应的树，最后插入第三个元素的 `<li>third</li>` 树。

​		如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：

```jsx
<ul>
  	<li>Duke</li>
  	<li>Villanova</li>
</ul>

<ul>
  	<li>Connecticut</li>
  	<li>Duke</li>
  	<li>Villanova</li>
</ul>
```

​		`React` 并不会意识到应该保留 `<li>Duke</li>` 和 `<li>Villanova</li>`，而是会重建每一个子元素。这种情况会带来性能问题。

##### 设置标识属性

​		为了解决上述问题，`React` 引入了 `key` 属性。当子元素拥有 `key` 时，`React` 使用 `key` 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 `key` 之后，使得树的转换效率得以提高：

```jsx
<ul>
  	<li key="2015">Duke</li>
  	<li key="2016">Villanova</li>
</ul>

<ul>
  	<li key="2014">Connecticut</li>
  	<li key="2015">Duke</li>
  	<li key="2016">Villanova</li>
</ul>
```

​		现在 `React` 知道只有带着 `'2014'` `key` 的元素是新元素，带着 `'2015'` 以及 `'2016'` `key` 的元素仅仅移动了。

​		实际开发中，编写一个 `key` 并不困难。你要展现的元素可能已经有了一个唯一 `ID`，于是 `key` 可以直接从你的数据中提取：

```jsx
<li key={item.id}>{item.name}</li>
```

​		当以上情况不成立时，你可以新增一个 `ID` 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 `key`。这个 `key` 不需要全局唯一，但在列表中需要保持唯一。

​		你也可以使用元素在数组中的下标作为 `key`。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，`diff` 就会变慢。

​		当基于下标的组件进行重新排序时，组件 `state` 可能会遇到一些问题。由于组件实例是基于它们的 `key` 来决定是否更新以及复用，如果 `key` 是一个下标，那么修改顺序时会修改当前的 `key`，导致非受控组件的 `state`（比如输入框）可能相互篡改，会出现无法预期的变动。

​		在 `Codepen` 有两个例子，分别为 [展示使用下标作为 `key` 时导致的问题](https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key)，以及 [不使用下标作为 `key` 的例子的版本，修复了重新排列，排序，以及在列表头插入的问题](https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key)。



#### 权衡

​		请谨记协调算法是一个实现细节。`React` 可以在每个 `action` 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 `render` 方法，这不代表 `React` 会卸载或装载它们。`React` 只会基于以上提到的规则来决定如何进行差异的合并。

​		我们定期优化启发式算法，让常见用例更高效地执行。在当前的实现中，可以理解为一棵子树能在其兄弟之间移动，但不能移动到其他位置。在这种情况下，算法会重新渲染整棵子树。

​		由于 `React` 依赖启发式算法，因此当以下假设没有得到满足，性能会有所损耗。

1. 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。在实践中，我们没有遇到这类问题。
2. `Key` 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 `key`（比如通过 `Math.random()` 生成的）会导致许多组件实例和 `DOM` 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。



### 插槽

​		`React` 允许直接传递虚拟 `DOM`，然后接收者组件可以直接使用它。这类似 `vue` 中插槽的功能。

##### 属性传递

​		在发送者组件中，直接在接收者组件上通过定义属性的方式，传递虚拟 `DOM`。

```jsx
class Child extends React.Component {
    render() {
        let { vp } = this.props;
        return (
            <div>
                <h1>子组件</h1>
                {vp}
            </div>
        );
    }
}

class Father extends React.Component {
    state = {
        vp: (<p>父组件中传递的p元素</p>)
    }
    render() {
        let { vp } = this.state;
        return (
            <div>
                <h1>父组件</h1>
                <Child vp={vp} /> {/* 在接收者组件上，通过定义属性传递DOM内容 */}
            </div>
        );
    }
}
```

##### 组件包裹

​		在发送者组件中，直接使用接收者组件包裹（双标签的形式）要传递的虚拟 `DOM`。

```jsx
class Father extends React.Component {
    render() {
        return (
            <div>
                <h1>父组件</h1>
                <Child> 
                    {/* 在接收者组件内，直接定义要传递的DOM内容 */}
                	<p>父组件中传递的p元素</p>
                </Child>
            </div>
        );
    }
}
```

​		这些被组件标签包裹的虚拟 `DOM` 也会被该组件实例的 `props` 属性接收到，统一存放在它的 `children` 属性中。

- 节点形式：如果组件包裹的只有一个虚拟 `DOM` 子节点，则 `children` 以虚拟 `DOM` 节点的形式接收它。
- 数组形式：如果组件包裹的有多个虚拟 `DOM` 子节点，则 `children` 以数组的形式接收每个虚拟 `DOM` 节点。

```jsx
// 这里以一个元素为例，因为组件的处理是一样的。
let vnode = (
    <div>
    	只有一个文本节点
    </div>
);

console.log(vnode.props.children); // '只有一个文本节点'
------------------------------------------------------------------------------------------------------------

let vnode = (
    <div>
    	<h1>只有一个子元素</h1>
    </div>
);

console.log(vnode.props.children); // {$$typeof: Symbol(react.element), type: 'h1', ...}
------------------------------------------------------------------------------------------------------------

let vnode = (
    <div>
        文本节点
    	<h1>子元素1</h1>
        <div>子元素2</div>
    </div>
);

console.log(vnode.props.children); // ['文本节点', {..., type: 'h1', ...}, {..., type: 'div', ...}]
```

​		当 `children` 是数组形式时，就可以使用各种数组 `API` 来对数据进行处理或直接渲染。

```jsx
class Child extends React.Component {
    render() {
        let { children } = this.props;
        return (
            <div>
                <h1>子组件</h1>
                {children[2]}
                {children[0]}
                {children[1]}
            </div>
        );
    }
}

class Father extends React.Component {
    render() {
        return (
            <div>
                <h1>父组件</h1>
                <Child>
                    {/* 在接收者组件内，直接定义要传递的DOM内容 */}
                    <p>父组件中传递的p1元素</p>
                    <p>父组件中传递的p2元素</p>
                    <p>父组件中传递的p3元素</p>
                </Child>
            </div>
        );
    }
}
```



### 条件渲染

​		`React` 中的条件渲染，通过在定义虚拟 `DOM` 时使用逻辑运算符、三目运算符、`if` 语句和 `switch` 语句等来实现。

​		使用三目运算符：

```jsx
class T extends React.Component {
    state = {
        bool: true,
        domTrue: <span>条件为true时，渲染的元素</span>,
        domFalse: <span>条件为false时，渲染的元素</span>
    }
    switchDom = () => {
        let { bool } = this.state;
        this.setState({bool: !bool});
    }
    render() {
        let { bool, domTrue, domFalse } = this.state;
        return (
            <div>
                <h1>条件渲染</h1>
                <button onClick={this.switchDom}>切换组件</button>
                <div>{bool ? domTrue : domFalse}</div>
            </div>
        );
    }
}
```

​		使用 `if` 语句：

```jsx
class T extends React.Component {
    state = {
        bool: true,
        dom: null,
        domTrue: <span>条件为true时，渲染的元素</span>,
        domFalse: <span>条件为false时，渲染的元素</span>
    }
    switchDom = () => {
        let { bool } = this.state;
        this.setState({bool: !bool});
    }
    render() {
        let { bool, dom, domTrue, domFalse } = this.state;
        
        if (bool) {
            dom = domTrue;
        } else {
            dom = domFalse;
        }
        
        return (
            <div>
                <h1>条件渲染</h1>
                <button onClick={this.switchDom}>切换组件</button>
                <div>{dom}</div>
            </div>
        );
    }
}
```

