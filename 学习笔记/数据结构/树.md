# 树

**树**是一种[数据结构](https://baike.baidu.com/item/数据结构/1450?fromModule=lemma_inlink)，它是由 *`n (n ≥ 0)`* 个有限节点组成一个具有层次关系的[集合](https://baike.baidu.com/item/集合/2908117?fromModule=lemma_inlink)。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树。

树的种类：

- 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树，也称为自由树；
- [有序树](https://baike.baidu.com/item/有序树?fromModule=lemma_inlink)：树中任意节点的子结点之间有顺序关系，这种树称为有序树；
- [二叉树](https://baike.baidu.com/item/二叉树/1602879?fromModule=lemma_inlink)：每个节点最多含有两个子树的树称为二叉树；
- [满二叉树](https://baike.baidu.com/item/满二叉树?fromModule=lemma_inlink)：叶节点除外的所有节点均含有两个子树的树被称为满二叉树；
- [完全二叉树](https://baike.baidu.com/item/完全二叉树?fromModule=lemma_inlink)：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树；
- [哈夫曼树](https://baike.baidu.com/item/哈夫曼树/2305769?fromModule=lemma_inlink)（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。

结点的种类：

- 内部节点：有子节点的结点，被称为内部结点。
- 外部结点：无子节点的结点，被称为外部结点或叶结点。

树的层次，被称为树的深度。例如，一颗树有 3 层结构，则其深度为 3。

树的遍历表达法有 4 种方法：[先序遍历](https://baike.baidu.com/item/先序遍历/6442839?fromModule=lemma_inlink)、[中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)、[后序遍历](https://baike.baidu.com/item/后序遍历/1214806?fromModule=lemma_inlink)、层次遍历。

 									<img src="images/%E6%A0%91/image-20230524211720843.png" alt="image-20230524211720843" style="zoom:80%;" /> 

- [先序遍历](https://baike.baidu.com/item/先序遍历/6442839?fromModule=lemma_inlink)（又称先根遍历）：为 `ABDECF`（根 ==> 左 ==> 右）

- [中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)（又称中根遍历）：为 `DBEAFC`（左 ==> 根 ==> 右）（仅二叉树有[中序遍历](https://baike.baidu.com/item/中序遍历/757281?fromModule=lemma_inlink)）
- [后序遍历](https://baike.baidu.com/item/后序遍历/1214806?fromModule=lemma_inlink)（又称后根遍历）：为 `DEBFCA`（左 ==> 右 ==> 根）
- 层次遍历：为 `ABCDEF`（同[广度优先搜索](https://baike.baidu.com/item/广度优先搜索/2148012?fromModule=lemma_inlink)）



### 实现

#### 二叉搜索树

##### 简单实现

二叉搜索树，将比当前结点数据小的数据存在左边的子节点中，将大于或等于当前结点数据的数据存在右边的子节点中。

在往二叉搜索树中插入新的结点时，每次都要先从根节点开始，依次跟其下的每个节点进行比较以确定该新节点的去向。

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
    }
})();
```

使用

```js
const bst = new BST();

bst.insert(5);
bst.insert(6);
bst.insert(2);
bst.insert(5);
bst.insert(1);
bst.insert(3);
bst.insert(7);
bst.insert(4);
bst.insert(8);
bst.insert(0);
bst.insert(9);
```

二叉搜索树，将所有比根节点小的数据放到左边，所有比根节点大的数据放到右边。

##### 中序遍历

```js
const BST = (function() {
    // 生成结点
    const Node = class {
        constructor(data) {
            this.data = data; 	// 当前结点的数据
            this.left = null; 	// 左子节点
            this.right = null; 	// 右子节点
        }
    }
    
    // 递归地插入节点
    const insertNode = function(root, node) {
        // 确定结点的去向
        const direction = node.data < root.data ? "left" : "right";
        if (root[direction]) {
            insertNode(root[direction], node);
        } else {
            root[direction] = node;
        }
    }
    
    // 中序遍历：左根右
    function MiddleOrderTraversalNode(root, arr) {
        if (!root) return;
        // 左
        MiddleOrderTraversalNode(root.left, arr);
        // 根
        arr.push(root.data);
        // 右
        MiddleOrderTraversalNode(root.right, arr);
    }
    
    // 生成树
    return class BST {
        constructor() {
            this.root = null;
        }
        insert(data) {
            const node = new Node(data);
            if (this.root) {
                insertNode(this.root, node);
            } else {
                this.root = node;
            }
        }
        MiddleOrderTraversalNode() {
            const arr = [];
            MiddleOrderTraversalNode(this.root, arr);
            return arr;
        }
    }
})();
```

中序遍历，实现了数据的升序读取。

