# 函数

### 函数类型

限定函数类型，其实是在限定其输入和输出的类型，即：参数和返回值。

##### 限定参数

在 `TS` 中，必须限定参数的类型，否则，会提示错误。限定参数就是限定函数的形参，通过限定形参的类型，来间接地控制实参的输入。因为设置一个形参其实就是在函数的顶层作用域中声明一个局部变量，因此，限定形参类型的方式也与声明变量无异。

```tsx
// 限制形参a为number型，形参b为string型
function fn(a: number, b: string) {} // 类型注解
```

注意：当限定了某个形参的类型之后，在调用函数时，就必须为该形参传入指定类型的值（没有隐式类型转换）。否则，会报错。

```tsx
fn(1, '2'); // TS只对参数进行类型检验，不会发生类型转换。
```

另外，`TS` 对参数的数量也进行了严格的限制。实参必须与形参的数量相同，否则在编译时会报错。

```tsx
fn(1, '2', 3); // Expected 2 arguments, but got 3.
```

##### 限定返回值

限定返回值，要在函数声明的小括号后紧跟一个 `:` 以及一个数据类型。即：在小括号内限定参数类型，在小括号外限制返回值类型。

```tsx
function fn1(a: number, b: string): string {
    return ""; // 必须返回一个string类型的值
}

let fn2 = (a: number, b: string): string => "";
```

注意：当限制了返回值的类型之后，就必须在函数内部返回一个该类型的值。否则，会因为函数默认返回 `void` 而提示语法错误。

默认返回值：在 `TS` 中，函数的默认返回值是 `void`，而不是 `undefined`。但是在执行 `ts` 文件时，默认返回 `undefined`，因为它已经被编译成了 `js` 文件，执行 `js` 文件，就会得到 `undefined`。

##### 函数表达式

针对函数表达式，还有另外的限制方式。因为函数表达式是使用变量初始化的方式声明一个函数的，所以还可以给这个变量添加注解。

```tsx
// 声明时限制变量fn的a、b参数以及返回值的类型，然后将一个被应用了同样类型约束的函数对象赋给它。
let fn: (a: number, b: number) => string = (a: number, b: number): string => "";

// 因为，两边应用了相同的类型约束，所以可以省略掉一边。
let fn = (a: number, b: number): string => "";
let fn: (a: number, b: number) => string = (a, b) => "";
```

注意：当限制左边时，使用 `=>` 来指定返回值的类型；而限制右边时，仍然使用 `:` 限制返回值的类型。

另外，当类型约束应用在两边时，以左边的限制为主；只应用在左边时，以左边为主；只应用在右边时，以右边为主。因为，限制左边变量的类型主要是为了使要赋值给它的函数对象必须符合它的赋值要求。而限制右边的函数对象则主要是为了使函数的实参和返回值符合函数对输入和输出的控制要求。

```tsx
// 因此，当应用左边的类型约束时，右边的形参不一定要与左边的同名。
let fn: (a: number, b: number) => string = (x, y) => ""; // 约束自动应用到右边，右边只需要提供合规的形参和返回值即可。

let fn: (a: number, b: number) => string = (x: number, y: number): string => x + y + "";
```

注意：当在左边限定返回值的类型为：`{}`、`viod` 或 `any` 时，则相当于没有限定返回值的类型，此时会采用右边的约束规则。

```tsx
let fn1: (a: number, b: number) => {} = (x, y): number => x + y; 	// 返回值为number型
let fn2: (a: number, b: number) => viod = (x, y): number => x + y; 	// 返回值为number型
let fn3: (a: number, b: number) => any = (x, y): number => x + y; 	// 返回值为number型
```

##### 函数返回值

因为 `TS` 函数的默认返回值是 `void`。因此，当只需要函数完成某些任务，而不需要返回值时，就可以将其返回值限定为 `void` 类型。

```tsx
function fn(): void {} // 表示该函数没有返回值，或返回值没有意义。

// 函数表达式
let fn: (a: number, b: number) => void = (x, y) => {};
```

当不明确指定返回值的类型时，`TS` 会根据函数的实际返回值对其返回值进行类型推论，并将其限定为推论出来的类型。

另外，当在左边将返回值的类型指定为：`{}`、`viod` 或 `any` 时，也不会影响右边的函数对其返回值应用类型推论机制。

```tsx
// 左边将返回值的类型指定为{}，但这并没有影响类型推论对它的判断。
let fn: (a: number, b: number) => {} = (x, y) => x + y; 	// 被推论为number型

// 在左边将返回值的类型限定为viod，也不会影响类型推论对它的判断。
let fn: (a: number, b: number) => viod = (x, y) => x + y; 	// 被推论为number型

// 在左边将返回值的类型限定为any，还是不会影响类型推论对它的判断。
let fn: (a: number, b: number) => any = (x, y) => x + y; 	// 被推论为number型
```

注释：在左边将返回值的类型指定为：`{}`、`viod` 或 `any`，相当于没有限定返回值的类型，即：允许方法返回任意类型的值。但如果在右边限制返回值的类型（即：直接在函数上限制返回值类型）或者左边指定的返回值类型不是如上三者，那么返回值必须符合类型要求。

```tsx
let fn: (a: string, b: number) => {} = (x, y) => x ? x : y;
// 其效果相当于：
let fn: (a: string, b: number) => number | string = (x, y) => x ? x : y;
let fn: (a: string, b: number) => number | string = (x, y): number | string => x ? x : y;
let fn: (a: string, b: number) => void = (x, y): number | string => x ? x : y;
let fn = (x: string, y: number): number | string => x ? x : y;
// 其实质接近于：
let fn = (x: string, y: number) => x ? x : y;

console.log(fn('f', 0)); 	// 'f'
console.log(fn('', 0)); 	// 0
```

##### 可选参数

设置参数时，可以在参数后面紧跟一个 `?` 来将该参数设定为可选的参数。

```tsx
function fn(a: number, b?: number) {
    // 注意：不可以不加判断地直接使用任何一个可选的参数，因为它们可能没有意义，这在ts中会提示语法错误。
    if(b) {
        return a + b;
    }
    return a;
}

console.log(fn(1, 2)); 	// 3
console.log(fn(1)); 	// 1
```

规定：

- 问号必须在冒号的前面，前后的空格可有可无。
- 可选参数必须放在所有必选参数的后面，相当于是一种对函数输入的扩展。
- 将参数设为可选，相当于将它设置为联合类型（在指定的类型上联合一个 `undefined` 型），如：`b: number | undefined`。
- 给可选的形参，只能传递 `undefined`（相当于不传值）或者指定类型的值，要么不传任何值。
- 在函数内部，必须判断每一个可选参数是否有意义，否则会提示语法错误。

```tsx
// 可选参数，实际上是在参数的设定类型上又联合一个undefined类型。
function fn1(a: number, b?: number): void {} 			// 第二个参数可传可不传
function fn2(a: number, b: number | undefined): void {}	// 第二个参数必须传
// 它们并不等价，因为fn1的b参数是可选的，而fn2的b参数是必选的。
```

##### 默认参数

默认参数，就是给参数设定一个默认值，用法和作用与 `js` 一样。默认参数可以放在任何位置，但一般放在末尾当作一种输入扩展使用。

```tsx
let fn = (a: number, b: number = 10): number => {
    return a + b;
}

// 默认参数，因为具有了默认值，所以它会作为可选参数来使用，相当于：b?: number。
fn(1);
```

由于默认参数也是一种可选参数，因此它们可以写在可选参数的后面。不过，不允许将一个参数既设为可选又设定默认值。

```tsx
let fn = (a: number, b?: number, c: number = 10): number => {
    return a + c;
}

// 错误的写法：不能给参数同时应用问号和初始化式
let fn = (a: number, b?: number = 0, c: number = 10): number => {
    return a + b;
}
```

另外，`TS` 不允许将首位空缺，如果要使用首位的默认值，则可以传入一个 `undefined`。

##### 剩余参数

使用扩展运算符可以将调用时多余传入的实参统一收集到一个数组中，必须应用限制数组类型的语法去间接地控制实参的输入。

```tsx
// TS要求必须限制每个参数的类型
function fn(a: number, ...args: (number | string)[]) {
    console.log(a);
    console.log(args);
}

fn(1, 2, '3', 4);
/*
> 1
> [2, '3', 4]
*/
```

注释：剩余参数只能作为最后一个参数使用，且每个函数只能有一个。



### 函数重载

原生的 `JS` 并没有真正的函数重载，只能通过 `if-else` 等语句进行分支执行，模拟函数重载的功能，即：根据传入参数的类型、顺序或个数的不同，输出不同的结果。

```js
// 使数字或字符串翻转
function reverse(x) {
    if (typeof x === 'number') {
        return Number(x.toString().split("").reverse().join(""));
    } else if(typeof x === 'string') {
        return x.split("").reverse().join("");
    }
}
```

在 `TS` 中，可以改写为如下代码：

```tsx
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split("").reverse().join(""));
    } else if(typeof x === 'string') {
        return x.split("").reverse().join("");
    }
}
```

注意：将 `return` 语句放到块级作用域中之后，函数将检测不到它的存在。因此，可在函数作用域中 `return` 一个值，或令其为 `void`。

但是，上述代码在类型安全方面仍然存在威胁。因为，输入和输出的类型并没有进行严格地绑定。要实现严格绑定，就需要函数重载。

##### 函数重载

函数重载是 `C++` 中的一个概念。重载函数是函数的一种特殊情况，为方便使用，`C++` 允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数必须不同（主要指参数的个数、类型或者顺序），也就是说可以使用同一个函数完成不同的功能，这就是重载函数。重载函数常用来实现功能类似而所处理的数据类型不同的问题。

但是，`JS` 和 `TS` 都不允许多个函数使用一个名称，因此 `TS` 的重载函数与 `C++` 有所不同，但与 `JS` 相似。

##### 函数签名

在 `TS` 中，要使用函数重载的功能，首先要定义函数的重载签名，然后实现重载签名。

一个函数签名 （`Function Signature`，亦称：类型签名或方法签名）定义了函数或方法的输入与输出。

一个签名可以包括：

- 参数及参数的类型。
- 一个返回值及其类型。
- 可能被抛出或传回的异常。
- 有关面向对象程序中方法可用性的信息（例如：关键字 `public`、`static` 或 `prototype`）。

然而，`JS` 并没有函数签名。这是因为 `JS` 是一门动态型语言，它的参数实际上是使用一个 `arguments` 类数组来表示的，所谓的形式参数也只是为了提供便利而设计的，并不是必须要求的。在其他语言中，命名参数这块要求必须事先创建函数签名，而将来的调用也必须与该签名一致。`JS` 中没有这些条条框框，解析器不会验证命名参数，所以说 `JS` 没有函数签名。

##### 重载签名

要实现将输入与输出的类型进行绑定，关键就是重载签名。重载签名时只需要指定函数输入和输出的类型即可，不需要函数体。

```tsx
// 重载签名：绑定输入和输出的类型
function reverse(x: number): number // 输入number，输出number
function reverse(x: string): string	// 输入string，输出string
```

重载签名中的签名主要指的是函数的输入和输出及其类型，即：参数和返回值及其类型。

##### 实现签名

实现签名就是兼容重载签名的函数实现，它是实际的函数执行逻辑，与 `JS` 很相似。

当调用函数，传入的参数与任意一个重载的签名匹配时，都可以调用函数体来执行。

```tsx
// 实现签名
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split("").reverse().join(""));
    } else if(typeof x === 'string') {
        return x.split("").reverse().join("");
    }
}

reverse(123); // 首先检查实参的类型，然后与重载的签名参数进行匹配，只要有一个签名匹配成功，则就会使用该参数执行函数体。
```

注释：实际上，只需要保证重载签名与实现签名中的输入及其类型保持一致即可。重载中的输出类型只要不超出实现中的输出类型，是可以随意指定的，并没有强制绑定输出的类型。这意味着即使重载签名绑定了输入和输出的类型，实际的输出可能不一定是绑定的类型。

```tsx
// 重载签名：严控输入，期望输出
function reverse(x: number): string // 当x的输入为number时，期望输出一个string

// 实现签名：须完全兼容重载签名
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split("").reverse().join("")); // 实际输出
    } else if(typeof x === 'string') {
        return x.split("").reverse().join("");
    }
}

// 函数执行：输入参数，获得输出
reverse(123); // 尽管重载签名期望输出string，但实际上却输出了number。
```

由此，可以看出：函数重载主要是给开发者看的提示语，或者说是对输入和输出类型的一种期望，但并不是对实际输入和实际输出的严格绑定。因为函数的实际输入是好控制的，但实际输出是由内部的实现逻辑决定的，就算限定返回值的类型也只会将其限定在一个允许的范围中。因为想要根据不同的输入获得不同的输出，就必定要允许有多种类型的返回值。无论实际的输出如何，都必定是指定的类型之一。

##### 匹配签名

匹配顺序：调用重载函数时，会使用实参的类型，按照重载签名的顺序从上到下依次匹配。因此，尽量将匹配率高的重载签名放在前面。

另外，当多个重载签名中的参数个数不一致时，要注意在实现签名中将多余的参数设为可选参数或默认参数。

```tsx
// 重载签名：参数的数量不一致
function fn(x: string): string;
function fn(x: number, y: number): string;
function fn(x: number, y: number, z: number): string;

// 实现签名：将多余的参数设为可选或默认
function fn(x: string | number, y?: number, z: number = 10): string | void {
    y = y || 0;
    if (typeof x === 'number') {
        return x + y + z + '';
    }
    return x;
}

console.log(fn('1')); // '1'
console.log(fn(1, 2)); // '13'
console.log(fn(1, 2, 3)); // '6'
```

当然，重载签名也可以设定可选参数和联合类型，但要注意不能超出实现签名提供的范围。

```tsx
// 重载签名
function fn(x: string): string;
function fn(x: number, y?: number): number;
function fn(x: string | number, y?: number, z?: number): string | number;

// 实现签名
function fn(x: string | number, y?: number, z?: number): string | number | void {}
```

