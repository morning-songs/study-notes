# 数字型

`Number` 类型使用 `IEEE 754` 格式表示整数和浮点值（在某些语言中也叫双精度值），数值默认采用双精度保存。



### 进制

- 八进制：八进制字面量以0开头，数值0~7。若超出范围将被视为十进制数。【严格模式下，八进制数无效】
- `ES6` 中的八进制值通过前缀 `0o` 来表示；严格模式下，前缀 0 会被视为语法错误，如果要表示八进制值，应该使用前缀 `0o`。
- 十六进制：十六进制字面量以`0x`开头，数值0~9，A~F。
- 无论是哪种进制数，最终都会被转换为对应的十进制数后，再参与数学运算。



### 浮点值

- 浮点值中必须且只能有一个小数点，小数点前后至少要有一位数字。
- 因为存储浮点值使用的内存空间是存储整数值的两倍，所以 `ECMAScript` 总是想方设法把浮点值转换为整数值。
- 例如：在小数点后面没有数字或只有0的情况下，浮点值就会变成整数值。
- 对于非常大或非常小的数值，`ES` 会采用科学计数法来表示。默认情况下，将小数点后至少包含 6 个零的浮点值转为科学记数法。

精度不准：浮点值的精确度最高可达 17 位小数，但因为使用 `IEEE 754` 格式，浮点值在算术计算中远不如整数精确。

```js
let a = 0.1, b = 0.2, c = 0;
c = a + b; // 结果是0.300 000 000 000 000 04，而不是0.3

// 减法是加法的逆运算，因此部分浮点数的减法也是不准的。
0.3 - 0.1; // 0.19999999999999998
```



### 数值范围

- 由于内存的限制，`ECMAScript` 并不能表示这个世界上的所有数值。
- `ES` 将可以表示的最小数值保存在 `Number.MIN_VALUE` 属性中，这个值在多数浏览器中是 `5e-324`；
- 将可以表示的最大数值保存在`Number.MAX_VALUE` 属性中，这个值在多数浏览器中是 `1.797 693 134 862 315 7e+308`。
- 如果数值超出了`MIN`到`MAX`的范围，会被转换为一个可以表示无穷大的值：`Infinity`（不能参与任何数学计算）。
- 任何无法表示的负数以`-Infinity`表示，任何无法表示的正数以`Infinity`表示。

判断有限值：使用`isFinite`方法，可以判断参数是否是有限数值（介于`MIN`和`MAX`之间）。

```js
let num = Infinity;
isFinite(num); // false

num = 5 / 0; // Infinity
num = -5 / 0; // -Infinity
```

无限值属性：`Number.NEGATIVE_INFINITY` 和 `Number.POSITIVE_INFINITY` 分别表示`-Infinity` 和 `Infinity`。



### 非数值

-  `NaN` 是一个特殊的数值 ，意思是“非数值”（`Not a Number`），用于表示`Number`转换失败时的返回值。
-  任何涉及 `NaN` 的数学操作都始终返回 `NaN`，其次，`NaN` 不等于任何数值（包括自身）。
-  若要判断数值是否为`NaN`非数值，可使用`isNaN`方法。传入其他类型会首先被`Number`转为数值型。
-  `isNaN`用于测试对象时。首先会调用对象的 `valueOf`方法，确定返回值是否可以转换为数值。如果不能，再调用 `toString`方法，继续测试其返回值是否能转换为数值。这通常是 `ECMAScript` 内置函数和操作符的工作方式。

```js
// NaN表示在转为数值型失败时，返回的特殊数值。
let num = "red";
Number(num); // NaN

// 当0相互除时，返回NaN，数值结果无法表示
num = 0 / 0; // NaN

typeof NaN; // "number"
NaN == NaN; // false
```



### 类型转换

使用`Number`转型函数，可以将任何类型的值转换为对应的数值型。

转换规则：【表示空的值可转为0；无法表示的值转为`NaN`】

- 布尔型：`true`转为1；`false`转为0
- 空值型：`null`转为0【`null`表示空，可转为0】
- 未定义型：`undefined`转为`NaN`【`undefined`意为未定义，`Number`无法表示】
- 字符串型：
  - 空字符串以及空格字符串均转为0；【空字符串以及空格字符串均表示空，可转为0】
  - 纯数字形式的字符串转为对应的数值型，包括八进制(`0o`)、十六进制(`0x`)以及浮点值
  - 非纯数字形式的字符串一律转为`NaN`
- 数组型：空数组转为0；非空数组转为1
- 对象和函数：任何函数和对象都会转为`NaN`（包括空函数和空对象）
- 符号型：符号型禁止被转换为数字类型，否则会报错。



### 获取整数

使用`parseInt`方法，可以将字符串中的整数部分提取出来并转为数值型。

提取规则：自动忽略开头的空格字符，空的字符串返回`NaN`。

- 字符串必须以数学形式的值开头（包括加减号），否则直接返回`NaN`。

- 从第一个数值字符开始，一直提取到末尾或非数值字符（包括小数点和`e`）。【不识别科学计数法】
- 第二个参数：指定截取的整数是哪种进制，将数值按指定进制转为十进制。

```js
// 空的字符串
parseInt(""); // NaN

// 浮点值，只取整数部分
parseInt("1.123456"); // 1

// 科学计数法：由于不识别小数点，parseInt也不识别科学计数法
parseInt("1.1e1"); // 1
parseInt("1e2"); // 1

// 八进制：必须指定为八进制，且不识别0o前缀。
parseInt("010"); // 10
parseInt("0o10"); // 0
parseInt("0o10", 8); // 0
parseInt("10", 8); // 8

// 十六进制：识别0x前缀，指定为十六进制后，可省略前缀
parseInt("0x10"); // 16
parseInt("a", 16); // 10
parseInt("aBCdeF", 16); // 11259375
```



### 获取浮点数

使用`parseFloat`方法，可以将字符串中的浮点值部分提取出来并转为数值型。

提取规则：

- 字符串必须以数值开头（包括加减号），否则直接返回`NaN`。
- 解析到字符串末尾或者解析到一个无效的浮点数值字符为止。【第一个小数点有效，其余的无效】
- `parseFloat`直解析十进制，不能指定底数。因此，十六进制的数始终被转为0。
- `parseFloat`方法既可以将值转为浮点数，也可以转为整数（小数点后只有0时），并且识别科学计数法。

```js
// 提取到非数值字符
parseFloat("10.213a"); // 10.213

// 多个小数点：仅识别第一个
parseFloat("0.2.1.1"); // 0.2

// 十六进制：仅提取前缀0
parseFloat("0x10"); // 0

// 转为整数
parseFloat("001.0000"); // 1

// 科学计数法
parseFloat("1.1e1"); // 11
```



### 包装类

使用`new Number`的方式，可以将数值包装为数值型对象。非数值型先调用`Number`转换类型。

在`ES`中，数值不可以直接调用任何方法，必须将其包装为数值型对象，才可调用`Number`原型上的各种方法。

注释：使用小括号将数值包裹起来，可以将其隐式地转为数值型对象（不是真对象），以方便调用原型方法。

```js
// 获取数值的字符串表示
123.toString(); // SyntaxError: Invalid or unexpected token【不能直接使用数字字面量来调用任何方法】
new Number(123).toString(); // "123"
(123).toString(); // "123"

// 使用变量调用
let num = 123;
num.toString(); // "123"
```

扩展：`Number`在继承`toString`方法时进行了改写，使其可以接受一个参数，它将数值输出为指定进制的字符串形式。

```js
let num = 10;
num.toString(8); // "12"，将数值10转为其八进制格式的字符串。
```



### 重写的方法

`Number` 重写了 `valueOf()` 、`toLocaleString()` 和 `toString()` 方法。

- `valueOf`：返回原始数值。
- `toString`：返回指定进制的字符串。



### 格式化方法

除了继承的方法，`Number` 类型还提供了几个用于将数值格式化为字符串的方法。

- `toFixed`：保留几位小数【通常最多为 20 位】，四舍五入。
- `toExponential`：保留几位小数，科学计数法（也称指数计数法）形式。
- `toPrecision`：根据情况返回数值最合理的输出结果，可能是固定长度，也可能是科学记数法形式。

注释：

- `toPrecision` 方法接收一个参数，表示结果中**数字的总位数**（不包含指数）【通常最多 21 个小数】
- 本质上，`toPrecision()` 方法会根据数值和精度来决定调用 `toFixed()` 还是 `toExponential()`。
- 而为了以正确的小数位精确表示数值，这 3 个方法都会向上或向下舍入。

```js
// 四舍五入，保留几位小数
let num = 10.007;
num.toFixed(2); // "10.01"

// 科学计数法，保留几位小数
let num = 10;
num.toExponential(2); // "1.00e+1"

// 最适合的形式，指定数字总位数
let num = 99;
num.toPrecision(1); // "1e+2"
num.toPrecision(2); // "99"
num.toPrecision(3); // "99.0"
```



### 整数与安全整数

`ES6` 新增了 `Number.isInteger()` 方法，用于辨别一个数值是否保存为整数。

为了节约内存， `ECMAScript` 总会想方设法地把浮点值转换为整数值。例如：当小数点后只有 0 的情况下，浮点数会被转为整数。

```js
Number.isInteger(1); 	// true
Number.isInteger(1.00); // true
Number.isInteger(1.01); // false
```

安全整数：

- `IEEE 754` 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示为一个整数值。
- 这个数值范围从 `Number.MIN_SAFE_INTEGER(-2^53 + 1)` 到 `Number.MAX_SAFE_INTEGER(2^53 - 1)`。
- 对于超出这个范围的数值，即使尝试保存为整数，`IEEE 754` 编码格式也意味着二进制值可能会表示为一个完全不同的数值。
- 为了鉴别整数是否在这个安全范围之内，可以使用 `Number.isSafeInteger()` 方法。

```js
// 最小安全整数
Number.isSafeInteger(-(2 ** 53)); // false
Number.isSafeInteger(-(2 ** 53) + 1); // true

// 最大安全整数
Number.isSafeInteger(2 ** 53); // false
Number.isSafeInteger(2 ** 53 - 1); // true
```

