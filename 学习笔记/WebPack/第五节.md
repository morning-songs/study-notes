# 项目打包

通常，`vue` 项目会使用 `vue` 官方提供的 `vue/cli` 脚手架或 `vite` 来打包。因为它们已经内置了一些基础的命令，使用起来更方便。



### `vue`

使用 `webpack` 打包 `vue` 项目。

##### `vue` 文件

处理 `vue` 文件，需要使用 `vue-loader`、`vue` 和 `@vue/compiler-sfc` 三个包。其中，`vue` 和 `@vue/compiler-sfc` 的版本须一致。

```shell
npm i vue-loader vue @vue/compiler-sfc -D
```

模块配置

```js
{
    test: /\.vue$/i,
    use: ["vue-loader"]
}
```

处理 `vue3` 项目，还需要一个插件来配合使用。该插件已内置在 `vue-loader` 之中，只需导出后挂载使用即可。

```js
const {VueLoaderPlugin} = require("vue-loader");

module.exports = {
    plugins: [
        new VueLoaderPlugin()
    ]
}
```

注意：上述 `loader` 只处理 `vue` 文件，对于 `vue Router` 和 `vuex` 等还需要使用相应的 `loader` 和配置。因此，推荐 `vue/cli` 打包。

##### 静态目录

在 `vue` 项目中，通常在项目根目录下会有一个 `public` 静态目录，用于存储静态的公共资源（如：入口页面和网站 `Logo` 等）。

```diff
public
|- index.html
|- logo.png
```

而在打包项目时，一般是不会打包处理该静态目录的，而是直接将其中的静态公共资源复制到打包后的项目根目录中。

手动复制 `public` 中的文件可能会导致意外的错误，所以更推荐的做法是使用一个 `copy-webpack-plugin` 插件来执行这个复制工作。

```shell
npm i copy-webpack-plugin -D
```

工具配置

```js
const CopyWebpackPlugin = require("copy-webpack-plugin");

module.exports = {
    plugins: [
        new CopyWebpackPlugin({
            // 指定不需要被打包处理，而是直接复制其中资源的静态目录
            patterns: [{
                from: "./public" // 指定静态目录
            }]
        })
    ]
}
```

但是由于入口页面一般都交给 `html-webpack-plugin` 插件去打包处理，所以在配置工具时还需要将 `public` 中的入口页面排除在外。

```js
module.exports = {
    plugins: [
        new CopyWebpackPlugin({
            patterns: [{
                from: "./public", // 指定静态目录
                globOptions: {
                    ignore: ["**/index.html"] // 指定不需要被复制的文件
                }
            }]
        })
    ]
}
```

注释：当 `public` 中只有入口页面，而没有其他资源时，会得到警告，但没有任何影响。



### 代理

代理是基于 `HTTP` 服务器的，因此，`webpack-dev-server` 工具是必需的。

##### 跨域问题

浏览器遵守同源策略，只允许在同一个域（同一协议、同一主机、同一端口）中传递消息，阻止非同源的请求。

解决跨域：

- `jsonp`：浏览器不会同源限制 `src` 发起的请求
- 后端设置：`Access-Control-Allow-Origin: true`，允许跨域访问
- 代理：基于 `HTTP` 服务器（即：绕开浏览器），帮别人转发请求

阻止跨域，是浏览器的安全限制。不涉及浏览器的请求是没有同源限制的，因此，后端（即：服务器）之间发送请求没有跨域的问题。

```js
// 后端
const express = require("express");
const app = express();

app.get("/user", (req, res) => {
    res.send({msg: "获取user数据"});
})

app.post("/info", (req, res) => {
    res.send({msg: "提交info数据"});
})

app.listen(4000, () => {
    console.log("启动4000端口");
})
```

```js
// 前端
import axios from "axios";

window.onload = async () => {
    let res1 = await axios.get("http://localhost:4000/user");
    let res2 = await axios.post("http://localhost:4000/info");
    
    console.log(res1);
    console.log(res2);
}
```

这个前端请求由浏览器发出，受到了浏览器的同源限制而被阻止。此时，便可以使用 `HTTP` 服务器来转发这个请求，以解决跨域问题。

##### 代理配置

要使用 `webpack` 启动的 `HTTP` 服务器去转发浏览器的请求，需要在 `webpack.config.js` 中配置 `devServer` 的 `proxy` 选项。

```js
module.exports = {
    devServer: {
        // 代理配置
        proxy: {
            // 在属性名上指定要转发的路由，在属性值上指定要转发的域（包括：协议、主机和端口）
            "/user": "http://localhost:4000", // 代理/user及其子路由，如：/user/a
            "/info": "http://localhost:4000", // 代理/info及其子路由，如：/info/a
            "/": "http://localhost:4000" 	  // 根路由（代理所有的路由）
        }
    }
}
```

然后，在前端直接使用 `proxy` 路由发起请求即可。当监听到 `proxy` 路由的请求时，服务器会自动将其值拼接到路由上，然后发起请求。

```js
import axios from "axios";

window.onload = async () => {
    let res1 = await axios.get("/user");  // 对"/user"的请求，服务器会将请求代理到"http://localhost:4000/user"
    let res2 = await axios.post("/info"); // 对"/info"的请求，服务器会将请求代理到"http://localhost:4000/info"
    
    console.log(res1);
    console.log(res2);
}
```

代理请求是由服务器发起的，所以不会产生浏览器的跨域问题。由此，解决了跨域请求的问题。因原始服务器是隐藏的，属于反向代理。

更多参考：[`devServer.proxy`](https://webpack.docschina.org/configuration/dev-server/#devserverproxy) 

##### 正向代理

代理：通常是指一个中间服务器，它是一个位于客户端和原始服务器之间的中间服务器（代理服务器）。

正向代理：代理的对象是客户端。为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标服务器（原始服务器），然后代理服务器向原始服务器转交客户端的请求并将（从原始服务器上）获得的内容返回给客户端。

正向代理中，只有代理服务器才可以访问和获得原始服务器上的内容，客户端是无法直接访问原始服务器的，但它可以访问代理服务器。

客户端才能使用正向代理，对原始服务器来说，它并不知道发起请求的是哪个客户端。换句话说，客户端对服务器是未知的。

特点：客户端知道要访问的原始服务器，而被访问的原始服务器不知道是哪个客户端在访问。代理客户端，对客户端负责。

应用：

- 科学上网：客户端通过代理服务器，访问原本访问不到的网站。如：`VPN` 软件等。
- 加速访问：客户端直接访问原始服务器很慢时，可通过代理服务器去访问它。如：加速器等。
- 缓存数据：访问代理服务器后，代理服务器会缓存获得的资源，再次访问同一资源时直接返回。
- 授权访问：
- 隐藏用户：客户端不希望原始服务器知道访问者的身份时，可以通过委托代理服务器去访问。

##### 反向代理

反向代理：代理的对象是服务器。以代理服务器来接收客户端的请求，然后将请求转发给内部网络上的服务器，将从服务器上得到的结果返回给客户端，此时代理服务器对外表现为一个反向代理服务器。

特点：客户端不知道原始服务器的存在，它从代理服务器上获得内容，以为代理服务器就是原始服务器。代理服务器，对服务器负责。

应用：

- 保护服务器：为了服务器的安全，只允许代理服务器访问它。用户只能通过访问代理服务器来访问原始服务器。
- 负载均衡：同时向原始服务器发起多个请求时，可以先经过代理服务器的负载均衡算法合理地将请求分发到不同的服务器。

二者区别：

- 正向代理：代理的是客户端，代理服务器替用户访问原始服务器（前半段）。用户知道原始服务器，但原始服务器不知道用户。
- 反向代理：代理的是服务器，代理服务器替原始服务器收发请求（后半段）。用户只知代理服务器，却不知原始服务器的存在。

<img src="images/%E7%AC%AC%E4%BA%94%E8%8A%82/1620.png" alt="img" style="zoom:47%;" />  <img src="images/%E7%AC%AC%E4%BA%94%E8%8A%82/1620-16734191792893.png" alt="img" style="zoom:50%;" /> 

更多参考：[正向代理与反向代理详解](https://cloud.tencent.com/developer/article/1996633) 

##### 路由重写

在 `proxy` 中指定要代理的路由时，可以使用一个对象值来对代理路由进行重写，然后代理服务器使用新的路由去访问原始服务器。

首先在要代理的路由（如：`/api`）中通过 `target` 指定目标服务器（原始服务器），然后通过 `pathRewrite` 重写代理路由片段。

```js
module.exports = {
    devServer: {
        proxy: {
            "/api": {
                target: "http://localhost:4000",
                pathRewrite: {
                    "/api": "/test", // 将/api替换为/test，如：/api/a ==> /test/a
                    "/api": ""  	 // 将/api替换为空字串，如：/api/a ==> /a
                }
            }
        }
    }
}
```



### 上线

默认情况下，`webpack` 会将项目的所有内容打包输出到项目根目录下的 `dist` 目录中。最终，要提交上线的就是这个 `dist` 中的内容。

##### 提交合并

先在后端项目的根目录下新建一个 `public` 目录（后端静态资源目录），然后将 `dist` 中的所有内容复制到 `public` 中。最后，在后端将 `public` 目录指定为静态资源目录（静态资源服务器）。

```js
// 在后端项目的app.js中
app.use(express.static("./public"));
```

##### 前端访问

后端设置了静态资源服务器之后，浏览器访问服务器地址时，浏览器便会自动寻找并打开静态资源服务器中的 `index.html` 作为首页。



### 环境

在开发时，会使用一些方便的开发工具，但上线后，不再需要使用它们。因此，上线之前，必须清除在开发环境下配置的参数。

实际上，在对 `webpack` 进行配置时，便可以针对不同的环境参数进行不同的配置。此时，便要将 `module.exports` 设为函数。

##### 环境信息

当在 `webpack.config.js` 文件中导出一个函数时，该函数会被自动调用并接收到一个包含环境信息的参数，其返回值便是项目配置。

```js
module.exports = (env) => {
    // env是自动传参的对象，其中包含环境信息。如：生产环境 ==> {production: true}
    console.log(env);
}
```

##### 环境模式

使参数 `env` 获得环境信息的前提是，必须指定打包的环境模式。这个环境模式要在执行指令时指定，因此可在 `package.json` 中配置。

在打包指令中指定环境模式，可以在 `"webpack"` 指令后追加一个 `"--env"` 以及环境模式（`development` 或 `production`）。

```json
{
    "scripts": {
        "build": "webpack --env production"
    }
}
```

##### 配置调整

有了环境信息，便可以将公共的配置（无关环境的、基础的配置）提取出来，然后针对不同的环境再给予不同的配置。

```js
// 公共配置（基础配置）
const config = {
    entry: "",
    output: {},
    module: {},
    plugins: []
}

module.exports = (env) => {
    if (env.production) { 
        // 基于生产环境的配置
        config.mode = "production";
    } else { 
        // 基于开发环境的配置
        config.mode = "development";
        config.devtool = "source-map";
        config.devServer = {};
    }
    return config;
}
```

