# 哈希表

[散列表](https://baike.baidu.com/item/散列表/10027933?fromModule=lemma_inlink)（`Hash table`，也叫哈希表），是根据关键码值（`Key value`）而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构/1450?fromModule=lemma_inlink)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/散列函数/2366288?fromModule=lemma_inlink)，存放记录的[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink)叫做[散列表](https://baike.baidu.com/item/散列表/10027933?fromModule=lemma_inlink)。

给定表 `M`，存在函数 `f(key)`，对任意给定的关键字值 `key`，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 `M` 为哈希（`Hash`）表，函数 `f(key)` 为哈希函数。

哈希表也是一种键值对的表，但它不直接以源键为键，而是将源键经过哈希函数转换为哈希键，然后，使用哈希键来存储源键的值。



### 实现

#### 简单实现

哈希表，相当于给键做了一次加密。当取值时，只需要提供源键即可，它会将源键转换为哈希键，然后使用哈希键提取数据。

```js
const Hash = (function() {
    function HASH(key) {
        let code = "";
        [...key].forEach(str => {
            code += str.charCodeAt();
        });
        return code;
    }
    const sym = Symbol();
    return class Hash {
        constructor() {
            this[sym] = {};
            this[sym].size = 0;
        }
        set(key, value) {
            const hashCode = HASH(key);
            this[sym][hashCode] = value;
            this[sym].size++;
        }
        get(key) {
            const hashCode = HASH(key);
            return this[sym][hashCode];
        }
    }
})();
```

使用

```js
const hashTable = new Hash();

hashTable.set("abc", "abc");
hashTable.set("acb", "acb");
hashTable.set("bac", "bac");
hashTable.set("bca", "bca");
hashTable.set("cab", "cab");
hashTable.set("cba", "cba");

hashTable.get("abc"); // "abc"
```

#### 传统实现

哈希表，通常在内部使用一个数组来实现键值的映射。然后，通过让哈希键模上数组长度来控制哈希表的大小。

```js
const Hash = (function() {
    const SIZE = 17; // 设置哈希表大小为：17（建议使用质数）
    function HASH(key) {
        let code = 0;
        [...key].forEach(str => {
            code += str.charCodeAt();
        });
        return code % SIZE;
    }
    const sym = Symbol();
    return class Hash {
        constructor() {
            this[sym] = new Array(SIZE);
        }
        set(key, value) {
            const hashCode = HASH(key);
            this[sym][hashCode] = value;
        }
        get(key) {
            const hashCode = HASH(key);
            return this[sym][hashCode];
        }
    }
})();
```

不过，上述的哈希函数实现还存在一个哈希键冲突的问题，例如：源键 `"abc"` 和 `"acb"` 经转换后是同一个哈希键。这会导致哈希表中的值被意外的覆盖，而这个问题通常会使用线性探查（即：线性循环）或链表来解决。

##### 线性探查

```js
const Hash = (function () {
    const SIZE = 5; // 设置哈希表大小为：5（建议使用质数）
    function HASH(key) {
        let code = 0;
        [...key].forEach(str => {
            code += str.charCodeAt();
        });
        return code % SIZE;
    }
    const sym = Symbol();
    return class Hash {
        constructor() {
            this[sym] = new Array(SIZE);
        }
        set(key, value) {
            const hashCode = HASH(key);
            // 线性探查
            let index = hashCode;
            while(this[sym][index]) {
                index = (index + 1) % SIZE; 	// 当前键有值时，设置下一个键
                if(index === hashCode) break;	// 所有键有值时，停止线性探查
            }
            return this[sym][index] = [key, value];
        }
        get(key) {
            const hashCode = HASH(key);
            if(!this[sym][hashCode]) return undefined;
            // 线性探查
            let index = hashCode;
            while(this[sym][index][0] !== key) {
                index = (index + 1) % SIZE;
                if(index === hashCode) return undefined; // 该键可能已被删除
            }
            return this[sym][index][1];
        }
    }
})();
```

使用

```js
const hashTable = new Hash();

hashTable.set("", "abc");
hashTable.set("acb", "acb");
hashTable.set("bac", "bac");
hashTable.set("bca", "bca");
hashTable.set("cab", "cab");
hashTable.set("cba", "cba");

console.log(hashTable.get(""));   	// "abc"
console.log(hashTable.get("acb")); 	// undefined
console.log(hashTable.get("bac"));	// "bac"
console.log(hashTable.get("bca"));	// "bca"
console.log(hashTable.get("cab"));	// "cab"
console.log(hashTable.get("cba"));	// "cba"
console.log(hashTable.get("acs"));	// undefined
```

##### 链表探查

可以将每个哈希键映射为一个链表，然后使用链表来存储哈希键相同的所有数据。

```js
const Hash = (function() {
    // 单向链表
    const LinkedList = (function() {
        const HEAD = Symbol();
        class DataNode {
            constructor(data) {
                this.data = data;
                this.next = null;
            }
        }
        return class LinkedList {
            constructor(data) {
                this[HEAD] = null;
            }
            append(data) {
                const node = new DataNode(data);
                let target = this[HEAD];
                if (target) {
                    while(target.next) {
                        target = target.next;
                    }
                    target.next = node;
                } else {
                    this[HEAD] = node;
                }
            }
            find(key) {
                let target = this[HEAD];
                while(target) {
                    if(target.data[0] === key) {
                        return target.data[1];
                    }
                    target = target.next;
                }
            }
        }
    })();
    
    // 哈希函数
    const SIZE = 5; // 设置哈希表大小为：5（建议使用质数）
    function HASH(key) {
        let code = 0;
        [...key].forEach(str => {
            code += str.charCodeAt();
        });
        return code % SIZE;
    }
    
    // 哈希链表
    const SYM = Symbol();
    return class Hash {
        constructor() {
            this[SYM] = new Array(SIZE);
        }
        set(key, value) {
            const charCode = HASH(key);
            if (!this[SYM][charCode]) {
                this[SYM][charCode] = new LinkedList();
            }
            this[SYM][charCode].append([key, value]);
        }
        get(key) {
            const hashCode = HASH(key),
                  linkedList = this[SYM][hashCode]; // 取得对应链表
            if (!linkedList) return undefined;
            return linkedList.find(key); 			// 从链表中查找
        }
    }
})();
```

使用

```js
const hashTable = new Hash();

hashTable.set("", "abc");
hashTable.set("acb", "acb");
hashTable.set("bac", "bac");
hashTable.set("bca", "bca");
hashTable.set("cab", "cab");
hashTable.set("cba", "cba");

console.log(hashTable.get("")); 	// "abc"
console.log(hashTable.get("acb"));	// "acb"
console.log(hashTable.get("bac"));	// "bac"
console.log(hashTable.get("bca"));	// "bca"
console.log(hashTable.get("cab"));	// "cab"
console.log(hashTable.get("cba"));	// "cba"
console.log(hashTable.get("acs"));	// undefined

console.log(hashTable);
```

#### 哈希函数

以下是几个使用率比较高的哈希函数。

```js
// 1、DJB
function DJBHash(str) {
    var hash = 5381;
    var len = str.length, i = 0;
   	
    while (len--) {
        hash = (hash << 5) + hash + str.charCodeAt(i++);
    }
    hash &= ~(1 << 31);
    return hash;
}

// 2、JS
function JSHash(str) {
    var hash = 1315423911;
    for(var i = 0; i < str.length; i++) {
        hash ^= ((hash << 5) + str.charCodeAt(i) + (hash >> 2));
    }
    return hash;
}

// 3、PJW
function PJWHash(str) {
    var BitsInUnsignedInt = 4 * 8;
    var ThreeQuarters = (BitsInUnsignedInt * 3) / 4;
    var OneEighth = BitsInUnsignedInt / 8;
    var HighBits = (0xFFFFFFFF) << (BitsInUnsignedInt - OneEighth);
    var hash = 0;
    var test = 0;
    for(var i = 0; i < str.length; i++) {
        hash = (hash << OneEighth) + str.charCodeAt(i);
        if ((test = hash & HighBits) != 0) {
            hash = ((hash ^ (test >> ThreeQuarters)) & (~HighBits));
        }
    }
    return hash;
}
```

