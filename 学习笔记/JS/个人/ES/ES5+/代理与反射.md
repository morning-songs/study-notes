# 代理与反射

## 代理

​		`Proxy` 对象使您能够为另一个对象创建一个代理，该代理可以拦截和重新定义该对象的基本操作。



### 描述

​		`Proxy` 对象允许您创建一个可用于代替原始对象的对象，但它可能重新定义基本的对象操作，如获取、设置和定义属性。代理对象通常用于记录属性访问、验证、格式化或清除输入等。

​		你可以使用两个参数创建一个代理对象：

- `target`：要代理的原始对象
- `handler`：一个对象，它定义将拦截哪些操作以及如何重新定义被拦截的操作。

例如，这段代码定义了一个只有两个属性的简单目标对象 `target`，以及一个更简单的没有属性的处理程序对象 `handler`：

```js
const target = {
  	message1: "hello",
  	message2: "everyone"
};

const handler1 = {};

const proxy1 = new Proxy(target, handler1);
```

因为，处理程序对象 `handler` 是空的，这个代理对象的行为正如原始目标对象一样。

```js
console.log(proxy1.message1); // hello
console.log(proxy1.message2); // everyone
```

为了自定义代理，我们在 `handler` 对象上定义函数:

```js
const target = {
  	message1: "hello",
  	message2: "everyone"
};

const handler2 = {
  	get(target, prop, receiver) {
    	return "world";
  	}
};

const proxy2 = new Proxy(target, handler2);
```

这里我们提供了 `get()` 处理程序的实现，它拦截尝试访问目标中属性的行为。

​		处理程序函数有时称为陷阱（捕获器），大概是因为它们会捕获对目标对象的调用。上面 `handler2` 中非常简单的捕获器重新定义了所有的属性访问器：

```js
console.log(proxy2.message1); // world
console.log(proxy2.message2); // world
```

​		在 `Reflect` 类的帮助下，我们可以赋予一些访问器以原始的行为，并重新定义其他访问器的行为：

```js
// 选择性代理属性访问器
const target = {
  	message1: "hello",
  	message2: "everyone"
};

const handler3 = {
  	get(target, prop, receiver) {
    	if (prop === "message2") {
      		return "world";
    	}
    	return Reflect.get(...arguments);
  },
};

const proxy3 = new Proxy(target, handler3);

console.log(proxy3.message1); // hello
console.log(proxy3.message2); // world
```



#### 构造器

`Proxy` 构造器用于创建 `Proxy` 对象。

注意：`Proxy()` 只能用 `new` 构造。尝试不使用 `new` 调用它会抛出 `TypeError`。

参数：

- `target`：要用 `Proxy` 包装的目标对象。它可以是任何类型的对象，包括原生数组、函数，甚至是另一个代理。
- `handler`：一个对象，其属性是定义在对其执行操作时代理行为的函数。

​		空 `handler` 将创建一个空代理，其行为在几乎所有方面都与 `target` 完全相同。通过在处理程序对象上定义一组函数中的任何一个，您可以自定义代理行为的特定方面。例如，通过定义 `get()`，您可以提供目标属性访问器的自定义版本。

​		但是 `Proxy` 没有原型，因此其创建的实例也不具有 `[[Prototype]]` 特性。

```js
new Proxy({}, {}); // Proxy {}
/*
{
	[[Handler]]: Object {},
	[[Target]]: Object {},
	[[IsRevoked]]: false
}
*/
```



#### 静态方法

`Proxy` 上只有一个静态方法，`revocable` 方法。它创建一个可撤销的 `Proxy` 对象。

参数：

- `target`：目标对象
- `handler`：处理程序对象

返回值：一个具有以下两个属性的普通对象：

- `proxy`：一个与使用 `new Proxy(target, handler)` 创建的完全相同的 `Proxy` 对象。
- `revoke`：一个撤销（关闭）代理的无参函数。

​		`Proxy.revocable()` 工厂函数与 `Proxy()` 构造函数相同，不同的是，除了创建代理对象之外，它还创建一个可调用的撤销函数来关闭代理。代理对象和撤销函数被封装在一个普通对象中。

```js
Proxy.revocable({}, {});
/*
{
	proxy: Proxy {},
	revoke: f (),
	[[Prototype]]: Object
}
*/

new Proxy({}, {}); // Proxy {}
```

​		`revoke` 函数不接受任何参数，也不依赖于 `this` 值。创建的代理对象会作为私有属性被附加到 `revoke` 函数上，当调用该私有属性时，`revoke` 函数在自身上访问该私有属性（私有属性的存在无法从外部观察到，但它与垃圾收集的发生方式有关）。代理对象不会在`revoke` 函数的闭包中被捕获（如果 `revoke` 仍然存在，这将使代理的垃圾收集极其艰难）。

​		调用 `revoke()` 函数后，代理将变得不可用：捕捉任何一个处理程序都会抛出 `TypeError`，代理的 `[[IsRevoked]]` 特性将变为 `true`。代理一旦被撤销，它将保持撤销状态，再次调用 `revoke()` 将不起作用——实际上，调用 `revoke()` 会将代理对象从 `revoke` 函数中分离，因此 `revoke` 函数将完全不能再次访问代理。如果代理没有在其他地方被引用，那么它就会符合垃圾回收的条件。`revoke` 函数还会从代理中分离出目标对象和处理程序对象，因此，如果目标对象没有被引用到其他地方，它也有了被垃圾收集的资格，即使它的代理仍然存在，因为已不再有与目标对象进行有意义交互的方式了。

​		允许用户通过可撤销的代理与对象交互，允许您控制对用户公开的对象的生命周期——即使用户仍然持有对其代理的引用，您也可以使对象变得可回收。

```js
const revocable = Proxy.revocable({}, {
    get(target, name) {
        return `[[${name}]]`;
    }
});

const proxy = revocable.proxy;
proxy.foo; // '[[foo]]'

revocable.revoke();

proxy.foo; // TypeError: Cannot perform 'get' on a proxy that has been revoked
proxy.foo = 1; // TypeError: Cannot perform 'set' on a proxy that has been revoked
delete proxy.foo; // TypeError: Cannot perform 'deleteProperty' on a proxy that has been revoked
```



#### 处理程序函数

​		以下列出了可以定义的所有处理程序函数（`handler functions`）。处理程序函数有时称为陷阱 / 捕获器（`tarps`），因为它们捕获对底层目标对象的调用（捕获器就是监听器，并且可以拦截相关行为）。

- `handler.apply()`：调用函数的捕获器
- `handler.construct()`：`new` 操作符的捕获器
- `handler.defineProperty()`：`Object.defineProperty` 的捕获器
- `handler.deleteProperty()`：`delete` 操作符的捕获器
- `handler.get()`：获取属性值的捕获器
- `handler.getOwnPropertyDescriptor()`：`Object.getOwnPropertyDescriptor` 的捕获器
- `handler.getPrototypeOf()`：`Object.getPrototypeOf` 的捕获器
- `handler.has()`：`in` 操作符的捕获器
- `handler.isExtensible()`：`Object.isExtensible` 的捕获器
- `handler.ownKeys()`：`Object.getOwnPropertyNames` 和 `Object.getOwnPropertySymbols` 的捕获器
- `handler.preventExtensions()`：`Object.preventExtensions` 的捕获器
- `handler.set()`：设置属性值的捕获器
- `handler.setPrototypeOf()`：`Object.setPrototypeOf` 的捕获器



##### `apply`

`handler.apply()` 方法是函数调用的捕获器，用于监听对代理函数的调用行为。

参数：以下参数被传递给 `apply()` 方法，`this` 绑定到处理程序对象。

- `target`：可调用的目标对象
- `thisArg`：调用时的 `this` 参数
- `argumentsList`：调用时的参数列表

返回值：`apply()` 方法可以返回任何值。

拦截（监听）的操作：

- `proxy(...args)`
- `Function.prototype.apply()` 和 `Function.prototype.call()`
- `Reflect.apply()`

不变式：如果违反以下不变式，则代理会抛出 `TypeError`。

- 目标自身必须是可调用的对象。也就是说，它必须是一个函数对象。

```js
const proxy = new Proxy(function () {}, {
  	apply(target, thisArg, argumentsList) {
    	console.log(target);
    	console.log(thisArg);
        console.log(argumentsList);
  	}
});

// target是自动传参的，不需要手动传递；thisArg必须通过call或apply进行传递；直接传给proxy的参数将全部被argumentsList收录。
proxy(1, 2, 3);
/*
> f () {}
> undefined
> [1, 2, 3]
*/

// 传入this
proxy.call({a: 1}, 1, 2, 3);
/*
> f () {}
> {a: 1}
> [1, 2, 3]
*/
```



##### `construct`

​		`handler.construct()` 方法是 `new` 操作符的捕获器。为了使 `new` 操作在结果 `Proxy` 对象上有效，用于初始化代理的目标对象自身必须有一个 `[[Construct]]` 内部方法（即：`new target` 必须有效）。

参数：

- `target`：目标对象
- `argumentsList`：构造函数的参数列表
- `newTarget`：最初被 `new` 调用的构造函数，相当于 `new.target`。

返回值：`construct` 方法必须返回一个对象。

拦截的操作：

- `new proxy(...args)`
- `Reflect.construc()`

不变式：

- 目标必须是函数，结果必须是对象，否则抛出 `TypeError`。

```js
const proxy = new Proxy(function () {}, {
    construct(target, argumentsList, newTarget) {
        console.log(target);
        console.log(argumentsList);
        console.log(newTarget); // newTarget === proxy;
        return {a: 1};
    }
});

// target和newTarget都是自动传参的，传递给proxy的参数都会被argumentsList收录。
new proxy(1, 2, 3);
/*
> f () {}
> [1, 2, 3]
> Proxy {} // ==> 就是proxy本身。
> {a: 1}
*/
```



##### `defineProperty`

`handler.defineProperty()` 方法是 `Object.defineProperty()` 的捕获器，它不会主动在目标上添加或修改属性。

参数：

- `target`：目标对象
- `property`：要检索其描述符的属性的名称或符号。
- `descriptor`：被定义或修改的属性的描述符。

返回值：`defineProperty()` 方法必须返回一个布尔值，指示属性是否已被成功定义。

拦截的操作：

- `Object.prototype.__defineGetter__()`
- `Object.prototype.__defineSetter__()`
- `Object.defineProperty(proxy, prop, {})` 和 `Object.defineProperties(proxy, {})`【依次触发捕获器】
- `Reflect.defineProperty(proxy, ...)`

不变式：

- 如果目标对象不可扩展，则不能在代理上添加属性。
- 如果属性不作为目标对象的自有不可配置属性存在（即：属性在目标上可配置或不存在），则不能在代理上将其同名属性添加为或修改为不可配置。
- 如果目标对象存在相应的可配置属性，则该属性在代理上可能不是不可配置的（因为在传递过程中可能被改为不可配置）。
- 如果 `prop` 具有一个对应的目标对象属性，那么 `Object.defineProperty (target, prop, descriptor)` 将不会抛出异常。
- 在严格模式下，`defineProperty()` 处理程序返回 `false` 值将导致抛出 `TypeError` 异常。

```js
const proxy = new Proxy({
    foo: ''
}, {
    defineProperty(target, property, descriptor) {
        console.log(target);
        console.log(property);
        console.log(descriptor);
        return true;
    }
});

// 这个操作并不会将描述符添加到目标上。
Object.defineProperty(proxy, 'foo', {
    value: 'bar'
});
/*
> {foo: ''}
> 'foo'
> {value: 'bar'}
*/

// 并没有在捕获器内部，将描述符添加到目标上。只是拦截了该行为。
proxy; // Proxy {foo: ''}
/*
Proxy {
	[[Handler]]: Object {defineProperty: f defineProperty(target, property, descriptor)},
	[[Target]]: Object {foo: ''},
	[[IsRevoked]]: false
}
*/

// 添加不可配置的且不存在的属性，或者将可配置的属性改为不可配置，都将抛出TypeError。
Object.defineProperties(proxy, {
    foo: {
        configurable: false
    },
    baz: {
        configurable: false,
        value: 'qux'
    }
});

// TypeError: 'defineProperty' on proxy: trap returned truish for defining non-configurable property 'foo' which is either non-existent or configurable in the proxy target
```

​		当调用 `Object.defineProperty()` 或 `Reflect.defineProperty()` 时，传递给 `defineProperty()` 捕获器的描述符有一个限制——只有以下属性可用（非标准属性将被忽略）：

- 公共特性：`configurable` 和 `enumerable`
- 数据特性：`writable` 和 `value`
- 访问特性：`get` 和 `set`

```js
const proxy = new Proxy({}, {
  	defineProperty(target, prop, descriptor) {
    	return Reflect.defineProperty(target, prop, descriptor);
  	}
});

Object.defineProperty(proxy, 'name', {
  	value: 'proxy',
  	type: 'custom'
});

proxy; // Proxy {name: 'proxy'}
/*
{
	[[Handler]]: Object {defineProperty: f defineProperty(target, prop, descriptor)},
	[[Target]]: Object {
		name: 'proxy'
	},
	[[IsRevoked]]: false
}
*/
```



##### `deleteProperty`

`handler.deleteProperty()` 方法是一个针对 `delete` 操作符的捕获器。

参数：

- `target`：目标对象
- `property`：要删除的属性的名称或符号

返回值：`deleteProperty()` 方法必须返回一个布尔值，指示属性是否已成功删除。

拦截的操作：

- 删除属性：`delete proxy[property]` 和 `delete proxy.property`
- `Reflect.deleteProperty()`

不变式：

- 如果属性作为目标对象的不可配置的自有属性存在，则不能删除该属性。

```js
const proxy = new Proxy({}, {
    deleteProperty(target, property) {
        console.log(target);
        console.log(property);
        return true;
    }
});

proxy.a = 'aa';

// 自动传参
delete proxy.a;
/*
> {a: 'aa'}
> 'a'
> true
*/
```

```js
const proxy = new Proxy({}, {
    deleteProperty(target, property) {
        if(!(property in target)) {
            console.log(`property not found: ${property}`);
            return false;
        }
        delete target[property];
        console.log(`property removed: ${property}`);
        return true;
    }
});

proxy.a = 10;
'a' in proxy; // true

delete proxy.a; // 'property removed: a', true
'a' in proxy; // false

delete proxy.a; // 'propperty not found: a', false
```



##### `get`

`handler.get()` 方法是获取属性值的捕获器。

参数：

- `target`：目标对象
- `property`：要获取的属性的名称或符号
- `receiver`：代理或从代理继承的对象【接管该行为的接收器】

返回值：`get()` 方法可以返回任何值。

拦截的操作：

- 访问属性：`proxy.property` 和 `proxy[property]`
- 访问继承属性：`Object.create(proxy)[property]`【因为实例属性已被抛弃】
- `Reflect.get(proxy, property, receiver)`

不变式：

- 如果目标对象属性是不可写、不可配置的自有数据属性，则为该属性报告的值必须与相应的目标对象属性的值相同。
- 如果相应的目标对象属性是一个不可配置的自有访问器属性，其 `[[Get]]` 属性为 `undefined`，则报告的属性值必须为 `undefined`。

```js
const proxy = new Proxy({}, {
    get(target, property, receiver) {
        console.log(target);
        console.log(property);
        console.log(receiver);
        return 10;
    }
});

proxy.a;
/*
> {}
> 'a'
> Proxy {} // 默认为代理对象
> 10
*/
```



##### `getOwnPropertyDescriptor`

`handler.getOwnPropertyDescriptor()` 方法是 `Object.getOwnPropertyDescriptor()` 的一个捕获器。

参数：

- `target`：目标对象
- `property`：应该检索其描述符的属性的名称。

返回值：`getOwnPropertyDescriptor()` 方法必须返回一个对象或 `undefined`。

拦截的操作：

- `Object.getOwnPropertyDescriptor(proxy, property)` 和 `Object.getOwnPropertyDescriptors(proxy)`
- `Reflect.getOwnPropertyDescriptor(proxy, property)`

不变式：

- `getOwnPropertyDescriptor()` 必须返回一个对象或 `undefined`。
- 如果属性是目标对象的自有属性，且目标对象不可扩展，则不能将其报告为不存在。
- 如果属性不是目标对象的自有属性，且目标对象不可扩展，则不能将其报告为存在。
- 如果属性不是目标对象的自有属性或者是目标对象的可配置自有属性，则不能将其报告为不可配置。
- `Object.getownpropertydescriptor(target)` 的结果可以使用 `Object.defineproperty()` 应用到目标对象，且不会抛出异常。

```js
const proxy = new Proxy({a: 1}, {
    getOwnPropertyDescriptor(target, property) {
        console.log(target);
        console.log(property);
        return {value: 10, configurable: true}; // 未提及的均默认为false，因此configurable必须配置。
    }
});

Object.getOwnPropertyDescriptor(proxy, 'a');
/*
> {a: 1}
> 'a'
> {value: 10, writable: false, enumerable: false, configurable: true}
*/

proxy.a; // 1
```

```js
const proxy = new Proxy({a: 1}, {
    getOwnPropertyDescriptor(target, property) {
        return {value: 10}; // 未配置configurable，将导致TypeError
    }
});

Object.getOwnPropertyDescriptor(proxy, 'a'); 
// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property 'a' which is either non-existent or configurable in the proxy target
```



##### `getPrototypeOf`

`handler.getPrototypeOf()` 方法是 `[[GetPrototypeOf]]` 内部方法的捕获器。

注意：

- 代理对象只有 `[[Handler]]`、`[[Target]]` 和 `[[IsRevoked]]` 三个特性，没有 `[[Prototype]]` 特性。
- 因此，所有对代理原型的操作都会被传达到目标原型上，例如：`getPrototypeOf` 和 `setPrototypeOf`。

参数：

- `target`：目标对象

返回值：`getPrototypeOf()` 方法必须返回一个对象或 `null`

拦截的操作：

- `Object.getPrototypeOf(proxy)`
- `Reflect.getPrototypeOf(proxy)`
- `proxy.__proto__`
- `Object.prototype.getPrototypeOf()`
- `instanceof`

不变式：

- `getPrototypeOf()` 方法必须返回一个对象或 `null`。
- 如果 `target` 是不可扩展的，`Object.getPrototypeOf(proxy)` 方法必须返回与 `Object.getPrototypeOf(target)` 相同的值。

```js
const obj = {},
      proto = {},
      handler = {
          getPrototypeOf(target) {
              console.log(target === obj); // true
              console.log(this === handler); // true
              return proto;
          }
      };

const proxy = new Proxy(obj, handler);

// 获取的是目标对象的[[Prototype]]特性
Object.getPrototypeOf(proxy) === proto; // true × 3
```

```js
// 触发捕获器的五种方式：
const obj = {};
const p = new Proxy(obj, {
  	getPrototypeOf(target) {
    	return Array.prototype;
  	},
});

console.log(
  	Object.getPrototypeOf(p) === Array.prototype,  // true
  	Reflect.getPrototypeOf(p) === Array.prototype, // true
  	p.__proto__ === Array.prototype,               // true
  	Array.prototype.isPrototypeOf(p),              // true
  	p instanceof Array,                            // true
);
```



##### `has`

`handler.has()` 方法是 `in` 操作符的捕获器。

参数：

- `target`：目标对象
- `property`：要检查是否存在的属性的名称或符号

返回值：`has()` 方法必须返回布尔值。

拦截的操作：

- 属性查询：`property in proxy`
- 查询继承的属性：`property in Object.create(proxy)`
- `with` 检查：`with(proxy) {(property);}`
- `Reflect.has(proxy, property)`

不变式：

- 如果属性作为目标对象的不可配置的自有属性存在，则不能被报告为不存在（即：`false` 值）。
- 如果属性作为目标对象的一个自有属性存在，且目标对象不可扩展，则不能将其报告为不存在（即：`false` 值）。

```js
const proxy = new Proxy({}, {
    has(target, property) {
        console.log(target);
        console.log(property);
        return true;
    }
});

'a' in proxy;
/*
> {}
> 'a'
> true
*/
```

```js
const obj = { a: 10 };

Object.preventExtensions(obj);

const p = new Proxy(obj, {
  	has(target, prop) {
    	return false;
  	}
});

'a' in p; 
// TypeError: 'has' on proxy: trap returned falsish for property 'a' but the proxy target is not extensible
```



##### `isExtensible`

`handler.isExtensible()`方法是 `Object.isExtensible()` 的捕获器。

参数：

- `target`：目标对象

返回值：`isExtensible()` 方法必须返回一个布尔值。

拦截的操作：

- `Object.isExtensible(proxy)`
- `Reflect.isExtensible(proxy)`

不变式：

- `Object.isExtensible(proxy)` 必须返回与 `Object.isExtensible(target)` 相同的值。

```js
const proxy = new Proxy({}, {
    isExtensible(target) {
        console.log(target);
        return true;
    }
});

Object.isExtensible(proxy);
/*
> {}
> true
*/
```

```js
const proxy = new Proxy({}, {
  	isExtensible(target) {
    	return false;
  	}
});

Object.isExtensible(proxy); // TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')
```



##### `ownKeys`

`handler.ownKeys()` 方法是 `Reflect.ownKeys()` 的一个捕获器。

参数：

- `target`：目标对象

返回值：`ownKeys()` 方法必须返回一个可枚举对象。

拦截的操作：

- `Object.keys(proxy)`
- `Object.getOwnPropertyNames(proxy)`
- `Object.getOwnPropertySymbols(proxy)`
- `Reflect.ownKeys(proxy)`

不变式：

- `ownKeys()` 的结果必须是一个数组。
- 每个数组元素的类型要么是字符串，要么是符号。
- 结果列表必须包含目标对象所有不可配置的属性键。
- 如果目标对象不可扩展，则结果列表必须包含目标对象所有的自有属性键，而不包含其他值。

```js
const proxy = new Proxy({}, {
    ownKeys(target) {
        console.log(target);
        return ['a', 'b', 'c']; // 只能包含字符串及符号，其余值均报错。
    }
});

// keys方法能触发捕获器，但不会采取其返回值。
Object.keys(proxy);
/*
> {}
> []
*/

Object.getOwnPropertyNames(proxy);
/*
> {}
> ['a', 'b', 'c']
*/

Reflect.ownKeys(proxy);
/*
> {}
> ['a', 'b', 'c']
*/
```



##### `preventExtensions`

`handler.preventExtensions()` 方法是 `Object.preventExtensions()` 的捕获器。

参数：

- `target`：目标对象

返回值：`preventExtensions()` 方法必须返回一个布尔值（注意：这并不代表着执行的结果，因为它最终返回参数对象）。

拦截的操作：

- `Object.preventExtensions()`
- `Object.seal()`
- `Object.freeze()`
- `Reflect.preventExtensions()`

不变式：

- `Object.preventExtensions(proxy)` 只在 `Object.isExtensible(proxy)` 为 `false` （即：对象不可扩展）时返回 `true`。

```js
const proxy = new Proxy({}, {
    preventExtensions(target) {
        console.log(target);
        // 以下两句是同时存在且通常必须的。
        Object.preventExtensions(target); // 阻止目标扩展。
        return true;
    }
});

// 该方法本身返回传入的对象，而不是一个布尔值。
Object.preventExtensions(proxy);
/*
> {}
> Proxy {}
*/
```

```js
const p = new Proxy({}, {
  	preventExtensions(target) {
    	return true;
  	}
});

Object.preventExtensions(p); 
// TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible
```



##### `set`

`handler.set()` 方法是设置属性值的捕获器。

参数：

- `target`：目标对象
- `property`：要设置的属性的名称或符号
- `value`：要设置的属性的新值
- `receiver`：赋值最初指向的对象，通常是代理本身。但是 `set()` 处理程序也可以通过原型链或各种其他的方式间接调用。

​		例如，假设有一个脚本执行 `obj.name = "jen"`，且 `obj` 不是一个代理，也没有自己的 `name` 属性，但它的原型链上有一个代理。该代理的 `set()` 处理程序将被调用，然后 `obj` 将被当作接收器（`receiver` 其实就是 `this` 的指向者）。

返回值：`set()` 方法应该返回一个布尔值。

- 返回 `true` 表示赋值成功
- 如果返回 `false`，且赋值发生在严格模式下，将会抛出 `TypeError`

```js
const proxy = new Proxy({
    name: 'target'
}, {
    set(target, property, value, receiver) {
        console.log(target);
        console.log(property);
        console.log(value);
        console.log(receiver);
        return true;
    }
});

proxy.a = 1;
/*
> {name: 'target'}
> 'a'
> 1
> Proxy {name: 'target'}
> 1
*/

const obj = Object.create(proxy);

// 该语句的执行结果是传入的新值，并非布尔值。
obj.a = 1;
/*
> {name: 'target'}
> 'a'
> 1
> {[[Prototype]]: Proxy {name: 'target'}}
> 1
*/
```

拦截的操作：

- 属性的赋值：`proxy.property = value` 和 `proxy[property] = value`
- 继承属性的赋值：`Object.create(proxy)[property] = value`
- `Reflect.set()`

不变式：

- 如果相应的目标对象属性是不可写的、不可配置的数据属性，则不能将属性的值更改为与相应的目标属性不同的值。
- 如果相应的目标对象属性是不可配置的访问器属性，且其 `[[set]]` 属性未定义，则不能设置属性的值。
- 在严格模式下，来自 `set()` 处理程序的 `false` 返回值将抛出 `TypeError` 异常。

```js
const proxy = new Proxy({}, {
    set(target, property, value, receiver) {
        target[property] = value;
        console.log(`property set: ${property} = ${value}`);
        return true;
    }
});

proxy.a = 10;
/*
> 'property set: a = 10'
> 10
*/
```



##### `setPrototypeOf`

`handler.setPrototypeOf()` 方法是 `Object.setPrototypeOf()` 的捕获器。

参数：

- `target`：目标对象
- `prototype`：对象的新原型（对象或 `null`）

返回值：如果 `[[Prototype]]` 被成功更改，`setPrototypeOf()` 方法返回 `true`，否则返回 `false`。

拦截的操作：

- `Object.setPrototypeOf()`
- `Reflect.setPrototypeOf()`

不变式：

- 如果 `target` 不可扩展，则 `prototype` 参数必须与 `Object.getPrototypeOf(target)` 相同。

```js
const proxy = new Proxy({
    name: 'target'
}, {
    setPrototypeOf(target, prototype) {
        console.log(target);
        console.log(prototype);
        return true;
    }
});

// 设置的是目标对象的[[Prototype]]特性。
Object.setPrototypeOf(proxy, {
    name: 'proto'
});
/*
> {name: 'target'}
> {name: 'proto'}
> Proxy {name: 'target'}
*/

// 获取的是目标对象的[[Ptototype]]特性。
Object.getPrototypeOf(proxy) === Object.prototype; // true
```

如果你想禁止为你的对象设置一个新的原型，你的处理程序中的 `setPrototypeOf()` 方法可以返回 `false`，或者抛出异常。

```js
// 返回false：
// 这种方法意味着在突变失败时抛出异常的任何突变操作都必须自己创建异常。
// 例如，Object.setPrototypeOf()本身将创建并抛出TypeError。如果突变是由一个通常不会在失败时抛出异常的操作执行的，例如Reflect.setPrototypeOf()，则不会抛出异常。

const handler = {
    setPrototypeOf(target, prototype) {
        // 任何在突变失败时会抛出异常的操作，都应该在此创建自己的突变异常。
        return false;
    }
};

const proxy = new Proxy({}, handler);

Object.setPrototypeOf(proxy, {});
// TypeError: 'setPrototypeOf' on proxy: trap returned falsish for property 'undefined'

Reflect.setPrototypeOf(proxy, {});
// false

Object.getPrototypeOf(proxy);
// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}

Object.prototype === Object.getPrototypeOf(proxy); // true
```

```js
// 另一种方法是将任何试图突变的操作都抛出异常。
// 如果您希望在失败时即使是非异常操作也要抛出异常，或者希望抛出自定义的异常，那么这种方法是最好的。
const handler = {
    setPrototypeOf(target, prototype) {
        throw new Error('custom error');
    }
};

const proxy = new Proxy({
    name: 'target'
}, handler);

Object.setPrototypeOf(proxy, {}); // Error: custom error

Reflect.setPrototypeOf(proxy, {}); // Error: custom error
```



#### 未有属性的默认值

在这个简单的示例中，为对象中所有不存在的属性设置默认值。它使用 `get()` 处理程序。

```js
const handler = {
    get(obj, prop) {
        return prop in obj ? obj[prop] : 37;
    }
}

const proxy = new Proxy({}, handler);

proxy.a = 1;
proxy.b = undefined;

proxy.a; // 1
proxy.b; // undefined

proxy.c; // 37
```



#### 无操作转发代理

​		无操作转发代理（`No-op forwarding proxy`），就是创建一个可以无障碍所有传递原始行为的空代理。

​		在本例中，我们使用的是一个原生 `JavaScript` 对象，把应用于代理的所有操作不经任何处理地转发给目标。

```js
const target = {};

const proxy = new Proxy(target, {});

proxy.a = 37;
// 将操作转发到目标

target.a; // 37
// 操作已被正确地转发
```

​		注意，虽然这种 “无操作”（`no-op`）适用于普通 `JavaScript` 对象，但不适用于原生对象，如 `DOM` 元素、`Map` 对象或任何具有内部插槽的对象。有关更多信息，见下文 `No private property forwarding`。



#### 无私有属性转发

无私有属性转发（`No private property forward`）的关键问题在于：代理无法访问目标的私有属性。

代理仍然是另一个具有不同身份的对象——它是一个在包装对象和外部之间操作的代理。因此，代理不能直接访问原始对象的私有属性。

```js
class Secret {
    #secret;
    constructor(secret) {
        this.#secret = secret;
    }
    get secret() {
        return this.#secret.replace(/\d+/, "[REDACTED]");
    }
}

const secret = new Secret('0731');
secret.secret; // "[REDACTED]"

const proxy = new Proxy(secret, {}); // 看起来像是一个无操作转发代理
proxy; // Proxy {#secret: '0731'}
/*
Proxy { 
	[[Handler]]: Object {},
	[[Target]]: Secret {
		#secret: '0731',
		secret: '[REDACTED]'
	},
	[[IsRevoked]]: false
}
*/

// 但实际上，它会被（默认的）get捕获器拦截。
proxy.secret; // TypeError: Cannot read private member #secret from an object whose class did not declare it
```

​		这是因为当代理的 `get` 捕获器被调用时，`this` 值是代理而不是原始的 `secret`，因此不可访问 `#secret` 。为了解决这个问题，可使用原始的 `secret` 作为 `this`：

```js
const proxy = new Proxy(secret, {
    get(target, property, receiver) {
        // 默认情况下，它看起来像是具有一个不同的this值的Reflect.get(target, property, receiver)
        return target[property]; // 直接访问目标对象上的指定私有属性。
    }
});

proxy.secret; // "[REDACTED]"
```

​		对于方法，这意味着你必须要将方法的 `this` 值重定向到原始对象：

```js
class Secret {
    #x = 1;
    x() { return this.#x; }
}

const secret = new Secret();

const proxy = new Proxy(secret, {
    get(target, property, receiver) {
        const value = target[property];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
    }
});

proxy.x(); // 1
```

​		一些原生 `JavaScript` 对象具有被称为 **“内部插槽”** 的属性，这些属性不能从 `JavaScript` 代码中访问。例如，`Map` 对象有一个名为`[[MapData]]` 的内部插槽，用于存储映射的键值对。因此，你不能简单地为映射创建转发代理：

```js
const proxy = new Proxy(new Map(), {});

proxy.size; // TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>
```

​		此时，您必须使用上面演示的 “`this-recovering`” 代理来解决这个问题。

```js
// 以Map为例，其余内置对象亦如此：
const proxy = new Proxy(new Map(), {
    get(target, prop, receiver) {
        const value = target[prop];
        if(value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            }
        } else {
            return value;
        }
    }
});

proxy.size; 				// 0
proxy.set('foo', 'bar'); 	// Map(1) {'foo' => 'bar'}
proxy.get('foo'); 			// 'bar'
```



#### 数据验证

使用代理，您可以很容易地验证传递给对象的值。这个例子使用了 `set()` 处理程序。

```js
const validator = {
  	set(obj, prop, value) {
        // 要求：age属性必须是不大于200的整数。
    	if (prop === 'age') {
      		if (!Number.isInteger(value)) {
        		throw new TypeError('The age is not an integer');
      		}
      		if (value > 200) {
        		throw new RangeError('The age seems invalid');
      		}
    	}

    	// 将合格的值存入目标对象obj中
    	obj[prop] = value;

    	// Indicate success（提示操作成功）
    	return true;
  	}
};

const person = new Proxy({}, validator);

person.age = 100; 	// true
person.age; 		// 100
person.age = 'young';    // Throws an exception
person.age = 300;        // Throws an exception
```



#### 扩展构造函数

函数代理可以很容易地使用一个新的构造函数去扩展一个既有的构造函数。这个例子使用 `construct()` 和 `apply()` 处理程序。

```js
// 定义一个实现继承的函数：使得base继承自sup。
function extend(sup, base) {
  	base.prototype = Object.create(sup.prototype); // 使base继承自sup：base的原型是sup的一个实例。
    
    // 重写base的constructor，使其成为一个直接对自身类base进行代理的函数代理。
  	base.prototype.constructor = new Proxy(base, {
        // 监听base类的构造和调用操作。
    	construct(target, args) {
      		const obj = Object.create(base.prototype); // 创建一个base的实例，但舍弃实例属性。
      		this.apply(target, obj, args); // this指向处理程序对象，即：调用本对象中的apply方法。
      		return obj;
    	},
    	apply(target, that, args) {
            // 调用sup和base类，并修改this为刚创建的base实例。
      		sup.apply(that, args); 	// 盗用父类构造函数，让父类构造器给子类实例添加实例属性。
      		base.apply(that, args); // 给自身实例添加实例属性。
    	}
  	});
    
    // 返回base的构造器，它已经是一个类代理了。
  	return base.prototype.constructor;
}

const Person = function (name) {
  	this.name = name;
};

// 使Boy扩展Person，并得到一个对自身构造器进行代理的构造函数代理。
const Boy = extend(Person, function (name, age) {
  	this.age = age;
});

Boy.prototype.gender = 'M';

const peter = new Boy('Peter', 13); // Person {name: 'Peter', age: 13}
/*
Person {
	age: 13,
	name: 'Peter',
	[[Prototype]]: Person {
		constructor: Proxy {
			[[Handler]]: Object {apply: f apply(), construct: f construct()},
			[[Target]]: f (name, age),
			[[IsRevoked]]: false
		},
		gender: 'M',
		[[Prototype]]: Object {constructor: f (name)}
	}
}
*/

peter.gender;  // "M"
peter.name;    // "Peter"
peter.age;     // 13
```



#### 操作 `DOM` 节点

​		在本例中，我们使用 `Proxy` 来切换两个不同元素的属性：因此，当我们在一个元素上设置属性时，另一个元素的该属性会复位。

​		我们创建一个 `view` 对象，它是一个具有 `selected` 属性的对象的代理。这个代理的处理程序对象中定义了 `set()` 处理程序。

​		当我们将一个 `HTML` 元素赋值给 `view.selected` 时，此元素的 `"aria-selected"` 属性被设置为 `true`。如果我们将另一个不同的元素赋值给 `view.selected` ，此元素的 `"aria-selected"` 属性被设置为 `true`，并且前一个元素的 `"aria-selected"` 属性被自动设置为 `false`。

```js
const view = new Proxy({
  	selected: null,
},
{
  	set(obj, prop, newval) {
    	const oldval = obj[prop]; // oldVal：旧元素（初始值为null），newVal：新元素

        // 拦截（监听）selected属性
    	if (prop === 'selected') {
      		if (oldval) {
        		oldval.setAttribute('aria-selected', 'false'); // 设置旧元素属性的状态
      		}
      		if (newval) {
        		newval.setAttribute('aria-selected', 'true');  // 设置新元素属性的状态
      		}
    	}

    	// 将属性设为新元素
    	obj[prop] = newval;

    	// 指示操作成功的状态
    	return true;
  	}
});

const item1 = document.getElementById('item-1');
const item2 = document.getElementById('item-2');

// 选中item1
view.selected = item1;

console.log(`item1: ${item1.getAttribute('aria-selected')}`); // item1: true

// 选中item2会取消选中item1
view.selected = item2;

console.log(`item1: ${item1.getAttribute('aria-selected')}`); // item1: false

console.log(`item2: ${item2.getAttribute('aria-selected')}`); // item2: true
```



#### 值修正及附加属性

​		`products` 代理对象计算传递的值，并在需要时将其转换为数组。该对象还支持一个名为 `latestBrowser` 的额外属性，它可以同时作为 `getter` 和 `setter`。

```js
const products = new Proxy({
  	browsers: ['Internet Explorer', 'Netscape']
},
{
    // 将数组中的最后一个槽位作为附加属性，并可以进行读写。
  	get(obj, prop) {
    	// 附加一个属性
    	if (prop === 'latestBrowser') {
      		return obj.browsers[obj.browsers.length - 1];
    	}

    	// 默认行为：返回该值
    	return obj[prop];
  	},
  	set(obj, prop, value) {
    	// 附加属性
    	if (prop === 'latestBrowser') {
      		obj.browsers.push(value);
      		return true;
    	}

    	// 如果传递的是一个字符串而不是数组，则转为数组。
    	if (typeof value === 'string') {
      		value = [value];
    	}

    	// 默认行为：存储该值
    	obj[prop] = value;

    	// 指示操作成功
    	return true;
  	}
});

console.log(products.browsers); // ['Internet Explorer', 'Netscape']

products.browsers = 'Firefox'; // 传递一个字符串（不小心地）

console.log(products.browsers); // ['Firefox'] <- 没问题，值依然是一个数组

products.latestBrowser = 'Chrome';

console.log(products.browsers); // ['Firefox', 'Chrome']

console.log(products.latestBrowser); // 'Chrome'
```



#### 通过属性查找数组中的特定对象

​		该代理为数组扩展一些实用特性。如您所见，您可以灵活地 “定义” 属性，而无需使用 `Object.defineProperties()`。此示例适用于根据单元格查找表格中的一行。在这种情况下，目标对象将会是 `table.rows`。

```js
const products = new Proxy([
  	{ name: 'Firefox', type: 'browser' },
  	{ name: 'SeaMonkey', type: 'browser' },
  	{ name: 'Thunderbird', type: 'mailer' }
],
{
  	get(obj, prop) {
    	// 如果属性存在，则返回其值。
    	if (prop in obj) {
      		return obj[prop];
    	}

    	// 获取number属性，它是length属性的别名。
    	if (prop === 'number') {
      		return obj.length;
    	}

    	let result;
    	const types = {}; // 以元素的type为键，其值是一个包含类型同为type的元素数组。

        // 遍历目标数组
    	for (const product of obj) {
      		if (product.name === prop) {
        		result = product; // 如果指定元素已存在，则将该元素赋给result。
      		}
      		if (types[product.type]) {
        		types[product.type].push(product); // 如果types中存在指定的类型，则将该元素存入对应的类型中。
      		} else {
        		types[product.type] = [product]; // 如果指定类型不存在，则定义新类型组，将元素放入新类型数组中。
      		}
    	}

    	// 通过name获取一个元素
    	if (result) {
      		return result;
    	}

    	// 通过type获取多个元素
    	if (prop in types) {
      		return types[prop];
    	}

    	// 获取元素的types
    	if (prop === 'types') {
      		return Object.keys(types);
    	}

    	return undefined;
  	}
});

// 获取第一个元素
products[0];          // { name: 'Firefox', type: 'browser' }
// 根据name获取特定元素
products['Firefox'];  // { name: 'Firefox', type: 'browser' }
// 提供的name不存在
products['Chrome'];   // undefined
// 根据类型获取多个元素
products.browser;     // [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]
// 获取元素的总类型
products.types;       // ['browser', 'mailer']
// 获取目标数组的长度
products.number;      // 3
```



#### 一个完整的捕获器列表示例

​		现在，为了创建一个完整的捕获器列表示例，出于教学目的，我们将尝试代理一个特别适合这种类型操作的非原生对象：通过一个简单的 `cookie` 框架创建这个 `docCookies` 全局对象。

```js
/*
  	const docCookies = ... get the "docCookies" object here:
  	https://reference.codeproject.com/dom/document/cookie/simple_document.cookie_framework
*/

const docCookies = {
  	getItem: function (sKey) {
    	if (!sKey) { return null; }
    	return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + 
             encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + 
             "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
  	},
    
  	setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    	if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
    	var sExpires = "";
    	if (vEnd) {
      		switch (vEnd.constructor) {
        		case Number:
          			sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" 
                    : "; max-age=" + vEnd;
          			break;
        		case String:
          			sExpires = "; expires=" + vEnd;
         			 break;
        		case Date:
          			sExpires = "; expires=" + vEnd.toUTCString();
          			break;
      		}
    	}
    	document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires +
            (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") +
            (bSecure ? "; secure" : "");
    	return true;
  	},
    
  	removeItem: function (sKey, sPath, sDomain) {
    	if (!this.hasItem(sKey)) { return false; }
    	document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" +
            (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
    	return true;
  	},
    
  	hasItem: function (sKey) {
    	if (!sKey) { return false; }
    	return (new RegExp("(?:^|;\\s*)" + 
        	encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  	},
    
  	keys: function () {
    	var aKeys = document.cookie
        .replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "")
        .split(/\s*(?:\=[^;]*)?;\s*/);
    	for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
        	aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); 
        }
    	return aKeys;
  	}
};

const docCookiesProxy = new Proxy(docCookies, {
  	get(target, key) {
        // 获取并返回指定值
    	return target[key] || target.getItem(key) || undefined;
  	},
  	set(target, key, value) {
        // 如果属性已存在则不可再写入，如果不存在则写入数据。
    	if (key in target) { return false; }
    	return target.setItem(key, value);
  	},
  	deleteProperty(target, key) {
        // 如果不存在则返回false，存在则删除它。
    	if (!(key in target)) { return false; }
    	return target.removeItem(key);
  	},
  	ownKeys(target) {
        // 返回自有键数组。
    	return target.keys();
  	},
  	has(target, key) {
        // 属性是否存在
    	return key in target || target.hasItem(key);
  	},
  	defineProperty(target, key, descriptor) {
        // 如果提供了数据描述符，则在目标中存入该值。否则，直接返回目标。
    	if (descriptor && 'value' in descriptor) {
      		target.setItem(key, descriptor.value);
    	}
    	return target;
  	},
  	getOwnPropertyDescriptor(target, key) {
        // 如果指定属性的值存在，则返回其描述符对象。否则，返回undefined。
    	const value = target.getItem(key);
    	return value ? {
      		value,
      		writable: true,
      		enumerable: true,
      		configurable: false,
    	} : undefined;
  	},
});

/* Cookies test */ // 存在未知BUG

console.log(docCookiesProxy.myCookie1 = 'First value');
console.log(docCookiesProxy.getItem('myCookie1'));

docCookiesProxy.setItem('myCookie1', 'Changed value');
console.log(docCookiesProxy.myCookie1);
```

<hr>

### 代理基础

​		`ECMAScript 6` 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。

​		在 `ES6` 之前，`ECMAScript` 中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的 `ECMAScript` 代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。

​		代理是对目标对象的抽象。从很多方面看，代理类似 `C++` 指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。

​		`ECMAScript` 代理与 `C++` 指针有重大区别（见下文）。不过作为一种有助于理解的类比，指针在概念上还是比较合适的结构。



#### 创建代理

​		默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过

同样的方式来使用与之关联的代理对象。

​		代理是使用 `Proxy` 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 `TypeError`。



##### 空代理

​		最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做（没有任何额外的行为和操作）。

​		要创建空代理，可以传一个简单的空对象字面量作为处理程序对象，从而让所有操作畅通无阻地 **“直达”** 目标对象。

​		在代理对象上执行的任何操作实际上都会应用到目标对象上。唯一可感知的不同就是代码中操作的是代理对象。

```js
// 目标对象
const target = {
    id: 'target'
}

// 处理程序对象
const handler = {};

// 代理对象
const proxy = new Proxy(target, handler);

proxy; // Proxy {id: 'target'}【折叠显示】
/* 展开显示：
Proxy {
	[[Handler]]: Object {},
	[[Target]]: Object { id: 'target' },
	[[IsRevoked]]: false
}
*/

------------------------------------------------------------------------------------------------------------

// 执行一些操作：

// id属性访问的是同一个值
target.id === proxy.id; // true

// 访问的是同一个值
target.id = 'foo';
target.id === proxy.id; // true

// 对代理的操作同步转移到目标上
proxy.id = 'bar';
target.id === proxy.id; // true

// hasOwnProperty()方法在两个地方都会应用到目标对象
target.hasOwnProperty('id'); // true
proxy.hasOwnProperty('id'); // true

// Proxy.prototype是undefined，因此不能使用instanceof操作符
target instanceof Proxy; 
// TypeError: Function has non-object prototype 'undefined' in instanceof check at [Symbol.hasInstance]
proxy instanceof Proxy; 
// TypeError: Function has non-object prototype 'undefined' in instanceof check at [Symbol.hasInstance]

// 尽管代理与目标表现得像是同一个引用值，但它们是相互独立的不同个体。
target === proxy; // fasle
```



#### 撤销代理

​		有时候可能需要中断代理对象与目标对象之间的联系。对于使用 `new Proxy()` 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。

​		`Proxy` 也暴露 `revocable()` 静态方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是**不可逆**的。而且，撤销函数（`revoke()`）是**幂等**的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 `TypeError`。

​		另外，撤销函数（`revoke`）和代理对象（`proxy`）是在实例化时同时生成的：

```js
const target = {
    foo: 'bar'
};

const handler = {
    get() {
        return 'intercepted';
    }
};

// 获取包含撤销函数的对象
const result = Proxy.revocable(target, handler);
result; // {proxy: Proxy, revoke: f}
/*
{
	proxy: Proxy {foo: 'bar'}, // 就是new Proxy创建的实例
	revoke: f() // 撤销函数
}
*/

const {proxy, revoke} = result;

proxy.foo; 	// 'intercepted'
target.foo; // 'bar'

// 撤销代理：中断对目标的代理
revoke();
proxy; // Proxy {}
/*
{
	[[Handler]]: null, 	// 清除引用
	[[Target]]: null,	// 清除引用
	[[IsRevoked]]: true	// 修改状态
}
*/

proxy.foo; // TypeError: Cannot perform 'get' on a proxy that has been revoked
```

<hr>

### 捕获器

​		使用代理的主要目的就是拦截并修改直达目标对象的行为，而这可以通过捕获器（`trap`）来实现。如前所述：在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。

​		捕获器就是**定义在处理程序对象中的 “基本操作的拦截器”**。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用，且只能在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。

注释：捕获器（`trap`）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。

​		例如，可以定义一个 `get()` 捕获器，在 `ECMAScript` 操作以某种形式调用 `get()` 时触发。

```js
const target = {
    foo: 'foo'
};

const handler = {
    // 设置一个get()捕获器，当执行getter时，会被它捕获拦截。
    get() {
        return 'handler override';
    }
};

const proxy = new Proxy(target, handler);
```

​		这样，当通过代理对象执行 `get()` 操作（即：访问代理对象上的属性）时，就会触发定义的 `get()` 捕获器。当然，`get()` 不是 `ECMAScript` 对象可以调用的方法。这个操作在 `JavaScript` 代码中可以通过多种形式触发并被 `get()` 捕获器（捕捉）拦截到。如：`proxy[property]`、`proxy.property` 或 `Object.create(proxy)[property]` 等操作都会触发基本的 `get()` 操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 `get()` 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。

```js
const target = {
    foo: 'bar'
};

const handler = {
    // 捕获器在处理程序的对象中，以方法名为键
    get() {
        return 'handler override';
    }
};

const proxy = new Proxy(target, handler);
proxy; // {foo: 'bar'}
/*
{
	[[Handler]]: Object {
		get: f get()
	},
	[[Target]]: Object {
		foo: 'bar'
	},
	[[IsRevoked]]: false
}
*/

targer.foo; // 'bar'
proxy.foo; 	// 'handler override'
```

```js
// 若是给get一个具体的名称，则它只能拦截指定的属性访问？
const target = {
    foo: 'foo',
    bar: 'bar'
};

const handler = {
    get foo() {
        return 'handler override';
    }
}

const proxy = new Proxy(target, handler);
proxy; // {foo: 'foo', bar: 'bar'}
/*
{
	[[Handler]]: Object {
		foo: 'handler ovrride',
		get foo: f foo()
	},
	[[Target]]: Object {
		bar: 'bar',
		foo: 'foo'
	},
	[[IsRevoked]]: false
}
*/

// 反而使得foo恢复正常了
proxy.foo; 	// 'foo'
target.foo; // 'foo'

proxy.bar; 	// 'bar'
target.bar; // 'bar'
```



#### 参数与反射

##### 参数

​		所有捕获器都可以访问（自动接收）相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，`get()` 捕获器会自动接收到目标对象、要查询的属性和代理对象这三个参数。

```js
const target = {
    foo: 'bar'
};

const handler = {
    get(trapTarget, property, receiver) {
        console.log(trapTarget === target);
        console.log(property);
        console.log(receiver === proxy);
    }
};

const proxy = new Proxy(target, handler);

proxy.foo; // true, 'foo', true
```

​		有了这些参数，就可以重建被捕方法的原始行为：

```js
const target = {
    foo: 'bar'
};

const handler = {
    get(trapTarget, property, receiver) {
        return trapTarget[property] + 1;
    }
}

const proxy = new Proxy(target, handler);

proxy.foo; 	// 'bar1'
target.foo; // 'bar'
```



##### 反射

​		**反射就是为了在捕获器中重建行为时，仍然可以引用原始的行为，这就是反射的含义。即：在重建中反射（或表现）出原来的行为。**

​		所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 `get()` 那么简单。因此，通过手写代码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 `Reflect` 对象上（**封装了原始行为**）的同名方法来轻松重建（这就意味着反射的重建是指在原始行为的基础上进行重建，而不是完全脱离原始行为的重建）。

​		处理程序对象中所有可以捕获的方法（所有捕获器）都有对应的反射（`Reflect`）`API` 方法。**这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为**。因此，使用反射 `API` 也可以像下面这样定义出空代理对象：

```js
const target = {
    foo: 'bar'
};

const handler = {
    get() {
        return Reflect.get(...arguments); // 反射方法与捕获器方法具有相同的名称和函数签名，而且其行为与原始行为相同。
    }
}

const proxy = new Proxy(target, handler);

proxy.foo; 	// bar
target.foo; // bar
```

甚至还可以写得更简洁些：

```js
const target = {
    foo: 'bar'
};

const handler = {
    get: Reflect.get
};

const proxy = new Proxy(target, handler);

proxy.foo; 	// 'bar'
target.foo; // 'bar'
```

事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 `API` 的空代理，那么甚至不需要定义处理程序对象：

```js
const target = {
    foo: 'bar'
};

const proxy = new Proxy(target, Reflect);

proxy; // {foo: 'bar'}
/*
{
	[[Handler]]: Reflect {
		apply: ƒ apply(),
		construct: ƒ construct(),
		defineProperty: ƒ defineProperty(),
		deleteProperty: ƒ deleteProperty(),
		get: ƒ (),
		getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor(),
		getPrototypeOf: ƒ getPrototypeOf(),
		has: ƒ has(),
		isExtensible: ƒ isExtensible(),
		ownKeys: ƒ ownKeys(),
		preventExtensions: ƒ preventExtensions(),
		set: ƒ (),
		setPrototypeOf: ƒ setPrototypeOf(),
		Symbol(Symbol.toStringTag): "Reflect"
	},
	[[Target]]: Object {
		foo: 'bar'
	},
	[[IsRevoked]]: false
}
*/
```

​		反射 `API` 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：

```js
const target = {
    foo: 'bar',
    baz: 'qux'
};

const handler = {
    get(trapTarget, property, receiver) {
        let decoration = '';
        if(property === 'foo') {
            decoration = '!!!';
        }
        return Reflect.get(...arguments) + decoration;
    }
};

const proxy = new Proxy(target, handler);

// Proxy实例展示出来的数据是其[[Target]]中的数据。
proxy; // {foo: 'bar', baz: 'qux'}

proxy.foo; 	// 'bar!!!'
target.foo; // 'bar'

proxy.baz; 	// 'qux'
target.baz; // 'qux'
```



#### 捕获器不变式

​		使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 `ECMAScript` 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（`trap invariant`）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。

​		比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器中返回一个与该属性值不同的值时，会抛出 `TypeError`：

```js
const target = {};

Object.defineProperty(target, 'foo', {
    configurable: false,
    writable: false,
    value: 'bar'
});

const handler = {
    get() {
        return 'qux'; // 代理是对目标的抽象（也可以说是它的替身），因此对目标的约束同样会反映到代理上。
    }
};

const proxy = new Proxy(target, handler);

proxy.foo; // TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'bar' but got 'qux')
```



#### 实用反射 `API`

某些情况下应该优先使用反射 `API`，这是有一些理由的。



##### 反射 `API` 与对象 `API`

在使用反射 `API` 时，要记住：

- 反射 `API` 并不限于捕获处理程序。
- 大多数反射 `API` 方法在 `Object` 类型上都有对应的方法。

通常，`Object` 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。

```js
Reflect; // Reflect是一个对象，而不是构造函数。

/*
Reflect {
	apply: ƒ apply(),
	construct: ƒ construct(),
	defineProperty: ƒ defineProperty(),
	deleteProperty: ƒ deleteProperty(),
	get: ƒ (),
	getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor(),
	getPrototypeOf: ƒ getPrototypeOf(),
	has: ƒ has(),
	isExtensible: ƒ isExtensible(),
	ownKeys: ƒ ownKeys(),
	preventExtensions: ƒ preventExtensions(),
	set: ƒ (),
	setPrototypeOf: ƒ setPrototypeOf(),
	Symbol(Symbol.toStringTag): "Reflect"
}
*/
```



##### 状态标记

​		很多反射方法返回称作 “状态标记” 的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 `API` 方法更有用。例如，可以使用反射 `API` 对下面的代码进行重构：

```js
// 初始代码 
const o = {}; 

try { 
 	Object.defineProperty(o, 'foo', 'bar'); // 描述符必须是一个对象，否则会报错。
 	console.log('success'); 
} catch(e) { 
 	console.log('failure'); 
}
```

​		如果定义新属性失败，`Reflect.defineProperty()` 会返回 `false`，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：

```js
// 重构后代码
const o = {};

// Reflect.defineProperty()用于判断属性是否定义成功，而如果描述符是原始值，一样会报错。
if(Reflect.defineProperty(o, 'foo', {value: 'bar'})) {
    console.log('success');
} else {
    console.log('failure');
}
```

以下反射方法都会提供状态标记：`defineProperty`、`preventExtensions`、`setPrototypeOf`、`set`、`deleteProperty`。



##### 替代操作符

以下反射方法提供（实现了原本）只有通过操作符才能完成的操作：

- `Reflect.get()`：可以替代对象属性访问操作符。
- `Reflect.set()`：可以替代 `=` 赋值操作符。
- `Reflect.has()`：可以替代 `in` 操作符或 `with()`。
- `Reflect.deleteProperty()`：可以替代 `delete` 操作符。
- `Reflect.construct()`：可以替代 `new` 操作符。



##### 安全地应用函数

​		在通过 `apply` 方法调用函数时，被调用的函数可能也定义了自己的 `apply` 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 `Function` 原型上的 `apply` 方法，比如：`Function.prototype.apply.call(myFunc, thisVal, argumentList);` 

​		现在，这种可怕的代码完全可以使用 `Reflect.apply` 来避免：`Reflect.apply(myFunc, thisVal, argumentsList);`

```js
// 函数可能重写apply方法，带来意料之外的结果。
function person(name, age) {
    console.log(this);
    console.log(name + ': ' + age);
}

person.apply(null, ['wz', 18]);
/*
> Window {window: Window, ...}
> 'wz: 18'
*/

person.apply = 1; // 重写

person.apply({}, ['wz', 18]); // TypeError: person.apply is not a function
------------------------------------------------------------------------------------------------------------

// 为避免这个问题，可直接借用Function原型上的apply方法。
// 但由于是借用原型方法，还必须继续使用call来完成以下两件事：1、提供调用者，2、修改this指向。
// 因此，参数如下：一：借用者，二：this值，三：实参列表。
Function.prototype.apply.call(person, null,['wz', 18]);
/*
> Window {window: Window, ...}
> 'wz: 18'
*/
------------------------------------------------------------------------------------------------------------

// 不过，现在完全可以使用Reflect.apply来避免这个问题。
Reflect.apply(person, null, ['wz', 18]);
/*
> Window {window: Window, ...}
> 'wz: 18'
*/
```

<hr>

### 代理进阶

#### 代理另一个代理

​		代理可以拦截反射 `API` 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：

```js
const target = {
    foo: 'bar'
};

const firstProxy = new Proxy(target, {
    get() {
        console.log('first proxy');
        return Reflect.get(...arguments);
    }
});

const secondProxy = new Proxy(firstProxy, {
    get() {
        console.log('second proxy');
        return Reflect.get(...arguments);
    }
});

secondProxy; // {foo: 'bar'}
/*
{
	[[Handler]]: Object {
		get: f get()
	},
	[[Target]]: Proxy { // 该对象正是firstProxy对象
		[[Handler]]: Object {
			get: f get()
		},
		[[Target]]: Object {
			foo: 'bar'
		},
		[[IsRevoked]]: false
	},
	[[IsRevoked]]: false
}
*/

Object.getPrototypeOf(secondProxy) === firstProxy; // true

secondProxy.foo;
/*
> 'second proxy'
> 'first proxy'
> 'bar'
*/
```



#### 代理的问题

​		代理是在 `ECMAScript` 现有基础之上构建起来的一套新 `API`，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理尚不能与现在的 `ECMAScript` 机制很好地协同。



##### 代理中的 `this`

​		代理潜在的一个问题来源是 `this` 值。我们知道，方法中的 `this` 通常指向调用这个方法的对象：

```js
const target = { 
 	thisValEqualsProxy() { 
 		return this === proxy; 
 	} 
} 

const proxy = new Proxy(target, {}); 

target.thisValEqualsProxy(); // false 
proxy.thisValEqualsProxy();  // true
```

​		从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 `proxy.outerMethod()`，而这个方法进而又会调用另一个方法，如 `this.innerMethod()`，实际上都会调用 `proxy.innerMethod()`。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。

```js
const target = {
    outerMethod() {
        console.log(this === proxy, 'out');
        this.innerMethod();
    },
    innerMethod() {
        console.log(this === proxy, 'in');
    }
};

const proxy = new Proxy(target, {});

proxy.outerMethod();
/*
> true, 'out'
> true, 'in'
*/
```

​		例如，在使用 `Map` 结构存储数据时，引用键及其值之间的映射关系依赖于引用键的对象标识，那么对引用键进行代理就会出问题。

```js
// 简化版：通过WeakMap保存私有变量
const wm = new WeakMap();

class User {
    constructor(userId) {
        wm.set(this, userId); // 以this为键，以userId为值。
    }
    get id() {
        return wm.get(this); // 需要以this为键来获取值。
    }
    set id(userId) {
        wm.set(this, userId);
    }
}

// 由于这个实现依赖User实例的对象标识（即：'User'），在这个实例被代理的情况下就会出问题：
const user = new User(123);

const proxy = new Proxy(user, {});

user.id;  // 123
proxy.id; // undefined
```

​		首先在 `User` 类的内部，使用 `User` 实例作为 `WeakMap` 的键，并且 `getter` 要求读取属性时必须以 `this` 值为键来读取，然后在外部代理再以 `User` 实例为目标对象。然而虽然代理对象是对目标对象的抽象，但它们的引用不同（对象标识也不同），因此当代理对象尝试从自身读取同样存在于目标对象上的属性时，（由于 `getter` 的硬性限制）它是读取不到的。要解决这个问题，就需要重新配置代理，把代理 `User` 实例改为代理 `User` 类本身。之后再以该代理为类所创建的实例（即：`User` 实例）就能够被识别为 `WeakMap` 的键了：

```js
// 将代理目标改为User类自身
const UserClassProxy = new Proxy(User, {});
UserClassProxy; // Proxy {length: 1, name: 'User', ...}
/*
{
	[[Handler]]: Object {},
	[[Target]]: class User,
	[[IsRevoked]]: false
}
*/

// 再以该代理为类创建的新实例其实是User的实例，因为它是对User类的代理。
const proxyUser = new UserClassProxy(456); // 其实是调用其[[Target]]对象。
proxyUser; // User {id: 456}
/*
User {
	id: 456,
	[[Prototype]]: Object {
		constructor: class User,
		id: 456,
		get id: f id(),
		set id: f id(userId)
	}
}
*/

proxyUser.id; // 456
```



##### 代理与内部槽位

​		代理与内置引用类型（比如 `Array`）的实例通常可以很好地协同，但有些 `ECMAScript` 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。

​		一个典型的例子就是 `Date` 类型。根据 `ECMAScript` 规范，`Date` 类型方法的执行依赖 `this` 值上的内部槽位 `[[NumberDate]]`。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 `get()` 和 `set()` 操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 `TypeError`：

```js
const target = new Date();

const proxy = new Proxy(target, {});
proxy; // Proxy {}
/*
Proxy {
	[[Handler]]: Object,
	[[Target]]: Sun Oct 09 2022 15:57:38 GMT+0800 (中国标准时间) {
		[[Prototype]]: Object {
			constrcutor: f Date(),
			getDate: f getDate(),
			...
		}
	},
	[[IsRevoked]]: false
}
*/

proxy instanceof Date; // true

// Date类型方法的内部this必须是Date实例。
target.getDate(); // 9
proxy.getDate();  // TypeError: this is not a Date object.

proxy.getDate.call(target); // 9
```

<hr>

### 捕获器与反射方法

代理可以捕获 13 种不同的基本操作（13 种捕获器）。这些操作有各自不同的反射 `API` 方法、参数、关联 `ECMAScript` 操作和不变式。

​		正如前面示例所展示的，有几种不同的 `JavaScript` 操作会调用同一个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。

​		只要在代理上调用，所有捕获器都会拦截它们对应的反射 `API` 操作。



#### `get`

`get()` 捕获器会在获取属性值的操作中被调用。对应的反射 `API` 方法为 `Reflect.get()`。

```js
const proxy = new Proxy({}, {
    get(target, property, receiver) {
        console.log('get()');
        return Reflect.get(...arguments);
    }
});

proxy.foo;
/*
> 'get()'
> undefined
*/ 
```

##### 返回值

返回值无限制。

##### 拦截的操作

- 任何获取属性的操作，如：`proxy.property`、`proxy[property]`、`Object.create(proxy)[property]` 等。
- 相应的反射 `API`：`Reflect.get(proxy, property, receiver)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性（包括符号属性）
- `receiver`：代理对象或继承代理对象的对象

##### 捕获器不变式

- 如果 `target.property` 不可写且不可配置，则处理程序返回的值必须与 `target.property` 匹配。
- 如果 `target.property` 不可配置且 `[[Get]]` 特性为 `undefined`，处理程序的返回值也必须是 `undefined`。



#### `set`

`set()` 捕获器会在设置属性值的操作中被调用。对应的反射 `API` 方法为 `Reflect.set()`。

```js
const proxy = new Proxy({}, {
    set(target, property, reciever) {
        console.log('set()');
        return Reflect.set(...arguments);
    }
});

proxy.foo = 'bar';
/*
> 'set()'
> 'bar'
*/
```

##### 返回值

一个指示赋值操作是否成功的布尔值：`true` 表示成功，`false` 表示失败（严格模式下会抛出 `TypeError`）。

##### 拦截的操作

- 任何设置属性的操作，如：`proxy.property = value`、`proxy[property] = value`、`Object.create(proxy)[property] = value` 等。
- 相应的反射 `API`：`Reflect.set(proxy, property, value, receiver)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性
- `value`：要赋给属性的值
- `receiver`：接收最初赋值的对象

##### 捕获器不变式

- 如果 `target.property` 不可写且不可配置，则不能修改目标属性的值。
- 如果 `target.property` 不可配置且 `[[Set]]` 特性为 `undefined`，则不能修改目标属性的值。
- 在严格模式下，处理程序中返回 `false` 的情况会变成抛出 `TypeError`。



#### `has`

`has()` 捕获器会在 `in` 操作符中被调用。对应的反射 `API` 方法为 `Reflect.has()`。

```js
const proxy = new Proxy({
    foo: 'bar'
}, {
    has(target, property) {
        console.log('has()');
        return Reflect.has(...arguments);
    }
});

'foo' in proxy;
/*
> 'has()'
> true
*/

with(proxy) {foo;}
/*
> 'has()'
> 'bar'
*/
```

##### 返回值

`has()` 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- 使用 `in` 的地方，如：`property in proxy`、`property in Object.create(proxy)`
- 使用 `with` 的地方，如：`with(proxy) {(property);}`
- 相应的反射 `API`：`Reflect.has(proxy, property)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性

##### 捕获器不变式

- 如果 `target.property` 存在且不可配置，则处理程序必须返回 `true`。
- 如果 `target.property` 存在且目标对象不可扩展，则处理程序必须返回 `true`。



#### `defineProperty`

`defineProperty()` 捕获器会在 `Object.defineProperty()` 中被调用。对应的反射 `API` 方法为 `Reflect.defineProperty()`。

```js
const proxy = new Proxy({}, {
    defineProperty(target, property, descriptor) {
        console.log('defineProperty()');
        return Reflect.defineProperty(...arguments);
    }
});

Object.defineProperty(proxy, 'foo', {value: 'bar'});
/*
> 'defineProperty()'
> Proxy {foo: 'bar'}
*/
```

##### 返回值

`defineProperty()` 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- `Object.defineProperty(proxy, property, descriptor)`

- `Reflect.defineProperty(proxy, property, descriptor)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性
- `descriptor`：属性的描述符对象

##### 捕获器不变式

- 如果目标对象不可扩展，则无法定义属性。
- 如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。
- 如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。



#### `getOwnPropertyDescriptor`

​		`getOwnPropertyDescriptor()` 捕获器会在 `Object.getOwnPropertyDescriptor()` 中被调用。对应的反射 `API` 方法为`Reflect.getOwnPropertyDescriptor()`。

```js
const proxy = new Proxy({}, {
    getOwnPropertyDescriptor(target, property) {
        console.log('getOwnPropertyDescriptor()');
        return Reflect.getOwnPropertyDescriptor(...arguments);
    }
});

Object.getOwnPropertyDescriptor(proxy, 'foo');
/*
> 'getOwnPropertyDescriptor()'
> undefined
*/
```

##### 返回值

`getOwnPropertyDescriptor()` 必须返回对象，或者在属性不存在时返回 `undefined`。

##### 拦截的操作

- `Object.getOwnPropertyDescriptor(proxy, property)`
- `Reflect.getOwnPropertyDescriptor(proxy, property)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性

##### 捕获器不变式

- 如果自有的 `target.property` 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。
- 如果自有的 `target.property` 存在且可配置，则处理程序必须返回表示该属性可配置的对象。
- 如果自有的 `target.property` 存在且 `target` 不可扩展，则处理程序必须返回一个表示该属性存在的对象。
- 如果 `target.property` 不存在且 `target` 不可扩展，则处理程序必须返回 `undefined` 表示该属性不存在。
- 如果 `target.property` 不存在，则处理程序不能返回表示该属性可配置的对象。



#### `deleteProperty`

`deleteProperty()` 捕获器会在 `delete` 操作符中被调用。对应的反射 `API` 方法为 `Reflect.deleteProperty()`。

```js
const proxy = new Proxy({}, {
    deleteProperty(target, property) {
        console.log('deleteProperty()');
        return Reflect.deleteProperty(...arguments);
    }
});

delete proxy.foo;
/*
> 'deleteProperty()'
> true
*/
```

##### 返回值

`deleteProperty()` 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- 任何使用 `delete` 的地方，如：`delete proxy.property`、`delete proxy[property]`
- `Reflect.deleteProperty(proxy, property)`

##### 捕获器处理程序参数

- `target`：目标对象
- `property`：目标对象上的属性

##### 捕获器不变式

如果自有的 `target.property` 存在且不可配置，则处理程序不能删除这个属性。



#### `ownKeys`

`ownKeys()` 捕获器会在 `Object.keys()` 及类似方法中被调用。对应的反射 `API` 方法为 `Reflect.ownKeys()`。

```js
const proxy = new Proxy({}, {
    ownKeys(target) {
        console.log('ownKeys()');
        return Reflect.ownKeys(...arguments);
    }
});

Object.keys(proxy);
/*
> 'ownKeys()'
> []
*/
```

##### 返回值

`ownKeys()` 必须返回包含字符串键或符号键的可枚举对象（通常是数组）。

##### 拦截的操作

- 任何只返回键数组的方法，如：`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`
- `Reflect.ownKeys(proxy)`

##### 捕获器处理程序参数

- `target`：目标对象

##### 捕获器不变式

- 返回的可枚举对象必须包含 `target` 的所有不可配置的自有属性。

- 如果 `target` 不可扩展，则返回可枚举对象必须准确地包含自有属性键。



#### `getPrototypeOf`

`getPrototypeOf()` 捕获器会在 `Object.getPrototypeOf()` 中被调用。对应的反射 `API` 方法为 `Reflect.getPrototypeOf()`。

```js
const proxy = new Proxy({}, {
    getPrototypeOf(target) {
        console.log('getPrototypeOf()');
        return Reflect.getPrototypeOf(...arguments);
    }
});

Object.getPrototypeOf(proxy);
/*
> 'getPrototypeOf()'
> {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
*/
```

##### 返回值

`getPrototypeOf()` 必须返回对象（即：指定对象的 `[[Prototype]]` 对象）或 `null`。

##### 拦截的操作

- 任何获取 `[[Prototype]]` 特性的地方，如：`Object.getPrototypeOf(proxy)`、`proxy.__proto__`、`Object.prototype.isPrototypeOf(proxy)`、`proxy instanceof Object`。
- `Reflect.getPrototypeOf(proxy)`

##### 捕获器处理程序参数

- `target`：目标对象

##### 捕获器不变式

如果 `target` 不可扩展，则 `Object.getPrototypeOf(proxy)` 唯一有效的返回值就是 `Object.getPrototypeOf(target)` 的返回值。



#### `setPrototypeOf`

`setPrototypeOf()` 捕获器会在 `Object.setPrototypeOf()` 中被调用。对应的反射 `API` 方法为 `Reflect.setPrototypeOf()`。

```js
const proxy = new Proxy({}, {
    setPrototypeOf(target, prototype) {
        console.log('setPrototypeOf()');
        return Reflect.setPrototypeOf(...arguments);
    }
});

Object.setPrototypeOf(proxy, Object); // 主要是设置了[[Target]]特性
/*
> 'setPrototypeOf()'
> Proxy {[[Handler]]: Object, [[Target]]: Function, [[IsRevoked]]: false}
*/
```

##### 返回值

`setPrototypeOf()` 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- `Object.setPrototypeOf(proxy)`
- `Reflect.setPrototypeOf(proxy)`

##### 捕获器处理程序参数

- `target`：目标对象
- `prototype`：`target` 的替代原型，如果是顶级原型则为 `null`。

##### 捕获器不变式

如果 `target` 不可扩展，则唯一有效的 `prototype` 参数就是 `Object.getPrototypeOf(target)` 的返回值。



#### `isExtensible`

`isExtensible()` 捕获器会在 `Object.isExtensible()` 中被调用。对应的反射 `API` 方法为 `Reflect.isExtensible()`。

```js
const proxy = new Proxy({}, {
    isExtensible(target) {
        console.log('isExtensible()');
        return Reflect.isExtensible(...arguments);
    }
});

Object.isExtensible(proxy);
/*
> 'isExtensible()'
> true
*/
```

##### 返回值

`isExtensible()` 必须返回布尔值，表示 `target` 是否可扩展。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- `Object.isExtensible(proxy)`
- `Reflect.isExtensible(proxy)`

##### 捕获器处理程序参数

- `target`：目标对象

##### 捕获器不变式

- 如果 `target` 可扩展，则处理程序必须返回 `true`。
- 如果 `target` 不可扩展，则处理程序必须返回 `false`。



#### `preventExtensions`

`preventExtensions()` 捕获器会在 `Object.preventExtensions()` 中被调用。对应的反射 `API` 方法为 `Reflect.preventExtensions()`。

```js
const proxy = new Proxy({}, {
    preventExtensions(target) {
        console.log('preventExtensions()');
        return Reflect.preventExtensions(...arguments);
    }
});

Object.preventExtensions(proxy);
/*
> 'preventExtensions()'
> Proxy {}
*/
```

##### 返回值

`preventExtensions()` 必须返回布尔值，表示 `target` 是否已经不可扩展。返回非布尔值会被转型为布尔值。

##### 拦截的操作

- `Object.preventExtensions(proxy)`
- `Reflect.preventExtensions(proxy)`

##### 捕获器处理程序参数

- `target`：目标对象

##### 捕获器不变式

如果 `Object.isExtensible(proxy)` 是 `false`，则处理程序必须返回 `true`。



#### `apply`

`apply()` 捕获器会在调用函数时中被调用。对应的反射 `API` 方法为 `Reflect.apply()`。

```js
const myTarget = () => {};

const proxy = new Proxy(myTarget, {
    apply(target, thisArg, ...argumentsList) {
        console.log('apply()');
        return Reflect.apply(...arguments);
    }
});

proxy();
/*
> 'apply()'
> undefined
*/
```

##### 返回值

返回值无限制

##### 拦截的操作

- `proxy(...argumentsList)`
- `Function.prototype.apply(thisArg, argumentsList)`
- `Function.prototype.call(thisArg, ...argumentsList)`
- `Reflect.apply(target, thisArgument, argumentsList)`

##### 捕获器处理程序参数

- `target`：目标对象
- `thisArg`：调用函数时的 `this` 参数
- `argumentsList`：调用函数时的参数列表

##### 捕获器不变式

`target` 必须是一个函数对象。



#### `construct`

`construct()` 捕获器会在 `new` 操作符中被调用。对应的反射 `API` 方法为 `Reflect.construct()`。

```js
const myTarget = function() {};

const proxy = new Proxy(myTarget, {
    construct(target, argumentsList, newTarget) {
        console.log('construct()');
        return Reflect.construct(...arguments);
    }
});

new proxy();
/*
> 'construct()'
> myTarget {}
*/
```

##### 返回值

`constructor()` 必须返回一个对象。

##### 拦截的操作

- `new proxy(...argumentsList)`

- `Reflect.construct(target, argumentsList, newTarget)`

##### 捕获器处理程序参数

- `target`：目标构造函数
- `argumentsList`：传给目标构造函数的参数列表
- `newTarget`：最初被调用的构造函数

##### 捕获器不变式

`target` 必须可以用作构造函数。

<hr>

### 代理模式

使用代理可以在代码中实现一些有用的编程模式。



#### 跟踪属性访问

​		通过捕获 `get`、`set` 和 `has` 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：

```js
const user = {
    name: 'Jake'
};

const proxy = new Proxy(user, {
    get(target, property, receiver) {
        console.log(`Getting ${property}`);
        return Reflect.get(...arguments);
    },
    set(target, property, value, receiver) {
        console.log(`Setting ${property} = ${value}`);
        return Reflect.set(...arguments);
    }
});

proxy.name; 	// 'Getting name', 'Jake'
proxy.age = 18; // 'Setting age = 18', 18
```



#### 隐藏目标属性

代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。比如：

```js
const hiddenProperties = ['foo', 'bar'];

const targetObject = { 
 	foo: 1, 
 	bar: 2, 
 	baz: 3 
}; 

const proxy = new Proxy(targetObject, { 
 	get(target, property) { 
 		if (hiddenProperties.includes(property)) { 
 			return undefined; 
 		} else { 
 			return Reflect.get(...arguments); 
 		} 
 	}, 
 	has(target, property) {
      	if (hiddenProperties.includes(property)) { 
 			return false; 
 		} else { 
 			return Reflect.has(...arguments); 
 		} 
 	} 
});

// get();
proxy.foo; // undefined
proxy.bar; // undefined
proxy.baz; // 3

// has();
'foo' in proxy; // false
'bar' in proxy; // false
'baz' in proxy; // true
```



#### 属性验证

因为所有赋值操作都会触发 `set()` 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：

```js
const proxy = new Proxy({
    onlyNumbersGoHere: 0
}, {
    set(target, property, value) {
        if(typeof value !== 'number') {
            return false;
        } else {
            return Reflect.set(...arguments);
        }
    }
});

proxy.onlyNumbersGoHere = 1;
proxy.onlyNumbersGoHere; // 1

proxy.onlyNumbersGoHere = '2';
proxy.onlyNumbersGoHere; // 1
```



#### 参数验证

​		跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：

```js
function median(...nums) {
    // 按字典序法排序，并返回中间（或中偏左）的那个元素。
    return nums.sort()[Math.floor(nums.length / 2)];
}

const proxy = new Proxy(median, {
    apply(target, thisArg, argumentsList) {
        for(const arg of argumentsList) {
            if(typeof arg !== 'number') {
                throw 'Non-number argument provided';
            }
        }
        return Reflect.apply(...arguments); // 全部参数验证通过后，再传入反射。
    }
});

proxy(0, 9, 2, 3); 	 // 3
proxy(0, '9', 2, 3); // Uncaught Non-number argument provided
```

​		类似地，可以要求实例化时必须给构造函数传参：

```js
class User {
    constructor(id) {
        this._id = id;
    }
}

const proxy = new Proxy(User, {
    construct(target, argumentsList, newTarget) {
        if(argumentsList[0] === undefined) {
            throw 'User cannot be instantiated without id';
        } else {
            return Reflect.construct(...arguments);
        }
    }
});

new proxy(1); // User {_id: 1}

new proxy();  // Uncaught User cannot be instantiated without id
```



#### 数据绑定与可观察对象

​		通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。

​		比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：

```js
const userList = [];

class User {
    constructor(name) {
        this._name = name;
    }
}

const proxy = new Proxy(User, {
    construct() {
        const newUser = Reflect.construct(...arguments); 
 		userList.push(newUser); 
 		return newUser;
    }
});

new proxy('John');
new proxy('Jobe');
new proxy('Nuri');

userList; // [User {_name: 'John'}, User {_name: 'Jobe'}, User {_name: 'Nuri'}]
```

​		另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：

```js
const userList = [];

function emit(newValue) {
    console.log(newValue);
}

const proxy = new Proxy(userList, {
    set(target, property, value, receiver) {
        const result = Reflect.set(...arguments);
        if(result) {
            emit(Reflect.get(target, property, receiver));
        }
        return result;
    }
});

proxy.push('John');
/*
> 'John'【emit的log结果】
> 1【emit的log结果】
> 1【push的返回结果】
*/

proxy.push('Joge');
/*
> 'Joge'
> 2
> 2
*/
```

<hr>

### 小结

​		代理是 `ECMAScript 6` 新增的令人兴奋和动态十足的新特性。尽管**不支持向后兼容**，但它开辟出了一片前所未有的 `JavaScript` 元编程及抽象的新天地。

​		从宏观上看，代理是真实 `JavaScript` 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分 `JavaScript` 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。

​		与代理如影随形的反射 `API`，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射 `API`看作一套基本操作，这些操作是绝大部分 `JavaScript` 对象 `API` 的基础。

​		代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。

​		**`proxy` 与 `defineProperty` 的重要区别**：

- `defineProperty` 只能监听属性的读写操作，而 `proxy` 拥有 13 种捕获器，可以监听 13 种不同的基本操作。
- `Proxy` 可以更好地支持对数组的监视，而 `defineProperty` 则需要通过重写数组的操作方法来实现监听。
- `Proxy` 是以非入侵的方式监管了对象的读写，即：以代理的身份监管多种对对象的行为。

​		代理类似中间件，但远远强于中间件，它相当于一个中间层，负责监管对目标对象的 13 种基本操作。工作流程可以比喻成如下的例子：一个粉丝想要知道明星的本名，这个行为首先被代理拦截，代理能够处理这个事件则直接告知其结果。不过，代理也可能会遇到一些无法处理的事件，比如：一个粉丝想要明星的手写签名。此时，代理会将这个请求传达给明星（即：该行为的目标对象），明星写好后将签名托付给代理，然后由代理将签名交给粉丝。

<hr>



## 反射

​		`Reflect` 是一个内置对象，为可劫持的 `JavaScript` 操作提供方法。这些方法与代理处理程序的方法相同。`Reflect` 是一个对象，而不是函数，因此它是不可构造的。

​		与大多数全局对象不同，`Reflect` 不是构造函数。不能将它与 `new` 操作符一起使用，或者将 `Reflect` 对象作为函数调用。`Reflect` 的所有属性和方法都是静态的（就像 `Math` 对象一样）。

<hr>

### 差异

​		`Reflect` 对象提供了以下静态函数，它们的名称与代理处理程序方法相同。其中一些方法也与 `Object` 上相应的方法相同，尽管它们之间确实有一些微妙的区别（具体可参考：[`Comparing Reflect and Object methods`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods)），如果 `API` 不存在，则标记为 `N/A`。

| Method Name                   | `Object`                                                     | `Reflect`                                                    |
| :---------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `defineProperty()`            | `Object.defineProperty()` 返回传递给函数的对象。如果在对象上未成功定义属性，则抛出 `TypeError`。 | `Reflect.defineProperty()` 如果在对象上定义了属性，则返回 `true`；如果没有，则返回 `false`。 |
| `defineProperties()`          | `Object.defineProperties()` 返回传递给函数的对象。如果在对象上未成功定义任何一个属性，都会抛出 `TypeError`。 | N/A                                                          |
| `has()`                       | N/A                                                          | 如果属性存在于对象或其原型链上，则返回 `true` ，否则返回 `false`，类似于 `in` 操作符。如果目标不是对象，抛出 `TypeError`。 |
| `get()`                       | N/A                                                          | `Reflect.get()` 返回属性的值。如果目标不是对象，则抛出 `TypeError`。 |
| `set()`                       | N/A                                                          | `Reflect.set()` 如果在对象上成功设置了属性，则返回 `true`，否则返回 `false`。如果目标不是对象，则抛出 `TypeError`。 |
| `deleteProperty()`            | N/A                                                          | 如果从对象中删除了属性，则返回 `true`，否则返回 `false`。    |
| `getOwnPropertyDescriptor()`  | `Object.getOwnPropertyDescriptor()` 如果给定的属性存在于传入的对象参数中，则返回它的属性描述符，如果不存在则返回 `undefined`。但是，如果传入的第一个参数不是对象，它将被强制转换为一个对象。 | `Reflect.getOwnPropertyDescriptor()` 返回给定属性的属性描述符（如果它存在于对象上）。如果不存在则返回 `undefined`，如果传入的第一个参数不是对象（而是原始值），则返回 `TypeError`。 |
| `getOwnPropertyDescriptors()` | `Object.getOwnPropertyDescriptors()` 返回一个对象，其中包含指定对象的所有自有属性的描述符。如果指定的对象没有自有的属性描述符，则返回空对象。 | N/A                                                          |
| `getPrototypeOf()`            | `Object.getPrototypeOf()` 返回给定对象的原型。如果给定对象没有任何继承属性，则返回 `null`。在 `ES5` 中为非对象，则抛出 `TypeError`，但在 `ES6` 中强制转换非对象。 | `Reflect.getprototypeof()` 返回给定对象的原型。如果没有继承的属性，则返回 `null`，对于非对象会抛出 `TypeError`。 |
| `setPrototypeOf()`            | `Object.setPrototypeOf()` 如果成功设置了目标的原型，则返回该目标。如果传入的目标是非对象，直接返回该目标。如果传入的原型不是对象或 `null`，或者传入的目标是不可扩展的，都会抛出 `TypeError`。 | 如果成功设置了原型，则返回 `true`；如果失败，则返回 `false`（包括传入目标不可扩展的情况）。如果传入的目标不是 `Object`，或者传入原型不是 `Object` 或 `null`，都抛出 `TypeError`。 |
| `isExtensible()`              | `Object.isExtensible()` 如果对象是可扩展的，则返回 `true`，不是则返回 `false`。如果参数不是对象，在 `ES5` 中抛出 `TypeError`。在 `ES6` 中，它将暂时地被包装为对象以用于判断，最后会返回 `false`。 | 如果对象是可扩展的，则返回 `true`，否则返回 `false`。如果参数不是对象，则会直接抛出 `TypeError`。 |
| `preventExtensions()`         | `Object.preventExtensions()` 返回不可扩展的对象。如果参数不是对象，在 `ES5` 中抛出 `TypeError`。在 `ES6` 中，直接返回参数。 | `Reflect.preventExtensions()` 如果对象不可扩展，返回 `true`，否则返回 `false`。如果参数不是对象，则抛出 `TypeError`。 |
| `keys()`                      | `Object.keys()` 返回一个数组，它包含了目标对象所有的自有（可枚举的）字符串属性键。如果目标不是对象，在 `ES5` 中抛出 `TypeError`，在 `ES6` 中将被强制转为对象。 | N/A                                                          |
| `ownKeys()`                   | N/A                                                          | `Reflect.ownkeys()` 返回一个数组，它包含了目标对象所有的自有属性键。如果目标不是对象，则抛出 `TypeError`。 |

<hr>

### `Polyfill`

**注解**：`Polyfill`（或 `polyfiller`）是一段代码（或插件），它提供了开发者希望浏览器原生提供的技术。在 `web` 开发中，`polyfill`（或 `polyfiller`）是可下载的代码，它提供了 `web` 浏览器中没有内置实现的功能。例如，`HTML5` 的许多特性在 `ie8` 或 `ie9` 之前的版本中是不支持的，但如果网页安装了 `polyfill`，就可以在这些网页上使用。`polyfill` 的原意为：腻子脚本。

```tsx
namespace Reflect {
  	apply(target: Function, thisArgument: any, argumentsList: Array<mixed>): any;
  	construct(target: Function, argumentsList: Array<mixed>, newTarget?: Function): Object;
  	defineProperty(target: Object, propertyKey: PropertyKey, attributes: PropertyDescriptor): boolean;
  	deleteProperty(target: Object, propertyKey: PropertyKey): boolean;
  	get(target: Object, propertyKey: PropertyKey, receiver?: any): any;
  	getOwnPropertyDescriptor(target: Object, propertyKey: PropertyKey): PropertyDescriptor | void;
  	getPrototypeOf(target: Object): Object | null;
  	has(target: Object, propertyKey: PropertyKey): boolean;
  	isExtensible(target: Object): boolean;
  	ownKeys(target: Object): Array<string | symbol>;
  	preventExtensions(target: Object): boolean;
  	set(target: Object, propertyKey: PropertyKey, V: any, receiver?: any): boolean;
  	setPrototypeOf(target: Object, proto: Object | null): boolean; // required __proto__ - IE11+
}
```

<hr>

### 静态方法

##### `apply`

静态的 `Reflect.apply()` 方法调用一个带有规定参数的目标函数。

参数：

- `target`：要调用的目标函数
- `thisArgument`：调用目标函数时提供的 `this` 值（**提供 `undefined` 或 `null` 意味着使用默认的 `this` 值，其余值会被转为对象**）
- `argumentsList`：一个类数组对象，包含调用目标函数时传入的参数。

返回值：使用指定的 `this` 值和实参，调用给定的目标函数之后的结果。

```js
function fn() {
    console.log(this);
}

fn.call(null); // Window {}

fn.call(1); // Number {1}
```

异常说明：

- 如果目标不可调用，则为 `TypeError`。

示例：

​		在 `ES5` 中，通常使用 `Function.prototype.apply()` 方法调用一个函数，并带有一个给定的 `this` 值和作为数组（或类数组对象）提供的参数。

```js
// 使用call来提供调用者，其余参数的情况与apply一致。
Function.prototype.apply.call(Math.floor, undefined, [1.75]); // 1

// 这其实相当于执行了如下代码（编译器在内部可能就是这样转换的），但上述方式更适用于无法直接提供调用者的情况。
Math.floor.apply(undefined, [1.75]); // 1
```

​		使用 `Reflect.apply()`，这将变得不那么冗长，且更容易理解。

```js
Reflect.apply(Math.floor, undefined, [1.75]); // 1

// 其他的用法
Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]); // "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index; // 4

Reflect.apply(''.charAt, 'ponies', [3]); // "i"
```



##### `construct`

​		静态方法 `Reflect.construct(target, argumentsList)` 的行为类似于 `new` 操作符，但它是一个函数。它相当于执行 `new target(...argumentsList)`，并且还提供了附加选项去指定一个不同的原型。

参数：

- `target`：要调用的目标函数
- `argumentsList`：一个类数组，包含了调用目标函数时传入的参数。
- `newTarget`：要使用其原型的构造函数。可参阅 `new.target` 操作符。如果 `newTarget` 不存在，它的值默认为 `target`。

返回值：`target`（或者 `newTarget`，如果存在）的一个新实例，使用给定的 `argumentsList` 通过 `target` 像构造函数一样初始化。

异常：

- 如果 `target` 或 `newTarget` 不是构造函数，则抛出 `TypeError`。

```js
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}

// 使用默认原型（即：Person.prototype），不指定为其他的原型。
Reflect.construct(Person, ['wz', 18, '♀']);
/*
Person {
	name: 'wz',
	age: 18,
	sex: '♀'
	[[Prototype]]: Object {
		constructor: f Person(name, age, sex)
	}
}
*/

// 指定原型：使用String.prototype创建一个空实例（舍弃实例属性），然后调用Person来添加实例属性，类似于盗用构造函数。
Reflect.construct(Person, ['cy', 19, '🚺'], String);
/*
String {
	name: 'cy',
	age: 19,
	sex: '🚺',
	[[Prototype]]: String {
		constructor: f String(),
		... // 其他原型方法
		[[PrimitiveValue]]: ""
	}
}
*/
```

示例：

​		`construct()` 允许调用具有可变数量参数的构造函数（通过将扩展语法与 `new` 操作符结合使用，也可以实现这一点）。

```js
new Foo(...args);

Reflect.construct(Foo, args);
```

`Object.create()` 与 `Reflect.construct()` 的区别：

在引入 `Reflect` 之前，可以通过 `Object.create()` 使用构造函数和原型的任意组合来构造对象。

```js
function OneClass() {
    this.name = 'one';
}

function OtherClass() {
    this.name = 'other';
}

const obj1 = Reflect.construct(OneClass, [], OtherClass);
obj1; // OtherClass {name: 'one'}
/*
OtherClass {
	name: 'one',
	[[Prototype]]: Object {
		constructor: f OtherClass()
	}
}
*/

// 模拟obj1对象的创建过程。
const obj2 = Object.create(OtherClass.prototype); // 先利用OtherClass.prototype创建一个空实例
OneClass.apply(obj2, []); // 然后利用盗用构造函数技术，调用OneClass为实例添加实例属性。
obj2; // OtherClass {name: 'one'}
/*
OtherClass {
	name: 'one',
	[[Prototype]]: Object {
		constructor: f OtherClass()
	}
}
*/

obj1 instanceof OneClass; 	// false
obj1 instanceof OtherClass; // true

obj2 instanceof OneClass; 	// false
obj2 instanceof OtherClass; // true
```

​		然而，虽然最终结果是一样的，但在这个过程中有一个重要的区别。当使用 `Object.create()` 和 F`unction.prototype.apply()` 时，在被用作构造函数的函数中，`new.target` 操作符将指向 `undefined`，因为没有使用 `new` 关键字来创建对象。

​		另一方面，当调用 `Reflect.construct()` 时，如果提供了 `newTarget` 参数，`new.target` 操作符将指向 `newTarget` 参数，如果没有提供，则指向 `target`。

```js
function OneClass() {
  	console.log('OneClass');
  	console.log(new.target);
}

// 该函数内部的代码不会被执行，它仅用来提供一个原型和创建一个空实例。
function OtherClass() {
  	console.log('OtherClass');
  	console.log(new.target);
}

const obj1 = Reflect.construct(OneClass, []);
/*
> 'OneClass'
> function OneClass() {...}
*/

const obj2 = Reflect.construct(OneClass, [], OtherClass);
/*
> 'OneClass'
> function OtherClass() {...}
*/

const obj3 = Object.create(OtherClass.prototype);
OneClass.apply(obj3, []);
/*
> 'OneClass'
> undefined
*/
```

```js
const date = Reflect.construct(Date, [1776, 6, 4]);

date instanceof Date  // true
date.getFullYear()    // 1776
```



##### `defineProperty`

静态的 `Reflect.defineProperty()` 方法类似于 `Object.defineProperty()`，但返回布尔值。

参数：

- `target`：在其上定义属性的目标对象。
- `property`：要定义或修改的属性的名称。
- `attributes`：被定义或修改的属性的特性。

返回值：指示属性是否已成功定义的布尔值。

异常：

- 如果目标不是对象，则抛出 `TypeError` 。

​		`Reflect.defineproperty` 方法允许对对象的属性进行精确的添加或修改。更多请参阅 `Object.defineProperty`，它与此类似。

注意：`Object.defineproperty` 返回对象，如果未成功定义属性则抛出 `TypeError`。然而，`Reflect.defineproperty` 返回一个布尔值，指示属性是否已成功定义。

```js
const obj = {};

Reflect.defineProperty(obj, 'foo', {
    configurable: true,
    enumerable: true,
    writable: true,
    value: 'bar'
}); // true

Object.getOwnPropertyDescriptors(obj);
/*
{
	foo: {value: 'bar', writable: true, enumerable: true, configurable: true}
}
*/
```

检查属性是否定义成功：

​		使用 `Object.defineproperty`，如果成功则返回对象，否则抛出 `TypeError`，您可以使用 `try…catch` 块捕获定义属性时发生的任何错误。

​		因为 `Reflect.defineProperty` 返回一个反映成功状态的布尔值，所以你正好可以使用 `if…else` 块。

```js
if (Reflect.defineProperty(target, property, attibutes)) {
    // success
} else {
    // failure
}
```



##### `deleteProperty`

静态的 `Reflect.deleteProperty()` 方法允许删除属性。它是一个与 `delete` 操作符很像的函数。

参数：

- `target`：要删除属性的目标对象。
- `property`：要删除的属性的名称。

返回值：一个指示属性是否已成功删除的布尔值。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

​		`Reflect.deleteproperty` 方法允许您删除对象上的属性。它返回一个布尔值，以指示属性是否已成功删除。它几乎与非严格的 `delete` 操作符相同。

```js
// 删除普通对象上的属性
const obj = {foo: 'bar'};
Reflect.deleteProperty(obj, 'foo'); // true
obj; // {}

// 删除数组中的元素
const array = [1, 2, 3, 4, 5];
Reflect.deleteProperty(array, '3'); // true
array; // [1, 2, 3, empty, 5]

// 删除不存在的属性
Reflect.deleteProperty({}, 'foo'); // true

// 删除不可配置的属性
Reflect.deleteProperty(Object.freeze({foo: 'bar'}), 'foo'); // false
```



##### `get`

静态的 `Reflect.get()` 方法作为一个函数，其行为类似于从对象（`target[property]`）获取一个属性。

参数：

- `target`：获取属性的目标对象。
- `property`：要获取的属性的名称。
- `receiver`：如果 `target` 对象中指定了`getter`，则 `receiver` 参数会被作为此 `getter` 中的 `this` 值。当与 `Proxy` 一起使用时，它可以是一个从 `target` 继承而来的对象。

返回值：属性的值

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
const target = {         
    get foo() {
        console.log(this); // this原本指向target对象自身，但提供receiver参数之后，this会指向它。
        return 'bar';
    }
};

target.foo;
/*
> {foo: 'bar', get foo: f foo()} // target对象自身
> 'bar'
*/

Reflect.get(target, 'foo', {name: 'receiver'});
/*
> {name: 'reciver'}
> 'bar'
*/
------------------------------------------------------------------------------------------------------------

// 与Proxy一起使用：
let proxy = new Proxy({
    foo: ''
}, {
    get(target, property, receiver) {
        console.log(receiver); // 默认为proxy对象自身，可以通过Reflect.get提供receiver参数来取代它。
        return 'bar';
    }
});

// 使用默认的receiver参数
Reflect.get(proxy, 'foo');
/*
> Proxy {foo: ''}
> 'bar'
*/

// 使用提供的receiver参数
Reflect.get(proxy, 'foo', {name: 'receiver'});
/*
> {name: 'receiver'}
> 'bar'
*/
```



##### `getOwnPropertyDescriptor`

​		静态的 `Reflect.getOwnPropertyDescriptor()` 方法类似于 `Object.getOwnPropertyDescriptor()`。如果给定的属性存在于对象上，则返回该属性的属性描述符，不存在则返回 `undefined`。

参数：

- `target`：要在其中查找属性的目标对象。
- `property`：要获取其属性描述符的属性的名称。

返回值：如果属性存在于目标对象中，则为该属性的描述符对象；否则，`undefined`。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
Reflect.getOwnPropertyDescriptor({foo: 'bar'}, 'foo');
// {value: 'bar', writable: true, enumerable: true, configurable: true}

Reflect.getOwnPropertyDescriptor({foo: 'bar'}, 'baz'); // undefined

// 获取数组默认的length描述符对象
Reflect.getOwnPropertyDescriptor([], 'length');
// {value: 0, writable: true, enumerable: false, configurable: false}
```

​		`Reflect.getOwnPropertyDescriptor` 方法与 `Object.getOwnPropertyDescriptor()` 的唯一区别是如何处理 `target` 非对象。

​		如果 `Reflect.getOwnPropertyDescriptor` 方法的 `target` 参数不是一个对象（而是一个原始值），那么它将导致 `TypeError`。对于 `Object.getOwnPropertyDescriptor` 来说，非对象首参将首先被强制转换为对象。

```js
Reflect.getOwnPropertyDescriptor('foo', 0);
// TypeError: Reflect.getOwnPropertyDescriptor called on non-object

Object.getOwnPropertyDescriptor('foo', 0);
// {value: 'f', writable: false, enumerable: true, configurable: false}
```



##### `getPrototypeOf`

​		静态的 `Reflect.getPrototypeOf()` 方法与 `Object.getPrototypeOf()` 方法几乎相同。它返回指定对象的原型（即：内部特性 `[[prototype]]` 的值）。

参数：

- `target`：获取其原型的目标对象。

返回值：给定对象的原型。如果给定对象没有任何继承属性，则返回 `null`。

异常：

- 如果目标为非对象，则抛出 `TypeError`。

```js
Reflect.getPrototypeOf({}); // Object.prototype

// Object.prototype是以null为原型创建而来的，即：Object.create(null)。
Reflect.getPrototypeOf(Object.prototype); // null

Reflect.getPrototypeOf(Object.create(null)) // null
```

```js
// 与Object.getPrototypeOf的比较
// 对同一种对象而言，返回相同的结果。
Object.getPrototypeOf({}) === Reflect.getPrototypeOf({}); // true

// 在ES5中，对于非对象首参都会抛出错误。
Object.getPrototypeOf('foo'); 	// TypeError
Reflect.getPrototypeOf('foo'); 	// TypeError

// 在ES6中，仅Reflect抛错，Object会强制转换非对象。
Object.getPrototypeOf('foo'); 	// String.prototype
Reflect.getPrototypeOf('foo'); 	// TypeError

// 要模仿Object在ES6中的行为，需要强制转换。
Reflect.getPrototypeOf(Object('foo')); // String.prototype
```



##### `has`

静态的 `Reflect.has()` 方法作为一个函数像 `in` 操作符一样工作。

参数：

- `target`：要在其中查找属性的目标对象。
- `property`：要检查的属性的名称。

返回值：一个指示目标对象是否具有指定属性的布尔值。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
Reflect.has({foo: 'bar'}, 'foo'); // true

Reflect.has({}, 'foo'); // false
```

```js
// Proxy使用has方法
let proxy = new Proxy({}, {
    has(target, property) {
        return property.startsWith('door');
    }
});

Reflect.has(proxy, 'doorbell'); 	// true
Reflect.has(proxy, 'dormitory'); 	// false

// 对于任何继承属性都返回true，就in操作符那样。
const a = {foo: '123'};
const b = {__proto__: a};
const c = {__proto__: b};

// 原型链为：c -> b -> a
Reflect.has(c, 'foo'); // true
```



##### `isExtensible`

​		静态的 `Reflect.isExtensible()` 方法确定对象是否可扩展（是否可以向其添加新属性）。它类似于 `Object.isExtensible()`，但有一些不同。

参数：

- `target`：要检查其是否可扩展的目标对象。

返回值：一个指示目标对象是否可扩展的布尔值。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
// 新创建的对象是可扩展的（默认状态）
Reflect.isExtensible({}); // true

// 根据定义：阻止对象扩展、密封对象、冻结对象都会使对象不可扩展。
const frozen = Object.freeze({});
Reflect.isExtensible(frozen); // false
```

​		如果这个方法的 `target` 参数不是一个对象（而是一个原始值），那么它将导致 `TypeError`。对于 `Object.isExtensible()`，非对象 `target` 将返回 `false` 而没有任何错误。

```js
Reflect.isExtensible('foo'); // TypeError: Reflect.isExtensible called on non-object

Object.isExtensible('foo'); // false
```



##### `ownKeys`

静态的 `Reflect.ownKeys()` 方法返回一个包含目标对象自有属性键的数组。

参数：

- `target`：要从中获取自有键的目标对象。

返回值：

- 目标对象的自有属性键（包括字符串键以及符号键）数组。
- 与 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))` 的相同

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
// 获取数组的默认自有属性
Reflect.ownKeys([]); // ['length']

const obj = {
    [Symbol.for('foo')]: 'foo',
    1: 1,
    3: 3,
    bar: 'bar',
    '-1': -1,
    0: 0
}
// 在ES6中，对象拥有了一定的属性秩序：1、按数字大小（负数被视为字符），2、按字符插入顺序、3、按符号插入顺序。
Reflect.ownKeys(obj); // ['0', '1', '3', 'bar', '-1', Symbol(foo)]
```



##### `preventExtensions`

​		静态的 `Reflect.preventExtensions()` 方法可以防止将新属性添加到对象中（也就是说，防止将来对对象进行扩展）。它类似于`Object.preventExtensions()`，但有一些不同。

参数：

- `target`：要在其上阻止扩展的目标对象。

返回值：一个布尔值，指示是否成功地设置了目标不可扩展。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
const empty = {};

// 对象默认可扩展
Reflect.isExtensible(empty); // true

// 阻止扩展
Reflect.preventExtensions(empty); // true
Reflect.isExtensible(empty); // false
```

​		如果这个方法的 `target` 参数不是对象（而是一个原始值），那么它将导致 `TypeError`。使用 `Object.preventExtensions()`，将按原样返回这个非对象 `target`，但没有任何错误。

```js
Reflect.preventExtensions('foo'); // TypeError: Reflect.preventExtensions called on non-object

Object.preventExtensions('foo'); // 'foo'
```



##### `set`

静态的 `Reflect.set()` 方法的工作原理类似于在对象上设置属性。

参数：

- `target`：要对其设置属性的目标对象。
- `property`：要设置的属性的名称。
- `value`：要设置的值。
- `receiver`：该值是目标属性 `setter` 中的 `this` 值。如果目标属性没有 `setter`，则该值将被设置为这个目标属性。

返回值：一个指示设置属性是否成功的布尔值。

异常：

- 如果 `target` 不是对象，则抛出 `TypeError`。

```js
// 对象
const obj = {};
Reflect.set(obj, 'foo', 'bar');
obj; // {foo: 'bar'}

// 数组
const arr = ['duck', 'duck', 'duck'];
Reflect.set(arr, 2, 'goose');
arr; // ['duck', 'duck', 'goose']

// 截断数组
Reflect.set(arr, 'length', 2);
arr; // ['duck', 'duck']

// 如果只提供目标参数，将为其自动设置一个undefined属性，其值也为undefined，但这个操作是幂等的。
const obj = {};
Reflect.set(obj);
obj; // {undefined: undefined}
```

​		当 `target` 和 `receiver` 不同时，`Reflect.set` 将使用 `target` 的属性描述符（以查找 `setter` 或确定属性是否可写），但会将属性设置在 `receiver` 上。

```js
// 属性被添加到receiver上，而不是target上。
const target = {},
      receiver = {};

Reflect.set(target, 'a', 2, receiver); // true
target; // {}
receiver; // {a: 2}

// 来看另一个例子
const target = {
    set a(v) {
        this._a = v; // this默认指向target，但传入receiver之后，this指向receiver。
    }
},
receiver = {};

Reflect.set(target, 'a', 2, receiver);
target; 	// {set a: f a(v)}
receiver; 	// {_a: 2}
```



##### `setPrototypeOf`

​		静态的 `Reflect.setPrototypeOf()` 方法与 `Object.setPrototypeOf()` 方法相同，除了它的返回类型不同。它将指定对象的原型（即内部的 `[[prototype]]` 属性）设置为另一个对象或 `null`，如果操作成功则返回 `true`，否则返回 `false`。

参数：

- `target`：要设置其原型的目标对象。
- `prototype`：对象的新原型（对象或 `null`）。

返回值：一个指示原型是否成功设置的布尔值。

异常：

- 如果目标不是对象，或者原型既不是对象也不是 `null`，则抛出 `TypeError`。

```js
const empty = {};

// 将empty的[[Prototype]]指向String.prototype，程序会直接将empty变为String的一个空实例。
Reflect.setPrototypeOf(empty, String.prototype);

empty; // String {}
/*
String {
	[[Prototype]]: String { // 这个对象就是String.prototype
		constructor: f String(),
		...
		[[PrimitiveValue]]: ""
	}
}
*/
```

```js
// 如果目标对象不可扩展，则返回false
Reflect.setPrototypeOf(Object.freeze({}), null); // false

// 如果会造成原型链循环，也返回false
const target = {};
const proto = Object.create(target);
Reflect.setPrototypeOf(target, proto); // false
```

