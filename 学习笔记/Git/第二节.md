# 分支

分支（`branch`）：为了方便多人协作开发，先将项目拆分开发，最后合并到一起。

几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。

使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。

<img src="images/%E7%AC%AC%E4%BA%8C%E8%8A%82/image-20230115161547632.png" alt="image-20230115161547632" style="zoom: 67%;" /> 

当分支上的任务开发完毕后，就可以将它合并到主分支上，从而完成该项目的开发。

使用分支的优点：

- “分而治之”：各分支与主分支以及各分支之间都是相互独立的，在一条分支上的修改不会影响到其他的分支和主分支。
- “分支融合”：各个分支在开发时保持相互独立，但它们随时可融合成一个分支（分开后互不影响，但随时可以合并）。
- “君臣相辅”：将项目拆分成多个任务，每个分支负责一个任务，完成后合并到主分支。主分支只负责保存完整的项目。

更多参考：[分支管理-菜鸟教程](https://www.runoob.com/git/git-branch.html) 



### 使用

##### 查看分支

使用 `git branch` 指令，可以列出当前本地仓库的所有分支。

```bash
git branch # 列出该本地仓库的所有分支
```

##### 当前分支

使用 `git branch` 列出分支时，分支名前带 `*` 号的正是当前所使用的分支，并且分支名为绿色（默认情况下是灰色）。

在 `Git` 命令行中工作目录右侧也会显示当前分支的名称，如：`(master)`。所有的 `git` 指令都是针对当前分支的操作。

##### 创建分支

使用 `git branch <name>` 指令，可以创建并命名一条新的分支。

```bash
git branch dev # 创建一条名为dev的分支
```

注释：新建一个分支后，它会自动克隆一份父节点上的项目内容。

##### 切换分支

使用 `git switch <name>` 指令，可以切换到指定的分支（命名行中工作目录右侧的分支名也会切换）。

```bash
git switch dev 		# 将当前分支切换为dev分支 
```

另外，使用 `git checkout <name>` 指令，也可以切换到指定的分支。

```bash
git checkout dev 	# 将当前分支切换为dev分支（不推荐）
```

由于每一个分支都有着自己独立的项目内容。因此，当切换分支时，项目内容也会随之切换（在编辑器中尤为明显）。

注释：

- 只有提交（`commit`）到分支上的项目内容，才会随着分支的切换而切换。
- 没有提交到分支的内容，不属于任何一个分支，会成为该项目的公共资源。

##### 创建切换

使用 `git switch` 指令，在分支名前还可以携带一个参数 `-c`，表示创建并切换到指定的分支。

```bash
git switch -c demo 	# 创建并切换到demo分支
```

另外，使用 `git checkout -b <name>` 指令，也可以创建新分支并立即切换到该分支下。

```bash
git checkout -b demo # 创建并切换到demo分支
```

不过，使用 `git switch` 指令是更推荐的做法。

##### 删除分支

使用 `git branch` 指令并携带一个 `-d` 参数，可以删除指定的分支。

```bash
git branch -d demo # 删除demo分支（demo分支已被合并）
```

注意：不能删除当前正在操作的分支，只能删除其他分支，否则会报错。

不过，`-d` 参数只能删除已合并的分支，未合并的分支要使用 `-D` 参数。

```bash
git branch -D demo # 删除demo分支（demo分支未被合并）
```

##### 合并分支

使用 `git merge` 指令，可以将指定的其他分支合并到当前分支（默认使用快速合并模式）。

```bash
git merge dev # 将dev分支合并到当前操作的分支
```

将其他分支合并到主分支：

```bash
git switch master
git merge dev
```

通常，在合并分支之后，应删除被合并的分支。

```bash
git branch -d dev
```

如果使用默认的快速合并模式，则还应将合并后的内容提交到当前分支。

```bash
git add .
git commit -m "提交合并dev之后的内容"
```

##### 合并冲突

如果要合并的内容有两套不同的定义，那么在合并时便会产生冲突。

例如：在要合并的两个分支上存在两个同名文件，而这两个文件在同样的位置上，给予了不同的内容，那么合并时就必然会导致冲突。

`Git` 对于冲突的内容，选择一起保留，并以连续的七个 `<`、`=` 和 `>` 来划分冲突的内容。以 `<<<<<<< HEAD` 开头，后面是当前分支的内容；以 `=======` 间隔，后面是合并分支的内容；以 `>>>>>>> name` 结尾，冲突部分到此结束。示例如下：

```html
<div>
    以下是合并时，产生冲突的内容
<<<<<<< HEAD
	<p>当前分支中的内容</p>
=======
	<p>合并分支中的内容</p>
>>>>>>> dev
	以上是合并时，产生冲突的内容
</div>
```

另外，当合并时产出冲突，在命令行中工作目录的右侧，会出现合并中的标识。如，当前分支是主分支时：`(master|MERGING)`。

解决冲突：

- `Git` 将存在争议的合并内容一并保留到合并中的当前分支，而将决定去留冲突内容的权力交给开发者。
- 当开发者在当前分支中解决了冲突内容后，还需要将合并后的项目内容重新提交到合并中的当前分支。

```bash
# 对冲突内容做出取舍后，重新提交内容到当前分支。
git add .
git commit -m "已手动解决了合并冲突"
```

重新提交后，在命令行中工作目录右侧的分支标识，会切换回当前分支。如：`(master)`。

##### 普通合并

使用 `git merge` 指令，默认采用快速合并模式。快速合并模式只合并但不会提交到库，因此，在当前分支的库中没有合并的记录。

而在合并分支名后使用 `--no-ff` 参数，则可以使用普通合并模式（合并后立即提交到库），并且可以接着使用 `-m` 设置版本描述。

```bash
git merge dev --no-ff -m "将dev合并到当前分支后，立即提交到当前分支"
```

##### 功能分支

在实际开发中，可能要开发一些实验性的功能。这些功能只是暂定的，最终不一定会被采纳进项目的。此时，就可以在主分支上再创建一个功能（`feature`）分支，来单独地开发和保存这些实验性的功能。

```bash
git switch master 		# 切换回主分支
git switch -c feature 	# 在主分支上创建feature分支，并立即切换到该分支。
```

开发好新功能之后，将其提交到功能分支，等待采纳即可。

```bash
git add .
git commit -m "实验性的功能"
```

如果该分支上的功能，最终被采纳，则可以将其合并到主分支上。如果没有被采纳，则可以将其删除。

##### 推送分支

分支上的任务完成之后，就可以将该分支提交到远程仓库中存储，使用 `git push` 指令。

```bash
git push origin dev # 推送本地的当前分支推送到远程仓库的dev分支中
```

如果远程仓库中不存在 `dev` 分支，则会先创建它然后再存储。

通常，开发分支和主分支都需要推送到远程仓库，而修复 `bug` 的分支则不建议。另外，至于功能分支的推送则视需求而定。

##### 默认分支

默认分支，对远程仓库来说是很重要的。本地仓库第一个推送的分支将自动成为远程仓库的默认分支。但好在默认分支是可以切换的：

- `Github`：进入仓库 -- `Settings` -- `Branches` -- `Default branch` -- 点击切换按钮 -- 选择分支 -- `Update` -- 确认。
- `Gitee`：进入仓库 -- 管理 -- 保护分支设置 -- 默认分支 -- 选择分支 -- 设为默认分支。

##### 抓取分支

两个程序员互相推送代码，需要其中一个先将代码推送到远程仓库，然后另一个再从远程仓库中抓取到自己的本地。在与自己的代码融合后，最终将合并后的分支推送到远程仓库。这里，后者就需要从远程仓库中抓取分支。然而，使用 `git clone` 指令克隆远程仓库时，默认只会拉取远程仓库的默认分支（通常是 `master` 分支）。

要拉取全新的分支，则首先应建立一条同名的本地分支，然后将远程分支中的代码填充到该本地分支中。如下，拉取 `dev` 分支到本地：

```bash
git switch -c dev origin/dev # 格式：git switch -c <本地分支名> <远程仓库名>/<远程分支名>
```

上述指令，表示先在本地仓库中创建并切换到 `dev` 分支，然后将远程仓库 `origin` 中的 `dev` 分支填充到本地的当前分支（即：`dev`）。

如果要拉取到本地已存在分支的分支上，则不需要再创建分支。此时，可使用 `git pull` 指令。

```bash
git pull origin dev # 格式：git pull <远程仓库名> <远程分支名>
```

上述指令，表示将远程仓库 `origin` 中的 `dev` 分支拉取到本地仓库的当前分支上。如果命令行弹出是否与本地分支合并的确认信息，则首先按下字母 `I` 键进入 `-- INSERT --` 界面，然后按 `Esc` 键退出，最后输入 `:wq` 按 `Enter` 键确认即可。

如果与远程仓库关联的只有一个本地仓库，那么在本地仓库向远程仓库推送时，可以正常地推送各个本地分支到远程。

但当与远程仓库关联的有多个本地仓库（例如：经克隆产生的分身仓库）时，那么在本地仓库向远程仓库推送前，如果要推送的分支在远程已被其他分身仓库更新，则要先拉取远程分支更新的内容到本地，与本地的分支进行合并后，再将它推送到远程。

```bash
# 当远程仓库在本地有多个分身仓库时，如果其中一个更新了远程仓库的dev分支，则其他分身在推送dev前须先拉取远程dev，合并后才能推送。
git pull origin dev # 拉取远程dev更新的内容到本地dev
git add . 			# 添加到dev分支的本地暂存区
git commit -m "" 	# 提交到dev分支的本地仓库
git push origin dev # 将在本地合并后的最新dev分支推送到远程仓库的dev分支中
```



### 缓存

如果在开发过程中，要中断还未完成的工作，但又不能正式提交时。可以先缓存工作，然后在合适时恢复缓存的工作以继续开发。

##### 缓存工作

使用 `git stash` 指令，可以保存当前分支上的工作区和暂存区的最新状态，并把当前的修改藏匿到 `git` 栈中，以待需要时恢复。

```bash
git stash # 保存当前分支上工作区和暂存区的当前状态，保存并移除当前的修改。
```

当你想记录工作目录和索引的当前状态，但又想回到一个干净的工作目录（上次 `commit` 提交的状态）时，使用 `git stash`。该命令保存本地修改，并恢复工作目录以匹配 `HEAD` 提交。它只缓存已有记录的文件的修改（`modified`），将修改保存到 `git` 栈中后（从工作区中）删除，这样不仅能够得到干净的工作目录，而且可以在任意分支上进行恢复。【`stash`：藏匿；贮藏】

`git stash` 指令，其实有一个默认的 `push` 参数，表示将修改推入贮藏列表中。

```bash
git stash push # 相当于git stash
```

##### 恢复缓存

在实际开发中，可能会遇到一些 `bug`。通常，不建议直接在开发分支中修复 `bug`，而应该新建一个暂存分支来进行调试和修复。

```bash
git switch -c issue # 新建一个暂存分支，用来恢复和调试修改
```

在 `git stash` 指令后，使用一个 `apply` 参数，可以恢复藏匿的修改。

```bash
git stash apply # 恢复git stash暂存的修改内容
```

##### 缓存列表

在 `git stash` 指令后，使用一个 `list` 参数，可以查看贮藏列表（堆栈结构）。这意味着可以多次藏匿修改，但遵循先进后出的原则。

```bash
git stash list # 给出贮藏的列表，先贮藏的后恢复
```

在 `git stash apply` 指令后，可以通过携带列表中的编号来恢复指定的贮藏。编号格式：`stash@{num}`。

```bash
git stash apply stash@{0} # 恢复最新一次藏匿的修改
```

##### 剔除缓存

缓存被恢复之后，缓存列表依旧会保留缓存的内容。因此，在恢复缓存后，应该将对应的缓存从列表中删除。

在 `git stash` 指令后，使用一个 `drop` 参数，可以将缓存的修改从贮藏列表中从上到下依次删除，并刷新。

```bash
git stash drop # 删除最新一次藏匿的修改，然后刷新列表。
```

当然，也可以在 `git stash drop` 后使用列表编号来删除指定的贮藏，用法与 `apply` 一样。

```bash
git stash drop stash@{0} # 与git stash drop一样
```

##### 弹出缓存

如果要在恢复缓存的同时剔除缓存，可以在 `git stash` 指令后，使用 `pop` 参数。

```bash
git stash pop # 恢复并删除最新一次藏匿的修改
```

该命令相当于 `apply` 和 `drop` 参数的结合命令，在恢复缓存后将其从列表中剔除。

```bash
git stash pop stash@{0} # 与git stash pop一样
```

##### 清空缓存

在 `git stash` 指令后，使用一个 `clear` 参数，可以清空贮藏列表。

```bash
git stash clear # 清空贮藏列表，并不恢复缓存。
```

